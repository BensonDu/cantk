var gCantkBuildDate = "2016年 03月 25日 星期五 18:18:32 CST";console.log("cantk build date: " + gCantkBuildDate);
if(!window.CanTK) {
	window.CanTK = {};
}

window.CanTK.config = {
	logoImageSrc : null,
	progressBarBgSrc : null,
	progressBarFgSrc : null
};
/*
 * File: shape.js
 * Brief: Base class of all shapes.
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

function Shape() {
	return;
}

Shape.MODE_EDITING = 0;
Shape.MODE_RUNNING = 1;
Shape.MODE_PREVIEW = 2;

Shape.HIT_TEST_NONE = 0;
Shape.HIT_TEST_TL = 1;
Shape.HIT_TEST_TM = 2;
Shape.HIT_TEST_TR = 3;
Shape.HIT_TEST_ML = 4;
Shape.HIT_TEST_MR = 5;
Shape.HIT_TEST_BL = 6;
Shape.HIT_TEST_BM = 7;
Shape.HIT_TEST_BR = 8;
Shape.HIT_TEST_HANDLE = 9;
Shape.HIT_TEST_WORKAREA = 10;
Shape.HIT_TEST_ROTATION = 11;
Shape.HIT_TEST_MOVE = 12;
Shape.HIT_TEST_MAX = 13;
Shape.HIT_TEST_MM = -1;

Shape.ALIGN_LEFT = 1;
Shape.ALIGN_RIGHT = 2;
Shape.ALIGN_TOP = 3;
Shape.ALIGN_BOTTOM = 4;
Shape.ALIGN_CENTER = 5;
Shape.ALIGN_MIDDLE = 6;
Shape.ALIGN_TO_SAME_WIDTH = 7;
Shape.ALIGN_TO_SAME_HEIGHT = 8;
Shape.ALIGN_DIST_VER = 9;
Shape.ALIGN_DIST_HOR = 10;

Shape.STAT_CREATING_0 = 0;
Shape.STAT_CREATING_1 = 1;
Shape.STAT_CREATING_2 = 2;
Shape.STAT_NORMAL = 3;

Shape.TEXT_NONE = 0;
Shape.TEXT_INPUT = 1;
Shape.TEXT_TEXTAREA = 2;

Shape.EVT_POINTER_DOWN = 1;
Shape.EVT_POINTER_MOVE = 0;
Shape.EVT_POINTER_UP = -1;

Shape.prototype.initPanelShape = function() {
    return;
}

Shape.prototype.initIconShape = function() {
   return;
}

Shape.prototype.setNearRange = function(nearRange) {
	this.nearRange = nearRange;

	return this;
}

Shape.prototype.getNearRange = function() {
	return this.nearRange ? this.nearRange : 20;	
}

Shape.prototype.findNear = function(point) {
	return null;
}

Shape.prototype.getCreatingShape = function() {
	return this.view ? this.view.getCreatingShape() : null;
}

Shape.prototype.getTextCookie = function(point) {
	return 0;
}

Shape.isTransparentColor = function(color) {
	return !color || color === "rgba(0,0,0,0)";
}

Shape.prototype.isFillColorTransparent = function() {
	return Shape.isTransparentColor(this.style.fillColor);
}

Shape.prototype.isStrokeColorTransparent = function() {
	return Shape.isTransparentColor(this.style.lineColor);
}

Shape.prototype.isTextColorTransparent = function() {
	return Shape.isTransparentColor(this.style.textColor);
}

Shape.prototype.setParent = function(parentShape) {
	this.parentShape = parentShape;
	return this;
}

Shape.prototype.getParent = function(name) {
	if(name) {
		for(var iter = this.parentShape; iter != null; iter = iter.parentShape) {
			if(iter.name === name || iter.type === name) {
				return iter;
			}
		}
	}

	return name ? null : this.parentShape;
}

Shape.prototype.textEditable = function(point) {
	return true;
}

Shape.prototype.setInputType = function(inputType) {
	this.inputType = inputType;

	return this;
}

Shape.prototype.editText = function(point) {
	return;
}

Shape.prototype.exec = function(cmd) {
	if(this.app) {
		this.app.exec(cmd);
	}
	else {
		cmd.doit();
		delete cmd;
	}

	return;
}

Shape.prototype.setTextTitle = function(textTitle) {
	this.textTitle = textTitle;

	return this;
}
	
Shape.prototype.initShape = function(x, y, w, h, type) {
	this.w = w;
	this.h = h;
	this._x = x;
	this._y = y;
	this._left = x;
	this._top = y;
	this.type = type;
	this.text = "";
	this.app = null;
	this.view = null;
	this.rotation = 0;
	this.scaleX = 1;
	this.scaleY = 1;
	this.selected = false;
	this.parentShape = null;
	this.pointerDown = false;	
	this.userMovable = true;
	this.userResizable = true;
	this.state = Shape.STAT_NORMAL;
	this.lastPosition = {x:0, y:0};
	this.selectMarkPoint = {x:0, y:0};
	this.textType = Shape.TEXT_INPUT;
	this.setDefaultStyle();
	this.setTextAlignV("middle");
	this.setTextAlignH("center");
	this.hitTestResult = Shape.HIT_TEST_NONE;

	return;
}

Shape.prototype.setDefaultStyle = function() {
	this.style = new ShapeStyle();
	this.setStyle(Shape.getDefaultStyle());

	return this;
}

Shape.prototype.setState = function(state) {
	this.state = state;
	
	return this;
}

Shape.prototype.setTextType= function(textType) {
	this.textType = textType;
	
	return this;
}

Shape.prototype.isSelected = function() {
	return this.selected;
}

Shape.prototype.userRemovable = function() {
	return true;
}

Shape.prototype.intersectWithRect = function(rect) {
	var ret = false;
	var x = this.getX();
	var y = this.getY();
	var w = this.getWidth();
	var h = this.getHeight();

	var p1 = {x:x, y:y};
	var p2 = {x:x+w, y:y+h};
	var p3 = {x:x+w, y:y};
	var p4 = {x:x, y:y+h};

	return isPointInRect(p1, rect) || isPointInRect(p2, rect) 
		|| isPointInRect(p3, rect) || isPointInRect(p4, rect);
}


Shape.prototype.isThisInRect = function(rect) {
	var ret = false;
	var x = this.getX();
	var y = this.getY();
	var w = this.getWidth();
	var h = this.getHeight();
	
	if((x >= rect.x && x < (rect.x + rect.w))
		&& (y >= rect.y && y < (rect.y + rect.h))) {
		ret = true;
	}
	
	return ret;
}

Shape.prototype.isClicked = function() {
	if(this.view) {
		return this.view.isClicked();
	}

	return false;
}

Shape.prototype.isAltDown = function() {
	if(this.view) {
		return this.view.isAltDown();
	}

	return false;
}

Shape.prototype.isCtrlDown = function() {
	if(this.view) {
		return this.view.isCtrlDown();
	}

	return false;
}

Shape.prototype.onMoving = function() {
}

Shape.prototype.onMoved = function() {

}

Shape.prototype.onSized = function() {

}

Shape.prototype.onUserMoved = function(x, y) {

}

Shape.prototype.onUserResized = function() {

}

Shape.prototype.fixChildPosition = function(child) {
	var maxW = this.w;
	var maxH = this.h;
	var dx = child.left >= 0 ? child.left : 0;
	var dy = child.top >= 0 ? child.top : 0;

	if((dx + child.w) > maxW) {
		dx = maxW - child.w; 
	}

	if((dy + child.h) > maxH) {
		dy = maxH - child.h;
	}

	child.left = dx;
	child.top = dy;

	return;
}

Shape.prototype.fixPosition = function() {
	if(!this.parentShape) {
		return;
	}

	this.parentShape.fixChildPosition(this);

	return;
}

Shape.prototype.move = function(x, y) {
	if(this.left !== x || this.top !== y) {
		this.setLeftTop(x, y);

		if(!this.isIcon) {
			this.fixPosition();
			this.onMoved();
		}
	}

	return this;
}

Shape.prototype.moveDelta = function(dx, dy) {
	return this.move(this.left + dx, this.top + dy);
}

Shape.prototype.getWidth = function() {
	return this.w;
}

Shape.prototype.getHeight = function() {
	return this.h;
}

Shape.prototype.getPositionInScreen = function() {
	var pv = {x:0, y:0};
	var scale = this.getRealScale();
	var p = this.getPositionInView();
	
	if(this.view) {
		pv = this.view.getAbsPosition();
	}

	p.x = pv.x + p.x * scale;
	p.y = pv.y + p.y * scale;

	return p;
}

Shape.prototype.getRealScale = function() {
	return this.view ? this.view.getScale() : 1;
}

Shape.prototype.getAbsPosition = function() {
	var p = this.getPositionInView();

	if(this.view) {
		var pv = this.view.getAbsPosition();
		p.x = p.x + pv.x;
		p.y = p.y + pv.y;
	}

	return p;
}

Shape.prototype.getPositionInView = function() {
	var x = this.getX();
	var y = this.getY();
	var point = {x:0, y:0};
	var iter = this.parentShape;

	while(iter != null) {
		x += iter.left;
		y += iter.top;
		iter = iter.parentShape;
	}

	point.x = x;
	point.y = y;

	return point;
}


Shape.prototype.getXinView = function() {
	var x = this.getPositionInView().x; 

	return x;
}

Shape.prototype.getYinView = function() {
	var y = this.getPositionInView().y; 

	return y;
}

Shape.prototype.getX = function() {
	return this.x;
}

Shape.prototype.getY = function() {
	return this.y;
}

Shape.prototype.setX = function(x) {
	this.x = x;

	return this;
}

Shape.prototype.setY = function(y) {
	this.y = y;
	
	return this;
}

Shape.prototype.align = function(type, value) {
	return;
}

Shape.prototype.setRotatable = function(rotatable) {
	this.rotatable = rotatable;
	
	return this;
}

Shape.prototype.setScaleX = function(scaleX) {
	this.scaleX = scaleX;

	return this;
}

Shape.prototype.setScaleY = function(scaleY) {
	this.scaleY = scaleY;

	return this;
}

Shape.prototype.getScale = Shape.prototype.getScaleX = function() {
	return this.scaleX !== undefined ? this.scaleX : this.scale;
}

Shape.prototype.getScaleY = function() {
	return this.scaleY !== undefined ? this.scaleY : this.scale;
}

Shape.prototype.setScale = function(scaleX, scaleY) {
	this.scaleX = scaleX;
	this.scaleY = scaleY !== undefined ? scaleY : scaleX;

	return this;
}

Shape.prototype.getRotation = function() {
	return this.rotation;
}

Shape.prototype.setRotation = function(rotation) {
	this.rotation = rotation;
	
	return this;
}

Shape.prototype.getOpacity = function() {
	return this.opacity;
}

Shape.prototype.setOpacity = function(opacity) {
	this.opacity = Math.max(0, opacity);
	this.opacity = Math.min(1, this.opacity);

	return this;
}

Shape.prototype.setStyle = function(style) {
	this.style.copy(style);
	this.textNeedRelayout = true;
	
	return this;
}

Shape.prototype.getStyle = function() {
	return this.style;
}

Shape.prototype.setName = function(name) {
	this.name = name;

	return this;
}

Shape.prototype.getName = function() {
	return this.name;
}

Shape.prototype.getLocaleText = function(text) {
	return text;
}

Shape.prototype.getLocaleInputTips = function(text) {
	return dappGetText(text);
}
	
Shape.prototype.setNeedRelayoutText = function() {
	this.textNeedRelayout = true;

	return this;
}	

Shape.prototype.setTextAlignH = function(hTextAlign) {
	this.hTextAlign = hTextAlign;

	return this;
}

Shape.prototype.setTextAlignV = function(vTextAlign) {
	this.vTextAlign = vTextAlign;

	return this;
}

Shape.prototype.getTextAlignH = function() {
	var hTextAlign = this.hTextAlign ? this.hTextAlign : "left";

	return hTextAlign;
}

Shape.prototype.getTextAlignV = function() {
	var vTextAlign = this.vTextAlign ? this.vTextAlign : "top";

	return vTextAlign;
}

Shape.prototype.toText = function(value) {
	if(value !== null && value != undefined) {
		return value + "";
	}
	else {
		return "";
	}
}

Shape.prototype.setText = function(text) {
	this.text = this.toText(text);
	this.textNeedRelayout = true;
	
	return this;
}

Shape.prototype.setText2 = function(text) {
	this.text2 = text;
	
	return this;
}

Shape.prototype.setText3 = function(text) {
	this.text3 = text;
	
	return this;
}

Shape.prototype.getText = function() {
	return this.text;
}

Shape.prototype.getApp = function() {
	return this.app;
}

Shape.prototype.getView = function() {
	return this.view;
}

Shape.prototype.setApp = function(app) {
	this.app = app;
	
	return this;
}

Shape.prototype.setView = function(view) {
	this.view = view;
	
	return this;
}

Shape.prototype.redrawSelf = function() {
	if(this.view) {
		var scale = this.getRealScale();
		var p = this.getPositionInView();
		var rect = {x: p.x*scale, y:p.y*scale, w:this.w*scale, h:this.h*scale};

		this.view.redraw(rect);
	}
	
	return;
}

Shape.prototype.postRedraw = function(rect) {
	if(this.view) {
		this.view.postRedraw(rect);
	}
	
	return;
}

Shape.prototype.beforePropertyChanged = function() {
	return;
}

Shape.prototype.afterPropertyChanged = function() {
	return;
}

Shape.prototype.showProperty = function() {
	return;
}

Shape.prototype.setSelectedMarkSize = function(selectedMarkSize) {
	this.selectedMarkSize = selectedMarkSize;

	return;
}

Shape.prototype.paint = function(canvas) {
	this.paintSelf(canvas);

	if(this.near) {
		var p = this.near.point;
		var r = this.getNearRange();

		canvas.beginPath();
		canvas.arc(p.x, p.y, 4, 0, Math.PI * 2);
		canvas.fillStyle = "Red";
		canvas.fill();

		canvas.beginPath();
		canvas.lineWidth = 2;
		canvas.arc(p.x, p.y, r, 0, Math.PI * 2);
		canvas.strokeStyle = "Black";
		canvas.stroke();
	}

	return;
}

Shape.prototype.paintSelf = function(canvas) {
	return;
}

Shape.prototype.setSelected = function(selected) {
	if(selected) {
		this.selectedTime = Date.now();
	}

	if(this.selected === selected) {
		return;
	}

	this.selected = selected;
	if(this.view && this.view.onShapeSelected) {
		this.view.onShapeSelected(this);
	}

	return;
}

Shape.prototype.isVisible = function() {
	return true;
}

Shape.prototype.findNearPoint = function(rect) {
	var p = null;

	for(var i = 0; i < 100; i++) {
		p = this.getNearPoint(i);

		if(!p) {
			break;
		}
		
		if(isPointInRect(p, rect)) {
			var near = {shape:this};
			near.nearPointIndex = i;
			near.point = {x:p.x, y:p.y};

			return near;
		}
	}

	return null;
}

Shape.prototype.dup = function() {
	var g = ShapeFactoryGet().createShape(this.type, C_CREATE_FOR_PROGRAM);

	g.fromJson(this.toJson());
	g.state = Shape.STAT_NORMAL;

	return g;
}


Shape.prototype.hitTest = function(point) {
	return Shape.HIT_TEST_NONE;
}

Shape.prototype.showProperty = function() {
	return;
}

Shape.prototype.onLongPress = function(point) {
	return;
}

Shape.prototype.onGesture = function(gesture) {
}

Shape.prototype.onDoubleClick = function(point) {
	return true;
}

Shape.prototype.onPointerDown = function(point) {
	this.pointerDown = true;
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		return false;
	}
	
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	this.handlePointerEvent(point, Shape.EVT_POINTER_DOWN);
	
	return true;
}

Shape.prototype.handlePointerEvent = function(point, evt) {
	return false;
}

Shape.prototype.onPointerMove = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, Shape.EVT_POINTER_MOVE);
		return true;
	}
	
	return false;
}

Shape.prototype.onPointerUp = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, Shape.EVT_POINTER_UP);
		this.hitTestResult = Shape.HIT_TEST_NONE;
		
		return true;
	}
	this.pointerDown = false;
	
	return false;
}

Shape.prototype.onKeyDown = function(code) {
	console.log("onKeyUp Widget: code=" + code)
	return;
}

Shape.prototype.onKeyUp = function(code) {
	console.log("onKeyUp Widget: code=" + code)
	return;
}

Shape.prototype.canBeComponent = function() {
	return false;
}

Shape.prototype.shouldShowContextMenu = function() {
	return true;
}

Shape.prototype.toJson = function() {
	return null;
}

Shape.prototype.fromJson = function(js) {
	return this;
}

Shape.prototype.afterApplyFormat = function() {
	return;
}

Shape.prototype.applyFormat = function(js) {
	if(!js) {
		return;
	}

	for(var key in js) {
		var value = js[key];
		var type = typeof value;
		if(type === "function" || type === "object" || type === "undefined") {
			continue;
		}

		if(key == "type") {
			continue;
		}

		if(type === "number" || type === "string" || type === "boolean") {
			this[key] = value;
		}
	}

	if(js.images) {
		for(var key in js.images) {
			var value = js.images[key];
			
			if(key === "display") {
				this.images[key] = value;
			}
			else {
				var src = value.getImageSrc();
				this.setImage(key, src);
			}
		}
	}

	if(js.style) {
		this.style.fromJson(js.style);
	}
	
	if(js.animations) {
		this.animations = JSON.parse(js.animations);
		this.defaultAnimationName = js.defaultAnimationName;
	}

	this.afterApplyFormat();
	this.textNeedRelayout = true;

	return;
}

Shape.prototype.setUserMovable = function(value) {
	this.userMovable = value;

	return this;
}

Shape.prototype.setUserResizable = function(value) {
	this.userResizable = value;

	return this;
}

Shape.prototype.isUserMovable = function() {
	return this.userMovable && !this.isLocked();
}

Shape.prototype.isUserResizable = function() {
	return this.userResizable;
}

function splitText(text) {
	text = text.replaceAll("\r\n", "\n");
	text = text.replaceAll("\r", "\n");

	return text.split("\n--\n");
}

Shape.onRestacked = function(shapes, shape) {
}

function restackShapeInArray(shapes, offset) {
	var n = 0;
	var pos = 0;
	var s = null;
	var new_pos = 0;
	var selectedShape = null;

	for(var i = 0; i < shapes.length; i++) {
		s = shapes[i];
		if(s.selected) {
			n++;
			if(!selectedShape) {
				selectedShape = s;
				pos = i;
			}
		}
	}

	if(n > 1 || !selectedShape) {
		return;
	}

	new_pos = pos + offset;
	if(new_pos < 0 || new_pos >= shapes.length) {
		return;
	}

	shapes[pos] = shapes[new_pos];
	shapes[new_pos] = selectedShape;
	Shape.onRestacked(shapes, selectedShape);

	return;
}

function getParentShapeOfShape(shape, view) {
	var p = shape.parentShape ? shape.parentShape : shape.container;

	if(!p) {
		p = view;
	}

	return p;
}

function getParentShapeOfShapes(shapes) {
	if(!shapes || shapes.length === 0) {
		return null;
	}

	var firstShape = shapes[0];
	var parentShape = firstShape.parentShape;

	for(var i = 0; i < shapes.length; i++) {
		var shape = shapes[i];

		if(shape.parentShape != parentShape) {
			return null;
		}
	}

	return parentShape ? parentShape : firstShape.view;
}

Shape.prototype.getTextColor = function(canvas) {
	return this.style.textColor;
}

Shape.prototype.getBgColor = function(canvas) {
	return this.style.fillColor;
}

Shape.prototype.getLineColor = function(canvas) {
	return this.style.lineColor;
}

Shape.prototype.defaultDrawText = function(canvas) {
	var width = this.getWidth(true);
	var text = this.getLocaleText(this.text);

	if(!text || this.editing) {
		return;
	}
	
	canvas.save();
	canvas.beginPath();
	canvas.lineWidth = 1;
	canvas.font = this.style.getFont();
	canvas.fillStyle = this.getTextColor();
	canvas.strokeStyle = this.getLineColor();

	var lines = text.split(/\n/);
	if(lines.length < 2) {
		if(canvas.measureText(text).width < 1.2 * width) {
			this.draw1LText(canvas);
		}
		else {
			this.drawMLText(canvas);
		}
	}
	else {
		this.drawMLText(canvas);
	}
	canvas.restore();

	return;
}

Shape.prototype.draw1LText = function(canvas, drawAll) {
	var text = this.getLocaleText(this.text);

	if(!text || this.editing) {
		return;
	}

	var x = 0;
	var y = 0;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var hTextAlign = this.getTextAlignH();
	var vTextAlign = this.getTextAlignV();
	var textU = this.style.textU;
	var fontSize = this.style.fontSize;
	var textWidth = canvas.measureText(text).width;

	var lx = 0;
	var ly = 0;
	var lw = Math.min(textWidth, width);

	switch(vTextAlign) {
		case "middle": {
			y = this.h >> 1;
			canvas.textBaseline = "middle";
			if(textU) {
				ly = Math.floor(y + fontSize * 0.8);
			}
			break;
		}
		case "bottom": {
			y = this.h - this.vMargin;
			canvas.textBaseline = "bottom";
			if(textU) {
				ly = y;
			}
			break;
		}
		default: {
			y = this.vMargin;
			canvas.textBaseline = "top";
			if(textU) {
				ly = Math.floor(y + fontSize * 1.5);
			}
			break;
		}
	}

	switch(hTextAlign) {
		case "center": {
			x = this.w >> 1;
			canvas.textAlign = "center";
			if(textU) {
				lx = Math.max((this.w - textWidth) >> 1, 0);
			}
			break;
		}
		case "right": {
			x = this.w - this.hMargin;
			canvas.textAlign = "right";
			if(textU) {
				lx = Math.max((this.w - textWidth - hMargin), 0);
			}
			break;
		}
		default: {
			x = this.hMargin;
			canvas.textAlign = "left";
			if(textU) {
				lx = x;
			}
			break;
		}
	}
	
	if(textU) {
		canvas.moveTo(lx, ly);
		canvas.lineTo(lx + lw, ly);
		canvas.stroke();
	}

	canvas.fillText(text, x, y, width);
	
	return textWidth;
}

Shape.prototype.drawMLText = function(canvas, drawAll) {
	this.layoutText(canvas);

	if(!this.lines) {
		return;
	}

	var x = 0;
	var y = 0;
	var lx = 0;
	var ly = 0;
	var lw = 0;
	var vMargin = this.vMargin;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var hTextAlign = this.getTextAlignH();
	var vTextAlign = this.getTextAlignV();

	var textU = this.style.textU;
	var fontSize = this.style.fontSize;
	var textLineHeight = this.getTextLineHeight();
	var textHeight = this.getTextHeight();

	canvas.textBaseline = "top";
	switch(vTextAlign) {
		case "middle": {
			y = (this.h - textHeight) >> 1;
			break;
		}
		case "bottom": {
			y = this.h - textHeight - vMargin;
			break;
		}
		default: {
			y = vMargin;
			break;
		}
	}

	y = y < 0 ? 0: y;

	for(var i = 0; i < this.lines.length; i++) {
		var str = this.lines[i];
		if(!str || str == " ") {
			y += fontSize;
			continue;
		}
		
		if((y + textLineHeight) >= this.h && !drawAll) {
			break;
		}

		var textWidth = canvas.measureText(str).width;

		lw = Math.min(textWidth, width);
		ly = Math.floor(y + (fontSize + textLineHeight)/2);

		switch(hTextAlign) {
			case "center": {
				x = this.w >> 1;
				canvas.textAlign = "center";
				if(textU) {
					lx = Math.max((this.w - textWidth) >> 1, 0);
				}
				break;
			}
			case "right": {
				x = this.w - hMargin;
				canvas.textAlign = "right";
				if(textU) {
					lx = Math.max((this.w - textWidth - hMargin), 0);
				}
				break;
			}
			default: {
				x = hMargin;
				canvas.textAlign = "left";
				if(textU) {
					lx = x;
				}
				break;
			}
		}

		if(textU) {
			canvas.moveTo(lx, ly);
			canvas.lineTo(lx + lw, ly);
			canvas.stroke();
		}
		canvas.fillText(str, x, y, width);

		y += textLineHeight;
	}

	return;
}

Shape.prototype.getTextHeight = function() {
	var h = 0;
	var fontSize = this.style.fontSize;
	var lineHeight = this.getTextLineHeight();

	if(!this.text || !this.lines) {
		return lineHeight;
	}

	for(var i = 0; i < this.lines.length; i++) {
		var str = this.lines[i];
		if(!str || str == " ") {
			h += fontSize;
		}
		else {
			h += lineHeight;
		}
	}

	return h;
}

Shape.prototype.getTextLineHeight = function() {
	return Math.floor(this.style.fontSize * 1.5);
}

Shape.prototype.setTextShadow = function(textShadow) {
	this.textShadow = textShadow;

	return this;
}

Shape.prototype.isValid = function() {
	return !this.isInvalid;
}

Shape.prototype.canCopy = function() {
	return true;
}

Shape.prototype.onDestroy = function() {
}

Shape.prototype.onRemoved = function(parent) {
}

Shape.prototype.destroy = function() {
	var parentShape = this.parentShape;
	if(parentShape) {
		if(parentShape.targetShape === this) {
			parentShape.targetShape = null;	
		}
		if(parentShape.pointerEventTarget === this) {
			parentShape.pointerEventTarget = null;
		}
		this.parentShape = null;	
	}

	if(this.container) {
		this.container = null;
	}

	this.app = null;
	this.view = null;

	if(this.children) {
		this.children.clear(true);
		this.children = null;
	}

	if(this.images) {
		this.images = null;
	}

	if(this.events) {
		this.events = null;
	}

	if(this.style) {
		this.style = null;
	}

	this.onDestroy();
	this.isInvalid = true;
	this.jsonData = null;

	return;
}

Shape.iconShapeStyle = null;
Shape.getIconShapeStyle = function() {
	if(!Shape.iconShapeStyle) {
		Shape.iconShapeStyle = ShapeStyle.create();
		Shape.iconShapeStyle.setLineWidth(1);
		Shape.iconShapeStyle.setFontSize(8);
		Shape.iconShapeStyle.setLineColor("Black");
		Shape.iconShapeStyle.setFillColor("White");
		Shape.iconShapeStyle.setTextColor("Black");
	}

	return Shape.iconShapeStyle;
}

Shape.defaultStyle = null;
Shape.getDefaultStyle = function() {
	if(!Shape.defaultStyle) {	
		Shape.defaultStyle = ShapeStyle.create();
	}

	return Shape.defaultStyle;
}

/*
 * File: shape_style.js
 * Brief: shape style
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function ShapeStyle() {
}
	
ShapeStyle.prototype.getFont = function() {
	var font = "";
	
	if(this.textI) {
		font = "italic  "
	}
	
	if(this.textB) {
		font = font + "bold "
	}
	
	font = font + this.fontSize + "pt \"" + this.fontFamily + "\"";

	return font;
}

ShapeStyle.prototype.setLineWidth = function(value) {
	this.lineWidth = value > 0 ? value : 1;

	return;
}

ShapeStyle.prototype.setLineColor = function(value) {
	this.lineColor = value;

	return;
}

ShapeStyle.prototype.setFillColor = function(value) {
	this.fillColor = value;

	return;
}

ShapeStyle.prototype.setTextColor = function(value) {
	this.textColor = value;

	return;
}

ShapeStyle.prototype.setFontSize = function(value) {
	var fontSize = Math.max(value, 6);

	this.fontSize = fontSize;

	return;
}

ShapeStyle.prototype.setFontFamily = function(fontFamily) {
	this.fontFamily = fontFamily ? fontFamily : "serif";

	return;
}

ShapeStyle.prototype.setTextB = function(value) {
	this.textB = value;

	return;
}

ShapeStyle.prototype.setTextU = function(value) {
	this.textU = value;

	return;
}

ShapeStyle.prototype.setTextI = function(value) {
	this.textI = value;

	return;
}

ShapeStyle.prototype.getStrokeStyle = function(canvas) {
	return this.strokeColor;
}

ShapeStyle.prototype.copy = function(other) {
	var js = other.toJson();

	this.fromJson(js);

	return ;
}

ShapeStyle.prototype.toJson = function() {
	var o = {};

	for(var key in this) {
		var value = this[key];
		if(typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			o[key] = value;
		}
	}

	return o;
}

ShapeStyle.prototype.fromJson = function(js) {
	for(var key in js) {
		var value = js[key];
		if(key.length < 4) continue;
		if(typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			this[key] = value;
		}
	}

	return;
}

ShapeStyle.prototype.dup = function() {
	var other = new ShapeStyle();
	
	other.copy(this);
	
	return other;
}

ShapeStyle.prototype.equalTo = function(style) {
	var thisJson = JSON.stringify(this.toJson());
	var otherJson = JSON.stringify(style.toJson());

	return thisJson === otherJson;
}

ShapeStyle.createFromJson = function(js) {
	var style = new ShapeStyle();

	style.fromJson(js);

	return style;
}

ShapeStyle.create = function() {
	return new ShapeStyle();
}

/*
 * File: r_shape.js
 * Brief: Base class of all rectangle shapes.
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2013  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function RShape() {
	return;
}

RShape.prototype = new Shape();

RShape.prototype.MIN_SIZE = 10;
RShape.prototype.isRect = true;

RShape.prototype.getX = function() {
	if(this.anchor) {
		return this._x;
	}
	else {
		return this._left;
	}
}

RShape.prototype.getY = function() {
	if(this.anchor) {
		return this._y;
	}
	else {
		return this._top;
	}
}

RShape.prototype.setX = function(x) {
	return this.setPosition(x, this.y);
}

RShape.prototype.setY = function(y) {
	return this.setPosition(this.x, y);
}

RShape.prototype.getLeft = function() {
	return this._left;
}

RShape.prototype.getTop = function() {
	return this._top;
}

RShape.prototype.setLeft = function(left) {
	this._left = left;

	return this;
}

RShape.prototype.setTop = function(top) {
	this._top = top;
	
	return this;
}

RShape.prototype.setLeftTop = function(left, top) {
	this._left = left;
	this._top = top;

	return this;
}

RShape.prototype.setPivot = function(x, y) {
	this.pivotX = x;
	this.pivotY = y;

	return this;
}

RShape.prototype.getPivot = function() {
	return {x:this.pivotX, y:this.pivotY};
}

RShape.prototype.onPositionChanged = function() {
}

RShape.prototype.getAnchorX = function() {
	return this.getAnchor().x;
}

RShape.prototype.getAnchorY = function() {
	return this.getAnchor().y;
}

RShape.prototype.setAnchorX = function(x) {
	return this.setAnchor(x, this.getAnchorY());
}

RShape.prototype.setAnchorY = function(y) {
	return this.setAnchor(this.getAnchorX(), y);
}

RShape.prototype.setAnchor = function(x, y) {
	var anchor = this.getAnchor();

	anchor.x = x;
	anchor.y = y;

	this.pivotX = x;
	this.pivotY = y;

	this._x = this._left + (this.w * x);
	this._y = this._top + (this.h * y);

	return this;
}

RShape.prototype.getAnchor = function() {
	if(!this.anchor) {
		this.anchor = {x:0, y:0};
		this._x = this._left;
		this._y = this._top;
	}

	return this.anchor;
}

RShape.prototype.getPosition = function() {
	var p = {};

	if(!this.anchor) {
		p.x = this._left;
		p.y = this._top;
	}
	else {
		p.x = this._x;
		p.y = this._y;
	}

	return p;
}

RShape.prototype.setPosition = function(x, y) {
	this._x = x;
	this._y = y;

	if(this.anchor) {
		var left = this._x - this.w * this.anchor.x;
		var top  = this._y - this.h * this.anchor.y;
		this.setLeftTop(left, top);
	}
	else {
		this.setLeftTop(this._x, this._y);
	}

	this.onPositionChanged();

	return this;
}

RShape.prototype.realResize = RShape.prototype.setSize = function(w, h) {
	if(this.w !== w || this.h !== h) {
		var ww = Math.max(Math.round(w), 4);
		var hh = Math.max(Math.round(h), 4);

		if(this.anchor) {
			this._left = this._x - ww * this.anchor.x;
			this._top = this._y - hh * this.anchor.y;
		}
		this.w = ww;
		this.h = hh;

		this.textNeedRelayout = true;
	}
	
	return this;
}


RShape.prototype.initRShape = function(x, y, w, h, type) {
	this.initShape(x, y, w, h, type);

	this.w = w;
	this.h = w;
	this.opacity = 1;
	this.hMargin = 0;
	this.vMargin = 0;
	this.rotation = 0;
	this.image = null;
	this.imageUrl = "";
	this.defWidth = w;
	this.defHeight = w;
	this.enable = true;
	this.visible = true;
	this.events = {};
	this.pivotX = 0.5;
	this.pivotY = 0.5;
	this.text = "";
	this.pointerDown = false;
	this.lastPosition = {x:0, y:0};
	this.pointerDownPosition = {x:0, y:0};
	this.setScale(1, 1);
	if(w === 0 || h === 0) {
		this.w = this.MIN_SIZE;
		this.h = this.MIN_SIZE;	
		this.setState(Shape.STAT_CREATING_0);
	}

	return;
}

RShape.prototype.onPointerDown = function(point) {
	if(!this.enable && this.mode !== Shape.MODE_EDITING) {
		console.log("Ignore pointer event because this.enable is false.");
		return;
	}

	this.pointerDownPosition.x = point.x;
	this.pointerDownPosition.y = point.y;
	this.postRedraw();

	return this.onPointerDownNormal(point);
}

RShape.prototype.onPointerMove = function(point) {
	if(!this.enable && this.mode !== Shape.MODE_EDITING) {
		console.log("Ignore pointer event because this.enable is false.");
		return;
	}

	if(this.isLocked()) {
		return false;
	}

	return this.onPointerMoveNormal(point);
}

RShape.prototype.onPointerUp = function(point) {
	if(!this.enable && this.mode !== Shape.MODE_EDITING) {
		console.log("Ignore pointer event because this.enable is false.");
		return;
	}

	var ret = this.onPointerUpNormal(point);
	this.pointerDown = false;
	this.postRedraw();

	return ret;
}

RShape.prototype.onPointerDownNormal = function(point) {
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		return false;
	}
	
	this.pointerDown = true;
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	this.handlePointerEvent(point, 1);

	return true;
}

RShape.prototype.onPointerMoveNormal = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, 0);
		return true;
	}

	return false;
}

RShape.prototype.onPointerUpNormal = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, -1);
		this.hitTestResult = Shape.HIT_TEST_NONE;

		return true;
	}

	return false;
}

RShape.prototype.fixSize = function() {
	if(this.w < this.MIN_SIZE) {
		this.w = this.MIN_SIZE;
	}

	if(this.h < this.MIN_SIZE) {
		this.h = this.MIN_SIZE;
	}

	if(this.wMin && this.w < this.wMin) {
		this.w = this.wMin;
	}
	
	if(this.wMax && this.w > this.wMax) {
		this.w = this.wMax;
	}
	
	if(this.hMax && this.h > this.hMax) {
		this.h = this.hMax;
	}
	
	if(this.hMin && this.h < this.hMin) {
		this.h = this.hMin;
	}

	if(this.whRadio) {
		if(this.whRadio > 1) {
			this.h = Math.floor(this.w / this.whRadio);
		}
		else {
			this.w = Math.floor(this.h * this.whRadio);
		}
	}
	
	if(this.parentShape) {	
		this.parentShape.fixChildSize(this);
	}

	return;
}

RShape.prototype.fixChildSize = function(child) {
	var maxW = this.w;
	var maxH = this.h;
	if((child.x + child.w) > maxW) {
		child.w = maxW - child.x;
	}

	if((child.y + child.h) > maxH) {
		child.h = maxH - child.y;
	}

	return;
}

RShape.prototype.setDefSize= function(w, h) {
	this.defWidth = w;
	this.defHeight = h;

	this.w = w;
	this.h = h;

	return this;
}

RShape.prototype.setSizeLimit = function(wMin, hMin, wMax, hMax, whRadio) {
	this.wMin = wMin;
	this.wMax = wMax;
	this.hMin = hMin;
	this.hMax = hMax;
	this.whRadio = whRadio;

	return this;
}

RShape.prototype.resizeDelta = function(dw, dh) {
	this.resize(this.w + dw, this.h + dh);

	return;
}

RShape.prototype.resize = function(w, h) {
	if(this.w !== w || this.h !== h) {
		this.setSize(w, h);

		if(!this.isIcon) {
			this.onSized();
			this.fixSize();
		}
	}

	return this;
}

RShape.prototype.translate = function(canvas) {
	canvas.translate(this.getLeft(), this.getTop());

	return;
}

RShape.prototype.setClipRect = function(x, y, w, h) {
	if(arguments.length > 3) {
		var r = {};
		r.x = x;
		r.y = y;
		r.w = w;
		r.h = h;
		this.clipInfo = r;
	}
	else {
		this.clipInfo = null;
	}

	return this;
}

RShape.prototype.setClipCircle = function(x, y, r) {
	if(arguments.length > 2) {
		circle = {};
		circle.x = x;
		circle.y = y;
		circle.r = r;
		this.clipInfo = circle;
	}
	else {
		this.clipInfo = null;
	}

	return this;
}

RShape.prototype.onClip = function(canvas) {
	if(this.clipInfo) {
		var info = this.clipInfo;

		canvas.beginPath();
		if(info.r) {
			canvas.arc(info.x, info.y, info.r, 0, Math.PI * 2);
		}
		else {
			canvas.rect(info.x, info.y, info.w, info.h);
		}
		canvas.clip();
		canvas.beginPath();
	}
}

RShape.prototype.applyScale = function(canvas) {
	var scaleX = this.getScaleX();
	var scaleY = this.getScaleY();

	var px = this.w * this.pivotX;
	var py = this.h * this.pivotY;
	canvas.translate(px, py);
	canvas.scale(scaleX, scaleY);
	canvas.translate(-px, -py);
}

RShape.prototype.applyRotation = function(canvas) {
	if(Math.abs(this.rotation) > 0.0001) {
		var px = this.w * this.pivotX;
		var py = this.h * this.pivotY
		canvas.translate(px, py);
		canvas.rotate(this.rotation);
		canvas.translate(-px, -py);
	}
}

RShape.prototype.applyTransform = function(canvas) {
	canvas.globalAlpha *=  this.opacity;

	if(this.offsetX) {
		canvas.translate(this.offsetX, 0);
	}

	if(this.offsetY) {
		canvas.translate(0, this.offsetY);
	}

	this.applyRotation(canvas);
	this.applyScale(canvas);

	return;
}

RShape.prototype.isPointIn = function(canvas, point) {
	return isPointInRect(point, this);
}

RShape.prototype.drawImage = function(canvas) {
	return;
}

RShape.prototype.paintShape = function(canvas) {
	canvas.rect(0, 0, this.w, this.h);		

	return;
}

RShape.prototype.setTextNeedRelayout = function(value) {
	this.textNeedRelayout = value;

	return this;
}

RShape.prototype.layoutText = function(canvas) {
	if(!this.textNeedRelayout || this.textType === Shape.TEXT_NONE) {
		return;
	}

	canvas.font = this.style.getFont();
	var vMargin = this.vMargin ? this.vMargin : 10;
	
	var w = this.w - 2 * vMargin;
	if(w > 0) {
		this.lines = layoutText(canvas, this.style.fontSize, this.getLocaleText(this.text), w);
	}
	else {
		this.lines = [];
	}

	this.textNeedRelayout = false;

	return;
}

RShape.prototype.drawTextUnderLine = function(canvas, textX, textY, text) {
	var x = 0;
	var y = 0;
	var h = 0;
	var w = 0;
	if(!this.style.textU) {
		return;
	}
	
	w = canvas.measureText(text).width;
	if(this.textBaseline === "middle") {
		h = this.style.fontSize/2;
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}
	else if(this.textBaseline === "top") {
		h = this.style.fontSize;
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}
	else {
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}

	y = textY + h;

	canvas.moveTo(x, y);
	canvas.lineTo(x+ w, y);
	canvas.lineWidth = 1;
	canvas.stroke();

	return;
}

RShape.prototype.needDrawTextTips = function() {
	return true;
}

RShape.prototype.setInputTips = function(inputTips) {
	this.inputTips = inputTips;

	return this;
}

RShape.prototype.getTextTipsPosition = function() {
	var pos = {};

	pos.x = this.getWidth() >> 1;
	pos.y = this.getHeight() >> 1;
	pos.textAlign = "center";
	pos.textBaseline = "middle";

	return pos;
}

RShape.prototype.drawTextTips = function(canvas) {
	if(this.text || this.isIcon || this.w < 120 || this.h < 20 || this.editing) {
		return;
	}

	var pos = this.getTextTipsPosition();

	var x = pos.x;
	var y = pos.y;

	canvas.textAlign = pos.textAlign;
	canvas.textBaseline = pos.textBaseline;

	canvas.font = this.style.getFont();
	canvas.fillStyle = "#E0E0E0";	
	if(this.inputTips) {
		canvas.fillText(this.getLocaleInputTips(this.inputTips), x, y, this.getWidth());
	}

	return;
}

RShape.prototype.getOneLineText = function(canvas, text) {
	var line = "";
	var w = this.getWidth(true);

	if(canvas.measureText(text).width <= w) {
		return text;
	}

	for(var i = 0; i < text.length; i++) {
		var str = text[i];
		w = w - canvas.measureText(str).width;
		if(w < 0) {
			break;
		}
	
		line = line + str;
	}

	return line;
}

RShape.prototype.setMargin = function(vMargin, hMargin) {
	this.vMargin = Math.floor(Math.min(vMargin, 0.5 * this.w));
	this.hMargin = Math.floor(Math.min(hMargin, 0.5 * this.h));

	return this;
}

RShape.prototype.getVMargin = function() {
	return this.vMargin ? this.vMargin : 0;
}

RShape.prototype.getHMargin = function() {
	return this.hMargin ? this.hMargin : 0;
}

RShape.prototype.setWidth = function(width) {
	return this.setSize(width, this.h);
}

RShape.prototype.setHeight = function(height) {
	return this.setSize(this.w, height);
}

RShape.prototype.getWidth = function(withoutMargin) {
	if(withoutMargin) {
		return this.w - 2 * this.getHMargin();
	}
	else {
		return this.w;
	}
}

RShape.prototype.getHeight = function(withoutMargin) {
	if(withoutMargin) {
		return this.h - 2 * this.getVMargin();
	}
	else {
		return this.h;
	}
}

RShape.prototype.drawText = function(canvas) {
	this.defaultDrawText(canvas);

	return;
}

RShape.prototype.prepareStyle = function(canvas) {
	var style = this.style;
	canvas.lineWidth = style.lineWidth;			
	canvas.strokeStyle = style.lineColor;
	canvas.fillStyle = style.fillColor;

	return;
}

RShape.prototype.resetStyle = function(canvas) {
	canvas.shadowOffsetX = 0;
	canvas.shadowOffsetY = 0;
	canvas.shadowBlur    = 0;
	canvas.fillStyle = "White";
	canvas.beginPath();

	return;
}

RShape.prototype.strokeFill = function(canvas) {
	if(this.style.enableShadow || isOldIE()) {
		if(canvas.lineWidth >= 1) {
			if(!this.isStrokeColorTransparent()) {
				canvas.stroke();	
			}
		}

		if(!this.isFillColorTransparent()) {
			canvas.fill();
		}
	}
	else {
		if(!this.isFillColorTransparent()) {
			canvas.fill();	
		}

		if(canvas.lineWidth >= 1) {
			if(!this.isStrokeColorTransparent()) {
				canvas.stroke();	
			}
		}
	}

	return;
}

RShape.prototype.paintSelf = function(canvas) {
	return;
}

RShape.prototype.getCanvasContext2D = function() {
	return this.view.getCanvas2D();
}

RShape.prototype.getHitTestCanavs = function() {
	var canvas = this.view.getCanvas2D();
	if(CantkRT.isCantkRTCordova()) {
		return canvas.getCanvasRenderingContext2D("2d");
	}
	else {
		return canvas;
	}
}

RShape.prototype.hitTest = function(point) {
	var ret = Shape.HIT_TEST_NONE;

	if(!this.enable && this.mode !== Shape.MODE_EDITING) {
		return ret;
	}

	var me = this;
	var canvas = this.getHitTestCanavs();

	function applyTransform(canvas) {
		me.translate(canvas);
		me.applyTransform(canvas);
	}
	
	if(this.isPointInMatrix({x: 0, y: 0, w: this.w, h: this.h}, point, applyTransform)) {
		ret = Shape.HIT_TEST_MM;
	}

	return ret;
}

//lock is used only in IDE
RShape.prototype.isLocked = function() {
	return false;
}

RShape.prototype.lock = function() {
	this.locked = true;

	return this;
}

RShape.prototype.unlock = function() {
	this.locked = false;

	return this;
}

RShape.prototype.execMoveResize = function(x, y, w, h) {
	if(window.MoveResizeCommand) {
		this.exec(new MoveResizeCommand(this, x, y, w, h));	
	}
	else {
		if(x || x === 0) {
			this.setLeft(x);
		}
		if(y || y === 0) {
			this.setTop(y);
		}
		if(w || w === 0) {
			this.w = w;
		}
		if(h || h === 0) {
			this.h = h;
		}
	}

	return;
}

RShape.prototype.onUserMoving = function() {
}

RShape.prototype.onUserResizing = function() {
}

RShape.prototype.onUserRotating = function() {
}

RShape.prototype.handlePointerEvent = function(point, type) {
	if(type === Shape.EVT_POINTER_DOWN) {
		this.saveLeft = this.getLeft();
		this.saveTop = this.getTop();;
		this.saveW = this.w;
		this.saveH = this.h;
		this.saveRotation = this.rotation;

		return;
	}
	
	var saveW = this.saveW;
	var saveH = this.saveH;
	var dx = point.x - this.pointerDownPosition.x;
	var dy = point.y - this.pointerDownPosition.y;
	
	var newDLeft = 0;
	var newDTop = 0;
	var newW = saveW;
	var newH = saveH;
	switch(this.hitTestResult) {
		case Shape.HIT_TEST_TL: {
			newDLeft = dx;
			newDTop = dy;
			newW = saveW - dx;
			newH = saveH - dy;
			break;
		}
		case Shape.HIT_TEST_TM: {
			newDTop = dy;
			newH = saveH - dy;	
			break;
		}			
		case Shape.HIT_TEST_TR: {
			newDLeft = 0;
			newDTop = dy;
			newW = saveW + dx;
			newH = saveH - dy;
			break;
		}
		case Shape.HIT_TEST_ML: {
			newDLeft = dx;
			newW = saveW - dx;		
			break;
		}			
		case Shape.HIT_TEST_MR: {
			newW = saveW  + dx;				
			break;
		}				
		case Shape.HIT_TEST_BL: {
			newDLeft = dx;
			newW = saveW - dx;
			newH = saveH + dy;			
			break;
		}
		case Shape.HIT_TEST_BM: {
			newH = saveH + dy;			
			break;
		}			
		case Shape.HIT_TEST_BR: {
			newW = saveW + dx;
			newH = saveH + dy;			
			break;
		}			
		case Shape.HIT_TEST_MOVE: 
		case Shape.HIT_TEST_MM: {		
			newDLeft = dx;
			newDTop = dy;
			break;
		}
		case Shape.HIT_TEST_ROTATION: {
			var cx = (this.w >> 1) + this.getLeft();
			var cy = (this.h >> 1) + this.getTop();
			var angle = Math.lineAngle({x:cx, y:cy}, point) + Math.PI * 0.5;

			if(angle > Math.PI * 2) {
				angle = angle - Math.PI * 2;
			}
			this.setRotation(angle);
			this.onUserRotating();
			if(type === Shape.EVT_POINTER_UP) {
				var rotation = this.rotation;
				this.rotation = this.saveRotation;
				this.exec(AttributeCommand.create(this, "rotation", null, rotation));
			}
			break;
		}
		default:break;
	}	
	
	if(type === Shape.EVT_POINTER_UP) {
		if(!this.isUserMovable()) {
			this.setLeftTop(this.saveLeft, this.saveTop);
		}

		if(!this.isUserResizable()) {
			this.w = saveW;
			this.h = saveH;
		}
		
		var w = this.w;
		var h = this.h;
		var left = this.getLeft();
		var top = this.getTop();

		if(left !== this.saveLeft || top !== this.saveTop || w !== saveW || h !== saveH) {
			this.w = saveW;
			this.h = saveH;
			this.setLeftTop(this.saveLeft, this.saveTop);

			left = (left === this.saveLeft) ? null : Math.round(left);
			top = (top === this.saveTop) ? null : Math.round(top);
			w = (w === saveW) ? null : Math.round(w);
			h = (h === saveH) ? null : Math.round(h);

			this.execMoveResize(left, top, w, h);
			this.onUserMoved();
			this.onUserResized();
		}
	}
	else {
		if(newDLeft || newDTop) {
			if(this.isUserMovable()) {
				this.setLeftTop(Math.round(this.saveLeft + newDLeft), Math.round(this.saveTop + newDTop));
				this.onUserMoving();
			}
		}
		
		if(saveW !== newW || saveH !== newH) {
			if(this.isUserResizable()) {
				this.w = Math.max(Math.round(newW), this.MIN_SIZE);
				this.h = Math.max(Math.round(newH), this.MIN_SIZE);

				this.onUserResizing();
			}
		}
	}
	
	if(this.hitTestResult === Shape.HIT_TEST_HANDLE) {
		dx = point.x - this.lastPosition.x;
		dy = point.y - this.lastPosition.y;
		this.moveHandle(dx, dy);
	}
	
	this.postRedraw();
	
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;

	return true;
}

RShape.prototype.onKeyDown = function(code) {
	return;
}

RShape.prototype.onKeyUp = function(code) {
	return;
}		

RShape.prototype.toJson = function() {
	var o = {};

	return this.doToJson(o);
}

RShape.saveProps =  ["type", "name", "uid", "z", "w", "h", "pivotX", "pivotY", "rotation", "opacity", "hMargin", "vMargin", "scaleX", "scaleY", "spacer", "roundRadius", "runtimeVisible", "enable", "visible", "text", "iconVMargin", "iconHMargin", "locked"];

RShape.prototype.propsToJson = function(o, props) {
	var n = props.length;
	for(var i = 0; i < n; i++) {
		var key = props[i];
		var value = this[key];
		if(value !== undefined) {
			o[key] = value;
		}
	}

	return this;
}

RShape.prototype.propsFromJson = function(js, props) {
	var n = props.length;
	for(var i = 0; i < n; i++) {
		var key = props[i];
		var value = js[key];
		if(value !== undefined) {
			this[key] = value;
		}
	}

	return this;
}

RShape.prototype.doToJson = function(o) {
	this.propsToJson(o, RShape.saveProps);

	o.x = this.left;
	o.y = this.top;
	o.style = this.style.toJson();
	
	return o;
}

RShape.prototype.onFromJsonDone = function(js) {
}

RShape.prototype.fromJson = function(js) {
	this.isUnpacking = true;
	this.doFromJson(js);
	this.onFromJsonDone(js);
	this.isUnpacking = false;

	return this;
}

RShape.prototype.doFromJson = function(js) {
	this.textNeedRelayout = true;
	this.state = Shape.STAT_NORMAL;
	this.propsFromJson(js, RShape.saveProps);

	if(js.x !== undefined) {
		this.left = js.x;
	}
	if(js.y !== undefined) {
		this.top = js.y;
	}

	this.setText(js.text);
	this.setEnable(js.enable);
	this.setVisible(js.visible !== false);
	this.style.fromJson(js.style);

	return;
}

RShape.prototype.setImage = function(value) {
	if(value === this.imageUrl) {
		return;
	}

	this.imageUrl = value;
	this.image = new WImage(value);
	
	return this;
}


RShape.prototype.asIcon = function() {
	this.setSize(36, 36);

	if(!this.isIcon) {
		this.setStyle(Shape.getIconShapeStyle());
	}

	this.isIcon = true;

	return;
}	

RShape.prototype.showProperty = function() {
	var app = this.getApp();
	if(app) {
		app.showRShapePropertyDialog(this);
	}

	return;
}
	
RShape.prototype.getMoveDeltaX = function() {
	return this.view ? this.view.getMoveDeltaX() : 0; 
}

RShape.prototype.getMoveDeltaY = function() {
	return this.view ? this.view.getMoveDeltaY() : 0;
}

RShape.prototype.getMoveAbsDeltaX = function() {
	return this.view ? this.view.getMoveAbsDeltaX() : 0;
}

RShape.prototype.getMoveAbsDeltaY = function() {
	return this.view ? this.view.getMoveAbsDeltaY() : 0;
}

RShape.prototype.setRoundRadius = function(roundRadius) {
	this.roundRadius = roundRadius;

	return this;
}

RShape.prototype.setFillColor = function(fillColor) {
	this.style.setFillColor(fillColor);

	return this;
}

RShape.prototype.setLineColor = function(lineColor) {
	this.style.setLineColor(lineColor);

	return this;
}

RShape.prototype.setTextColor = function(textColor) {
	this.style.setTextColor(textColor);

	return this;
}

RShape.prototype.getFillColor = function() {
	return this.style.fillColor;
}

RShape.prototype.getLineColor = function() {
	return this.style.lineColor;
}

RShape.prototype.getTextColor = function() {
	return this.style.textColor;
}

Object.defineProperty(RShape.prototype, "x", {
	get: function () {
		return this.getX();
	},
	set: function (value) {
		this.setX(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "y", {
	get: function () {
		return this.getY();
	},
	set: function (value) {
		this.setY(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "left", {
	get: function () {
		return this.getLeft();
	},
	set: function (value) {
		this.setLeft(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "top", {
	get: function () {
		return this.getTop();
	},
	set: function (value) {
		this.setTop(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "width", {
	get: function () {
		return this.getWidth();
	},
	set: function (value) {
		this.setWidth(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "height", {
	get: function () {
		return this.getHeight();
	},
	set: function (value) {
		this.setHeight(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "anchorX", {
	get: function () {
		return this.getAnchorX();
	},
	set: function (value) {
		this.setAnchorX(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "anchorY", {
	get: function () {
		return this.getAnchorY();
	},
	set: function (value) {
		this.setAnchorY(value);
	},
	enumerable: true,
	configurable: true
});


function RShapeInit(g, type) {
	g.initRShape(0, 0, 40, 40, type);

	return g;
}

/*
 * File: shape_factory.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: register all built-in shapes.
 * 
 * Copyright (c) 2011 - 2014  Li XianJing <xianjimli@hotmail.com>
 * 
 */

var C_CREATE_FOR_USER = 0;
var C_CREATE_FOR_ICON = 1;
var C_CREATE_FOR_PROGRAM = 2;

function ShapeCreator(type, name, icon, visible) {
	this.type = type;
	this.icon = icon;
	this.name = name;
	this.visible = visible;

	this.isVisibleToUser = function() {
		return this.visible;
	}
	
	this.getID = function() {
		return this.type;
	}
	
	this.getIcon = function() {
		return this.icon;
	}
	
	this.getName = function() {
		return this.name;
	}

	this.createIconShape = function() {
		if(!this.iconShape) {
			this.iconShape = this.createShape(C_CREATE_FOR_ICON);
            this.iconShape.initIconShape();
		}
	
		return this.iconShape;
	}
	
	this.createShape = function(createReason) {
		return null;
	}
	
	return;
}

function ShapeFactory() {
	this.defaultCategory = null;
	this.recentUsed = [];
	this.creators = [];
	this.categories = {};
	this.categoryNames = [];
	this.diagramTypes = [];
	this.listeners = [];

	ShapeFactory.CATEGORY_RECENT_USED = "Recent Used";
	ShapeFactory.CATEGORY_USER_COMPONENTS = "User Component";
    ShapeFactory.CATEGORY_USER = "User";
    ShapeFactory.CATEGORY_GAME = "Game";
    ShapeFactory.CATEGORY_ORGANIZATION = "Organization";

	this.setDefaultCategory = function(defaultCategory) {
		this.defaultCategory = defaultCategory;

		return;
	}

	this.getDiagramTypes = function() {
		return this.diagramTypes;
	}

	this.addDiagramType = function(type, defaultCategory) {
		var obj = {name:type, defaultCategory:defaultCategory};

		this.diagramTypes.push(obj);

		return;
	}

	this.removeCategoryName = function(name) {
		this.categoryNames.remove(name);

		return;
	}

	this.removeShapeCreator = function(type, category) {
		var creator = this.find(type);
		var categoryCreators = this.categories[category];
		if(creator) {
			this.creators.remove(creator);
			if(categoryCreators) {
				categoryCreators.remove(creator);
				this.notifyChanged("remove", category, creator);
			}
		}

		return;
	}

	this.isPlacehodler = function(category) {
		return category === "---";
	}
	
	this.isUserComponents = function(category) {
		return category === ShapeFactory.CATEGORY_USER_COMPONENTS;
	}

	this.addPlaceholder = function() {
		this.categoryNames.push("---");

		return;
	}

	this.loadRecentUsedShapeCreators = function() {
		var str = WebStorage.get("recentUsed");
		var types = str ? JSON.parse(str) : [];

		for(var i = 0; i < types.length; i++) {
			var type = types[i];
			var creator = this.find(type);
			if(creator) {
				this.addShapeCreator(creator, ShapeFactory.CATEGORY_RECENT_USED);
				this.recentUsed.push(type);
			}
		}

		return;
	}

	this.addRecentUsedShapeCreator = function(type) {
		var creator = this.find(type);
		if(creator) {
			this.recentUsed.remove(type);
			this.recentUsed.push(type);

			if(this.recentUsed.length > 10) {
				this.recentUsed.shift();
			}
			WebStorage.set("recentUsed", JSON.stringify(this.recentUsed));

			this.addShapeCreator(creator, ShapeFactory.CATEGORY_RECENT_USED);
		}
	}

	this.addShapeCreator = function(creator, category) {
		this.notifyChanged("add", category, creator);

		if(category != ShapeFactory.CATEGORY_RECENT_USED) {
			this.creators.push(creator);
		}

		if(category) {
			if(!this.defaultCategory) {
				this.setDefaultCategory(category);
			}

			if(!this.categories[category]) {
				this.categories[category] = [];

				if(category == ShapeFactory.CATEGORY_RECENT_USED) {
					this.categoryNames.unshift(category);
				}
				else {
					this.categoryNames.push(category);
				}
			}
			
			this.categories[category].remove(creator);
			if(category == ShapeFactory.CATEGORY_RECENT_USED) {
				this.categories[category].unshift(creator);
			}
			else {
				this.categories[category].push(creator);
			}
		}
//		console.log("Register: category=" + category + " id=" + creator.getID());

		return;
	}

	this.getCategoryNames = function() {
		return this.categoryNames;
	}
	
	this.getDefaultCategory = function() {
		return this.categories[this.defaultCategory];
	}

	this.getByCategory = function(category) {
		return this.categories[category];
	}
	
	this.find = function(type) {
		for(var i = 0; i < this.creators.length; i++) {
			var c = this.creators[i];
			if(c.getID() === type) {
				return c;
			}
		}
		
		return null;
	}

	this.createShapeByUser = function(type, exactly) {
		return this.createShape(type, C_CREATE_FOR_USER, exactly);
	}
	
	this.createShapeByProgram = function(type, exactly) {
		return this.createShape(type, C_CREATE_FOR_PROGRAM, exactly);
	}

	this.createShape = function(type, createReason, exactly) {
		if(!type) {
			return null;
		}

		var c = this.find(type);
		if(c) {
			var s = c.createShape(createReason);
            if(createReason === C_CREATE_FOR_USER) {
                s.initPanelShape(); 
            }
            return s;
		}
		
		console.log("not found type " + type + ", create ui-unkown instead.");

		if(!exactly) {
			c = this.find("ui-unkown");
			if(c) {
				return c.createShape(createReason);
			}

			return null;
		}
	}

	this.addListener = function(func) {
		this.listeners.push(func);

		return this;
	}

	this.removeListener = function(func) {
		this.listeners.remove(func);

		return this;
	}
	
	this.notifyChanged = function(type, category, creator) {
		var listeners = this.listeners;
		for(var i = 0; i < listeners.length; i++) {
			var func = listeners[i];
			if(func) {
				func(type, category, creator);
			}
		}

		return;
	}

	return;
}

ShapeFactory.instance = null;

ShapeFactory.getInstance = function() {
	if(!ShapeFactory.instance) {
		ShapeFactory.instance = new ShapeFactory();
		setTimeout(function() {
			ShapeFactory.instance.loadRecentUsedShapeCreators();
		}, 2000);
	}

	return ShapeFactory.instance;
}


function ShapeFactoryGet() {
	return ShapeFactory.getInstance();
}

function dappSetDefaultCategory(name) {
	return ShapeFactory.getInstance().setDefaultCategory(name);
}

function cantkRegShapeCreator(creator, category) {
	return ShapeFactory.getInstance().addShapeCreator(creator, category);
}
function dupDeviceConfig(config) {
	var o = {};

	o.name = config.name;
	o.bg = config.bg
	o.platform = config.platform;
	o.version = config.version;
	o.lcdDensity = config.lcdDensity;
	o.width = config.width;
	o.height = config.height;
	o.screenX = config.screenX;
	o.screenY = config.screenY;
	o.screenW = config.screenW;
	o.screenH = config.screenH;
	o.hasMenuBar = config.hasMenuBar;

	return o;
}
	
function cantkDetectDeviceConfig() {
	var deviceConfig = {version:4};
		
	if(isAndroid()) {
		deviceConfig.platform = "android";
	}
	else if(isIPhone () || isIPad()) {
		deviceConfig.platform = "iphone";
	}
	else if(isFirefoxOS()) {
		deviceConfig.platform = "firefox";
	}
	else if(isWinPhone()) {
		deviceConfig.platform = "winphone";
	}
	else if(isTizen()) {
		deviceConfig.platform = "tizen";
	}
	else {
		deviceConfig.platform = "android";
	}

	if(window.devicePixelRatio > 2.2) {
		deviceConfig.lcdDensity = "xxhdpi";
	}
	else if(window.devicePixelRatio > 1.5) {
		deviceConfig.lcdDensity = "xhdpi";
	}
	else if(window.devicePixelRatio > 1.1) {
		deviceConfig.lcdDensity = "hdpi";
	}
	else if(window.devicePixelRatio > 0.8) {
		deviceConfig.lcdDensity = "mdpi";
	}
	else if(!window.devicePixelRatio) {
		var minSize = Math.min(window.orgViewPort.width, window.orgViewPort.height);
		if(minSize > 600) {
			deviceConfig.lcdDensity = "xhdpi";
		}
		else {
			deviceConfig.lcdDensity = "hdpi";
		}
	}
	else {
		deviceConfig.lcdDensity = "ldpi";
	}

	if(isFirefoxOS()) {
		deviceConfig.lcdDensity = "mdpi";
	}

	if(!isMobile()) {
		deviceConfig.lcdDensity = "hdpi";
	}

	console.log("deviceConfig.lcdDensity:" + deviceConfig.lcdDensity);
	console.log("deviceConfig.platform:" + deviceConfig.platform);

	return deviceConfig;
}

function isDeviceConfigEqual(c1, c2) {
	var s1 = JSON.stringify(c1);
	var s2 = JSON.stringify(c2);

	return s1 === s2;
}

function cantkPreloadImage(src) {
	var image = new WImage(src);

	return image;
}
	
var gTempCanvas = null;
function cantkGetTempCanvas(width, height) {
	if(!gTempCanvas) {
		gTempCanvas = document.createElement("canvas");

		gTempCanvas.type = "backend_canvas";
		gTempCanvas.width = width;
		gTempCanvas.height = height;
	}

	if(gTempCanvas) {
		if(gTempCanvas.width != width) {
			gTempCanvas.width = width;
		}

		if(gTempCanvas.height != height) {
			gTempCanvas.height = height;
		}
	}

	return gTempCanvas;
}

//////////////////////////////////////////////////////////////////////////}-{

var gApp8LocaleStrings = {
	'Loading...':'正在努力加载...'
};

function webappGetText(text) {
	var str = null;
	if(!text) {
		return "";
	}

	if(gApp8LocaleStrings) {
		str = gApp8LocaleStrings[text];
	}

	if(!str) {
		str = text;
//		console.log("\""+text+"\":" + "\"" +text+ "\",");
	}

	return str;
}

function webappSetLocaleStrings(strs) {
	gApp8LocaleStrings = strs;

	return;
}

var gDeviceConfigs = [];
function cantkRegisterDevice(device) {
	gDeviceConfigs.push(dupDeviceConfig(device));

	return;
}

function cantkGetDeviceConfig(name) {
	for(var i = 0; i < gDeviceConfigs.length; i++) {
		var device = gDeviceConfigs[i];
		if(device.name === name) {
			return dupDeviceConfig(device);
		}
	}

	return null;
}

function cantkGetAllDeviceConfig() {
	return gDeviceConfigs;
}

function cantkLoadDefaultDeviceConfigs() {
	var androidWVGA800 = {
		name : "android-WVGA800",
		bg: "/drawapp8/images/devices/device_800x480.png",
		platform:"android",
		version: "4",
		lcdDensity:"hdpi",
		width:600,
		height:1126,
		screenX: 60,
		screenY: 198,
		screenW: 480,
		screenH: 800,
		hasMenuBar:true
	};
	
	var tizenWVGA800 = {
		name : "tizen-WVGA800",
		bg: "/drawapp8/images/devices/device_800x480.png",
		platform:"tizen",
		version: "4",
		lcdDensity:"hdpi",
		width:600,
		height:1126,
		screenX: 60,
		screenY: 198,
		screenW: 480,
		screenH: 800
	};

	var tizenWXGA720 = {
		name : "tizen-WXGA720",
		bg: "/drawapp8/images/devices/device_1280x720.png",
		platform:"tizen",
		version: "4",
		lcdDensity:"xhdpi",
		width:860,
		height:1802,
		screenX: 74,
		screenY: 268,
		screenW: 720,
		screenH: 1280
	};

	var androidWXGA720 = {
		name : "android-WXGA720",
		bg: "/drawapp8/images/devices/device_1280x720.png",
		platform:"android",
		version: "4",
		lcdDensity:"xhdpi",
		width:860,
		height:1802,
		screenX: 74,
		screenY: 268,
		screenW: 720,
		screenH: 1280,
		hasMenuBar:true
	};

	var androidWXGA800 = {
		name : "android-WXGA800",
		bg: "/drawapp8/images/devices/device.png",
		platform: "android",
		version: "4",
		lcdDensity:"mdpi",
		width:1400,
		height:964,
		screenX: 60,
		screenY: 82,
		screenW: 1280,
		screenH: 800,
		hasMenuBar:true
	};
	
	var androidWSVGA = {
		name : "android-WSVGA",
		bg: "/drawapp8/images/devices/device.png",
		platform:"android",
		version: "4",
		lcdDensity:"mdpi",
		width:1130,
		height:764,
		screenX: 60,
		screenY: 82,
		screenW: 1024,
		screenH: 600,
		hasMenuBar:true
	};

	
	var iphone4s = {
		name : "iphone4s",
		bg: "/drawapp8/images/devices/device_iphone4s.png",
		platform: "iphone",
		version: "4s",
		lcdDensity:"xhdpi",
		width:760,
		height:1487,
		screenX: 65,
		screenY: 265,
		screenW: 640,
		screenH: 960,
		hasMenuBar:false
	};
	
	var iphone5 = {
		name : "iphone5",
		bg: "/drawapp8/images/devices/device_iphone5.png",
		platform: "iphone",
		version: "5",
		lcdDensity:"xhdpi",
		width:765,
		height:1600,
		screenX: 65,
		screenY: 238,
		screenW: 640,
		screenH: 1136,
		hasMenuBar:false
	};
	
	var blackberryQ10 = {
		name : "BlackBerry Q10",
		bg: "/drawapp8/images/devices/device_bb_q10.jpg",
		platform: "blackberry",
		version: "10",
		lcdDensity:"xhdpi",
		width:860,
		height:1520,
		screenX: 66,
		screenY: 246,
		screenW: 720,
		screenH: 720,
		hasMenuBar:false
	};
	
	var blackberryZ10 = {
		name : "BlackBerry Z10",
		bg: "/drawapp8/images/devices/device_bb_z10.jpg",
		platform: "blackberry",
		version: "10",
		lcdDensity:"xhdpi",
		width:920,
		height:1820,
		screenX: 72,
		screenY: 258,
		screenW: 768,
		screenH: 1280,
		hasMenuBar:false
	};
	
	var lumia800 = {
		name : "Nokia Lumia 800",
		bg: "/drawapp8/images/devices/device_nokia_lumia_800.jpg",
		platform: "winphone",
		version: "8",
		lcdDensity:"hdpi",
		width:620,
		height:1170,
		screenX: 86,
		screenY: 146,
		screenW: 480,
		screenH: 800,
		hasMenuBar:false
	};
	
	var lumia920 = {
		name : "Nokia Lumia 920",
		bg: "/drawapp8/images/devices/device_nokia_lumia_920.jpg",
		platform: "winphone",
		version: "8",
		lcdDensity:"xhdpi",
		width:1050,
		height:1780,
		screenX: 136,
		screenY: 192,
		screenW: 768,
		screenH: 1280,
		hasMenuBar:false
	};
	
	var ipadmini = {
		name : "iPad Mini",
		bg: "/drawapp8/images/devices/device_ipad_mini.jpg",
		platform: "iphone",
		version: "5",
		lcdDensity:"mdpi",
		width:876,
		height:1290,
		screenX: 52,
		screenY: 132,
		screenW: 768,
		screenH: 1024,
		hasMenuBar:false
	};
	
	var ipad4 = {
		name : "iPad 4",
		bg: "/drawapp8/images/devices/device_ipad_4.jpg",
		platform: "iphone",
		version: "5",
		lcdDensity:"hdpi",
		width:1942,
		height:2542,
		screenX: 198,
		screenY: 238,
		screenW: 1536,
		screenH: 2048,
		hasMenuBar:false
	};
	
	var pcGeneral = {
		name : "PC-General",
		bg: "/drawapp8/images/pc-general.png",
		platform: "android",
		version: "4",
		lcdDensity:"hdpi",
		width:856,
		height:668,
		screenX: 30,
		screenY: 32,
		screenW: 800,
		screenH: 600
	};
	
	var pcPortrait = {
		name : "PC-Portrait",
		bg: "/drawapp8/images/pc-480x720.png",
		platform: "android",
		version: "4",
		lcdDensity:"hdpi",
		width:600,
		height:840,
		screenX: 60,
		screenY: 70,
		screenW: 480,
		screenH: 720,
		hasMenuBar:false
	};

	var device480x720 = {
		name : "480x720",
		bg: "/drawapp8/images/device.png",
		platform: "android",
		lcdDensity:"hdpi",
		width:552,
		height:878,
		screenX: 36,
		screenY: 80,
		screenW: 480,
		screenH: 720 
	};

	var device480x800 = {
		name : "480x800",
		bg: "/drawapp8/images/device.png",
		platform: "android",
		lcdDensity:"hdpi",
		width:552,
		height:974,
		screenX: 36,
		screenY: 88,
		screenW: 480,
		screenH: 800 
	};
	
	var device720x1280 = {
		name : "720x1280",
		bg: "/drawapp8/images/device.png",
		platform: "android",
		lcdDensity:"hdpi",
		width:832,
		height:1500,
		screenX: 56,
		screenY: 112,
		screenW: 720,
		screenH: 1280 
	};

	var device320x480 = {
		"name": "320x480",
		"bg": "/drawapp8/images/device.png",
		"platform": "android",
		"lcdDensity": "mdpi",
		"width": 370,
		"height": 590,
		"screenX": 25,
		"screenY": 55,
		"screenW": 320,
		"screenH": 480
	};
	
	cantkRegisterDevice(device480x720);
	cantkRegisterDevice(device720x1280);
	cantkRegisterDevice(device480x800);
	cantkRegisterDevice(device320x480);
	cantkRegisterDevice(pcGeneral);

	return;
}

cantkLoadDefaultDeviceConfigs();
/*
 * File: ui_animation.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: ui animation.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

//////////////////////////////////////////////////

VelocityTracker.prototype.HISTORY_SIZE = 20;
VelocityTracker.prototype.HORIZON = 200 * 1000000;
VelocityTracker.prototype.MIN_DURATION = 10 * 1000000;

function Movement() {
	this.eventTime = 0;
	this.point = new Point(0, 0);

	this.getPoint = function() {
		return this.point;
	}

	return this;
}

function VelocityTracker() {
    this.clear();

    return this;
}

VelocityTracker.prototype.clear = function() {
    this.index = 0;
	
	var HISTORY_SIZE = this.HISTORY_SIZE;
    if(!this.movements) {
		this.movements = new Array();
		for(var i = 0; i < HISTORY_SIZE; i++) {
			this.movements.push(new Movement());
		}
    }

	for(var i = 0; i < HISTORY_SIZE; i++) {
		var iter = this.movements[i];
		iter.eventTime = 0;
		iter.point = {x:0, y:0};
	}

    return;
}

VelocityTracker.prototype.addMovement = function(eventTime, point) {
    if (++this.index == this.HISTORY_SIZE) {
        this.index = 0;
    }

    this.movements[this.index].eventTime = eventTime;
    this.movements[this.index].point = point;

    return;
}

VelocityTracker.prototype.getVelocity = function() {
	var velocity = {x:0, y:0};

	this.estimate();

	velocity.x = this.xVelocity;
	velocity.y = this.yVelocity;

	return velocity;
}

VelocityTracker.prototype.estimate = function() {
	var HORIZON = this.HORIZON;
	var MIN_DURATION = this.MIN_DURATION;
	var HISTORY_SIZE = this.HISTORY_SIZE;
    var newestMovement = this.movements[this.index];
    var minTime = newestMovement.eventTime - HORIZON;
    var oldestIndex = this.index;
    var numTouches = 1;

    do {
        var nextOldestIndex = (oldestIndex == 0 ? HISTORY_SIZE : oldestIndex) - 1;
        var nextOldestMovement = this.movements[nextOldestIndex];
        if (nextOldestMovement.eventTime < minTime) {
            break;
        }
        oldestIndex = nextOldestIndex;
    } while (++numTouches < HISTORY_SIZE);

    var accumVx = 0;
    var accumVy = 0;
    var index = oldestIndex;
    var samplesUsed = 0;
    var oldestMovement = this.movements[oldestIndex];
   	var oldestPosition = oldestMovement.getPoint();
    var lastDuration = 0;

    while (numTouches-- > 1) {
        if (++index == HISTORY_SIZE) {
            index = 0;
        }
        var movement = this.movements[index];
        var duration = movement.eventTime - oldestMovement.eventTime;

        if (duration >= MIN_DURATION) {
            var position = movement.getPoint();
            var scale = 1000000000.0 / duration; // one over time delta in seconds
            var vx = (position.x - oldestPosition.x) * scale;
            var vy = (position.y - oldestPosition.y) * scale;
            accumVx = (accumVx * lastDuration + vx * duration) / (duration + lastDuration);
            accumVy = (accumVy * lastDuration + vy * duration) / (duration + lastDuration);
            lastDuration = duration;
            samplesUsed += 1;
        }
    }

    // Report velocity.
    if (samplesUsed) {
		this.xVelocity = accumVx;
		this.yVelocity = accumVy;
    } else {
		this.xVelocity = 0;
		this.yVelocity = 0;
    }

    return true;
}

function testVelocityTracker() {
	var v = null;
	var vt = new VelocityTracker();
	function toNs(ms) {
		return ms * 1000000;
	}

	for(var i = 0; i < 20; i++) {
		vt.addMovement(toNs(10 * i), {x:10*i, y:10*i*i/2});
	}

	v = vt.getVelocity();

	console.log("xv: " + v.x + " yv: " + v.y);

	return;
}

//testVelocityTracker();

//////////////////////////////////////////////////////////////////////

/**
 * @class Interpolator 
 * 插值算法接口。它的基本功能就是将时间进度(0-1)变换成任务实际进度(0,1)，重而实现加速，减速，先加速再减速和回弹等效果。
 */
function Interpolator() {

/**
 * @method get 
 * 获取任务实际进度。
 * @param {Number} percent 时间进度(0-1)。
 * @return {Number} 返回任务实际进度。
 */
	this.get = function(percent) {
		return 0;
	}

	return this;
}

/**
 * @class Interpolator 
 * 插值算法接口。它的基本功能就是将时间进度(0-1)变换成任务实际进度(0,1)，重而实现加速，减速，先加速再减速和回弹等效果。
 */
function LinearInterpolator() {
	this.get = function(percent) {
		return percent;
	}

	return this;
}

/**
 * @method create 
 * 创建插值算法对象。
 * @param {String} name 插值算法的名称。
 * @return {Interpolator} 返回插值算法对象。
 *
 *     @example small frame
 *     //创建线形插值算法（l|linear):
 *     var interpolator = Interpolator.create('l');
 *     //创建回弹插值算法 (b|bounce)
 *     var interpolator = Interpolator.create('b');
 *     //创建加速插值算法 (a|accelerate)
 *     var interpolator = Interpolator.create('a');
 *     //创建先加速再加速插值算法(ad|accelerate-decelerate)
 *     var interpolator = Interpolator.create('ad');
 *     //创建减速插值算法(d|decelerate)
 *     var interpolator = Interpolator.create('d');
 */
Interpolator.create = function(name, args) { 
	return AnimationFactory.createInterpolator(name, args);	
}

function BounceInterpolator() {
	function bounce(percent) {
		return 8 * percent * percent;
	}

	this.get = function(percent) {
		percent *= 1.1226;
        if (percent < 0.3535) return bounce(percent);
        else if (percent < 0.7408) return bounce(percent - 0.54719) + 0.7;
        else if (percent < 0.9644) return bounce(percent - 0.8526) + 0.9;
        else return bounce(percent - 1.0435) + 0.95;
	}

	return this;
}

function AccelerateInterpolator() {
	this.get = function(percent) {
		return percent * percent;
	}

	return this;
}

function AccDecelerateInterpolator() {
	this.get = function(percent) {
		return ((Math.cos((percent + 1) * Math.PI) / 2.0) + 0.5);
	}

	return this;
}

function DecelerateInterpolator(factor) {
	this.factor = factor ? factor : 2;
	this.get = function(percent) {
		if(this.factor === 1) {
			return (1.0 - (1.0 - percent) * (1.0 - percent));
		}
		else {
			return (1.0 - Math.pow((1.0 - percent), 2 * this.factor));
		}
	}

	return this;
}

function SineAccelerateInterpolator() {
	this.get = function(percent) {
		return -Math.cos(percent * (Math.PI / 2)) + 1;
	}

	return this;
}

function SineAccDecelerateInterpolator() {
	this.get = function(percent) {
		return (-0.5 * (Math.cos(Math.PI * percent) - 1));
	}

	return this;
}

function SineDecelerateInterpolator() {
	this.get = function(percent) {
		return Math.sin(percent * (Math.PI / 2));
	}

	return this;
}

//////////////////////////////////////////////////////////////////////
function AnimationFactory() {
	this.createAnimation = function(name, duration) {
		UIElement.getMainCanvasScale(true);
		var defaultDuration = isIPhone() ? 400 : 600;
		duration = duration ? duration : defaultDuration;
		switch(name) {
			case "anim-forward": {
				var interpolator =  new DecelerateInterpolator();
				animation = isAndroid() ? new AnimationHTranslate(true) : new AnimationHTranslate(true);
				animation.toLeft();
				animation.init(duration, interpolator);
				break;
			}
			case "anim-backward": {
				var interpolator =  new DecelerateInterpolator();
				animation = isAndroid() ? new AnimationHTranslate(false) : new AnimationHTranslate(false);
				animation.toRight();
				animation.init(duration, interpolator);
				break;
			}
			case "anim-upward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationVTranslate(true);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-downward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationVTranslate(false);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-show-win": {
				var interpolator =  new DecelerateInterpolator(1);
				if(isMobile()) {
					animation = new AnimationBrowserScaleWin(true);
					animation.setRange(1.2, 1.0);
				}
				else {
					animation = new AnimationScale(true);
					animation.setRange(0.9, 1.0);
				}
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-hide-win": {
				var interpolator =  new AccelerateInterpolator();
				if(isMobile()) {
					animation = new AnimationBrowserScaleWin(false);
					animation.setRange(0.9, 1.0);
				}
				else {
					animation = new AnimationScale(false);
					animation.setRange(1.0, 0.9);
				}
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-show-dialog": {
				duration = duration ? duration : 300;
				var interpolator =  new DecelerateInterpolator();
				animation = isAndroid() ? new AnimationBrowserScaleDialog(true) : new AnimationScale(true);
				animation.setRange(0.9, 1.0);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-hide-dialog": {
				duration = duration ? duration : 300;
				var interpolator =  new AccelerateInterpolator();
				animation = isAndroid() ? new AnimationBrowserScaleDialog(false) : new AnimationScale(false);
				animation.setRange(1.0, 0.9);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-fade-in": {
				var interpolator =  new AccelerateInterpolator();
				animation = isAndroid() ? new AnimationBrowserAlpha(true) : new AnimationAlpha(true);
				animation.setRange(0.6, 1.0);
				animation.init(500, interpolator);
				break;
			}
			case "anim-fade-out": {
				var interpolator =  new AccelerateInterpolator();
				animation = isAndroid() ? new AnimationBrowserAlpha(false) : new AnimationAlpha(false);
				animation.setRange(1.0, 0.8);
				animation.init(300, interpolator);
				break;
			}
			case "anim-move-up": {
				var interpolator =  new DecelerateInterpolator();
				animation = isMobile() ? new AnimationBrowserMove(true) : new AnimationMove(true);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-move-down": {
				var interpolator =  new AccelerateInterpolator();
				animation = isMobile() ? new AnimationBrowserMove(false) : new AnimationMove(false);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-expand-up": 
			case "anim-expand-left": 
			case "anim-expand-right": 
			case "anim-expand-down": {
				var interpolator =  new DecelerateInterpolator(); 
				animation = new Animation1Expand(true);
				animation.init(400, interpolator);
				break;
			}
			case "anim-collapse-up": 
			case "anim-collapse-left": 
			case "anim-collapse-right": 
			case "anim-collapse-down": {
				var interpolator =  new AccelerateInterpolator(); 
				animation = new Animation1Expand(true);
				animation.init(400, interpolator);
				break;
			}
			case "anim-scale1-show-origin-topleft":
			case "anim-scale1-show-origin-center":
			case "anim-scale1-show-origin-bottomleft":
			case "anim-scale1-show-origin-topright":
			case "anim-scale1-show-origin-bottomright":
			case "anim-scale1-show": {
				var interpolator =  new DecelerateInterpolator(); 
				animation = new Animation1Scale(true);
				animation.init(400, interpolator);
				break;
			}
			case "anim-scale1-hide-origin-topleft":
			case "anim-scale1-hide-origin-center":
			case "anim-scale1-hide-origin-bottomleft":
			case "anim-scale1-hide-origin-topright":
			case "anim-scale1-hide-origin-bottomright":
			case "anim-scale1-hide": {
				var interpolator =  new AccelerateInterpolator(); 
				animation = new Animation1Scale(false);
				animation.init(400, interpolator);
				break;
			}
			case "anim-alpha1-show": {
				var interpolator =  new DecelerateInterpolator(); 
				animation = new Animation1Alpha(true);
				animation.init(400, interpolator);
				break;
			}
			case "anim-alpha1-hide": {
				var interpolator =  new AccelerateInterpolator(); 
				animation = new Animation1Alpha(false);
				animation.init(400, interpolator);
				break;
			}
			
		}
		
		return animation;
	}

	return this;
}

AnimationFactory.createInterpolator = function(name, args) {
	switch(name) {
		case 'l': 
		case 'linear': {
			return new LinearInterpolator();
		}
		case 'b':
		case 'bounce': {
			return new BounceInterpolator();
		}
		case 'a':
		case 'accelerate': {
			return new AccelerateInterpolator();
		}
		case 'ad':
		case 'accelerate-decelerate': {
			return new AccDecelerateInterpolator();
		}
		case 'sa':
		case 'sine-accelerate': {
			return new SineAccelerateInterpolator();
		}
		case 'sd':
		case 'sine-decelerate': {
			return new SineDecelerateInterpolator();
		}
		case 'sad':
		case 'sine-accelerate-decelerate': {
			return new SineAccDecelerateInterpolator();
		}
		default: {
			return new DecelerateInterpolator();
		}
	}
}

AnimationFactory.create = function(name, duration) {
	if(!AnimationFactory.instance) {
		AnimationFactory.instance = new AnimationFactory();
	}

	return AnimationFactory.instance.createAnimation(name, duration);
}

Animation.getCanvas = function() {
	if(!Animation.canvas) {
		Animation.canvas = document.createElement("canvas");
		Animation.canvas.type = "animation_canvas";
	}
	
	Animation.canvas.style.zIndex = 9;
	Animation.canvas.style["opacity"] = 1;
	scaleElement(Animation.canvas, 1, 1);
	
	return Animation.canvas;
}

Animation.getOldWinCanvas = function() {
	if(!Animation.oldWnCanvas) {
		Animation.oldWnCanvas= document.createElement("canvas");
		Animation.oldWnCanvas.type = "animation_canvas";
	}
	
	Animation.oldWnCanvas.style.zIndex = 9;
	Animation.oldWnCanvas.style["opacity"] = 1;
	scaleElement(Animation.oldWnCanvas, 1, 1);
	
	return Animation.oldWnCanvas;
}

Animation.getNewWinCanvas = function() {
	if(!Animation.newWinCanvas) {
		Animation.newWinCanvas= document.createElement("canvas");
		Animation.newWinCanvas.type = "animation_canvas";
	}

	Animation.newWinCanvas.style.zIndex = 9;
	Animation.newWinCanvas.style["opacity"] = 1;
	scaleElement(Animation.newWinCanvas, 1, 1);
	
	return Animation.newWinCanvas;
}

Animation.getBackendCanvas = function(width, height) {
	if(!Animation.backendCanvas) {
		Animation.backendCanvas = document.createElement("canvas");

		Animation.backendCanvas.type = "backend_canvas";
		Animation.backendCanvas.width = width;
		Animation.backendCanvas.height = height;
	}

	if(Animation.backendCanvas) {
		if(Animation.backendCanvas.width != width) {
			Animation.backendCanvas.width = width;
		}

		if(Animation.backendCanvas.height != height) {
			Animation.backendCanvas.height = height;
		}
		Animation.scaleCanvas(Animation.backendCanvas, width, height);
	}
	scaleElement(Animation.backendCanvas, 1, 1);

	return Animation.backendCanvas;
}


function Animation(showWin) {
	this.scale = 1;
	this.visible = false;
	this.showWin = showWin;

	this.init = function(duration, interpolator) {
		this.duration = duration ? duration : 500;
		this.interpolator = interpolator;

		return;
	}

	this.setRectOfFront = function(x, y, w, h) {
		this.frontX = x;
		this.frontY = y;
		this.frontW = w;
		this.frontH = h;

		return;
	}

	this.setScale = function(scale) {
		this.scale = scale;

		return;
	}

	this.prepare = function(x, y, w, h, canvasImage, onFinish) {
		this.x = Math.round(x);
		this.y = Math.round(y);
		this.w = Math.round(w);
		this.h = Math.round(h);
		this.onFinish = onFinish;
		this.canvasImage = CantkRT.createImageFromCanvas(canvasImage);

		this.setRectOfFront(0, 0, w, h);
		if(canvasImage) {
			this.sw = canvasImage.width;
			this.sh = canvasImage.height;
		}

		this.show();

		return true;
	}

	this.moveResizeCanvas = function(canvasElement, x, y, w, h) {
		canvasElement.style.position = "absolute";
		canvasElement.width = w;
		canvasElement.height = h;
		setElementPosition(canvasElement, x, y);
		canvasElement.style.visibility = 'visible';

		Animation.scaleCanvas(canvasElement, w, h);

		return;
	}

	this.show = function() {
		var w = this.w * this.scale;
		var h = this.h * this.scale;

		this.visible = true;
		this.canvasElement = Animation.getCanvas();

		this.moveResizeCanvas(this.canvasElement, this.x, this.y, w, h);
		document.body.appendChild(this.canvasElement);
		
		return true;
	}

	this.hide = function() {
		this.visible = false;
		if(this.canvasElement && this.canvasElement.parentNode) {
			document.body.removeChild(this.canvasElement);
			this.canvasElement = null;
		}

		return true;
	}

	this.getTimePercent = function() {
		var date = new Date();
		var elapsed = date.getTime() - this.startTime;

		return elapsed/this.duration;
	}

	this.getPercent = function(timePercent) {
		return this.interpolator.get(timePercent);	
	}

	this.step = function(percent) {
		/*Overwrite it*/
		return true;
	}
	
	this.beforeRun = function() {
		/*Optional Overwrite it*/
		return true;
	}
	
	this.afterRun = function() {
		/*Optional Overwrite it*/
		return true;
	}

	this.drawBackground = function(canvas) {
		if(this.isFirstStep) {
			this.canvas.drawImage(this.canvasImage, 0, 0, this.w, this.h, 0, 0, this.w, this.h);
		}
		else {
			var x = this.frontX;
			var y = this.frontY;
			var w = this.frontW;
			var h = this.frontH;

			this.canvas.drawImage(this.canvasImage, x, y, w, h, x, y, w, h);
		}

		return;
	}

	this.doStep = function(percent) {
		this.canvas.save();
		this.canvas.scale(this.scale, this.scale);
		this.step(percent);
		this.canvas.restore();

		return;
	}
	
	this.run = function() {
		var date = new Date();
		var animation = this;
		this.startTime = date.getTime();
		animation.isFirstStep = true;

		this.beforeRun();
		WWindowManager.getInstance().setPaintEnable(false);

		function animStep() {
			var percent = 0;
			var timePercent = animation.getTimePercent();

			if(timePercent < 1) {
				percent = animation.getPercent(timePercent);
				animation.doStep(percent);

				requestAnimFrame(animStep);
			}
			else {
				animation.cleanup();
				animation.afterRun();
				WWindowManager.getInstance().setPaintEnable(true);
				console.log("Animation done.");
			}
			animation.isFirstStep = false;
		}
		
		animStep();

		return;
	}

	this.cleanup = function() {
		var animation = this;
		var onFinish = this.onFinish;

		setTimeout(function() {
			animation.hide();
		}, 100);

		if(onFinish) {
			onFinish();
		}

		if(this.canvasImage && this.canvasImage.unload) {
			this.canvasImage.unload();
		}
	}

	this.hide();

	return this;
}

function setElementPosition(element, x, y) {
	var scale = UIElement.getMainCanvasScale();

	x = x/scale.x;
	y = y/scale.y;
	element.style.position = "absolute";
	element.style.left = Math.round(x) + "px";
	element.style.top = Math.round(y) + "px";
	element.style["opacity"] = 1.0;

	return;
}

Animation.scaleCanvas = function(canvas, width, height) {
	var scale = UIElement.getMainCanvasScale();

	canvas.style.width = Math.round(width/scale.x) + "px";
	canvas.style.height = Math.round(height/scale.y) + "px";

	return;
}

function moveElement(element, x, y) {
	setElementPosition(element, x, y);

	return;
}

function alphaElement(element, opacity) {
	element.style["opacity"] = opacity;

	return;
}

function showElement(element) {
	element.style["opacity"] = 1;
}

function hideElement(element) {
	element.style["opacity"] = 0;
}

function scaleElement(element, scale, opacity, xOrigin, yOrigin) {
	var origin = (xOrigin && yOrigin) ? xOrigin + " " + yOrigin : "50% 50%";
	var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

	element.style['transform-style'] = "preserve-3d";
	for(var i = 0; i < transforms.length; i++) {
		var trans = transforms[i];
		element.style[trans + "-origin"] = origin;
		element.style[trans] = "scale("+scale+")";
	}
	element.style["opacity"] = opacity;

	return;
}

function rotateElement(element, deg) {
	var origin = "50% 50%";
	var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

	element.style['transform-style'] = "preserve-3d";
	for(var i = 0; i < transforms.length; i++) {
		var trans = transforms[i];
		element.style[trans + "-origin"] = origin;
		element.style[trans] = "rotate("+deg+"deg)";
	}

	return;
}

function AnimationHTranslateAndroid() {
	Animation.apply(this, arguments);
	
	this.leftToRight = true;

	this.show = function() {
		document.body.appendChild(Animation.backendCanvas);
		Animation.backendCanvas.style.zIndex = 9;
		this.canvasElement = Animation.backendCanvas;
		setElementPosition(Animation.backendCanvas, this.x, this.y);

		return true;
	}

	this.hide = function() {
		if(this.canvasElement) {
			document.body.removeChild(this.canvasElement);
			this.canvasElement = null;
		}
		return true;
	}

	this.doStep = function(percent) {
		this.step(percent);
		return;
	}

	this.beforeRun = function() {
		var range = this.sw - this.w;
		
		this.range = range * 0.7;
		this.start = range - this.range;

		return;
	}
	
	this.toLeft = function() {
		this.leftToRight = true;

		return;
	}
	
	this.toRight = function() {
		this.leftToRight = false;

		return;
	}

	this.step = function(percent) {
		var ox = 0;
		if(this.leftToRight) {
			ox = this.start + this.range * percent;
		}
		else {
			ox = this.w - this.range * percent - this.start;
		}

		moveElement(Animation.backendCanvas, -ox+this.x, this.y);

		return true;
	}
}

function AnimationVTranslate(showWin) {
	Animation.apply(this, arguments);

	this.beforeRun = function() {
		this.range = this.frontH;
		this.canvas = this.canvasElement.getContext("2d");

		return true;;
	}

	this.step = function(percent) {
		var x = this.frontX;
		var y = this.frontY;
		var w = this.frontW;
		var dy = this.range * percent;
		var h = this.showWin ? dy : (this.range - dy);		
		var oy = this.showWin ? (this.frontY + this.range - dy) : (this.frontY + dy);

		if(oy > 0) {
			this.canvas.drawImage(this.canvasImage, 0, this.h - oy, w, oy, 0, 0, w, oy);
		}

		if(h > 0) {
			this.canvas.drawImage(this.canvasImage, x+this.w, y, w, h, x, oy, w, h);
		}

		return true;
	}
}

function AnimationHTranslate() {
	Animation.apply(this, arguments);
	
	this.leftToRight = true;

	this.beforeRun = function() {
		var range = this.sw - this.w;
		
		if(isMobile()) {
			this.range = range * 0.8;
		}
		else {
			this.range = range;
		}

		this.start = range - this.range;
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.toLeft = function() {
		this.leftToRight = true;

		return;
	}
	
	this.toRight = function() {
		this.leftToRight = false;

		return;
	}

	this.step = function(percent) {
		var ox = 0;
		if(this.leftToRight) {
			ox = this.start + this.range * percent;
		}
		else {
			ox = this.w - this.range * percent - this.start;
		}

		if(this.lastOffset === ox) {
			return true;
		}

		this.canvas.drawImage(this.canvasImage, ox, 0, this.w, this.h, 0, 0, this.w, this.h);
		this.lastOffset = ox;
		//console.log("Step: " + percent + " ox=" + ox);
		return true;
	}
}

function AnimationScale() {
	Animation.apply(this, arguments);

	this.to = 1.0;
	this.from = 0;
	this.frontX = 0;
	this.frontY = 0;
	this.frontW = 0;
	this.frontH = 0;

	this.setRange = function(from, to) {
		this.to = to;
		this.from = from;

		return;
	}

	this.beforeRun = function() {
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.step = function(percent) {
		var scale = this.from + percent * (this.to - this.from);
		var alpha = this.to > this.from ? percent : (1-percent);
		if(this.canvasImage) {
			var canvas = this.canvas;
			var cx = this.frontX + 0.5 * this.frontW;
			var cy = this.frontY + 0.5 * this.frontH;

			this.drawBackground(canvas);

			canvas.save();
			canvas.translate(cx, cy);
			canvas.globalAlpha = alpha;
			canvas.scale(scale, scale);
			canvas.translate(-0.5 * this.frontW, -0.5 * this.frontH);

			canvas.drawImage(this.canvasImage, this.frontX + this.w, this.frontY, this.frontW, this.frontH,
				0, 0, this.frontW, this.frontH);
			canvas.restore();
		}

		//console.log("Step: " + percent + " scale=" + scale);
		return true;
	}
}

function AnimationAlpha() {
	Animation.apply(this, arguments);

	this.to = 1.0;
	this.from = 0;
	this.frontX = 0;
	this.frontY = 0;
	this.frontW = 0;
	this.frontH = 0;

	this.setRange = function(from, to) {
		this.to = to;
		this.from = from;

		return;
	}

	this.beforeRun = function() {
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.step = function(percent) {
		var alpha = this.from + percent * (this.to - this.from);

		if(this.canvasImage) {
			var canvas = this.canvas;
			
			canvas.drawImage(this.canvasImage, 0, 0, this.w, this.h, 0, 0, this.w, this.h);
			canvas.save();
			canvas.globalAlpha = alpha;
			canvas.drawImage(this.canvasImage, this.frontX + this.w, this.frontY, this.frontW, this.frontH,
				this.frontX, this.frontY, this.frontW, this.frontH);
			canvas.restore();
		}

		//console.log("Step: " + percent + " alpha=" + alpha);
		return true;
	}
}

function AnimationMove(showWin) {
	Animation.apply(this, arguments);

	this.beforeRun = function() {
		this.range = this.frontH;
		this.canvas = this.canvasElement.getContext("2d");

		return true;;
	}

	this.step = function(percent) {
		this.drawBackground(this.canvas);

		var x = this.frontX;
		var y = this.frontY;
		var w = this.frontW;
		var dy = this.range * percent;
		var h = this.showWin ? dy : (this.range - dy);		
		var oy = this.showWin ? (this.frontY + this.range - dy) : (this.frontY + dy);
		
		if(h > 0) {
			this.canvas.drawImage(this.canvasImage, x+this.w, y, w, h, x, oy, w, h);
		}

		return true;
	}
}

//////////////////////////////////////////////////////////////////

function AnimationBrowser(showWin) {
	Animation.apply(this, arguments);
	
	this.to = 1.0;
	this.from = 0;
	this.frontX = 0;
	this.frontY = 0;
	this.frontW = 0;
	this.frontH = 0;

	function removeCanvas(canvas) {
		try {
			document.body.removeChild(canvas);
		}
		catch(e) {
			console.log(e.toString());
		}

		return;
	}

	this.setRange = function(from, to) {
		this.to = to;
		this.from = from;

		return;
	}

	this.onShowCanvas = function() {
		setElementPosition(this.oldWinCanvas, this.x, this.y);
		setElementPosition(this.newWinCanvas, this.x, this.y);
		showElement(this.oldWinCanvas);
		showElement(this.newWinCanvas);

		return;
	}

	this.showCanvas = function(oldWinZIndex, newWinZIndex) {
		var w = this.w;
		var h = this.h;
		var oldWinCanvas = Animation.getOldWinCanvas();
		var newWinCanvas = Animation.getNewWinCanvas();

		this.moveResizeCanvas(oldWinCanvas, this.x, this.y, w, h);
		this.moveResizeCanvas(newWinCanvas, this.x, this.y, w, h);

		oldWinCanvas.style.zIndex = oldWinZIndex;
		newWinCanvas.style.zIndex = newWinZIndex;
		
		var oldWin = oldWinCanvas.getContext("2d");
		var newWin = newWinCanvas.getContext("2d");

		if(this.showWin) {
			oldWin.drawImage(Animation.backendCanvas, 0, 0, w, h, 0, 0, w, h);
			newWin.drawImage(Animation.backendCanvas, this.w, 0, w, h, 0, 0, w, h);
		}
		else {
			newWin.drawImage(Animation.backendCanvas, 0, 0, w, h, 0, 0, w, h);
			oldWin.drawImage(Animation.backendCanvas, this.w, 0, w, h, 0, 0, w, h);
		}

		this.oldWinCanvas = oldWinCanvas;
		this.newWinCanvas = newWinCanvas;

		this.onShowCanvas();
	
		if(oldWinZIndex > newWinZIndex) {
			document.body.appendChild(newWinCanvas);
			document.body.appendChild(oldWinCanvas);
		}
		else {
			document.body.appendChild(newWinCanvas);
			document.body.appendChild(oldWinCanvas);
		}

		return true;
	}
	
	this.show = function() {
		this.showCanvas(8, 9);

		return true;
	}

	this.hide = function() {
		if(this.oldWinCanvas && this.newWinCanvas) {
			if(this.showWin) {
				removeCanvas(this.oldWinCanvas);
				removeCanvas(this.newWinCanvas);
			}
			else {
				removeCanvas(this.oldWinCanvas);
				removeCanvas(this.newWinCanvas);
			}
			this.newWinCanvas = null;
			this.oldWinCanvas = null;
		}

		return true;
	}

	this.afterRun = function() {
	}

	this.doStep = function(percent) {
		this.step(percent);
		return;
	}

	this.step = function(percent) {
		var scale = this.from + percent * (this.to - this.from);
		var alpha = percent;
		scaleElement(this.newWinCanvas, scale, alpha);

		return true;
	}
}

function AnimationBrowserScaleWin(showWin) {
	AnimationBrowser.apply(this, arguments);
	
	this.onShowCanvas = function() {
		setElementPosition(this.oldWinCanvas, this.x, this.y);
		setElementPosition(this.newWinCanvas, this.x, this.y);
		showElement(this.oldWinCanvas);
		hideElement(this.newWinCanvas);

		return;
	}
	
	this.step = function(percent) {
		var alpha = percent;
		var scale = this.from + percent * (this.to - this.from);

		scaleElement(this.newWinCanvas, scale, alpha);

		return true;
	}
}

function AnimationBrowserScaleDialog(showWin) {
	AnimationBrowser.apply(this, arguments);
	
	this.show = function() {
		if(this.showWin) {
			this.showCanvas(8, 9);
		}
		else {
			this.showCanvas(9, 8);
		}

		return true;
	}
	
	this.step = function(percent) {
		var scale = this.from + percent * (this.to - this.from);
		var alpha = this.showWin ? percent : 1-percent;

		if(this.showWin) {
			scaleElement(this.newWinCanvas, scale, alpha);
		}
		else {
			scaleElement(this.oldWinCanvas, scale, alpha);
		}

		return true;
	}
}

function AnimationBrowserAlpha(showWin) {
	AnimationBrowser.apply(this, arguments);
	
	this.show = function() {
		if(this.showWin) {
			this.showCanvas(8, 9);
		}
		else {
			this.showCanvas(9, 8);
		}
	}

	this.step = function(percent) {
		var alpha = this.from + percent * (this.to - this.from);

		if(this.showWin) {
			alphaElement(this.newWinCanvas, alpha);
		}
		else {
			alphaElement(this.oldWinCanvas, alpha);
		}

		return true;
	}
}
function AnimationBrowserMove(showWin) {
	AnimationBrowser.apply(this, arguments);

	this.onShowCanvas = function() {
		if(this.showWin) {
			setElementPosition(this.oldWinCanvas, this.x, this.y);
			setElementPosition(this.newWinCanvas, this.x, this.frontH);
		}
		else {
			setElementPosition(this.oldWinCanvas, this.x, this.y);
			setElementPosition(this.newWinCanvas, this.x, this.y);
		}
		showElement(this.oldWinCanvas);
		showElement(this.newWinCanvas);

		return;
	}

	this.show = function() {
		if(this.showWin) {
			this.showCanvas(8, 9);
		}
		else {
			this.showCanvas(9, 8);
		}

		return;
	}

	this.step = function(percent) {
		var oy = 0;
		this.range = this.frontH;
		var dy = this.range * percent;
		if(this.showWin) {
			oy = this.range - dy;
			moveElement(this.newWinCanvas, 0, oy);
		}
		else {
			oy = dy;
			moveElement(this.oldWinCanvas, 0, oy);
		}
	
		return true;
	}
}

//////////////////////////////////////////widget animations/////////////////////////////////////////

var C_DIR_UP = 1;
var C_DIR_DOWN = 2;
var C_DIR_LEFT = 3;
var C_DIR_RIGHT = 4;
var C_ACTION_EXPAND = 1;
var C_ACTION_COLLAPSE = 2;

function Animation1Expand() {
	Animation.apply(this, arguments);
	
	this.prepare = function(x, y, w, h, canvasImage, onFinish) {
		this.x = Math.round(x);
		this.y = Math.round(y);
		this.w = Math.round(w);
		this.h = Math.round(h);
		this.onFinish = onFinish;
		this.canvasImage = canvasImage;
		
		this.xto = this.xfrom = 0;
		this.yto = this.yfrom = 0;
		this.wto = this.wfrom = w;
		this.hto = this.hfrom = h;
		
		this.show();

		return;
	}

	this.expandV = function(up) {
		this.direction = up? C_DIR_UP : C_DIR_DOWN;
		this.action =  C_ACTION_EXPAND;
		this.yfrom = this.h;
		this.yto = 0;
		this.hfrom = 0;
		this.hto = this.h;

		return;
	}
	
	this.expandH = function(left) {
		this.direction = left ? C_DIR_LEFT : C_DIR_RIGHT;
		this.action =  C_ACTION_EXPAND;
		this.xfrom = this.w;
		this.xto = 0;
		this.wfrom = 0;
		this.wto = this.w;

		return;
	}
	
	this.collapseV = function(up) {
		this.direction = up? C_DIR_UP : C_DIR_DOWN;
		this.action =  C_ACTION_COLLAPSE;
		this.yfrom = 0;
		this.yto = this.h;
		this.hfrom = this.h;
		this.hto = 0;

		return;
	}
	
	this.collapseH = function(left) {
		this.direction = left ? C_DIR_LEFT : C_DIR_RIGHT;
		this.action =  C_ACTION_COLLAPSE;
		this.xfrom = 0;
		this.xto = this.w;
		this.wfrom = this.w;
		this.wto = 0;

		return;
	}

	this.expandUp = function() {
		return this.expandV(true);
	}
	
	this.expandDown = function() {
		return this.expandV(false);
	}

	this.expandLeft = function() {
		return this.expandH(true);
	}

	this.expandRight = function() {
		return this.expandH(false);
	}

	this.collapseUp = function() {
		return this.collapseV(true);
	}
	
	this.collapseDown = function() {
		return this.collapseV(false);
	}

	this.collapseLeft = function() {
		return this.collapseH(true);
	}

	this.collapseRight = function() {
		return this.collapseH(false);
	}

	this.show = function() {
		this.canvasElement = Animation.getCanvas(); 
		this.moveResizeCanvas(this.canvasElement, this.x, this.y, this.w, this.h);
		this.canvas = this.canvasElement.getContext("2d");
		document.body.appendChild(this.canvasElement);
		this.canvasElement.style.zIndex = 9;
		setElementPosition(this.canvasElement, this.x, this.y);
		showElement(this.canvasElement);

		return true;
	}

	this.hide = function() {
		this.visible = false;
		if(this.canvasElement) {
			document.body.removeChild(this.canvasElement);
			this.canvasElement = null;
		}

		return true;
	}

	this.step = function(percent) {
		var canvas = this.canvas;
		var x = this.xfrom + ((this.xto - this.xfrom) * percent);
		var y = this.yfrom + ((this.yto - this.yfrom) * percent);
		
		var w = this.wfrom + (this.wto - this.wfrom) * percent;
		var h = this.hfrom + (this.hto - this.hfrom) * percent;

		if(!w || !h) {
			return;
		}

		canvas.clearRect(0, 0, this.w, this.h);
		
		var dx = x;
		var dy = y;
		var sx = x;
		var sy = y;

		if(this.action === C_ACTION_EXPAND) {
			switch(this.direction) {
				case C_DIR_UP: {
					sy = 0;			
					break;
				}
				case C_DIR_DOWN: {
					dy = 0;			
					break;
				}
				case C_DIR_LEFT: {
					sx = 0;			
					break;
				}
				case C_DIR_RIGHT: {
					dx = 0;			
					break;
				}
			}
		}
		else {
			switch(this.direction) {
				case C_DIR_UP: {
					dy = 0;			
					break;
				}
				case C_DIR_DOWN: {
					sy = 0;			
					break;
				}
				case C_DIR_LEFT: {
					dx = 0;			
					break;
				}
				case C_DIR_RIGHT: {
					sx = 0;			
					break;
				}
			}
		}

		//console.log("y:" + y + " h:" + h);
		canvas.drawImage(this.canvasImage, sx, sy, w, h, dx, dy, w, h);
		//canvas.fillRect(dx, dy, w, h);

		return true;
	}
}

function Animation1Alpha() {
	Animation.apply(this, arguments);
	
	this.prepare = function(x, y, w, h, canvasImage, onFinish) {
		this.x = Math.round(x);
		this.y = Math.round(y);
		this.w = Math.round(w);
		this.h = Math.round(h);
		this.onFinish = onFinish;
		this.canvasImage = canvasImage;
		
		this.show();

		return;
	}

	this.setRange = function(from, to) {
		this.from = from;
		this.to = to;

		return;
	}
	
	this.show = function() {
		this.canvasElement = Animation.getCanvas(); 
		this.moveResizeCanvas(this.canvasElement, this.x, this.y, this.w, this.h);
		this.canvas = this.canvasElement.getContext("2d");
		document.body.appendChild(this.canvasElement);
		this.canvasElement.style.zIndex = 9;
		setElementPosition(this.canvasElement, this.x, this.y);
		showElement(this.canvasElement);

		this.canvas.drawImage(this.canvasImage, 0, 0, this.w, this.h, 0, 0, this.w, this.h);

		return true;
	}

	this.hide = function() {
		this.visible = false;
		if(this.canvasElement) {
			try {
				document.body.removeChild(this.canvasElement);
			}catch(e) {
				console.log("document.body.removeChild: not found.");
			}
			this.canvasElement = null;
		}

		return true;
	}

	this.step = function(percent) {
		var canvas = this.canvas;
		var opacity = this.from + (this.to - this.from) * percent;

		alphaElement(this.canvasElement, opacity);
		console.log("opacity:" + opacity);
		return true;
	}
}

function Animation1Scale() {
	Animation.apply(this, arguments);
	
	this.prepare = function(x, y, w, h, canvasImage, onFinish) {
		this.x = Math.round(x);
		this.y = Math.round(y);
		this.w = Math.round(w);
		this.h = Math.round(h);
		this.xOrigin = "50%";
		this.yOrigin = "50%";
		this.onFinish = onFinish;
		this.canvasImage = canvasImage;
		
		this.show();

		return;
	}

	this.setOrigin = function(xOrigin, yOrigin) {
		this.xOrigin = xOrigin;
		this.yOrigin = yOrigin;

		return;
	}

	this.setRange = function(from, to) {
		this.from = from;
		this.to = to;

		return;
	}
	
	this.show = function() {
		this.canvasElement = Animation.getCanvas(); 
		this.moveResizeCanvas(this.canvasElement, this.x, this.y, this.w, this.h);
		this.canvas = this.canvasElement.getContext("2d");
		document.body.appendChild(this.canvasElement);
		this.canvasElement.style.zIndex = 9;
		setElementPosition(this.canvasElement, this.x, this.y);
		showElement(this.canvasElement);

		this.canvas.drawImage(this.canvasImage, 0, 0, this.w, this.h, 0, 0, this.w, this.h);

		return true;
	}

	this.hide = function() {
		this.visible = false;
		if(this.canvasElement) {
			document.body.removeChild(this.canvasElement);
			this.canvasElement = null;
		}

		return true;
	}

	this.step = function(percent) {
		var canvas = this.canvas;
		var scale = this.from + (this.to - this.from) * percent;
		var alpha = this.showWin ? percent : 1-percent;

		scaleElement(this.canvasElement, scale, alpha, this.xOrigin, this.yOrigin);

		return true;
	}
}

function animateUIElement(uiElement, animHint, onAnimDone) {
	var visible = false;
	var scale = uiElement.getRealScale();
	var p = uiElement.getPositionInView();
	var pv = uiElement.view.getAbsPosition();

	var x = Math.round(p.x * scale) + pv.x;
	var y = Math.round(p.y * scale) + pv.y;
	var w = Math.round(uiElement.w * scale);
	var h = Math.round(uiElement.h * scale);

	var canvasElement = Animation.getBackendCanvas(w, h);
	var canvas = canvasElement.getContext("2d");

	canvas.save();
	visible = uiElement.visible;
	uiElement.visible = true;
	canvas.scale(scale, scale);
	canvas.translate(-uiElement.x, -uiElement.y);
	uiElement.paint(canvas);
	uiElement.visible = visible;
	canvas.restore();

	var anim = AnimationFactory.create(animHint);

	anim.prepare(x, y, w, h, canvasElement, function() {
		if(onAnimDone) {
			onAnimDone();
		}
		uiElement.setVisible(!visible);
		uiElement.postRedraw();
	});

	if(visible) {
		uiElement.setVisible(!visible);
		uiElement.postRedraw();
	}

	switch(animHint) {
		case "anim-expand-up": {
			anim.expandUp();
			break;
		}
		case "anim-expand-left": {
			anim.expandLeft();
			break;
		}
		case "anim-expand-right": {
			anim.expandRight();
			break;
		}
		case "anim-expand-down": {
			anim.expandDown();
			break;
		}
		case "anim-collapse-up": {
			anim.collapseUp();
			break;
		}
		case "anim-collapse-left": {
			anim.collapseLeft();
			break;
		}
		case "anim-collapse-right": {
			anim.collapseRight();
			break;
		}
		case "anim-collapse-down": {
			anim.collapseDown();
			break;
		}
		case "anim-scale1-show-origin-topleft": {
			anim.setOrigin("0%", "0%");
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-show-origin-center": {
			anim.setOrigin("50%", "50%");
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-show-origin-bottomleft": {
			anim.setOrigin("0%", "100%");
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-show-origin-topright": {
			anim.setOrigin("100%", "0%");
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-show-origin-bottomright": {
			anim.setOrigin("100%", "100%");
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-show": {
			anim.setRange(0.5, 1.0);
			break;
		}
		case "anim-scale1-hide-origin-topleft": {
			anim.setOrigin("0%", "0%");
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-scale1-hide-origin-center": {
			anim.setOrigin("50%", "50%");
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-scale1-hide-origin-bottomleft": {
			anim.setOrigin("0%", "100%");
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-scale1-hide-origin-topright": {
			anim.setOrigin("100%", "0%");
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-scale1-hide-origin-bottomright": {
			anim.setOrigin("100%", "100%");
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-scale1-hide": {
			anim.setRange(1.0, 0.5);
			break;
		}
		case "anim-alpha1-show": {
			anim.setRange(0.2, 1.0);
			break;
		}
		case "anim-alpha1-hide": {
			anim.setRange(1.0, 0.2);
			break;
		}
	}

	anim.run();

	return;
}


function testAnimation1Expand(uiElement) {
	var testElement = uiElement.getWindow().findChildByName("ui-button-test", true);

	testElement.setVisible(false);
	testElement.postRedraw();
	setTimeout(function() {
		animateUIElement(testElement, "anim-alpha1-show");
	}, 100);
	
	setTimeout(function() {
		animateUIElement(testElement, "anim-alpha1-hide");
	}, 3000);

	return;
}
/*
 * File: ui-element.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: UIElement
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIElement() {
	return;
}

UIElement.IMAGE_DISPLAY_CENTER = WImage.DISPLAY_CENTER;
UIElement.IMAGE_DISPLAY_TILE   = WImage.DISPLAY_TILE;
UIElement.IMAGE_DISPLAY_9PATCH = WImage.DISPLAY_9PATCH;
UIElement.IMAGE_DISPLAY_SCALE  = WImage.DISPLAY_SCALE;
UIElement.IMAGE_DISPLAY_AUTO = WImage.DISPLAY_AUTO;
UIElement.IMAGE_DISPLAY_DEFAULT = WImage.DISPLAY_DEFAULT;
UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO  = WImage.DISPLAY_SCALE_KEEP_RATIO;
UIElement.IMAGE_DISPLAY_TILE_V = WImage.DISPLAY_TILE_V;
UIElement.IMAGE_DISPLAY_TILE_H = WImage.DISPLAY_TILE_H;
UIElement.IMAGE_DISPLAY_AUTO_SIZE_DOWN = WImage.DISPLAY_AUTO_SIZE_DOWN;
UIElement.IMAGE_DISPLAY_FIT_WIDTH = WImage.DISPLAY_FIT_WIDTH;
UIElement.IMAGE_DISPLAY_FIT_HEIGHT = WImage.DISPLAY_FIT_HEIGHT;

UIElement.HTEXT_ALIGNS = ["left", "center", "right"];
UIElement.VTEXT_ALIGNS = ["top", "middle", "bottom"];

UIElement.IMAGE_DISPLAY_NAMES = ["incenter", "tile", "9patch", "scale", "auto", "default", "scale(keep ratio)", "vtile", "htile", "auto-size-down", "fit-width","fit-height"];

UIElement.X_FIX_LEFT = 0;
UIElement.X_FIX_RIGHT = 1;
UIElement.X_SCALE = 2;
UIElement.X_CENTER_IN_PARENT = 3;
UIElement.X_LEFT_IN_PARENT	 = 4;
UIElement.X_RIGHT_IN_PARENT  = 5;
UIElement.X_AFTER_PREV       = 6;
//UIElement.X_LAYOUT_NAMES = ["fix_left", "fix_right", "scale", "center_in_parent", "left_in_parent", "right_in_parent", "after_prev"];
UIElement.X_LAYOUT_NAMES = ["fix_left", "fix_right", "scale", "center_in_parent", "left_in_parent", "right_in_parent"];

UIElement.Y_FIX_TOP = 0;
UIElement.Y_FIX_BOTTOM = 1;
UIElement.Y_SCALE = 2;
UIElement.Y_MIDDLE_IN_PARENT = 3;
UIElement.Y_TOP_IN_PARENT	 = 4;
UIElement.Y_BOTTOM_IN_PARENT = 5;
UIElement.Y_AFTER_PREV       = 6;
//UIElement.Y_LAYOUT_NAMES = ["fix_top", "fix_bottom", "scale", "middle_in_parent", "top_in_parent", "bottom_in_parent", "after_prev"];
UIElement.Y_LAYOUT_NAMES = ["fix_top", "fix_bottom", "scale", "middle_in_parent", "top_in_parent", "bottom_in_parent"];

UIElement.WIDTH_FIX = 0;
UIElement.WIDTH_SCALE = 1;
UIElement.WIDTH_FILL_PARENT = 2;
UIElement.WIDTH_FILL_AVAILABLE = 3;
UIElement.WIDTH_FILL_TO_PARENT_RIGHT = 4;

UIElement.HEIGHT_FIX = 0;
UIElement.HEIGHT_SCALE = 1;
UIElement.HEIGHT_FILL_PARENT = 2;
UIElement.HEIGHT_FILL_AVAILABLE = 3;
UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH = 4;
UIElement.HEIGHT_FILL_TO_PARENT_BOTTOM = 5;

UIElement.WIDTH_LAYOUT_NAMES = ["fix", "scale", "fill_parent"];
UIElement.HEIGHT_LAYOUT_NAMES = ["fix", "scale", "fill_parent"];
//UIElement.WIDTH_LAYOUT_NAMES = ["fix", "scale", "fill_parent", "fill_avaible", "fill_to_parent_right"];
//UIElement.HEIGHT_LAYOUT_NAMES = ["fix", "scale", "fill_parent", "fill_avaible", "keep_ratio_with_width", "fill_to_parent_bottom"];

UIElement.IMAGE_DEFAULT	   = "default_bg";
UIElement.IMAGE_MASK	   = "mask_fg";
UIElement.IMAGE_NORMAL	   = "normal_bg";
UIElement.IMAGE_FOCUSED	   = "focused_bg";
UIElement.IMAGE_ACTIVE	   = "active_bg";
UIElement.IMAGE_POINTER_OVER = "pointer_over_bg";
UIElement.IMAGE_DISABLE	   = "disable_bg";
UIElement.IMAGE_DISABLE_FG = "disable_fg";
UIElement.IMAGE_NORMAL_FG  = "normal_fg";
UIElement.IMAGE_ACTIVE_FG  = "active_fg";
UIElement.IMAGE_ON_FG	   = "on_fg";
UIElement.IMAGE_OFF_FG	   = "off_fg";
UIElement.IMAGE_ON_BG	   = "on_bg";
UIElement.IMAGE_OFF_BG	   = "off_bg";
UIElement.IMAGE_CHECKED_FG	   = "checked_fg";
UIElement.IMAGE_UNCHECK_FG	   = "unchecked_fg";
UIElement.IMAGE_ON_FOCUSED	   = "focused_on_bg";
UIElement.IMAGE_ON_ACTIVE	   = "active_on_bg";
UIElement.IMAGE_OFF_FOCUSED	   = "focused_off_bg";
UIElement.IMAGE_OFF_ACTIVE	   = "active_off_bg";
UIElement.IMAGE_NORMAL_DRAG    = "normal_drag";
UIElement.IMAGE_DELETE_ITEM    = "delete_item_icon";
UIElement.IMAGE_CHECKED_ITEM   = "checked_item_icon";
UIElement.IMAGE_POINT          = "point_img";
UIElement.IMAGE_POINT1         = "point1_img";
UIElement.IMAGE_POINT2         = "point2_img";
UIElement.IMAGE_POINT3         = "point3_img";
UIElement.IMAGE_POINT4         = "point4_img";
UIElement.IMAGE_TIPS1          = "tips_img_1";
UIElement.IMAGE_TIPS2          = "tips_img_2";
UIElement.IMAGE_TIPS3          = "tips_img_3";
UIElement.IMAGE_TIPS4          = "tips_img_4";
UIElement.IMAGE_TIPS5          = "tips_img_5";

UIElement.ITEM_BG_NORMAL  = "item_bg_normal";
UIElement.ITEM_BG_ACTIVE  = "item_bg_active";
UIElement.ITEM_BG_CURRENT_NORMAL = "item_bg_current_normal";
UIElement.ITEM_BG_CURRENT_ACTIVE = "item_bg_current_active";

UIElement.TEXT_ALIGN_CENTER = 0;
UIElement.TEXT_ALIGN_LEFT	= 0;
UIElement.TEXT_ALIGN_RIGHT = 0;
UIElement.TEXT_ALIGN_NAMES = ["center", "left", "right"];

UIElement.ORIGIN_UP = 1;
UIElement.ORIGIN_DOWN = 2;
UIElement.ORIGIN_LEFT = 3;
UIElement.ORIGIN_RIGHT = 4;
UIElement.ORIGIN_UP_LEFT = 5;
UIElement.ORIGIN_UP_RIGHT = 6;
UIElement.ORIGIN_DOWN_LEFT = 7;
UIElement.ORIGIN_DOWN_RIGHT = 8;
UIElement.ORIGIN_MIDDLE_CENTER = 9;

UIElement.STATE_STOP = 1;
UIElement.STATE_RUNNING = 2;
UIElement.STATE_PAUSED = 3;

UIElement.prototype = new RShape();
TEventTarget.apply(UIElement.prototype);

UIElement.Style = function() {
	this.lineWidth = 2;
	this.lineColor = "Orange";
	this.fillColor = "White";
	this.textColor = "Blue";
	this.fontSize = 24;

	return;
}

UIElement.Style.prototype = new ShapeStyle();

UIElement.prototype.isUIElement = true;
UIElement.prototype.hasChildren = true;
UIElement.prototype.isContainer = true;

UIElement.disableGetRelativePathOfURL = false;

UIElement.prototype.addResource = function(url) {
	if(!this.resources) {
		this.resources = [];
	}

	if(this.resources.indexOf(url) < 0) {
		this.resources.push(url);
	}

	return;
}

UIElement.prototype.setParent = function(parentShape) {
	this.parentShape = parentShape;

	return this;
}

UIElement.prototype.setDefaultStyle = function() {
	this.style = new UIElement.Style();

	return;
}

UIElement.prototype.clone = function() {
	var obj = null;
	
	UIElement.disableGetRelativePathOfURL = true;
	obj = this.dup();
	UIElement.disableGetRelativePathOfURL = false;

	obj.setVisible(true);
	obj.xAttr = UIElement.X_FIX_LEFT;
	obj.yAttr = UIElement.Y_FIX_TOP;
	obj.widthAttr = UIElement.WIDTH_FIX;
	obj.heightAttr = UIElement.HEIGHT_FIX;
	obj.uid = UIElement.uidStart++;

	if(this.anchor) {
		obj.setAnchor(this.anchor.x, this.anchor.y);
	}

	return obj;
}

UIElement.prototype.getRelativePathOfURL = function(url) {
	if(UIElement.disableGetRelativePathOfURL || !url) {
		return url;
	}

	return url.toRelativeURL();
}

UIElement.prototype.setFreePosition = function(value) {
	this.freePosition = value;

	return;
}

UIElement.prototype.fixChildPosition = function(child) {
	return;
}

UIElement.prototype.setFreeSize = function(value) {
	this.freeSize = value;
	
	return;
}

UIElement.prototype.fixChildSize = function(child) {
	return;
}

UIElement.prototype.onInit = function() {
	this.callOnInitHandler();

	if(this.dataSourceUrl && this.dataSourceUrl.length > 5) {
		this.bindDataUrl(this.dataSourceUrl);
	}

	return;
}

UIElement.prototype.onDeinit = function() {
	if(this.animatingInfo) {
		this.stopAnimation(true);
	}

	return;
}

UIElement.prototype.onWindowOpen = function() {
	if(this.animations && this.defaultAnimationName) {
		var config = this.animations[this.defaultAnimationName];
		if(config) {
			this.animate(config);
		}
	}

	return;
}

UIElement.prototype.initChildren = function() {
	var children = this.children;
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var iter = children[i];
		iter.init();
	}

	return;
}

UIElement.prototype.init = function() {
	try {
		this.onInit();
	}catch(e) {
		console.log("onInit Failed:" + e.message  + "\n" + e.stack);
	}
	this.initChildren();

	return;
}

UIElement.prototype.deinit = function() {
	var i = 0;
	var iter = null;
	var children = this.children;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		iter = children[i];
		iter.deinit();
	}
	
	this.onDeinit();

	return;
}

UIElement.prototype.onModeChanged = function() {
	return;
}

UIElement.prototype.userRemovable = function() {
	return this.mode === Shape.MODE_EDITING;
}

UIElement.prototype.postRedraw = function() {
	if(this.view) {
		this.view.postRedrawAll();
	}

	return this;
}

UIElement.prototype.requestRedraw = UIElement.prototype.postRedraw; 

UIElement.prototype.setMode = function(mode, recursive) {
	this.mode = mode;

	if(this.type !== "ui-menu-bar") {
		if(mode === Shape.MODE_EDITING) {
			this.setVisible(true);
		}
	}

	if(recursive) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child.isContainer) {
				child.setMode(mode, true);
			}
		}
	}
	this.onModeChanged();

	return this;
}

UIElement.prototype.calcChildrenRange = function() {
	return this.calcShapesRange(this.children);
}

UIElement.prototype.calcShapesRange = function(shapes) {
	var x = 0;
	var y = 0;
	var w = 0;
	var h = 0;

	var r = 0;
	var b = 0;
	var t = 10000;
	var l = 10000;
	var range = {};

	if(shapes.length > 0) {
		for(var i = 0; i < shapes.length; i++) {
			var iter = shapes[i];
			
			x = iter.getX();
			y = iter.getY();
			w = iter.getWidth();
			h = iter.getHeight();

			if(x < l) l = x;
			if(y < t) t = y;
			if((x + w) > r) r = x + w;
			if((y + h) > b) b = y + h;
		}

		range.l = l;
		range.r = r;
		range.t = t;
		range.b = b;
	}
	else {
		range.l = 0;
		range.r = 0;
		range.t = 0;
		range.b = 0;
	}

	return range;
}

UIElement.prototype.relayoutChildren = function() {
}

UIElement.prototype.onSized = function() {
	this.updateLayoutParams();

	return;
}

UIElement.prototype.findSelectedShapes = function(shapes) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child.selected) {
			shapes.push(child);
			continue;
		}
	
		if(child.isContainer) {
			child.findSelectedShapes(shapes);
		}
	}

	return;
}

UIElement.onSelected = function(shape) {
}

UIElement.prototype.onSelectChanged = function() {
	if(this.selected) {
		UIElement.onSelected(this);
	}

	return;
}

UIElement.prototype.setSelected = function(selected) {
	if(!selected) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			child.setSelected(false);
		}
	}
	
	if(selected) {
		this.selectedTime = Date.now();
	}

	if(this.selected === selected) {
		return;
	}

	this.targetShape = null;
	this.selected = selected;
	this.onSelectChanged();

	return;
}

UIElement.prototype.setPointerEventTarget = function(shape) {
	this.pointerEventTarget = shape;

	return;
}

UIElement.prototype.getPointerEventTarget = function() {
	return this.pointerEventTarget ? this.pointerEventTarget : this.targetShape;
}

UIElement.prototype.foreachImage = function(onVisit) {
	for(var key in this.images) {
		if(key !== "display") {
			var src = this.getImageSrcByType(key);
			onVisit(key, src);
		}
	}

	return;
}

UIElement.prototype.forEach = function(onVisit) {
	if(onVisit(this)) {
		return true;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.forEach(onVisit);
	}

	return false;
}

UIElement.prototype.getAllTabStopElements = function() {
	var arr = [];
	var win = this.getWindow();

	if(win) {
		win.forEach(function(el) {
			if(el.isUIButton || el.isUIEdit) {
				arr.push(el);
			}
		});
	}

	return arr;
}

UIElement.prototype.findNextTabStop = function() {
	var arr = this.getAllTabStopElements();
	if(!arr.length) {
		return;
	}

	var index = arr.indexOf(this);
	if(index >= 0 && (index + 1) < arr.length) {
		return arr[index+1];
	}
	else {
		return arr[0];
	}
}

UIElement.prototype.moveToNextStop = function() {
	var el = this.findNextTabStop();


	return;
}

UIElement.prototype.isPointerOverShape = function() {
	return this.parentShape && this.parentShape.pointerOverShape === this;
}

UIElement.prototype.setPointerOverShape = function(shape) {
	if(this.pointerOverShape !== shape) {
		if(this.pointerOverShape) {
			this.pointerOverShape.setPointerOverShape(null);
		}

		this.pointerOverShape = shape;
		this.postRedraw();
	}

	return;
}

UIElement.prototype.setTarget = function(shape) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child !== shape) {
			child.setSelected(false);
		}
	}

	this.targetShape = shape;
	this.selected = !shape;
	this.onSelectChanged();

	return this;
}

UIElement.prototype.getTarget = function() {
	return this.targetShape;
}

UIElement.prototype.initContainerShape = function(type) {
	this.children = new Array();

	RShapeInit(this, type);
	
	this.mode = Shape.MODE_EDITING;
	this.rectSelectable = true;

	return this;
}

UIElement.prototype.defaultDispatchPointerDownToChildren = function(p) {
	var targetShape = this.targetShape;
	if(targetShape && targetShape.mode === Shape.MODE_EDITING) {
		var hitTestResult = this.hitTest(p);

		if(hitTestResult != Shape.HIT_TEST_MM && hitTestResult != Shape.HIT_TEST_NONE) {
			if(this.selected) {
				this.setTarget(null);
				return true;
			}
			if(this.targetShape.onPointerDown(p)) {
				return true;
			}
		}
	}

	for(var i = this.children.length; i > 0; i--) {
		var child = this.children[i-1];

		if(child.visible && child.onPointerDown(p)) {
			this.setTarget(child);

			return true;
		}
	}

	return false;
}

UIElement.prototype.dispatchPointerDownToChildren = function(p) {
	return this.defaultDispatchPointerDownToChildren(p);
}

UIElement.prototype.onPointerDownEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(this.popupWindow || !this.pointerDown) {
		return;
	}

	return this.callOnPointerDownHandler(point, beforeChild);
}

UIElement.prototype.onPointerMoveEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(this.popupWindow) {
		return;
	}

	return this.callOnPointerMoveHandler(point, beforeChild);
}

UIElement.prototype.onPointerUpEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(this.popupWindow || !this.pointerDown) {
		return;
	}

	return this.callOnPointerUpHandler(point, beforeChild);
}

UIElement.prototype.onDoubleClick = function(point) {
	if(this.targetShape) {
		var p = this.translatePoint(point);
		return this.targetShape.onDoubleClick(p);
	}
	else {
		return this.callOnDoubleClickHandler(point);
	}
}

UIElement.prototype.onGesture = function(gesture) {
	if(this.popupWindow) {
		return;
	}

	if(this.targetShape) {
		return this.targetShape.onGesture(gesture);
	}

	return;
}

UIElement.prototype.onLongPress = function(point) {
	if(this.popupWindow || !this.pointerDown) {
		return;
	}

	this.longPressed = true;
	this.callOnLongPressHandler(point);
	if(this.targetShape) {
		var p = this.translatePoint(point);
		return this.targetShape.onLongPress(p);
	}

	return;
}

UIElement.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.popupWindow || !this.pointerDown) {
		return;
	}

	return this.callOnClickHandler(point);
}

UIElement.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left), y : (point.y - this.top)};

	return p;
}

UIElement.prototype.setCanRectSelectable = function(rectSelectable, recursive) {
	this.rectSelectable = rectSelectable;

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setCanRectSelectable(rectSelectable, recursive);
	}

	return;
}

UIElement.prototype.canRectSelectable = function() {
	return this.isUIWindow || this.isUIPage;
}

UIElement.prototype.setDraggable = function(value) {
	if(this.draggable === value) {
		return;
	}

	this.draggable = value;

	if(value) {
		this.addEventNames(["onDragStart", "onDragging", "onDragEnd"]);
	}
	else {
		this.removeEventNames(["onDragStart", "onDragging", "onDragEnd"]);
	}

	return;
}

UIElement.prototype.onDragStart = function() {
	console.log("Drag Start");
	this.callOnDragStartHandler();
	return;
}

UIElement.prototype.onDragging = function() {
	console.log("Dragging");
	this.callOnDragingHandler();

	return;
}

UIElement.prototype.onDragEnd = function() {
	console.log("Drag End");
	this.callOnDragEndHandler();

	return;
}

UIElement.prototype.dragMove = function(dx, dy, point) {
	this.left = this.left + dx;
	this.top = this.top + dy;
	
	this.onDragging(point);

	return;
}

UIElement.prototype.handleDragMove = function(point) {
	var dx = this.getMoveDeltaX();
	var dy = this.getMoveDeltaY();

	if(!this.dragging) {
		var absdx = this.getMoveAbsDeltaX();
		var absdy = this.getMoveAbsDeltaY();
		if(Math.abs(absdx) > 5 || Math.abs(absdy) > 5) {
			this.dragging = true;
			this.onDragStart();
			dx = absdx;
			dy = absdy;
		}
	}

	if(this.dragging) {
		this.dragMove(dx, dy, point);
		if(this.parentShape) {
			this.parentShape.onChildDragging(this, point);
		}
	}

	return;
}

UIElement.prototype.onChildDragging = function(child, point) {

	return;
}

UIElement.prototype.onChildDragged = function(child, point) {
	this.sortChildren();
	this.relayoutChildren("default");

	return;
}

UIElement.prototype.handleDragUp = function(point) {
	this.onDragEnd();
	delete this.dragging;

	if(this.parentShape) {
		this.parentShape.onChildDragged(this, point);
	}

	return;
}

UIElement.prototype.animMove = function(x, y) {
	if(!this.dragging) {
		this.animate({x:x, y:y});
	}
	return;
}

UIElement.getIntFromConfig = function(config, name, defValue) {
	var value = config[name];

	if(!value && value !== 0) {
		return defValue;
	}
	
	if(typeof value === "string") {
		if(value[1] === '+' || value[1] === '-') {
			value = defValue + parseInt(value.substr(1));
		} else {
			value = parseInt(value);
		}
	}

	return value;
}

UIElement.prototype.stopAnimation = function(callOnDone) {
	if(!this.animatingInfo) {
		return this;
	}

	if(callOnDone) {
		this.stepAnimation({needRedraw:0}, Date.now() + 100000000);
	}
	this.animatingInfo = null;

	return this;
}


UIElement.prototype.animate = function(config, onAnimationDone, onAnimationStep, actionWhenBusy) {
	var me = this;
	var deferred = Deferred();
	var onAnimationStep = onAnimationStep || config.onStep;
	var onAnimationDone = onAnimationDone || config.onDone;

	this.doAnimate(config, function() {
		if(typeof onAnimationDone === 'function') {
			onAnimationDone.apply(me, arguments);
		}
		deferred.resolve();
	}, function() {
		if(typeof onAnimationStep === 'function') {
			return onAnimationStep.apply(me, arguments);
		}
		return true;
	}, actionWhenBusy);

	return deferred.promise;
}

UIElement.prototype.doAnimate = function(config, onAnimationDone, onAnimationStep, actionWhenBusy) {
	if(typeof config === "string") {
		config = this.animations[config];
	}

	if(!this.parentShape) {
		UIElement.logWarning("animate error - parentShape is null.");
		return false;
	}

	if(this.dragging) {
		UIElement.logWarning("animate error - busy.");
		return false;
	}

	var animatingInfo = this.animatingInfo;
	if(animatingInfo) {
		var busyAction = actionWhenBusy || config.actionWhenBusy || "replace";

		if(busyAction === "replace") {
			this.callOnAnimateDone(animatingInfo);
			UIElement.logNotice("busy action - replace current animation.");
		}
		else if(busyAction === "append") {
			var c = 0;
			for(var iter = animatingInfo; iter; iter = iter.next) {
				if(iter === config) {
					UIElement.logWarning("animate error - already appended.");
					return false;
				}
			
				if(!iter.next || c > 30) {
					iter.next = config;
					break;
				}
				c++;
			}
			UIElement.logNotice("busy action - append animation.");
			return true;
		}
		else {
			UIElement.logWarning("animate error - busy.");
			return false;
		}
	}

	if(!config) {
		UIElement.logWarning("animate error - config is null.");
		return false;
	}

	var x = this.getX();
	var y = this.getY();
	var w = this.w;
	var h = this.h;

	var duration = config.duration || 800;
	var xStart = UIElement.getIntFromConfig(config, "xStart", x);
	var xEnd = UIElement.getIntFromConfig(config, "xEnd", x);
	var yStart = UIElement.getIntFromConfig(config, "yStart", y);
	var yEnd = UIElement.getIntFromConfig(config, "yEnd", y);

	var wStart = UIElement.getIntFromConfig(config, "wStart", w);
	var wEnd = UIElement.getIntFromConfig(config, "wEnd", w);
	var hStart = UIElement.getIntFromConfig(config, "hStart", h);
	var hEnd = UIElement.getIntFromConfig(config, "hEnd", h);

	var valueStart = config.valueStart || 0;
	var valueEnd   = config.valueEnd   || 0;

	var opacityStart = (config.opacityStart || config.opacityStart === 0) ? config.opacityStart : this.opacity;
	var opacityEnd = (config.opacityEnd || config.opacityEnd === 0) ? config.opacityEnd : this.opacity;
	var rotationStart = (config.rotationStart || config.rotationStart === 0) ? config.rotationStart : this.rotation;
	var rotationEnd = (config.rotationEnd || config.rotationEnd === 0) ? config.rotationEnd : this.rotation;
	var scaleXStart = (config.scaleXStart || config.scaleXStart === 0) ? config.scaleXStart : this.getScaleX();
	var scaleXEnd = (config.scaleXEnd || config.scaleXEnd === 0) ? config.scaleXEnd : this.getScaleX();
	var scaleYStart = (config.scaleYStart || config.scaleYStart === 0) ? config.scaleYStart : this.getScaleY();
	var scaleYEnd = (config.scaleYEnd || config.scaleYEnd === 0) ? config.scaleYEnd : this.getScaleY();

	if(config.scaleEnd !== undefined) {
		scaleXEnd = config.scaleEnd;
		scaleYEnd = config.scaleEnd;
	}

	if(config.scaleStart !== undefined) {
		scaleXStart = config.scaleStart;
		scaleYStart = config.scaleStart;
	}
	
	if(config.scale !== undefined) {
		scaleXEnd = config.scale;
		scaleYEnd = config.scale;
	}
	
	if(config.scaleX !== undefined) {
		scaleXEnd = config.scaleX;
	}
	
	if(config.scaleY !== undefined) {
		scaleYEnd = config.scaleY;
	}

	if(config.x !== undefined) {
		xEnd = config.x;	
	}
	
	if(config.y !== undefined) {
		yEnd = config.y;	
	}

	if(config.opacity !== undefined) {
		opacityEnd = config.opacity;
	}

	if(config.rotation !== undefined) {
		rotationEnd = config.rotation;
	}

	var onDone = onAnimationDone || config.onDone;
	var onStep = onAnimationStep || config.onStep;

	var xRange = xEnd - xStart;
	var yRange = yEnd - yStart;
	var scaleXRange = scaleXEnd - scaleXStart;
	var scaleYRange = scaleYEnd - scaleYStart;
	var opacityRange = opacityEnd - opacityStart;
	var rotationRange = rotationEnd - rotationStart;
	var valueRange = valueEnd - valueStart;

	var interpolator =  null;
	if(typeof config.interpolator === "string") {
		interpolator = AnimationFactory.createInterpolator(config.interpolator);
	}
	else {
		interpolator = config.interpolator ? config.interpolator : new DecelerateInterpolator();
	}

	if(!xRange) {
		this.setX(xStart);
		xEnd = xStart;
	}

	if(!yRange) {
		this.setY(yStart);
		yEnd = yStart;
	}

	var c = {};

	c.xRange = xRange;
	c.yRange = yRange;
	c.scaleXRange = scaleXRange;
	c.scaleYRange = scaleYRange;
	c.opacityRange= opacityRange;
	c.rotationRange = rotationRange;
	c.valueRange = valueRange;
	
	c.wStart = wStart;
	c.hStart = hStart;
	c.xStart = xStart;
	c.yStart = yStart;
	c.scaleXStart = scaleXStart;
	c.scaleYStart = scaleYStart;
	c.opacityStart= opacityStart;
	c.rotationStart = rotationStart;
	c.valueStart = valueStart;

	c.startTime = Date.now();
	c.duration = duration;
	c.onDone = onDone;
	c.onStep = onStep;
	c.interpolator = interpolator;
	c.next = config.next;
	c.name = config.name;
	c.now = c.startTime;

	if(config.delay) {
		c.startTime += config.delay;
	}

	this.animatingInfo = c;
	this.postRedraw();

	return true;
}

UIElement.prototype.callOnAnimateDone = function(config) {
	this.animating = false;
	this.animatingInfo = null;

	var onDone = config.onDone;
	if(onDone) {
		onDone.call(this, config.name);
	}
	
	if(!this.parentShape) return false;

	this.callOnAnimateDoneHandler(config.name);

	if(!this.parentShape) return false;

	var next = config.next;

	if(next) {
		if(typeof next === "string") {
			if(!this.animations[next]) {
				return false;
			}
		}

		//this.animate(next, next.onDone || config.onDone || '', 
		//	next.onStep || config.onStep || '', next.actionWhenBusy || '');
		this.animate(next);

		return true;
	}

	return false;
}

UIElement.prototype.isAnimating = function() {
	return this.animatingInfo && this.parentShape;
}

UIElement.prototype.stepAnimation = function(canvas, now) {
	var c = this.animatingInfo;
	
	if(!c || !this.parentShape) return;

	c.now += canvas.timeStep;
	if(!now) {
		now = c.now;
	}
	
	canvas.needRedraw++;
	if(c.startTime > now) {
		return;
	}

	if(!this.visible) {
		this.visible = true;
	}

	var xRange = c.xRange;
	var yRange = c.yRange;
	var valueRange 	  = c.valueRange;
	var scaleXRange   = c.scaleXRange;
	var scaleYRange   = c.scaleYRange;
	var opacityRange  = c.opacityRange;
	var rotationRange = c.rotationRange;
	
	var wStart = c.wStart;
	var hStart = c.hStart;
	var xStart = c.xStart;
	var yStart = c.yStart;
	var scaleXStart   = c.scaleXStart;
	var scaleYStart   = c.scaleYStart;
	var opacityStart  = c.opacityStart;
	var rotationStart = c.rotationStart;
	var valueStart 	  = c.valueStart;

	var onStep = c.onStep;
	var duration = c.duration;
	var startTime = c.startTime;
	var interpolator = c.interpolator;

	var timePercent = (now - startTime)/duration;
	var percent = interpolator.get(timePercent);

	if(valueRange) {
		c.value = valueStart + percent * valueRange;
	}

	if(timePercent >= 1) {
		percent = 1;
	}

	if(xRange || yRange) {
		var x = Math.floor(xStart + percent * xRange);
		var y = Math.floor(yStart + percent * yRange);
		this.setPosition(x, y);
	}

	if(opacityRange) {
		this.opacity = opacityStart + percent * opacityRange;	
	}

	if(rotationRange) {
		this.setRotation(rotationStart + percent * rotationRange);
	}

	if(scaleXRange) {
		this.setScaleX(scaleXStart + percent * scaleXRange);
	}

	if(scaleYRange) {
		this.setScaleY(scaleYStart + percent * scaleYRange);
	}

	if(onStep && !onStep(this, timePercent, c)) {
		this.callOnAnimateDone(c);
		return;
	}

	if(percent < 1) {
		this.animating = true;
	}
	else {
		this.callOnAnimateDone(c);
	}

	return;
}

UIElement.prototype.isHitWorkArea = function() {
	return this.hitTestResult === Shape.HIT_TEST_MM && this.children.length > 1 && this.canRectSelectable();
}

UIElement.prototype.onPointerDownNormal = function(point) {
	if(!this.getParent()) {
		this.setLastEventStatus(UIElement.EVENT_STATUS_NONE);
	}

	var p = this.translatePoint(point);
	
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		if(this.isUIScrollView && this.mode !== Shape.MODE_EDITING) {
			return false;
		}

		if(this.dispatchPointerDownToChildren(p)) {
			this.setPointerEventTarget(this.targetShape);
			return true;
		}
		return false;
	}

	this.pointerDown = true;
	this.pointerDownTime = Date.now();
	this.childrenRange = this.calcChildrenRange();

	if(this.mode === Shape.MODE_EDITING) {
		this.onPointerDownEditing(point, true);
	}
	else if(this.enable) {
		this.onPointerDownRunning(p, true);
	}

	this.setPointerEventTarget(null);
	if(this.hitTestResult === Shape.HIT_TEST_MM || !this.selected) {
		if(this.dispatchPointerDownToChildren(p)) {
			if(this.mode === Shape.MODE_EDITING) {
				this.onPointerDownEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerDownRunning(p, false);
			}
			
			this.lastPosition.x = point.x;
			this.lastPosition.y = point.y;
			this.setPointerEventTarget(this.targetShape);

			return true;
		}
	}

	if(this.isHitWorkArea()) {
		this.hitTestResult = Shape.HIT_TEST_WORKAREA;
	}

	this.setTarget(null);
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	if(this.mode === Shape.MODE_EDITING) {
		this.handlePointerEvent(point, 1);
	}
	
	if(this.mode === Shape.MODE_EDITING) {
		this.onPointerDownEditing(point, false);
	}
	else if(this.enable) {
		this.onPointerDownRunning(p, false);
	}

	this.postRedraw();

	return true;
}

UIElement.prototype.getPointerPosition = function() {
	var win = this.getWindow();

	return win.lastPosition;
}

UIElement.prototype.onPointerMoveNormal = function(point) {
	if(this.mode !== Shape.MODE_EDITING && !this.isUIWindowManager && !this.isUIWindow) {
		if(!this.win.pointerDown) {
			return;
		}
	}

	var p = this.translatePoint(point);
	if(!this.getParent()) {
		this.setLastEventStatus(UIElement.EVENT_STATUS_NONE);
	}

	if(this.draggable && this.pointerDown) {
		if(this.mode !== Shape.MODE_EDITING) {
			this.handleDragMove(point);
			return;
		}
		else {
			delete this.dragging;
		}
	}

	if(this.hitTestResult) {
		if(this.mode === Shape.MODE_EDITING) {
			this.onPointerMoveEditing(point, true);
		}
		else if(this.enable) {
			this.onPointerMoveRunning(p, true);
		}

		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerMove(p);
			if(this.mode === Shape.MODE_EDITING) {
				this.onPointerMoveEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, false);
			}
		}
		else {
			if(this.mode === Shape.MODE_EDITING) {
				this.onPointerMoveEditing(point, false);
				if(this.hitTestResult === Shape.HIT_TEST_WORKAREA && this.isUIWindow) {
					var p = {x:0, y:0};
					var w = point.x - this.pointerDownPosition.x;
					var h = point.y - this.pointerDownPosition.y;
					var x = this.pointerDownPosition.x - this.left;
					var y = this.pointerDownPosition.y - this.top;
					var r = {x:x, y:y, w:w, h:h};

					if(Math.abs(w) > 5 && Math.abs(h) > 5) {
						r = fixRect(r);
						this.setSelected(false);
						for(var i = this.children.length - 1; i >= 0; i--) {
							var iter = this.children[i];
							p.x = iter.left + iter.w/2;
							p.y = iter.top + iter.h/2;
							iter.setSelected(isPointInRect(p, r));
						}
					}
				}
				else {	
					this.handlePointerEvent(point, 0);
				}
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, false);
			}
		}

		this.lastPosition.x = point.x;
		this.lastPosition.y = point.y;

		return true;
	}
	else {
		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerMove(p);
		}

		if(target || this.isUIWindow) {
			if(this.mode === Shape.MODE_EDITING) {
				this.onPointerMoveEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, true);
				this.onPointerMoveRunning(p, false);
			}
		}
	}
		
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;

	return false;
}

UIElement.prototype.onPointerUpNormal = function(point) {
	if(!this.getParent()) {
		this.setLastEventStatus(UIElement.EVENT_STATUS_NONE);
	}

	if(this.hitTestResult) {
		var p = this.translatePoint(point);
		var isClick = this.isClicked();
		
		if(this.mode === Shape.MODE_EDITING) {
			this.onPointerUpEditing(point, true);
		}
		else if(this.enable) {
			this.onPointerUpRunning(p, true);
		}

		if(isClick && this.enable) {
			this.onClick(p, true);
		}

		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerUp(p);
		}
		else {
			if(this.mode === Shape.MODE_EDITING) {
				this.handlePointerEvent(point, -1);
			}
		}

		if(this.mode === Shape.MODE_EDITING) {
			this.onPointerUpEditing(point, false);
		}
		else {
			if(this.dragging) {
				this.handleDragUp(point);
			}
			else if(this.enable) {
				this.onPointerUpRunning(p, false);
			}
		}

		if(isClick && this.enable) {
			this.onClick(p, false);
		}
		
		this.hitTestResult = Shape.HIT_TEST_NONE;

		if(this.longPressed) {
			this.longPressed = false;
		}

		return true;
	}
	else {
		this.targetShape = null;

		if(this.mode !== Shape.MODE_EDITING && this.enable) {
			this.onPointerUpRunning(p, false);
			if(isClick) {
				this.onClick(p, false);
			}
		}

		if(this.longPressed) {
			this.longPressed = false;
		}
		
		var target = this.getPointerEventTarget();
		if(target) {
			var p = this.translatePoint(point);
			target.onPointerUp(p);
		}
	}

	return false;
}

UIElement.prototype.needDrawTextTips = function(point) {
	return this.mode === Shape.MODE_EDITING && !this.children.length;	
}

UIElement.prototype.textEditable = function(point) {
	return this.mode === Shape.MODE_EDITING;	
}

UIElement.prototype.isClicked = function() {
	if(!this.view) {
		return false;
	}

	if(this.longPressed && this.events["onLongPress"]) {
		console.log("Long Pressed, Ignore Click Event.");
		return false;
	}

	return this.view.isClicked();
}


UIElement.prototype.onKeyDownRunning = function(code) {
	if(!this.handleKeyDown || this.mode === Shape.MODE_PREVIEW) {
		var sourceCode = this.events["onKeyDown"];
		if(sourceCode) {
			sourceCode = "this.handleKeyDown = function(code) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleKeyDown) {
		try {
			this.handleKeyDown(code);
		}catch(e) {
			console.log("this.handleKeyDown:" + e.message);
		}
	}

	return true;
}

UIElement.prototype.onKeyDownEditing = function(code) {
}

UIElement.prototype.onKeyDown = function(code) {
	if(this.targetShape) {
		this.targetShape.onKeyDown(code);
	}

	if(this.mode === Shape.MODE_EDITING) {
		this.onKeyDownEditing(code);
	}
	else {
		this.onKeyDownRunning(code);
	}

	return;
}

UIElement.prototype.onKeyUpRunning = function(code) {
	if(!this.handleKeyUp || this.mode === Shape.MODE_PREVIEW) {
		var sourceCode = this.events["onKeyUp"];
		if(sourceCode) {
			sourceCode = "this.handleKeyUp = function(code) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleKeyUp) {
		try {
			this.handleKeyUp(code);
		}catch(e) {
			console.log("this.handleKeyUp:" + e.message);
		}
	}else if(this.isUIWindow && code == KeyEvent.DOM_VK_BACK_BUTTON && !cantkIsEditorActive()) {
		console.log("Back Key Pressed On: " + this.name);
		if(this.isMainWindow()) {
			var app = this.getApp();
			var wm = this.getWindowManager();

			if(this.mode === Shape.MODE_RUNNING) {
				wm.systemExit();
				app.exitApp();
				console.log("Back Key Pressed, Exit App.");
			}
		}
		else {
			this.closeWindow(0);
			console.log("Back Key Pressed, Close Current Window.");
		}
	}

	return true;
}

UIElement.prototype.onKeyUpEditing = function(code) {
}

UIElement.prototype.onKeyUp = function(code) {
	if(code === KeyEvent.DOM_VK_BACK && this.isUIWindow) {
		this.closeWindow(0);

		return;
	}

	if(this.targetShape) {
		this.targetShape.onKeyUp(code);
	}

	if(this.mode === Shape.MODE_EDITING) {
		this.onKeyUpEditing(code);
	}
	else {
		this.onKeyUpRunning(code);
	}

	return;
}

UIElement.prototype.afterSetView = function() {

	return true;
}

UIElement.prototype.setView = function(view) {
	this.view = view;

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setView(view);
	}

	this.afterSetView(view);

	return;
}

UIElement.prototype.setApp = function(app) {
	this.app = app;
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setApp(app);
	}

	return;
}

UIElement.prototype.shapeCanBeChild = function(shape) {
	return true;
}

UIElement.prototype.onAppendedInParent = function() {
	if(this._win) {
		delete this._win;
	}
}

UIElement.prototype.afterChildAppended = function(shape) {
	return true;
}

UIElement.prototype.beforeAddShapeIntoChildren = function(shape) {
	return true;
}

UIElement.prototype.addShapeIntoChildren = function(shape, p) {
	var r = {x:0, y:0, w:0, h:0};
	for(var i = this.children.length - 1; i >= 0; i--) {
		var iter = this.children[i];

		if(iter === shape) continue;

		if(iter.isContainer && iter.visible) {
			r.x = iter.left;
			r.y = iter.top;
			r.w = iter.w;
			r.h = iter.h;

			if(isPointInRect(p, r)) {
				return iter.addShape(shape, true, p);
			}
		}
	}

	return false;
}

UIElement.prototype.addChildWithJson = function(jsShape, index) {
	var type = jsShape.type ? jsShape.type : jsShape.id;
	var shape = ShapeFactoryGet().createShape(type, C_CREATE_FOR_USER);

	if(shape) {
		shape.fromJson(jsShape);
		this.addShape(shape, false, null, index || shape.z);
		shape.setVisible(true);
	}

	return shape;
}

UIElement.prototype.setAlwaysOnTop = function(value) {
	this.alwaysOnTop = value;

	return;
}

UIElement.onAddShape = function(shape, addByUser) {
}

UIElement.prototype.fixName = function() {
	var shape = this;
	var parentShape = this.getParent();

	if(!shape.name) {
		shape.name = shape.type;
	}

	var name = shape.name;
	var prefix = name;
	var index = name.replace(/[a-z\-]/g, "");

	if(index) {
		prefix = name.replace(index, "");
		index = Math.abs(parseInt(index));
	}
	else {
		index = 1;
	}

	for(var i = index; i < 1000; i++) {
		if(parentShape.find(name)) {
			if(prefix[prefix.length-1] === '-') {
				name = prefix + i; 
			}
			else {
				name = prefix +"-"+ i; 
			}
		}
		else {
			break;
		}
	}

	shape.name = name;

	return this;
}


UIElement.prototype.addShape = function(shape, offsetIt, point, index) {
	if(!shape.isUIElement) {
		return false;
	}

	if(offsetIt) {
		shape.moveDelta(-this.left, -this.top);
	}

	if(this.beforeAddShapeIntoChildren(shape) && point) {
		var p = this.translatePoint(point);
		if(this.addShapeIntoChildren(shape, p)) {
			return true;
		}
		shape.setLeftTop(p.x, p.y);	
	}

	if(!this.shapeCanBeChild(shape)) {
		return false;
	}

	shape.setParent(this);
	shape.setView(this.view);
	shape.setApp(this.app);

	var children = this.children;
	var n = children.length;

	if(index === undefined) {
		if(n) {
			index = this.children[n-1].z + 1;
		}
		else {
			index = 0;	
		}
	}
	
	children.push(shape);
	shape.setZIndex(index);
	n = children.length;

	if(shape.isUIElement) {
		shape.setMode(this.mode, true);
		if(this.mode !== Shape.MODE_EDITING) {
			shape.init();
		}
	}

	for(var i = 0; i < children.length; i++) {
		var iter = children[i];

		if(iter.alwaysOnTop) {
			children.remove(iter);
			children.push(iter);
			break;
		}
	}

	if(shape.isCreatingElement()) {
		shape.callOnBirthedHandler(true);
	}

	shape.onAppendedInParent();
	this.afterChildAppended(shape);
	UIElement.onAddShape(shape, offsetIt);

	return true;
}

UIElement.prototype.appendChild = function(shape) {
	var arr = this.children;
	var n = arr.length;
	
	if(shape.z === undefined) {
		shape.z = n;
	}

	if(!n) {
		arr.push(shape);
		return;
	}

	for(var i = n-1; i >= 0; i--) {
		var iter = arr[i];
		if(iter.z <= shape.z) {
			arr.splice(i+1, 0, shape);
			return;
		}
	}
	arr.splice(0, 0, shape);

	return;
}

UIElement.prototype.addShapeDirectly = function(shape) {
	if(!this.shapeCanBeChild(shape)) {
		return false;
	}

	this.disableRelayout = true;
	shape.disableRelayout = true;

	shape.setParent(this);
	shape.setView(this.view);
	shape.setApp(this.app);
	this.appendChild(shape);
	if(shape.isUIElement) {
		shape.mode = this.mode;
	}
	this.afterChildAppended(shape);

	delete shape.disableRelayout;
	delete this.disableRelayout;

	return true;
}

UIElement.prototype.addChild = function(child, zIndex) {
	if(this.addShape(child, false, null, zIndex || child.z)) {
		return child;
	}
	else {
		return null;
	}
}
	
UIElement.prototype.shapeCanBeRemove = function(shape) {
	return true;
}

UIElement.prototype.afterChildRemoved = function(shape) {
	return true;
}

UIElement.prototype.remove = function(destroyIt, sync) {
	var parentShape = this.getParent();

	if(parentShape) {
		parentShape.removeChild(this, destroyIt, sync);	
	}

	return this;
}

UIElement.prototype.removeAll = function() {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[0];
		this.removeShape(iter);
	}

	return;
}

UIElement.prototype.removeChildren = function() {
	this.targetShape = null;
	this.pointerEventTarget = null;

	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];

		if(iter.getParent() === this) {
			iter.setParent(null);
			iter.setView(null);
			iter.setApp(null);
		}
	}

	this.children.length = 0;

	return this;
}

UIElement.prototype.removeChild = function(child, destroyIt, sync) {
	var me = this;

	if(child.animatingInfo) {
		UIElement.logWarning("removing animating element.");
	}

	if(sync) {
		this.removeShape(child, destroyIt);
	}
	else {
		child.removed = true;
		setTimeout(function() {
			me.removeShape(child, destroyIt);
			child = null;
			me = null;
		}, 0);
	}

	return this;
}

UIElement.onRemoveShape = function(parentShape, shape) {
}

UIElement.prototype.removeShape = function(shape, destroyIt) {
	if(!this.shapeCanBeRemove(shape) || !shape.parentShape) {
		return false;
	}

	if(shape.animatingInfo) {
		UIElement.logWarning("removing animating element.");
	}

	if(this.targetShape === shape) {
		this.targetShape = null;
	}

	if(this.pointerEventTarget === shape) {
		this.pointerEventTarget = null;
	}

	this.children.remove(shape);
	
	shape.callOnRemovedHandler();
	this.afterChildRemoved(shape);

	if(shape.getParent() === this) {
		shape.setParent(null);
		shape.setView(null);
		shape.setApp(null);
	}

	if(this.mode === Shape.MODE_EDITING) {
		this.relayout();
	}

	UIElement.onRemoveShape(this, shape);
	shape.onRemoved(this);

	if(destroyIt) {
		shape.destroy();
	}

	return;
}

UIElement.prototype.reparent = function(newParent, keepAbsPosition) {
	var parent = this.getParent();
	if(newParent === parent) {
		return;
	}

	if(!newParent || !parent) {
		return;
	}

	if(keepAbsPosition) {
		var parentPos = parent.getPositionInWindow();
		var newParentPos = newParent.getPositionInWindow();
		var dx = parentPos.x - newParentPos.x;
		var dy = parentPos.y - newParentPos.y;

		this.left += dx;
		this.top += dy;
	}

	parent.children.remove(this);
	newParent.addShapeDirectly(this);

	return;
}

UIElement.prototype.afterPropertyChanged = function() {
	if(this.parentShape) {
		this.parentShape.relayoutChildren();
	}
	else {
		this.relayout();
	}

	return;
}

UIElement.prototype.getIndexOfChild = function(child) {
	return this.children.indexOf(child);
}

UIElement.prototype.getIndex = function() {
	if(this.parentShape) {
		return this.parentShape.getIndexOfChild(this);
	}
	else {
		return -1;
	}
}

UIElement.prototype.getZIndex = function() {
	return this.z;
}

UIElement.prototype.onRestack = function() {
}

UIElement.prototype.setZIndex = function(index) {
	this.z = index;

	var parentShape = this.parentShape;
	if(parentShape) {
		var arr = parentShape.children;
		var n = arr.length;
		for(var i = 0; i < n; i++) {
			var iter = arr[i];
			if(iter.z === undefined) {
				iter.z = i;	
			}
		}

		arr.sort(function(a, b) {
			return a.z - b.z;
		});
	}

	this.onRestack();

	return this;
}

UIElement.prototype.findChildByType = function(type, recursive) {
	var i = 0;
	var s = null;
	var shape = null;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		shape = this.children[i];
		if(shape.type === type) {
			return shape;
		}
	}

	if(recursive) {
		for(i = 0; i < n; i++) {
			shape = this.children[i];
			s = shape.findChildByType(type, recursive);
			if(s) {
				return s;
			}
		}
	}

	return null;
}

UIElement.prototype.findChildByPath = function(names) {
	var name = names.shift();
	var child = this.findChildByName(name);

	if(names.length) {
		return child.findChildByPath(names);
	}

	return child;
}

UIElement.prototype.findChildByName = function(name, recursive) {
	var i = 0;
	var s = null;
	var shape = null;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		shape = this.children[i];
		if(shape.name === name) {
			return shape;
		}
	}

	if(recursive) {
		for(i = 0; i < n; i++) {
			shape = this.children[i];
			s = shape.findChildByName(name, recursive);
			if(s) {
				return s;
			}
		}
	}

	return null;
}

UIElement.prototype.find = function(name, recursive) {
	if(!name) {
		return this;
	}

	if(name.indexOf("/") >= 0) {
		var names = name.split("/");
		names.remove("");

		return this.findChildByPath(names);
	}
	else {
		return this.findChildByName(name, recursive);
	}
}

UIElement.prototype.setValueOf = function(name, value) {
	var child = this.findChildByName(name, true);
	
	return child ? child.setValue(value) : null;
}

UIElement.prototype.getValueOf = function(name) {
	var child = this.findChildByName(name, true);
	
	return child ? child.getValue() : null;
}

UIElement.prototype.beforePaintChild = function(child, canvas) {
	return;
}

UIElement.prototype.afterPaintChild = function(child, canvas) {
	return;
}

UIElement.prototype.paintTargetShape = function(canvas) {
	var targetShape = this.targetShape;
	if(targetShape && ((this.isUIList && this.mode === Shape.MODE_EDITING) || this.isUIGrid)) {
		shape = targetShape;
		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}

	return;
}

UIElement.prototype.defaultPaintChildren = function(canvas) {
	canvas.save();
	canvas.beginPath();
	var shape = null;
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		shape = this.children[i];
		if(!shape) {
			continue;
		}

		if(shape.visible) {
			this.beforePaintChild(shape, canvas);
			shape.paintSelf(canvas);
			this.afterPaintChild(shape, canvas);
		}
		else if(shape.isAnimating()){
			shape.stepAnimation(canvas);
		}
	}
	
	this.paintTargetShape(canvas);

	canvas.restore();
	
	return;
}

UIElement.prototype.beforePaintChildren = function(canvas) {
	if(!this.rotateChildren && this.rotation) {
		var hw = this.w >> 1;
		var hh = this.h >> 1;
		canvas.translate(hw, hh);
		canvas.rotate(-this.rotation);
		canvas.translate(-hw, -hh);
	}

	return;
}

UIElement.prototype.afterPaintChildren = function(canvas) {
	return;
}

UIElement.prototype.paintChildren = function(canvas) {
	this.defaultPaintChildren(canvas);

	return;
}

UIElement.prototype.paintSelfOnly =function(canvas) {
	return;
}

UIElement.prototype.drawImageAtCenter = function(ctx, image, x, y, w, h, keepRatio) {

	if(image && image.width > 0) {
		var imageW = image.width;
		var imageH = image.height;

		if(keepRatio) {
			var scale = Math.min(1, Math.min(h/imageH, w/imageW));
			var dw = imageW * scale;
			var dh = imageH * scale;
			var dx = ((w - dw)>>1) + x;
			var dy = ((h - dh)>>1) + y;
			
			dx = Math.max(dx, x);
			dy = Math.max(dy, y);
		}
		else {
			dx = x;
			dy = y;
			dw = w;
			dh = h;
		}

		ctx.drawImage(image, 0, 0, imageW, imageH, dx, dy, dw, dh);
	}

	return;
}


UIElement.prototype.drawImage =function(canvas) {
	this.drawFgImage(canvas);

	return;
}

UIElement.prototype.drawFgImage =function(canvas) {
	return;
}

UIElement.prototype.getBgHtmlImage =function() {
	var image = this.getBgImage();

	return image ? image.getImage() : null;
}

UIElement.prototype.getBgImage =function() {
	var image = null;
	
	if(this.enable) {
		if(this.pointerDown && !this.isClicked()) {
			image = this.images.normal_bg;
		}
		else {
			if(this.pointerDown) {
				image = this.images.active_bg;
			}
			else {
				if(this.isPointerOverShape() && this.getHtmlImageByType(UIElement.IMAGE_POINTER_OVER)) {
					image = this.images.pointer_over_bg;
				}
				else if(this.isFocused()) {
					image = this.images.focused_bg;
				}
				else {
					image = this.images.normal_bg;
				}
			}
		}
	}
	else {
		image = this.images.disable_bg;
	}

	if(!image || !image.getImage()) {
		image = this.images.default_bg;
	}
	
	if(!image || !image.getImage()) {
		image = this.images.normal_bg;
	}

	if(!image || !image.getImage()) {
		return;
	}

//	image = image.getImage();

	return image;
}

UIElement.prototype.drawImageAt = function(canvas, image, display, x, y, dw, dh, srcRect) {
	UIElement.drawImageAt(canvas, image, display, x, y, dw, dh, srcRect);
}

UIElement.drawImageAt = function(canvas, image, display, x, y, dw, dh, srcRect) {
	return WImage.draw(canvas, image, display, x, y, dw, dh, srcRect);
}

UIElement.drawImageLine = function(canvas, image, display, p0, p1, srcRect) {
	var angle = Math.lineAngle(p0, p1);
	var distance = Math.round(Math.distanceBetween(p0, p1));

	canvas.save();
	canvas.translate(p0.x, p0.y);
	canvas.rotate(angle);
	canvas.translate(0, -image.height>> 1);
	UIElement.drawImageAt(canvas, image, display, 0, 0, distance, image.height, srcRect);
	canvas.restore();

	return;
}

UIElement.prototype.setImageScale = function(imageScaleX, imageScaleY) {
	if(imageScaleX || imageScaleX === 0) {
		this.imageScaleX = imageScaleX;
	}

	if(imageScaleY || imageScaleY === 0) {
		this.imageScaleY = imageScaleY;
	}

	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	return this;
}

UIElement.prototype.drawBgImage =function(canvas) {
	var wImage = this.getBgImage();
		
	if(wImage) {
		var image = wImage.getImage();
		var srcRect = wImage.getImageRect();
		var display = this.images.display;
		
		if(display === UIElement.IMAGE_DISPLAY_SCALE) {
			if(this.imageScaleX && this.imageScaleY) {
				var hw = this.w >> 1;
				var hh = this.h >> 1;
				var sx = this.imageScaleX || 1;
				var sy = this.imageScaleY || 1;

				canvas.save();
				canvas.translate(hw, hh);
				canvas.scale(sx, sy);
				canvas.translate(-hw, -hh);

				this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, this.w, this.h, srcRect);
				canvas.restore();
			}
			else {
				this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, srcRect);
			}
		}
		else {
			this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, srcRect);
		}
	}

	return;
}

UIElement.prototype.beforeDrawIcon = function(canvas) {
	return false;
}

UIElement.prototype.afterDrawIcon = function(canvas) {
	return false;
}

UIElement.prototype.prepareStyle = function(canvas) {
	var style = this.style;

	canvas.beginPath();
	if(canvas.lineWidth !== style.lineWidth) {
		canvas.lineWidth = style.lineWidth;	
	}

	if(canvas.strokeStyle != style.lineColor) {
		canvas.strokeStyle = style.lineColor;
	}
	
	if(canvas.fillStyle != style.fillColor) {
		canvas.fillStyle = style.fillColor;
	}

	return;
}

UIElement.prototype.updateTransform = function(canvas) {
	
	this.callOnUpdateTransformHandler(canvas);

	return;
}

//
//Example:
//==========================================
//var config = {};
//config.rotationFrom = -0.2;
//config.rotationTo = 0.2;
//
//config.scaleFrom =  0.9;
//config.scaleTo = 1.1;
//
//config.opacityFrom =  0.1;
//config.opacityTo = 1.0;
//config.frequency = 0.5;
//
//var image = this.getWindow().findChildByName("ui-image", true);
//image.setHighlightConfig(config);
//

UIElement.prototype.saveTransform = function() {
	this.savedTransform = {};
	this.savedTransform.opacity = this.opacity;
	this.savedTransform.scale = this.scale;
	this.savedTransform.scaleX = this.scaleX;
	this.savedTransform.scaleY = this.scaleY;
	this.savedTransform.rotation = this.rotation;
	this.savedTransform.offsetX = this.offsetX;
	this.savedTransform.offsetY = this.offsetY;

	return;
}

UIElement.prototype.restoreTransform = function() {
	if(this.savedTransform) {
		this.opacity = this.savedTransform.opacity;
		this.scale = this.savedTransform.scale;
		this.scaleX = this.savedTransform.scaleX;
		this.scaleY = this.savedTransform.scaleY;
		this.rotation = this.savedTransform.rotation;
		this.offsetX = this.savedTransform.offsetX;
		this.offsetY = this.savedTransform.offsetY;
	}

	return;
}

UIElement.prototype.setHighlightConfig = function(highlightConfig) {
	if(highlightConfig) {
		//this.restoreTransform();
		var c = JSON.parse(JSON.stringify(highlightConfig));

		c.startTime = 0;
		this.saveTransform();
		this.removeHighlightConfig = false;
		this.highlightConfig = c;

		if(c.rotationFrom !== undefined && c.rotationTo !== undefined) {
			c.rotationRange = c.rotationTo - c.rotationFrom;
			c.rotationMiddle = (c.rotationTo + c.rotationFrom)/2;
		}
		else {
			c.rotationRange = 0;
		}

		if(c.opacityFrom !== undefined && c.opacityTo !== undefined) {
			c.opacityRange = c.opacityTo - c.opacityFrom;
			c.opacityMiddle = (c.opacityTo + c.opacityFrom)/2;
		}
		else {
			c.opacityRange = 0;
		}

		if(c.scaleFrom !== undefined && c.scaleTo !== undefined) {
			c.scaleRange = c.scaleTo - c.scaleFrom;
			c.scaleMiddle = (c.scaleTo + c.scaleFrom)/2;
		}
		else {
			c.scaleRange = 0;
		}

		if(c.scaleXFrom !== undefined && c.scaleXTo !== undefined) {
			c.scaleXRange = c.scaleXTo - c.scaleXFrom;
			c.scaleXMiddle = (c.scaleXTo + c.scaleXFrom)/2;
		}
		else {
			c.scaleXRange = 0;
		}

		if(c.scaleYFrom !== undefined && c.scaleYTo !== undefined) {
			c.scaleYRange = c.scaleYTo - c.scaleYFrom;
			c.scaleYMiddle = (c.scaleYTo + c.scaleYFrom)/2;
		}
		else {
			c.scaleYRange = 0;
		}

		if(c.offsetXFrom !== undefined && c.offsetXTo !== undefined) {
			c.offsetXRange = c.offsetXTo - c.offsetXFrom;
			c.offsetXMiddle = (c.offsetXTo + c.offsetXFrom)/2;
		}
		else {
			c.offsetXRange = 0;
		}

		if(c.offsetYFrom !== undefined && c.offsetYTo !== undefined) {
			c.offsetYRange = c.offsetYTo - c.offsetYFrom;
			c.offsetYMiddle = (c.offsetYTo + c.offsetYFrom)/2;
		}
		else {
			c.offsetYRange = 0;
		}
	}
	else {
		this.removeHighlightConfig = true;
	}

	return;
}

UIElement.prototype.updateHighlightTransform = function(canvas) {
	var paused = this.timeScaleIsZero() || (this.mode === Shape.MODE_EDITING && this.disablePreview);

	if(this.highlightConfig && !paused) {
		var c = this.highlightConfig;
		
		if(c.paused) return;

		var me = this;
		var tOffset = 0;
		var random = c.random ? c.random/1000 : 0;	
		var frequency = c.frequency ? c.frequency : 4;

		if(c.startTime) {
			tOffset = (canvas.now - c.startTime)/1000;
		}
		else {
			c.startTime = Date.now();
		}
		tOffset += 1/(frequency*4) + random;
		var womiga = frequency * Math.PI * 2;
        var factor = this.scaleTime(Math.cos(womiga*tOffset) * 0.5);

		if(this.removeHighlightConfig && Math.abs(factor) < 0.1) {
			this.removeHighlightConfig = false;
			this.highlightConfig = null;
			this.restoreTransform();

			return;
		}

		if(c.rotationRange) {
			this.rotation = c.rotationMiddle + c.rotationRange * factor;
		}
		if(c.opacityRange) {
			this.opacity = c.opacityMiddle + c.opacityRange * factor;
		}
		if(c.scaleRange) {
			var scale = c.scaleMiddle + c.scaleRange * factor;
			this.scaleX = scale;
			this.scaleY = scale;
		}
		if(c.scaleXRange) {
			this.scaleX = c.scaleXMiddle + c.scaleXRange * factor;
		}
		if(c.scaleYRange) {
			this.scaleY = c.scaleYMiddle + c.scaleYRange * factor;
		}
		if(c.offsetXRange) {
			this.offsetX = c.offsetXMiddle + c.offsetXRange * factor;
		}
		if(c.offsetYRange) {
			this.offsetY = c.offsetYMiddle + c.offsetYRange * factor;
		}

		canvas.needRedraw++;
	}

	return;
}

UIElement.prototype.paintSelf = function(canvas) {
	this.stepAnimation(canvas);

	if(!this.visible) return;

	var animating = this.animating;

	canvas.save();
	this.translate(canvas);

	if(this.events["onUpdateTransform"] && !animating) {
		this.updateTransform(canvas);
	}
	if(this.highlightConfig) {
		this.updateHighlightTransform(canvas);
	}
	
	this.applyTransform(canvas);
	this.onClip(canvas);

	canvas.save();

	var flipX = this.flipX ? -1 : 1;
	var flipY = this.flipY ? -1 : 1;
	if(flipX < 0 || flipY < 0) {
		canvas.save();
		
		var hw = this.w >> 1;
		var hh = this.h >> 1;
		canvas.translate(hw, hh);
		canvas.scale(flipX, flipY);
		canvas.translate(-hw, -hh);
	}

	if(this.beforePaint) {
		this.beforePaint(canvas);
	}
	this.drawBgImage(canvas);
	this.paintSelfOnly(canvas);
	this.drawImage(canvas);

	if(flipX < 0 || flipY < 0) {
		canvas.restore();
	}

	canvas.restore();

	if(this.children.length || this.mode === Shape.MODE_EDITING) {
		canvas.save();
		if(animating) {
			canvas.animating++;
		}
		this.beforePaintChildren(canvas);
		this.paintChildren(canvas);
		this.afterPaintChildren(canvas);
		if(animating) {
			canvas.animating--;
		}
		canvas.restore();
	}

	if(this.drawText && this.textType !== Shape.TEXT_NONE) {
		this.drawText(canvas);
		this.drawTextTips(canvas);
	}

	if(this.afterPaint) {
		this.afterPaint(canvas);
	}

	canvas.restore();
	
	return;
}

UIElement.prototype.saveProps = [];
UIElement.prototype.urlProps = ["dataURL"];
UIElement.saveProps = ["xAttr", "yAttr", "widthAttr", "heightAttr", "xParam", "yParam", "widthParam", "heightParam", "sticky", "flipX", "flipY", "rotateChildren", "defaultAnimationName", "dataURL", "disablePreview", "dataSourceUrl", "imageScaleX", "imageScaleY"];

UIElement.prototype.doToJsonCustom = function(o) {
	o.propertySheetDesc = this.propertySheetDesc;
	for(var key in o.propertySheetDesc) {
		var value = this[key];
		if(value !== undefined) {
			o[key] = value;
		}
	}

	return this;
}

UIElement.prototype.doToJson = function(o) {
	this.updateLayoutParams();

	RShape.prototype.doToJson.call(this, o);
	
	o.runtimeVisible = this.runtimeVisible;
	if(this.isUILoadingWindow) {
		o.isUILoadingWindow = true;
	}

	if(this.value !== undefined) {
		o.value = this.value;
	}

	this.propsToJson(o, this.saveProps);
	this.propsToJson(o, UIElement.saveProps);

    if(this.urlProps) {
        for(var i = 0; i < this.urlProps.length; i++) {
            var prop = this.urlProps[i];
            var url = o[prop];
            if(url) {
            	o[prop] = this.getRelativePathOfURL(url);
            }
        }
    }

	this.imagesToJson(o);
	o.events = this.events;
	
	if(this.animations) {
		o.animations = JSON.parse(JSON.stringify(this.animations));
	}
	
	if(this.handle) {
		o.handle = {};
		o.handle.x = this.handle.x;
		o.handle.y = this.handle.y;
	}

	if(this.settings) {
		o.settings = this.settings;
	}

	if(this.propertySheetDesc) {
		this.doToJsonCustom(o);
	}

	this.childrenToJson(o);

	return o;
}

UIElement.prototype.childToJson = function(child) {
	return child.toJson();
}

UIElement.prototype.childrenToJson = function(o) {
	var n = this.children.length;
	var children = this.children;
	
	o.children = [];
	for(var i = 0; i < n; i++) {
		var iter = children[i];
		o.children.push(this.childToJson(iter));
	}

	return this;
}

UIElement.prototype.childrenFromJson = function(js) {
	if(js.children) {
		var n = js.children.length;
		var factory = ShapeFactoryGet();
		this.children.clear(true);
		for(var i = 0; i < n; i++) {
			var jsShape = js.children[i];

			if(!jsShape) {
				console.log("Warning: child is null.");
				continue;
			}

			var type = jsShape.type ? jsShape.type : jsShape.id;
			var shape = factory.createShape(type, C_CREATE_FOR_USER);
			if(shape) {
				if(jsShape.z === undefined) {
					jsShape.z = i;
				}
				shape.z = jsShape.z;
				if(this.addShapeDirectly(shape)) {
					shape.fromJson(jsShape);
				}
			}
		}
	}

	this.targetShape = null;
	this.pointerEventTarget = null;

	return;
}

UIElement.prototype.doFromJsonCustom = function(js) {
	this.propertySheetDesc = js.propertySheetDesc;

	for(var key in js.propertySheetDesc) {
		var value = js[key];
		if(value !== undefined) {
			this[key] = value;
		}
	}
}

UIElement.prototype.doFromJson = function(js) {
	RShape.prototype.doFromJson.call(this, js);
	
	if(js.runtimeVisible === undefined) {
		this.runtimeVisible = true;
	}
	else {
		this.runtimeVisible = js.runtimeVisible;
	}

	if(js.isUILoadingWindow) {
		this.isUILoadingWindow = true;
	}

	this.propsFromJson(js, UIElement.saveProps);
	this.propsFromJson(js, this.saveProps);

    Object.keys(js.events).forEach(function(ev) {
        this.events[ev] = js.events[ev];
    }, this);
   
	this.imagesFromJson(js);

	if(js.animations) {
		this.animations = js.animations;
	}

	if(js.handle) {
		this.handle = {};
		this.handle.x = js.handle.x;
		this.handle.y = js.handle.y;
	}

	if(js.settings) {
		this.settings = js.settings;
	}

	if(js.propertySheetDesc) {
		this.doFromJsonCustom(js);
	}
	
	if(js.value !== undefined) {
		this.value = js.value;
		this.setValue(this.getValue());
	}

	this.childrenFromJson(js);

	return this;
}
	
UIElement.prototype.afterApplyFormat = function() {
	if(this.parentShape) {
		this.parentShape.relayoutChildren();
	}
	else {
		this.relayout();
	}

	return;
}

UIElement.prototype.findChildByPoint = function(point, recursive, checkFunc) {
	var p = point;
	var n = this.children.length;

	for(var i = n; i > 0; i--) {
		var child = this.children[i-1];
		if(!child.visible) continue;

		if(child.hitTest(p)) {
			if(checkFunc && !checkFunc(child)) {
				continue;
			}

			if(recursive) {
				var tp = {};
				tp.x = p.x - child.left + (child.xOffset || 0);
				tp.y = p.y - child.top + (child.yOffset || 0);
				return child.findChildByPoint(tp, recursive, checkFunc);
			}
			else {
				return child;
			}
		}
		else {
			if(recursive) {
				var tp = {};
				tp.x = p.x - child.left + (child.xOffset || 0);
				tp.y = p.y - child.top + (child.yOffset || 0);
				var ret = child.findChildByPoint(tp, recursive, checkFunc);
				if(ret !== child) {
					return ret;
				}
			}
		}
	}

	return this;
}

UIElement.prototype.findShapeByPoint = UIElement.prototype.findChildByPoint;

UIElement.prototype.getChildren = function() {
	return this.children;
}

UIElement.prototype.getChildrenNr = function() {
	return this.children.length;
}

UIElement.prototype.getChild = function(index) {
	return (index < this.children.length && index >= 0) ? this.children[index] : null;
}

UIElement.prototype.canBindingData = function() {
	return (!this.isUIDevice && !this.isUIScreen && !this.isUIWindowManager && this.children.length > 0);
}

UIElement.prototype.onDataBindingTemplate = function(template) {
	//template.name = this.name;
	if(this.isUIImage) {
		var image = this.getImageByType(UIElement.IMAGE_DEFAULT);
		var src = image ? image.getImageSrc(): "";

		src = this.getRelativePathOfURL(src);

		template.image = src;
	}
	else {
		if(this.value !== undefined) {
			template.value = this.value;
		}
	}

	if(this.text || this.isUILabel) {
		template.text = this.text;
	}

	return template;
}

UIElement.prototype.getDataBindingTemplate = function() {
	var i = 0;
	var iter = null;
	var template = {};
	var children = this.children;
	var n = this.children.length;

	this.onDataBindingTemplate(template);

	if(n > 0) {
		template.children = [];

		for(i = 0; i < n; i++) {
			iter = children[i];
			if(!this.childIsBuiltin(iter)) {
				template.children.push(iter.getDataBindingTemplate());
			}
		}
	}

	return template;
}

UIElement.prototype.setUserData = function(userData) {
	this.userData = userData;

	return;
}

UIElement.prototype.getUserData = function() {
	return this.userData;
}

UIElement.prototype.onBindData = function(data) {
	var text = data.text;
	var image = data.image;
	var value = data.value;

	if(text !== undefined) {
		this.setText(text);
	}
	
	if(image !== undefined) {
		this.setImage(UIElement.IMAGE_DEFAULT, image);
	}

	if(value !== undefined) {
		this.setValue(value);
	}
	
	if(data.enable !== undefined) {
		this.setEnable(data.enable);
	}
	
	if(data.visible !== undefined) {
		this.setVisible(data.visible);
	}

	if(data.textColor) {
		this.style.setTextColor(data.textColor);
	}
	
	if(data.fillColor) {
		this.style.setFillColor(data.fillColor);
	}
	
	if(data.lineColor) {
		this.style.setLineColor(data.lineColor);
	}

	if(data.fontSize) {
		this.style.setFontSize(data.fontSize);
	}
	
	this.setUserData(data.userData);

	if(data.height) {
		this.h = data.height;
	}
	
	if(data.width) {
		this.w = data.width;
	}

	if(this.offset) {
		this.offset = 0;
	}

	var attrs = ["children", "text", "value", "image", "visible", "enable", "textColor", "fillColor", "lineColor", "fontSize", "userData"];
	for(var key in data) {
		if(attrs.indexOf(key) >= 0) continue;
		var value = data[key];
		var child = this.find(key, true);
		if(!child) continue;

		if(typeof value  === "object") {
			child.doBindData(value);
		}
		else {
			child.setValue(value);		
		}
	}

	return;
}

UIElement.prototype.moveMustBeLastItemToLast = function() {
	var last = null;
	var children = this.children;
	var n = this.children.length;
	
	for(var i = 0; i < n; i++) {
		var iter = children[i];
		if(iter.name === "ui-last") {
			last = iter;
			children[i] = children[n-1];
			children[n-1] = last;
			break;
		}
	}

	return;
}

UIElement.prototype.childIsBuiltin = function(child) {
	return false;
}

UIElement.makeImageURLToAbsOfJson = function(json) {
	if(!json) {
		return;
	}

	var images = json.images;
	var host = window.location.protocol + "//" + window.location.host + "/";

	for(var key in images) {
		var value = images[key];
		if(key !== "display") {
			if(value.indexOf("http://") < 0 && value.indexOf("https://") < 0) {
				value = host + value;
				images[key] = value;
			}
		}
	}

	if(!json.children) {
		return;
	}

	for(var i = 0; i < json.children.length; i++) {
		var iter = json.children[i];

		UIElement.makeImageURLToAbsOfJson(iter);
	}

	return;
}

UIElement.prototype.getTemplateChildJson = function() {
	if(!this.templateChildJson) {
		var child = this.getTemplateChild();
		this.templateChildJson = child ? child.toJson() : null;
		UIElement.makeImageURLToAbsOfJson(this.templateChildJson);

		if(this.templateChildJson) {
			delete this.templateChildJson.isTemplate;
		}
		else {
			console.log("No Template Child.");
		}
	}

	return this.templateChildJson;
}

UIElement.prototype.getTemplateChild = function() {
	if(!this.templateChild) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			if(iter.isTemplate) {
				this.children.remove(iter);
				this.templateChild = iter;
				break;
			}
		}
		
		if(!this.templateChild) {
			this.templateChild = this.getLastUserChild();
		}
	}
	
	return this.templateChild;
}

UIElement.prototype.dupTemplateChild = function() {
	var child = this.getTemplateChild().clone();
	
	delete child.isTemplate;

	return child;
}

UIElement.prototype.dupChild = function(name, zIndex) {
	var child = this.findChildByName(name);

	if(child) {
		var shape = child.clone();

		if(isNaN(zIndex)) {
			zIndex = child.z + 1;
		}

		this.addShape(shape, false, null, zIndex);
		shape.fixName();

		return shape;
	}
	else {
		return null;
	}
}

UIElement.prototype.getLastUserChild = function() {
	var children = this.children;
	var n = this.children.length;

	if(n > 0) {
		for(var i = n-1; i >= 0; i--) {
			var iter = children[i];
			if(!this.childIsBuiltin(iter)) {
				return iter;
			}
		}
	}

	return null;
}

UIElement.prototype.countUserChildren = function() {
	var nr = 0;
	var children = this.children;
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(!this.childIsBuiltin(iter)) {
			nr = nr + 1;
		}
	}

	return nr;
}

UIElement.prototype.bindData = function(data, animHint, clearOldData) {
	var shape = this;
	
	shape.disableRelayout = true;
	shape.doBindData(data, clearOldData);	
	delete shape.disableRelayout;
	shape.relayoutChildren(animHint);
	console.log("bindData: done");

	shape.postRedraw();

	return;
}

UIElement.prototype.doBindData = function(data, clearOldData) {
	var i = 0;
	var k = 0;
	var iter = null;
	var templateJson = (this.isUIList || this.isUIGrid) ? this.getTemplateChildJson() : null;
	
	this.onBindData(data);

	var children = this.children;
	var n = this.countUserChildren();
	if((n < 1 && !templateJson) || !data.children) {
		return;
	}

	var m = data.children.length;
	if((this.isUIList || this.isUIGrid)) {
		if(m > n) {
			templateJson.y = 0;
			templateJson.visible = true;
			for(i = n; i < m; i++) {
				this.addChildWithJson(templateJson);
			}
		}
		else if(m < n && clearOldData) {
			var arr = [];

			k = n - m;
			for(i = (this.children.length-1); i>= 0; i--) {
				var iter = this.children[i];
				if(!this.childIsBuiltin(iter) && !iter.isTemplate) {
					arr.push(iter);
				}
			}

			for(var i = 0; i < arr.length; i++) {
				var iter = arr[i];
				
				if(i === k) {
					break;
				}
				this.children.remove(iter);
				iter.setParent(null);
				iter.setApp(null);
				iter.setView(null);
			}
		}

		n = this.children.length;
	}
	else {
		n = this.children.length;
	}

	for(i = 0, k = 0; k < n & i < m; k++) {
		iter = children[k];
		if(!this.childIsBuiltin(iter)) {
			iter.doBindData(data.children[i]);
			i = i + 1;
		}
	}

	return;
}

UIElement.prototype.bindDataUrl = function(dataUrl, doConvert, onBindDone) {
	var rInfo = {};
	var shape = this;

	httpGetJSON(dataUrl, function(js) {
		if(doConvert) {
			js = doConvert(js);
		}

		if(js) {
			shape.bindData(js, "default", true);
		}

		if(onBindDone) {
			onBindDone(js);
		}
	});

	return;
}

///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////

function UIElementCreator(type) {
	type = type ? type : "ui-element";

	var args = [type, "UI-Element", null, 1];
	
	ShapeCreator.apply(this, args);
	
	this.createShape = function(createReason) {
		var g = new UIElement();

		return g.initUIElement(this.type);
	}
	
	return;
}

UIElement.prototype.sortChildren = function() {
	return;
}

UIElement.prototype.shouldShowContextMenu = function() {
	return this.mode === Shape.MODE_EDITING;
}

UIElement.prototype.setText = function(text, notify) {
	if(this.text != text) {
		this.text = this.toText(text);

		if(notify) {
			this.callOnChangedHandler(text);
		}

		this.textNeedRelayout = true;
	}

	return this;
}

UIElement.prototype.getValue = function() {
	return this.getText();
}

UIElement.prototype.setValue = function(value, notify, animation) {
	var me = this;
	var oldValue = this.getText() || 0;

	value = String(value);
	if(value == String(oldValue)) return this;
	if(!!animation && !isNaN(+value) && !isNaN(+oldValue)) {
		var fixLen = value.indexOf('.') > -1 ? (value.length - value.indexOf('.') - 1) : 0;

		this.animate({
			duration: 300,
			valueEnd: +value,
			valueStart: +oldValue,
			onStep: function(ui, timePercent, config) {
				me.setText(config.value.toFixed(fixLen));
				return true;
			},
			onDone: function(ui, aniName) {
				me.setText(value);
				console.debug('element setValue onDone');
			}
		});
	}
	else {
		this.setText(value);
	}

	return this;
}

UIElement.prototype.addValue = function(delta, notify, animation) {
	var oldValue = this.getValue();
	var colonIdx = String(oldValue).indexOf(':');

	if(colonIdx == -1) {
		oldValue = +oldValue;
		var value = (isNaN(oldValue) ? 0 : oldValue) + (isNaN(+delta) ? 0 : +delta);
		var lenOld   = getFixlen(String(oldValue));
		var lenDelta = getFixlen(String(delta));
		var lenValue = getFixlen(String(value));
		var length = lenOld > lenDelta ? lenOld : lenDelta;
			length = length > lenValue ? lenValue : length;

		function getFixlen(str) {
			return str.indexOf('.') > -1 ? (str.length - str.indexOf('.') - 1) : 0;
		}

		return this.setValue(value.toFixed(length), notify, animation);
	}
	else {
		var min   = +oldValue.substr(0, colonIdx);
		var sec   = +oldValue.substr(colonIdx+1, 2);
		var total = (isNaN(min) ? 0 : min*60) + (isNaN(sec) ? 0 : sec);
		var dst = total + delta>>0;
		if(isNaN(+delta) || dst < 0) {
			return this;
		}
		else {
			var min = Math.floor(dst/60);
			var sec = dst%60;
			min = min < 10 ? ('0' + min) : min;
			sec = sec < 10 ? ('0' + sec) : sec;
			return this.setValue(min + ':' + sec);
		}
	}
}

UIElement.prototype.getPositionInView = function() {
	var x = this.getX();
	var y = this.getY();
	var point = {x:0, y:0};
	var iter = this.parentShape;

	while(iter != null) {
		x += iter.getX();
		y += iter.getY();
		if(iter.isUIVScrollView) {
			y = y - iter.offset;
		}
		else if(iter.isUIHScrollView) {
			x = x - iter.offset;
		}
		else if(iter.isUIScene || iter.isUIScrollViewX) {
			x = x - iter.xOffset;
			y = y - iter.yOffset;
		}
		iter = iter.parentShape;
	}

	point.x = x;
	point.y = y;

	return point;
}

UIElement.prototype.getLocaleText = function(text) {
	var str = webappGetText(text);

	if(!str) {
		return text;
	}

	if(!this.locale) {
		this.locale = {text:str};
		this.needRelayout = true;
	}

	return str;
}

UIElement.prototype.getLocaleInputTips = function(text) {
	var str = webappGetText(text);

	return str ? str : text;
}

UIElement.prototype.setBgImage = function(src) {
	return this.setImage(UIElement.IMAGE_DEFAULT, src);
}

UIElement.prototype.setImage = function(type, src) {
	var me = this;
	var n = arguments.length;
	if(n < 2) {
		src = type;
		type = UIElement.IMAGE_DEFAULT;
	}
	else {
		type = type ? type : UIElement.IMAGE_DEFAULT;
	}
	var image = null;
	function onImageLoad(img) {
		me.postRedraw();
		return;
	}

	if(typeof src === "string") {
		image = WImage.create(src, onImageLoad);
	}
	else if(typeof src === "object") {
		if(src && src.image) {
			image = src;
		}
		else {
			image = WImage.createWithImage(src); 
		}
	}
	else if(typeof src === "number") {
		image = this.images["option_image_" + src];
	}
	else {
		image = WImage.create(src, onImageLoad);
	}

	this.images[type] = image;

	if(!image) {
		console.log("image is null:" + type + ":" + src);
	}

	return this;
}

UIElement.prototype.getHtmlImageByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}
	
	var image = this.images[type];
	return image ? image.getImage() : null;
}

UIElement.prototype.getImageByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}
	
	return this.images[type];
}

UIElement.prototype.getImageSrcByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}

	var image = this.images[type];
	return image ? image.getImageSrc() : "";
}

UIElement.prototype.getImageTypes = function() {
	var names = [];
	
	for(var key in this.images) {
		var value = this.images[key];
		if(key != "display") {
			names.push(key);
		}
	}

	return names;
}

UIElement.prototype.addEventNames = function(eventNames) {
	if(eventNames) {
		for(var i = 0; i < eventNames.length; i++) {
			var eName = eventNames[i];
			if(!this.events[eName]) {
				this.events[eName] = null;
			}
		}
	}

	return this;
}

UIElement.prototype.removeEventNames = function(eventNames) {
	if(eventNames) {
		for(var i = 0; i < eventNames.length; i++) {
			var eName = eventNames[i];
			delete this.events[eName];
		}
	}

	return this;
}

UIElement.prototype.getEventNames = function() {
	var eventNames = [];

	for(var key in this.events) {
		eventNames.push(key);
	}

	return eventNames;
}

UIElement.uidStart = 10000 + Math.floor(Math.random() * 10000);
UIElement.prototype.initUIElement= function(type) {
	this.initContainerShape(type);

	this.enable = true;
	this.visible = true;
	this.opacity = 1;
	this.vMargin = 0;
	this.hMargin = 0;
	this.xAttr		= UIElement.X_FIX_LEFT;
	this.yAttr		= UIElement.Y_FIX_TOP;
	this.widthAttr	= UIElement.WIDTH_FIX;
	this.heightAttr = UIElement.HEIGHT_FIX;
	this.name = type;
	this.events = {};
	this.uid = UIElement.uidStart++;
	this.runtimeVisible = true;

	this.images  = {};
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.addEventNames(["onClick"]);

	return this;
}

UIElement.prototype.updateLayoutParams = function() {
	var p = this.parentShape;

	if(!p) {
		return;
	}

	this.xParam = 1;
	this.yParam = 1;
	this.widthParam = 1;
	this.heightParam = 1;

	var wParent = p.getRelayoutWidth();
	var hParent = p.getRelayoutHeight();
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.xParam = this.left/wParent;
	}
	else if(this.xAttr === UIElement.X_FIX_RIGHT) {
		this.xParam = wParent - (this.left + this.w);
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.yParam = this.top/hParent;
	}
	else if(this.yAttr === UIElement.Y_FIX_BOTTOM) {
		this.yParam = hParent - (this.top + this.h);
	}

	if(this.widthAttr === UIElement.WIDTH_SCALE) {
		this.widthParam = this.w/wParent;
		this.widthScaleMin = this.w >> 1;
		this.widthScaleMax = this.w << 1;
	}

	if(this.heightAttr === UIElement.HEIGHT_SCALE) {
		this.heightParam = this.h/hParent;
		this.heightScaleMin = this.h >> 1;
		this.heightScaleMax = this.h << 1;
	}

	if(this.heightAttr === UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH) {
		this.heightParam = this.h/this.w;
	}

	return this;
}

UIElement.prototype.imagesToJson = function(o) {
	o.images = {};

	for(var key in this.images) {
		var value = this.images[key];
		if(key === "display") {
			o.images[key] = value;
		}
		else {
			var src = value.getImageSrc();
			src = this.getRelativePathOfURL(src);

			if(src) {
				o.images[key] = src;

				var sharpOffset = src.indexOf("#");
				if(sharpOffset > 0) {
					var realSrc = value.getRealImageSrc();
					realSrc = this.getRelativePathOfURL(realSrc);
				
					var url = src.substr(0, sharpOffset);	
					if(realSrc && realSrc.indexOf(src) < 0) {
						o.images["real-image-"+url] = decodeURI(realSrc);
					}
				}
			}
		}
	}

	return o;
}

UIElement.prototype.imagesFromJson = function(js) {
	if(js.images) {
		for(var key in js.images) {
			var value = js.images[key];
			if(key === "display") {
				this.images[key] = value;
			}
			else if(key.indexOf("real-image") !== 0) {
				this.setImage(key, value);
			}
		}
	}

	return;
}

UIElement.prototype.getEnable = function() {
	return this.enable;
}

UIElement.prototype.setEnable = function(enable) {
	this.enable = enable;

	return this;
}

UIElement.prototype.isEnable = function() {
	var iter = this;

	if(!this.isValid()) {
		return false;
	}

	while(iter != null) {
		if(!iter.enable) {
			return false;
		}

		iter = iter.parentShape;
	}

	return true;
}

UIElement.prototype.getVisible = function(visible) {
	return this.visible;
}

UIElement.prototype.setVisible = function(visible) {
	this.visible = visible;

	if(!visible) {
		if(this.animatingInfo) {
			UIElement.logWarning("hide animating element invisble.");
		}
	}

	return this;
}

UIElement.prototype.isVisible = function() {
	var iter = this;

	if(!this.isValid()) {
		return false;
	}

	while(iter != null) {
		if(!iter.visible) {
			return false;
		}

		iter = iter.parentShape;
	}

	return true;
}

UIElement.prototype.isFocused = function() {
	return this.parentShape && this.parentShape.targetShape == this;
}

UIElement.prototype.onShowHTML = function() {
	return;
}

UIElement.prototype.onHideHTML = function() {
	return;
}

UIElement.prototype.showHTML = function() {
	var i = 0;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		var child = this.children[i];
		child.showHTML();
	}

	this.onShowHTML();

	return;
}

UIElement.prototype.hideHTML = function() {
	var i = 0;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		var child = this.children[i];
		child.hideHTML();
	}

	this.onHideHTML();

	return;
}

UIElement.prototype.show = function() {
	return this.setVisible(true);
}

UIElement.prototype.hide = function() {
	return this.setVisible(false);
}

UIElement.prototype.beforeRelayout = function() {
}

UIElement.prototype.afterRelayout = function() {
}

UIElement.prototype.getPrevSibling = function() {
	if(!this.parentShape || this.parentShape.children.length < 2) {
		return null;
	}

	var i = 0;
	for(i = 0; i < this.parentShape.children.length; i++) {
		if(this.parentShape.children[i] === this) {
			break;
		}
	}

	return i > 0 ? this.parentShape.children[i-1] : null;
}

UIElement.prototype.setAutoScaleFontSize = function(value) {
	this.enableAutoScaleFontSize = value;

	return this;
}

UIElement.prototype.autoScaleFontSize = function(scale) {
	if(this.enableAutoScaleFontSize) {
		var fontSize = Math.round(this.style.fontSize * scale);
		
		fontSize = Math.min(fontSize, 36);
		fontSize = Math.max(fontSize, 12);
		this.style.setFontSize(fontSize);
	}

	return;
}


UIElement.prototype.getRelayoutWidth = function() {
	return this.getWidth();
}

UIElement.prototype.getRelayoutHeight = function() {
	return this.getHeight();
}

UIElement.prototype.relayout = function() {
	if(this.disableRelayout) {
		return;
	}
	
	var p = getParentShapeOfShape(this);
	if(!p || !p.isUIElement) {
		if(this.mode === Shape.MODE_EDITING) {
			this.setUserMovable(true);
			this.setUserResizable(true);
		}
	}

	if(this.isUIDevice) {
		this.setUserResizable(false);
	}

	if(!p) {
		this.relayoutChildren();
		return;
	}

	var w = 0;
	var h = 0;
	var x = 0;
	var y = 0;
	var xAttr = this.xAttr;
	var yAttr = this.yAttr;
	var wParent = p.getRelayoutWidth();
	var hParent = p.getRelayoutHeight();
	var hMargin = p.getHMargin();
	var vMargin = p.getVMargin();
	var wParentClient = wParent - hMargin - hMargin;
	var hParentClient = hParent - vMargin - vMargin;

	var bottom = this.top + this.h;
	var right = this.left + this.w

	this.beforeRelayout();

	switch(this.widthAttr) {
		case UIElement.WIDTH_SCALE: {
			w = wParent * this.widthParam;
			if(this.widthScaleMin && w < this.widthScaleMin) {
				if(this.pointerDown) {
					this.widthScaleMin = w;
				}
				else {
					w = this.widthScaleMin;
				}
			}
			if(this.widthScaleMax && w > this.widthScaleMax) {
				if(this.pointerDown) {
					this.widthScaleMax = w;
				}
				else {
					w = this.widthScaleMax;
				}
			}

			break;
		}
		case UIElement.WIDTH_FILL_PARENT: {
			w = wParentClient;
			this.left = hMargin;
			xAttr = UIElement.X_FIX_LEFT;
			break;
		}
		default: {
			w = this.w;
			break;
		}
	}

	switch(this.heightAttr) {
		case UIElement.HEIGHT_SCALE: {
			h = hParent * this.heightParam;
			if(this.heightScaleMin && h < this.heightScaleMin) {
				if(this.pointerDown) {
					this.heightScaleMin = h;
				}
				else {
					h = this.heightScaleMin;
				}
			}
			if(this.heightScaleMax && h > this.heightScaleMax) {
				if(this.pointerDown) {
					this.heightScaleMax = h;
				}
				else {
					h = this.heightScaleMax;
				}
			}

			break;
		}
		case UIElement.HEIGHT_FILL_PARENT: {
			h = hParentClient;
			this.top = vMargin;
			yAttr = UIElement.Y_FIX_TOP;
			break;
		}
		default: {
			h = this.h;
			break;
		}
	}

	switch(xAttr) {
		case UIElement.X_SCALE: {
			x = wParent * this.xParam;
			break;
		}
		case UIElement.X_FIX_RIGHT: {
			x = wParent - this.xParam - this.w;
			break;
		}
		case UIElement.X_CENTER_IN_PARENT: {
			x = (wParent - w) >> 1;
			break;
		}
		case UIElement.X_LEFT_IN_PARENT: {
			x = hMargin;
			break;
		}
		case UIElement.X_RIGHT_IN_PARENT: {
			x = wParent - w - hMargin;
			break;
		}
		default: {
			x = this.left;
			break;
		}
	}
		
	switch(yAttr) {
		case UIElement.Y_SCALE: {
			y = hParent * this.yParam;
			break;
		}
		case UIElement.Y_FIX_BOTTOM: {
			y = hParent - this.yParam - this.h;
			break;
		}
		case UIElement.Y_MIDDLE_IN_PARENT: {
			y = (hParent - h) >> 1;
			break;
		}
		case UIElement.Y_TOP_IN_PARENT: {
			y = vMargin;
			break;
		}
		case UIElement.Y_BOTTOM_IN_PARENT: {
			y = hParent - h - vMargin;
			break;
		}
		default: {
			y = this.top;
			break;
		}
	}
	
	if(this.widthAttr === UIElement.WIDTH_FILL_TO_PARENT_RIGHT) {
		w = wParent - x  - hMargin;
	}
			
	if(this.heightAttr === UIElement.HEIGHT_FILL_TO_PARENT_BOTTOM) {
		h = hParent - y - vMargin;
	}
	
	if(this.heightAttr === UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH) {
		h = w * this.heightParam;	
	}

	var oldW = this.w;

	this.w	= Math.round(w);
	this.h	= Math.round(h);
	this.setLeftTop(x, y);

	if(p.isUIElement) {
		if(this.mode === Shape.MODE_EDITING) {
			var win = this.getWindow();
			if(win && !win.isUIScene && !win.isUIDialog) {
				p.fixChildSize(this);
			}
		}
		p.fixChildPosition(this);
	}
	
	this.setSize(this.w, this.h);
	
	this.autoScaleFontSize(w/oldW);
	this.relayoutChildren();
	this.afterRelayout();
	this.setTextNeedRelayout(true);

	return;
}

UIElement.prototype.beforeRelayoutChild = function(shape) {
	return true;
}

UIElement.prototype.afterRelayoutChild = function(shape) {
	return true;
}


UIElement.prototype.relayoutChildren = function() {
	if(this.disableRelayout || !this.children) {
		return;
	}

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE || child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE) {
			continue;
		}

		if(this.beforeRelayoutChild(child)) {
			child.relayout();
		}
		this.afterRelayoutChild(child);
	}
	
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(!(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE || child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE)) {
			continue;
		}

		if(this.beforeRelayoutChild(child)) {
			child.relayout();
		}
		this.afterRelayoutChild(child);
	}

	return;
}

UIElement.prototype.getWindowManager = function() {
	var iter = this;

	while(iter != null && !iter.isUIWindowManager) {
		iter = iter.parentShape;
	}

	return iter;
}

UIElement.EVENT_STATUS_NONE = 0;
UIElement.EVENT_VSCROLL_HANDLED = 1;
UIElement.EVENT_HSCROLL_HANDLED = 2;

UIElement.lastEvent = {};
UIElement.lastEvent.element = null;
UIElement.lastEvent.status = UIElement.EVENT_STATUS_NONE;

UIElement.prototype.setLastEventStatus = function(status) {
	if(status) {
		UIElement.lastEvent.status |= status;
		UIElement.lastEvent.element = this;
	}
	else {
		UIElement.lastEvent.status = 0;
		UIElement.lastEvent.element = null;
	}

	return;
}

UIElement.prototype.getLastEventStatus = function() {
	return UIElement.lastEvent.status;
}

UIElement.prototype.getDevice = function() {
	var iter = this;

	while(iter != null && !iter.isUIDevice) {
		iter = iter.parentShape;
	}

	return iter;
}

UIElement.prototype.getDeviceConfig = function() {
	var windowManager = this.getWindowManager();
	if(windowManager) {
		return windowManager.getDeviceConfig();
	}

	return null;
}

UIElement.prototype.getTopWindow = function() {
	var wm = this.getWindowManager();

	return wm.getCurrentWindow();
}

UIElement.prototype.isTopWindow = function() {
	var win = this.getWindow();

	return win === this.getTopWindow();
}

UIElement.prototype.getWindow = function() {
	var iter = this;

	while(iter != null && !iter.isUIWindow) {
		iter = iter.parentShape;
	}

	return iter;
}

UIElement.prototype.getPositionInWindow = function() {
	var p = this.getAbsLeftTop();
	var anchor = this.anchor;

	if(anchor) {
		p.x += anchor.x * this.w;
		p.y += anchor.y * this.h;
	}

	return p;
}

UIElement.prototype.getAbsLeftTop = function() {
	var iter = this;
	var x = iter.left;
	var y = iter.top;

	while(iter != null && !iter.isUIWindow) {
		iter = iter.parentShape;
		if(iter.isUIWindow) {
			break;
		}

		x = x + iter.left;
		y = y + iter.top;
	}

	return {x:x, y:y};
}

UIElement.prototype.localToGlobal = function(point) {
	var p = this.getAbsLeftTop();

	p.x += point.x;
	p.y += point.y;

	return p;
}

UIElement.prototype.globalToLocal = function(point) {
	var p = this.getAbsLeftTop();

	p.x = point.x - p.x;
	p.y = point.y - p.y;

	return p;
}

UIElement.prototype.getWindowNames = function() {
	var manager = this.getWindowManager();
	if(manager) {
		return manager.getWindowNames();
	}

	return [];
}

UIElement.prototype.openScene = function(name, initData) {
	var wm = this.getWindowManager();
	setTimeout(function() {
		wm.openWindow(name, null, true, initData);
	}, 0);
}

UIElement.prototype.openWindow = function(name, onClose, closeCurrent, initData, options) {
	var manager = this.getWindowManager();
	if(manager) {
		return manager.openWindow(name, onClose, closeCurrent, initData, options);
	}

	return false;
}

UIElement.prototype.closeAllWindows = function() {
	var manager = this.getWindowManager();
	if(manager) {
		manager.closeAll();
	}

	return;
}

UIElement.prototype.backToHomeWin = function() {
	var manager = this.getWindowManager();
	if(manager) {
		manager.backToHomeWin();
	}

	return;
}

UIElement.prototype.closeWindow = function(retInfo, syncClose) {
	var win = this.getWindow();
	var manager = this.getWindowManager();

	if(manager && win) {
		if(manager.isWindowOpen(win)) {
			return manager.closeCurrentWindow(retInfo, syncClose);
		}
		else {
			console.log("Current Window Is Not Open.");
		}
	}

	return false;
}

UIElement.prototype.canBeComponent = function() {
	return true;
}

UIElement.prototype.isCreatingElement = function() {
	if(this.view && this.view.creatingShape === this) {
		return true;
	}

	return false;
}

UIElement.prototype.onScaleForDensityDone = function(sizeScale, lcdDensity) {
}

UIElement.prototype.setNotScaleForDensity = function(notScaleForDensity) {
	this.notScaleForDensity = notScaleForDensity;

	return;
}

UIElement.prototype.scaleForDensity = function(sizeScale, lcdDensity, recuresive) {
	if(!sizeScale || sizeScale === 1 || this.notScaleForDensity) {
		return;
	}

	if(this.widthAttr === UIElement.WIDTH_FIX) {
		this.w = Math.floor(this.w * sizeScale);
	}

	if(this.heightAttr === UIElement.HEIGHT_FIX) {
		this.h = this.h * sizeScale;
		if(this.h < 36 && (this.isUIButton || this.isUIProgressBar || this.isUIColorTile || this.isUIColorButton
			|| this.isUIEdit || this.isUIRadioBox || this.isUICheckBox || this.isUIWaitBar || this.isUISwitch)) {
			this.h = 40;
		}

		if(this.h < 50 && (this.isUIToolBar || this.isUIButtonGroup)) {
			this.h = 50;
		}

		if(this.hMin > this.h) {
			this.hMin = this.h;
		}
	}

	var isCreating = this.isCreatingElement();
	if(!isCreating && this.yAttr === UIElement.Y_FIX_TOP) {
		this.top = Math.floor(this.top * sizeScale);
	}

	if(!isCreating && this.xAttr === UIElement.X_FIX_LEFT) {
		this.left = Math.floor(this.left * sizeScale);
	}

	this.style.setFontSize(Math.floor(this.style.fontSize * sizeScale));

	if(this.itemHeight > 20) {
		this.itemHeight = Math.floor(this.itemHeight * sizeScale);
	}

	if(this.roundRadius) {
		this.roundRadius = Math.floor(this.roundRadius * sizeScale);
	}

	this.vMargin = Math.floor(this.vMargin * sizeScale);
	this.hMargin = Math.floor(this.hMargin * sizeScale);

	if(this.buttonHeight > 40) {
		this.buttonHeight = Math.floor(this.buttonHeight * sizeScale);
	}
	
	this.left = Math.floor(this.left);
	this.top = Math.floor(this.top);
	this.w = Math.round(this.w);
	this.h = Math.round(this.h);

	if(recuresive) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			iter.scaleForDensity(sizeScale, lcdDensity, true);
		}
	}

	if(this.isUIProgressBar) {
		var value = this.getValue();
		this.setValue(0);
		this.setValue(value);
	}

	this.onScaleForDensityDone(sizeScale, lcdDensity);

	return;
}

UIElement.prototype.onDeviceConfigChanged = function(oldConfig, newConfig) {
	return;
}

UIElement.prototype.fixImagePath = function(oldConfig, newConfig) {
	var oldVersion	= oldConfig.version;
	var oldPlatform = oldConfig.platform;
	var oldDensity	= oldConfig.lcdDensity;
	var newVersion	= newConfig.version;
	var newPlatform = newConfig.platform;
	var newDensity	= newConfig.lcdDensity;

	for(var key in this.images) {
		var value = this.images[key];
		if(key === "display") {
			continue;
		}
		
		var src = value.getImageSrc();
		if(src) {
//			src = src.replaceAll("/" + oldVersion + "/", "/" + newVersion + "/");
//			src = src.replaceAll("/" + oldPlatform + "/", "/" + newPlatform + "/");
			src = src.replaceAll("/" + oldDensity + "/", "/" + newDensity + "/");
			value.setImageSrc(src);
		}
	}

	return;
}

UIElement.prototype.scaleForCurrentDensity = function(value) {
	var config = this.getDeviceConfig();
	var lcdDensity = this.getDensitySizeByName(config ? config.lcdDensity : "hdpi");
	
	return value * (lcdDensity/160);
}

UIElement.prototype.getDensitySizeByName = function(density) {
	switch(density) {
		case "ldpi": {
			return 80;
		}
		case "mdpi": {
			return 160;
		}
		case "hdpi": {
			return 240;
		}
		case "xhdpi": {
			return 350;
		}
		case "xxhdpi": {
			return 450;
		}
		default: {
			console.log("not supported density: " + density);
		}
	}

	return 160;
}

UIElement.prototype.getSizeScale = function(oldDensity, newDensity) {
	var oldSize = this.getDensitySizeByName(oldDensity);
	var newSize = this.getDensitySizeByName(newDensity);

	var sizeScale = newSize/oldSize;

	return sizeScale;
}

UIElement.prototype.notifyDeviceConfigChanged = function(oldConfig, newConfig) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.notifyDeviceConfigChanged(oldConfig, newConfig);
	}

	this.fixImagePath(oldConfig, newConfig);
	this.onDeviceConfigChanged(oldConfig, newConfig);
	
	return;
}

UIElement.prototype.addMovementForVelocityTracker = function() {
	if(this.velocityTracker) {
		var p = {};
		p.x = this.getMoveAbsDeltaX();
		p.y = this.getMoveAbsDeltaY();

		var timeNs = Date.now() * 1000000;
		this.velocityTracker.addMovement(timeNs, p);
		delete date;
	}

	return;
}

UIElement.prototype.isUserMovable = function() {
	return this.userMovable && !this.isLocked();
}

UIElement.prototype.isUserResizable = function() {
	return this.userResizable;
}

UIElement.prototype.getEditorRect = function() {
	var rect = {};
	rect.x = this.left;
	rect.y = this.top;
	rect.w = this.w;
	rect.h = this.h;

	return rect;
}


UIElement.funcs = [];
UIElement.setAnimTimer = function(func, deltaTime) {
	return UIElement.setTimeout(func, deltaTime);	
}

UIElement.setTimeout = function(func, deltaTime) {
	deltaTime = deltaTime ? Math.max(deltaTime, 16) : 16;

	func.deltaTime = deltaTime;
	func.time = Date.now() + deltaTime;
	UIElement.funcs.push(func);

	function executeTimers() {
		var funcs = UIElement.funcs;

		var now = Date.now();
		var n = funcs.length;
		UIElement.funcs = [];

		for(var i = 0; i < n; i++) {
			var iter = funcs[i];
			if(iter.time <= now) {
				if(iter()) {
					iter.time = now + iter.deltaTime;
					UIElement.funcs.push(iter);
				}
			}
			else {
				UIElement.funcs.push(iter);
			}
		}

		funcs = null;
		if(UIElement.funcs.length) {
			UIElement.animTimerID = requestAnimFrame(executeTimers);
		}
		else {
			UIElement.animTimerID = 0;
		}
	}

	if(!UIElement.animTimerID) {
		UIElement.animTimerID = requestAnimFrame(executeTimers, 16);
	}

	return;
}

UIElement.getMainCanvas = function() {
	return CantkRT.getMainCanvas();
}

UIElement.getMainCanvasScale = function(force) {
	if(!UIElement.canvasScale || force) {
		var xScale = 1;
		var yScale = 1;
		UIElement.canvasScale = {};
		var mainCanvas = UIElement.getMainCanvas();
		
		if(mainCanvas.style.width && mainCanvas.style.height) {
			xScale = mainCanvas.width/parseFloat(mainCanvas.style.width);
			yScale = mainCanvas.height/parseFloat(mainCanvas.style.height);
		}

		UIElement.canvasScale.x = xScale;
		UIElement.canvasScale.y = yScale;
	}

	return UIElement.canvasScale;
}

UIElement.prototype.isFullscreenMode = function() {
	return cantkIsFullscreen();
}

UIElement.prototype.setFlipX = function(flipX) {
	this.flipX = flipX;

	return this;
}

UIElement.prototype.setFlipY = function(flipY) {
	this.flipY = flipY;

	return this;
}

UIElement.prototype.getFlipX = function() {
	return this.flipX;
}

UIElement.prototype.getFlipY = function() {
	return this.flipY;
}

UIElement.prototype.requestFullscreen = function(onDone) {
	if(!isMobile()) {
		if(onDone) {
			onDone(false);
		}
		console.log("UIElement.requestFullScreen Rejected(not mobile)");
	}
	else {
		if(!cantkRequestFullscreen(onDone)) {
			onDone(false);
		}
		console.log("UIElement.requestFullScreen");
	}

	return;
}

UIElement.prototype.pickFiles = function(contentType, onDone) {
	return showFileDialog(contentType, true, false, onDone);
}

UIElement.prototype.pickFile = function(contentType, onDone) {
	if(!window.FileReader) {
		return false;
	}

	showFileDialog(contentType, false, true, function(files) {
		var file = files[0];
		if (file) {
			var reader  = new FileReader();
			reader.readAsDataURL(file);
			reader.onloadend = function () {
				if(onDone) {
					onDone(file, reader.result);
				}
				reader = null;
			}
		}
	});

	return true;
}

UIElement.prototype.pickAudio = function(onDone) {
	return this.pickFile("audio/*", onDone);
}

UIElement.prototype.pickImage = function(onDone) {
	return this.pickFile("image/*", onDone);
}

UIElement.fixArtTextStyle = function(style) {
	style.fontSize = style.fontSize ? style.fontSize : 16;
	style.imageBorder = style.imageBorder? style.imageBorder: 10;
	style.textAlignH = style.textAlignH ? style.textAlignH : "left";
	style.startColor = style.startColor ? style.startColor : "Green";
	style.endColor = style.endColor ? style.endColor : "Green";
	style.lineWidth = style.lineWidth ? style.lineWidth : 0;
	style.lineColor = style.lineColor ? style.lineColor : "Black";
	style.shadowColor = style.shadowColor ? style.shadowColor : "Black";
	style.shadowBlur = style.shadowBlur ? style.shadowBlur : 0;
	style.shadowOffsetX = style.shadowOffsetX ? style.shadowOffsetX : 0;
	style.shadowOffsetY = style.shadowOffsetY ? style.shadowOffsetY : 0;
	
	return style;
}

UIElement.createArtTextImage = function(text, style, bgColor) {
	UIElement.fixArtTextStyle(style);

	if(!text) {
		return null;
	}

	var w = 300;
	var h = 80;
	var border = style.imageBorder;
	var fontSize = style.fontSize;
	var fontFamily = style.fontFamily;
	var textAlign = style.textAlignH;
	var monospace = style.monospace;
	var tcanvas = cantkGetTempCanvas(w, h);
	var ctx = tcanvas.getContext("2d");
	ctx.clearRect(0, 0, w, h);

	var x = w >> 1;
	var y = h >> 1;
	var fontStr = "";
	var n = text.length;
	if(style.textB) {
		fontStr += "Bold ";
	}

	if(style.textI) {
		fontStr += "Italic ";
	}

	fontStr += fontSize + "pt '" + fontFamily + "'";
	ctx.font = fontStr;
	ctx.textBaseline = "middle";
	ctx.textAlign = "center";

	switch(textAlign) {
		case 'left': {
			x = border;
			ctx.textAlign = "left";
			break;
		}
		case 'right': {
			x = w-border;
			ctx.textAlign = "right";
			break;
		}
		default:break;
	}

	if(monospace) {
		var cw = 0;
		for(var i = 0; i < n; i++) {
			var c = text[i];
			var charW = ctx.measureText(c).width;
			if(charW > cw) {
				cw = charW;
			}
		}
		cw = cw + 4;
		w = n * cw;
	}
	else {
		var textW = ctx.measureText(text).width;
		w = textW + border * 2;
	}
	h = style.fontSize + 2*(Math.abs(style.shadowOffsetY) + style.shadowOffsetY + border);
	tcanvas.width = w;
	tcanvas.height = h;

	if(bgColor) {
		ctx.fillStyle = bgColor;
		ctx.fillRect(0, 0, w, h);
	}

	ctx.font = fontStr;
	ctx.textBaseline = "middle";
	ctx.textAlign = "center";
	if(style.useTexture && style.texture) {
		var wimage = WImage.create(style.texture);
		var image = wimage.getImage();
		if(image) {
			var pattern = ctx.createPattern(image, "repeat");
			ctx.fillStyle = pattern;
		}
	}
	else {
		if(style.startColor != style.endColor) {
			var grd = ctx.createLinearGradient(0,0,0,h);
			if(style.horizonalGradient) {
				grd = ctx.createLinearGradient(0,0,w,0);
			}
			grd.addColorStop(0, style.startColor);
			grd.addColorStop(1, style.endColor);
			ctx.fillStyle = grd;
		}
		else {
			ctx.fillStyle = style.startColor;
		}
	}

	if(style.shadowBlur) {
		ctx.shadowOffsetX = style.shadowOffsetX;
		ctx.shadowOffsetY = style.shadowOffsetY;
		ctx.shadowBlur = style.shadowBlur;
		ctx.shadowColor = style.shadowColor;
	}

	x = w >> 1;
	y = h >> 1;
	ctx.lineWidth = style.lineWidth;
	ctx.strokeStyle = style.lineColor;

	if(monospace) {
		x = 0;
		var hcw = cw >> 1;
		var n = text.length;
		ctx.textAlign = "center";
		for(var i = 0; i < n; i++) {
			x = i * cw + hcw;
			var c = text[i];
			ctx.fillText(c, x, y);
			ctx.strokeText(c, x, y);
		}
	}
	else {
		ctx.fillText(text, x, y);
		if(ctx.lineWidth) {
			ctx.strokeText(text, x, y);
		}
	}

	var url = tcanvas.toDataURL();

	return url;
}

ShapeFactoryGet().addShapeCreator(new UIGroupCreator(200, 200, null));

UIElement.prototype.timeScaleIsZero = function() {
	return Math.abs(this.getTimeScale()) < 0.00001;
}

UIElement.prototype.getTimeScale = function() {
	return this.win.getTimeScale();
}

UIElement.prototype.scaleTime = function(t) {
	return this.win.getTimeScale() * t;
}

UIElement.prototype.setTimeScale = function(timeScale) {
	this.win.setTimeScale(timeScale);

	return this;
}

UIElement.prototype.getAppInfo = function() {
	var metaInfo = this.view.getMetaInfo();

	return metaInfo.general;
}

UIElement.logNotice = function(str) {
	console.log("%cNotice: " + str, "color: green; font-weight: bold");
}

UIElement.logWarning = function(str) {
	console.log("%cWarning: " + str, "color: red; font-weight: bold");
}

UIElement.logError = function(str, e) {
	console.log("%cWarning: " + str + "(" + e.message + ")\n" + e.stack, "color: red; font-weight: bold");
}

UIElement.prototype.isPointIn = function(canvas, point) {
	var ret = false;

	if(canvas) {
		canvas.beginPath();
		canvas.rect(0, 0, this.w, this.h);
		canvas.closePath();

		ret = canvas.isPointInPath(point.x, point.y);
	}
	else {
		ret = isPointInRect(point, this);	
	}

	return ret;
}

UIElement.prototype.pInPolygon = function(points, testx, testy) {
	var c = false;

	for (var i = 0, j = points.length-1; i < points.length; j = i++) {
		if (((points[i].y > testy) != (points[j].y > testy)) &&
			(testx < (points[j].x-points[i].x) * (testy-points[i].y) / (points[j].y-points[i].y) + points[i].x))
			c = !c;
	}

	return c;
}

UIElement.prototype.isPointInMatrix = function(rect, point, applyTransform) {
	var x = rect.x,
		y = rect.y,
		w = rect.w,
		h = rect.h,
		p1 = {x: x, 	y: y},
		p2 = {x: x+w, 	y: y},
		p3 = {x: x+w, 	y: y+h},
		p4 = {x: x, 	y: y+h},
		matrix = Matrix2D.identity;

	matrix.beginPath = function() {};
	matrix.clip = function() {};
	matrix.rect = function() {};
	matrix.arc  = function() {};

	try {
		applyTransform.call(this, matrix);
	}
	catch(e) {
		console.debug('applyTransform catch err', err);
	}

	var p11 = matrix.transformPoint(p1.x, p1.y),
		p21 = matrix.transformPoint(p2.x, p2.y),
		p31 = matrix.transformPoint(p3.x, p3.y),
		p41 = matrix.transformPoint(p4.x, p4.y),
		pps = [p11, p21, p31, p41];

	matrix.identity();

	return this.pInPolygon(pps, point.x, point.y);
}

UIElement.prototype.setImageDisplay = function(display) {
	this.images.display = display;

	return this;
}

UIElement.prototype.getPointerDeviceType = function() {
	return WEventsManager.getInstance().getPointerDeviceType();
}

function UIElementCreator(type) {
	var args = [type, "ui-element", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIElement();
		return g.initUIElement(this.type);
	}
	
	return;
}

UIElement.prototype.clearAssetsCache = function(check) {
	this.getWindowManager().clearAssetsCache(check);

	return this;
}

UIElement.prototype.loadAssets = function(winList, onProgress) {
	ResLoader.reset();
	this.getWindowManager().loadAssets(winList, onProgress);

	return this;
}

ShapeFactoryGet().addShapeCreator(new UIElementCreator("ui-element"));

UIElement.audioAssets = ["soundURL"];
UIElement.imagesAssets = ["textureURL"];
UIElement.jsonAssets = ["textureJsonURL", "skeletonJsonURL", "soundURL", "dataURL"];

UIElement.assets = UIElement.audioAssets.concat(UIElement.jsonAssets, UIElement.imagesAssets);


/**
 * @class UIElement 
 * 所有组件的基类，它通常是一个矩形区域，有一定的外观形状，并能处理用户事件。
 */

/**
 * @property {String} type
 * 控件的类型名称。如按钮的类型为"ui-button"，请不要修改。
 */

/**
 * @property {String} name
 * 控件的名称。
 */

/**
 * @property {Array} animations 
 * 在Studio的动画编辑器中为控件添加的动画列表，通过动画名字可以获取对应的动画参数。
 *
 *     @example small frame
 *     var fadeIn = this.animations["fade-in"];
 *     console.log(JSON.stringify(fadeIn));
 *
 */

/**
 * @property {UIElement} win
 * 控件所在的窗口或场景。
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */
Object.defineProperty(UIElement.prototype, "win", {
	get: function () {
		if(!this._win) {
			this._win = this.getWindow();
		}

		return this._win;
	},
	set: function (value) {
		console.log("Warning: can not set window.");
	},
	enumerable: false,
	configurable: true
});

/**
 * @property {Number} x
 * 在父控件中的X坐标。
 */

/**
 * @property {Number} y
 * 在父控件中的Y坐标。
 */

/**
 * @property {Number} anchorX
 * 控件的X锚点。
 */

/**
 * @property {Number} anchorY
 * 控件的Y锚点。
 */

/**
 * @property {Number} width
 * 控件的宽度。
 */

/**
 * @property {Number} height 
 * 控件的高度。
 */

/**
 * @property {Number} scaleX 
 * 控件的X方向的缩放系数。
 */

/**
 * @property {Number} scaleY
 * 控件的Y方向的缩放系数。
 */

/**
 * @property {Number} rotation 
 * 控件的旋转角度(弧度)。
 */

/**
 * @property {Number} opacity
 * 控件的不透明度(0-1)。
 */

/**
 * @property {Boolean} flipX 
 * 控件是否X方向翻转。
 */

/**
 * @property {Boolean} flipY 
 * 控件是否Y方向翻转。
 */

/**
 * @property {Boolean} visible
 * 控件是否对用户可见。
 */

/**
 * @property {Boolean} enable 
 * 控件是否接受用户事件（对于刚体来说，同时会决定刚体是否参与物理世界的运行）。
 */

/**
 * @property {Boolean} pointerDown
 * 指针是否按下。
 */
//==============================================================================

/**
 * @method setPosition
 * 设置控件的位置。
 * @param {Number} x 在父控件上的X坐标。
 * @param {Number} y 在父控件上的Y坐标。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */

/**
 * @method setAnchor
 * 设置控件的锚点。
 * @param {Number} x 0到1表示从控件左边到右边的位置。比如0.5表示中间。
 * @param {Number} y 0到1表示从控件顶部到底部的位置。比如0.5表示中间。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：把物体移动到场景的中间位置。
 *
 *     @example small frame
 *     var win = this.win;
 *     var ball = win.find("ball");
 *     ball.setAnchor(0.5, 0.5);
 *     ball.setPosition(win.width>>1, win.height>>1);
 */

/**
 * @method setPivot
 * 设置控件的旋转轴点(不适用于刚体)。
 * @param {Number} x 0到1表示从控件左边到右边的位置。比如0.5表示中间。
 * @param {Number} y 0到1表示从控件顶部到底部的位置。比如0.5表示中间。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setName
 * 设置控件的名称。
 * @param {String} name 名称。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setOpacity
 * 设置控件的不透明度。
 * @param {Number} opacity 透明度，取值范围(0~1)。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method forEach
 * 遍历所有子控件，callback返回true时停止遍历。
 * @param {Function} callback 函数原型 function(child) {}
 *
 */

/**
 * @method getTarget
 * 获取处理指针事件的子控件。通常用来判断玩家点击了哪个控件。
 * @return {UIElement} 处理指针事件的子控件。
 *
 */

/**
 * @method getOpacity
 * 获取控件的不透明度。
 * @return {Number} 返回对象的不透明度。
 *
 */

/**
 * @method setValue
 * 设置控件的值，不同控件的值有不同的意义，如进度条的值时进度，按钮的值就是上面的文本。
 * @param {Number} value 新的值。
 * @param {Boolean} notify 是否触发onChanged事件。
 * @param {Boolean} animation 是否启用动画(只能用于数值的值)。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：设置进度条的进度。
 *
 *     @example small frame
 *     var win = this.win;
 *     var progressbar = win.find("progressbar");
 *     progressbar.setValue(80, false, true);
 */

/**
 * @method getValue
 * 获取控件的值。
 * @return {Number} 返回对象的值。
 *
 */


/**
 * @method addValue 
 * 在当前的数值上加上一个增量(只能用于数值的值)。
 * @param {Number} delta 增量，可以为负数。
 * @param {Boolean} notify 是否触发onChanged事件。
 * @param {Boolean} animation 是否启用动画。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：设置进度条的进度。
 *
 *     @example small frame
 *     var win = this.win;
 *     var progressbar = win.find("progressbar");
 *     progressbar.addValue(20, false, true);
 */

/**
 * @method setValueOf
 * 设置子控件的值。
 * @param {String} name 子控件的名字。
 * @param {Number} value 值。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getValueOf
 * 获取子控件的值。
 * @param {String} name 子控件的名字。
 * @return {Number} 返回对象的值。
 *
 */

/**
 * @method setScale
 * 设置控件的缩放比例。
 * @param {Number} x x方向的缩放比例。
 * @param {Number} y y方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 * 注意：缩放比例不改变控件额实际大小和刚体碰撞检测的区域。
 */

/**
 * @method setScaleX
 * 设置控件x方向的缩放比例。
 * @param {Number} scale x方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setScaleY
 * 设置控件y方向的缩放比例。
 * @param {Number} scale y方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getScaleX
 * 获取控件x方向的缩放比例。
 * @return {Number} x方向的缩放比例。
 *
 */

/**
 * @method getScaleY
 * 获取控件y方向的缩放比例。
 * @return {Number} y方向的缩放比例。
 *
 */

/**
 * @method setSize
 * 设置控件的位置。
 * @param {Number} w 控件的宽度。
 * @param {Number} h 控件的高度。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setSize(100, 100);
 */

/**
 * @method setText
 * 设置控件的文本内容，如控件上的文字。
 * @param {String} text 文本内容
 * @param {Boolean} notify 是否触发onChanged事件。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getText
 * 获取控件的文本内容，如控件上的文字。
 * @return {String} 文本内容。
 */

/**
 * @method getParent
 * 获取控件的父控件。
 * @return {UIElement} 父控件。
 */

/**
 * @method find
 * 按名称查找子控件。
 * @param {String} name 子控件的名字。
 * @param {Boolean} recursive 是否递归查找。
 * @return {UIElement} 返回子控件。
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */

/**
 * @method findChildByPoint
 * 按点击位置查找子控件。
 * @param {Point} point 相对于当前控件左上角的坐标。
 * @param {Boolean} recursive 是否递归查找。
 * @param {Function} checkFunc 回调函数用于检查是否是需要的控件。
 * @return {UIElement} 如果找到子控件返回子控件，否者返回对象本身。
 *
 *     @example small frame
 *     var targetElement = this.findChildByPoint(point, true, function(child) {
 *         //Skip dragger self
 *         return child !== dragger;
 *     });
 */

/**
 * @method isAnimating
 * 判断animate是否完成。
 * @return {Boolean}
 */

/**
 * @method getPointerDeviceType
 * 获取指针输入设备的类型。
 * @return {String} "pointer"表示指针设备， "touch"表示触屏， "mouse"表示鼠标。
 */

/**
 * @method animate
 * 让控件动起来。
 * @param {AnimationConfig} config 动画配置信息或用动画编辑器创建的动画的名称。
 * @param {Function} onDone (可选) 完成时的回调函数。
 * @param {Function} onStep (可选) 每一步的回调函数。
 *
 * 让控件从x=100，移动到x=300：
 *
 *     @example small frame
 *     this.animate({xStart:100, xEnd:300});
 *
 * 让控件从当前位置移动到x=300：
 * 
 *     @example small frame
 *     this.animate({x:300});
 * 
 * 让控件在x=100和300之间往返运动：
 *     
 *     @example small frame
 *     var toLeft ={xStart:100, xEnd:300};
 *     var toRight = {xEnd:100, xStart:300}
 *     toLeft.next = toRight;
 *     toRight.next = toLeft;
 *     this.animate(toLeft);
 *
 * 完成时播放另外一个动画：
 *     
 *     @example small frame
 *     var me = this;
 *     var win = this.getWindow();
 *     var tree = win.find("tree");
 *     var config = {xStart:100, xEnd:300};
 *     config.onDone = function() {
 *         this.animate({xEnd:config.xStart, xStart:config.xEnd});
 *     }
 *     tree.animate(config);
 *
 * 如果需要从一个状态变化到另外一个状态，请用Start/End方式，如果从当前的状态变化到另外一个状态，直接指定它的值就行了。
 */

/**
 * @method stopAnimation
 * 停止animate开启的动画。
 * @param {Boolean} callOnDone 是否调用动画结束的回调函数。
 */

/**
 * @method postRedraw
 * 请求系统重画控件。
 * @param {Rect} rect 要求更新区域，一般为null。
 */

/**
 * @method addChildWithJson
 * 通过json数据创建一个控件，并作为子控件加入当前控件。(推荐使用dupChild来动态创建对象)。
 * @param {Object} json JSON数据
 * @param {Number} index zIndex
 * @return {UIElement} 返回子控件。
 * 
 *     @example small frame
 *     var win = this.getWindow();
 *     
 *     var json = {
 *         "type": "ui-button",
 *         "name": "ui-button2-general",
 *         "w": 200,
 *         "h": 69,
 *         "x": 209,
 *         "y": 155,
 *         "text": "ok",   
 *         "images": {
 *             "display": 2,
 *             "active_bg": "drawapp8/images/common/buttons/green_button_active.png",
 *             "normal_bg": "drawapp8/images/common/buttons/green_button.png",
 *             "disable_bg": "drawapp8/images/common/buttons/green_button.png"
 *         }
 *     }
 *     
 *     var button = win.addChildWithJson(json, 0);
 */

/**
 * @method addChild
 * 加入控件到当前控件中。配合clone函数使用。
 * @param {UIElement} child 要加入的控件。
 * @param {Number} index zIndex
 * @return {UIElement} 返回子控件。
 */

/**
 * @method clone
 * 克隆当前控件。clone的对象是游离的，需要调用addChild加入到某个控件中。
 * @return {UIElement} 返回新控件。
 */

/**
 * @method remove 
 * 移除从父控件中当前控件。
 * @param {Boolean} destroyIt 移除时是否销毁控件。如果后面还会把它加入其它控件就不要销毁，否则销毁。
 * @param {Boolean} syncExec 是否同步执行。如果在当前控件的事件中执行，请使用异步执行。
 */

/**
 * @method dupChild
 * 复制指定的子控件，并加入当前控件中。
 * @param {String} name 子控件的名称。
 * @param {Number} index 新控件的zIndex
 * @return {UIElement} 返回新控件。
 * 
 * 简单用法
 *
 *     @example small frame
 *     var newImage = this.dupChild("image");
 *     newImage.setPosition(10, 10);
 *
 *     复制子对象，然后移到其它控件中。
 *
 *     @example small frame
 *     var win = this.getWindow();
 *     
 *     var newImage = win.dupChild("image");
 *     newImage.remove(false, true);
 *     newImage.setPosition(0, 0);
 *     win.find("ball").addChild(newImage);
 */

/**
 * @method getWindow
 * 获取当前控件所在的窗口/场景。可以直接使用属性win代替。
 * 这是一个很常用的函数，你需要通过这个函数得到窗口对象，然后通过窗口的find函数去找窗口上的其它控件。
 * @return {UIWindow} 当前控件所在的窗口/场景。
 */

/**
 * @method getTopWindow
 * 获取当前最上层的窗口(普通窗口/对话框/场景)。
 * @return {UIWindow} 当前最上层的窗口。
 */

/**
 * @method openWindow 
 * 打开新窗口。目前有三种窗口：普通窗口，游戏场景和对话框。
 * @param {String} name 新窗口的名称。
 * @param {Function} onWindowClose onWindowClose(retInfo) (可选) 新窗口关闭时的回调函数。
 * @param {Boolean} closeCurrent (可选) 打开新窗口时是否关闭当前窗口。
 * @param {Object} initData (可选) 传递给新窗口的数据, 作为参数传递给新窗口的onOpen/onBeforeOpen事件。
 * @param {Object} options (可选) 其它参数。options.closeOldIfOpened 如果目标窗口已经打开，关闭它并重新打开。options.openNewIfOpened 如果目标窗口已经打开，打开新一个新窗口打开。
 *
 *     @example small frame
 *     this.openWindow("win-bonus",  function (retInfo) {console.log("window closed.");});
 */

/**
 * @method openScene
 * 本函数是对openWindow的包装。打开当前场景相当于重置当前场景，可以实现重玩的功能。
 * @param {String} name 新场景的名称。打开当前场景相当于重置当前场景，可以实现重玩的功能。
 * @param {Object} initData 传递给新窗口的数据, 作为参数传递给新窗口的onOpen/onBeforeOpen事件。
 */

/**
 * @method closeWindow
 * 关闭当前窗口。
 * @param {Object} retInfo 如果openWindow时指定了onWindowClose回调函数，retInfo会作为onWindowClose回调函数的参数。
 *
 *     @example small frame
 *     var retCode = 0;
 *     this.closeWindow(retCode);
 *
 */

/**
 * @method closeAllWindows 
 * 关闭所有打开的窗口。
 *
 */

/**
 * @method setFillColor
 * 设置控件的填充颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setLineColor
 * 设置控件的线条颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setTextColor
 * 设置控件的文本颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getFillColor
 * 获取控件的填充颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method getLineColor
 * 获取控件的线条颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method getTextColor
 * 获取控件的文本颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method setImage
 * 设置控件的图片。
 * @param {String} type (可选, 缺省为背景图片)。不同的控件支持的type不一样，请参控具体的控件文档。
 * @param {Object} src 可以是图片的URL，Image对象，WImage对象或备用图片的索引。
 * @return {UIElement} 返回控件本身。
 *
 * 把图片1设置为当前的图片(请在IDE中预先设置控件的图片1)。
 *
 *     @example small frame
 *     this.win.find("image").setImage(1);
 *
 * 设置按钮的正常和指针按下的图片：
 *
 *     @example small frame
 *     this.setImage(UIElement.IMAGE_NORMAL, 0);
 *     this.setImage(UIElement.IMAGE_ACTIVE, 1);
 *
 */

/**
 * @method getImageByType
 * 获取控件的图片
 * @param {String} type 不同的控件支持的type不一样，请参控具体的控件文档。
 * @return {WImage} 图片
 *
 * 可以通过索引取到备用图片：
 *
 *     @example small frame
 *     var image = this.getImageByType(0);
 *
 */

/**
 * @method getImageSrcByType
 * 获取控件的图片
 * @param {String} type 不同的控件支持的type不一样，请参控具体的控件文档。
 * @return {String} 图片SRC
 * 可以通过索引取到备用图片：
 *
 *     @example small frame
 *     var src = this.getImageSrcByType(0);
 */

/**
 * @method setTimeScale
 * 设置时间缩放系数，让游戏时间变快或变慢。
 * @param {Number} timeScale 时间缩放系数，0暂停，(0-1)变慢，1正常，大于1表示变快。
 * @return {UIElement} 返回控件本身。
 *
 * 暂停游戏：
 *
 *     @example small frame
 *     this.setTimeScale(0);
 */

/**
 * @method playSoundEffect
 * 播放音效。请先放一个音效控件到场景中，在音效控件的特有属性中添加音频文件。
 * 建议使用代码产生器来产生播放音效的代码。
 * @param {String} name 音效文件名，不用包含路径。
 * @param {Function} onDone (可选) 播放音效完成后的回调函数。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method playSoundMusic
 * 播放背景音乐。请先放一个背景音乐控件到场景中，在背景音乐控件的特有属性中添加音频文件。
 * 建议使用代码产生器来产生播放背景音乐的代码。
 * @param {String} name 背景音乐文件名，不用包含路径。
 * @param {Function} onDone (可选) 播放背景音乐完成后的回调函数。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method stopSoundEffect
 * 停止播放音效。
 * @param {String} name (可选) 音效文件名，不用包含路径。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method stopSoundMusic
 * 停止播放背景音乐。
 * @param {String} name (可选) 音乐文件名，不用包含路径。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundEffectVolume
 * 设置音效的音量。
 * @param {Number} volume 音量，范围0到1。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundMusicVolume
 * 设置音乐的音量。
 * @param {Number} volume 音量，范围0到1。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundEnable
 * 开启/禁止播放音效和背景音乐。
 * @param {Boolean} value 开启/禁止播放音效和背景音乐。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getSoundEnable
 * 获取处于音效和背景音乐是否开启的状态。
 * @return {Boolean} 音效和背景音乐是否开启。
 */

/**
 * @method getSoundMusicEnable
 * 获取背景音乐是否处于开启的状态。
 * @return {Boolean} 播放背景音乐是否开启。
 */

/**
 * @method getSoundEffectEnable
 * 获取音效是否处于开启的状态。
 * @return {Boolean} 播放音效是否开启。
 */

/**
 * @method getPointerPosition
 * 获取指针(Mouse/Touch)在窗口(场景)中的位置。
 * @return {Point} 指针(Mouse/Touch)的位置。 
 */

/**
 * @method setSoundEffectsEnable
 * 开启/禁止播放音效。
 * @param {Boolean} value 开启/禁止播放音效。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundMusicEnable
 * 开启/禁止播放背景音乐。
 * @param {Boolean} value 开启/禁止播放背景音乐。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getAppInfo
 * 获取游戏APP的信息
 * @return {Object} APP信息
 *
 * APP信息示例： 
 *
 *     @example small frame
 *     {
 *       "appid":"com.tangide.demo",
 *       "appversion":"1.0.0",
 *       "appname":"Demo",
 *       "appdesc":"Demo",
 *       "gapversion":"1.0",
 *       "screenscale":"fix-width",
 *       "orientation":"portrait",
 *       "developer":"Unkown <unkown@tangide.com>",
 *       "appIcon":"/drawapp8/images/appicons/96.png",
 *       "screenShot1":"",
 *       "screenShot2":"",
 *       "screenShot3":""
 *     }
 */

/**
 * @method getChild
 * 获取指定位置的子控件。
 * @param {Number} index 子控件的索引。
 * @return {UIElement} 返回子控件。
 */

/**
 * @method getChildrenNr
 * 获取子控件的个数。
 * @return {Number} 返回子控件的个数。
 */

/**
 * @method setClipCircle
 * 设置控件的圆形裁剪区域。
 * @param {Number} x
 * @param {Number} y
 * @param {Number} r
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setClipRect
 * 设置控件的矩形裁剪区域。
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 * @return {UIElement} 返回控件本身。
 *
 * 任意形状裁剪请重载onClip：
 *
 *     @example small frame
 *     var el = this.getWindow().find("el");
 *     
 *     el.onClip = function(ctx2d) {
 *         ctx2d.beginPath();
 *         ctx2d.moveTo(0, 0);
 *         ctx2d.lineTo(100, 100);
 *         ctx2d.lineTo(100, 200);
 *         ctx2d.closePath();
 *         ctx2d.clip();
 *     }
 */

/**
 * @method setRotation
 * 设置控件的旋转角度。
 * @param {Number} rotation 旋转的角度，单位是弧度。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setFlipX
 * 设置是否水平翻转。
 * @param {Boolean} flipX 是否水平翻转。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setFlipY
 * 设置是否垂直翻转。
 * @param {Boolean} flipY 是否垂直翻转。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getPositionInWindow
 * 返回控件在窗口里的位置。
 * @return {Point} 位置信息。
 *
 */

/**
 * @method localToGlobal
 * 把控件内的坐标转换成窗口内的坐标。
 * @param {Point} point 控件内的坐标。
 * @return {Point} 窗口内的坐标。 
 *
 */

/**
 * @method globalToLocal 
 * 把窗口内的坐标换成控件内的坐标。
 * @param {Point} point 窗口内的坐标。
 * @return {Point} 控件内的坐标。 
 *
 */

/**
 * @method getVisible
 * 控件是否可见。
 * @return {Boolean} 是否可见
 *
 */

/**
 * @method setVisible
 * 显示/隐藏控件。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setAnchorX
 * 设置控件的横向锚点。
 * @param {Number} x （范围0-1）。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setAnchorY
 * 设置控件的纵向锚点。
 * @param {Number} y （范围0-1）。
 * @return {UIElement} 返回控件本身
 *
 */

/**
 * @method relayout
 * 重新布局控件。
 *
 */

/**
 * @method removeChild
 * 删除指定的子控件，如果destroyIt为真，同时销毁它。
 * @param {UIElement} child 子控件对象。
 * @param {Boolean} destroyIt 是否同时销毁child对象。
 * @param {Boolean} sync 是否同步执行，缺省异步执行。
 * @return {UIElement} 返回控件本身。
 * 
 */

/**
 * @method removeChildren
 * 删除全部子控件。
 * @return {UIElement} 返回控件本身。
 * 
 */

/**
 * @method setEnable
 * 启用/禁用控件，不同的控件的表现有不同的意义，如UITimer被禁用时不触发onTimer事件，UIGSensor被禁用时不上报重力感应信息。
 * @param {Boolean} enable 是否启用控件。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setZIndex
 * 设置控件在父控件中的位置序数。
 * @param {Number} z 位置序数。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getZIndex
 * 获取控件在父控件中的位置序数。
 * @return {Number} 返回位置序数。
 *
 */

/**
 * @method pickImage 
 * 从当前系统中选择一张图片，返回file对象和DataURL。
 * @param {Function} onDone(file, dataURL) 选图成功后的回调函数。
 * @return 是否支持从本地读取图片。
 *
 * 选取图片:
 *
 *     @example small frame
 *     var image = this.getWindow().find("image");
 *     this.pickImage(function(name, url) {
 *         image.setValue(url);
 *         image.postRedraw();
 *     });
 *
 */

/**
 * @event onClick
 * 点击事件。事件处理函数返回true时事件终止传播(父控件不再处理)。
 * @param {Point} point 点击的位置。
 */

/**
 * @event onUpdateTransform
 * 绘制前事件。
 * @param {Object} canvas HTMLCanvasContext2d
 *
 * 实现按下时放大的效果：
 *
 *     @example small frame
 *     this.setScale(this.pointerDown ? 1.1 : 1);
 */

/**
 * @event onInit
 * 初始化事件。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 */

/**
 * @event onPointerDown
 * Pointer Down事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */

/**
 * @event onPointerMove
 * Pointer Move事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */

/**
 * @event onPointerUp
 * Pointer Up事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */


/**
 * @method beforePaint
 *
 * 本函数在控件绘制前执行(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var ball = this.find("ball");
 *     
 *     ball.beforePaint = function(canvas2dCtx) {
 *         canvas2dCtx.beginPath();
 *         canvas2dCtx.moveTo(0, 0);
 *         canvas2dCtx.lineTo(this.w, this.h);
 *         canvas2dCtx.lineWidth = 2;
 *         canvas2dCtx.strokeStyle = "red";
 *         canvas2dCtx.stroke();
 *     }
 *     
 *
 */

/**
 * @method afterPaint
 *
 * 本函数在控件绘制后执行(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var ball = this.find("ball");
 *     
 *     ball.afterPaint = function(canvas2dCtx) {
 *         canvas2dCtx.beginPath();
 *         canvas2dCtx.moveTo(0, this.h);
 *         canvas2dCtx.lineTo(this.w, 0);
 *         canvas2dCtx.lineWidth = 2;
 *         canvas2dCtx.strokeStyle = "red";
 *         canvas2dCtx.stroke();
 *     }
 *
 *
 */

/**
 * @method drawBgImage
 *
 * 本函数用于绘制控件的背景图片(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 * 如下面的代码放到onBeforeOpen中，实现动态背景效果。 
 *  
 *     @example small frame
 *      var win = this.win;
 *      win.bgOffsetX = 0;
 *      win.bgOffsetY = 0;
 *      win.bgInc = true;
 *      
 *      win.drawBgImage = function(canvas2dCtx) {
 *          var image = this.getBgImage();
 *          if(!image) return;
 *  
 *          var imageRect = image.getImageRect();
 *          var htmlImage = image.getImage();
 *  
 *          if (this.bgInc) {
 *              this.bgOffsetX++;
 *              if ((this.bgOffsetX + this.w) >= imageRect.w) {
 *                  this.bgInc = false;
 *              }
 *          } else {
 *              this.bgOffsetX--;
 *              if (this.bgOffsetX < 1) {
 *                  this.bgInc = true;
 *              }
 *          }
 *          this.bgOffsetY++;
 *          this.bgOffsetY = this.bgOffsetY % imageRect.h;
 *  
 *          var oy = imageRect.h - this.bgOffsetY;
 *          var rect = {
 *              x: this.bgOffsetX,
 *              y: this.bgOffsetY,
 *              w: this.w,
 *              h: this.h
 *          };
 *  
 *          rect.h = Math.min(this.h, oy);
 *          this.drawImageAt(canvas2dCtx, htmlImage, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, rect.h, rect);
 *  
 *          if (oy < this.h) {
 *              rect.y = 0;
 *              rect.h = this.h - oy;
 *              this.drawImageAt(canvas2dCtx, htmlImage, UIElement.IMAGE_DISPLAY_SCALE, 0, oy, this.w, rect.h, rect);
 *          }
 *  
 *          return;
 *      }
 *
 *
 */

/**
 * @method addEventListener
 *
 * 注册事件的回调函数。
 * @param {String} type 事件的类型。目前支持"updatetransform","pointerdown","pointermove","pointerup","click","removed","changing","change","moved","begincontact","endcontact","becomezero","becomefull","timer","open","close","scrolldone","scrolling"。
 * @param {Function} callback 回调函数。原型为callback(event)。callback中的this为对应的控件, event的成员变量与对应事件的参数一致。
 *
 * 注意：回调函数返回true时终止后续回调函数的处理。
 *
 *     @example small frame
 *     function initDialog(win) {
 *         function onButtonClicked(event) {
 *             var button = event.target;
 *             this.closeWindow(1);
 *             console.log(button.name + " clicked at:" + JSON.stringify(event.point));
 *         }
 *         win.find("button").addEventListener("click", onButtonClicked);
 *         
 *         function onOpen(event) {
 *             console.log("dialog open:" + JSON.stringify(event.initData));
 *         }
 *         win.addEventListener("open", onOpen);
 *         
 *         function onClose(event) {
 *             console.log("dialog closed with:" + JSON.stringify(event.retInfo));
 *         }
 *         win.addEventListener("close", onClose);
 *     }
 */

/**
 * @method removeEventListener
 *
 * 注销事件的回调函数。
 * @param {String} type 事件的类型。参考addEventListener。
 * @param {Function} callback 回调函数。
 *
 */

/**
 * @method loadAssets
 * 加载指定场景的资源。在缺省资源加载窗口中，可以指定预先加载部分场景的资源，其它资源可以通过本函数在需要时加载。
 * @param {Array} scenesNameList 要加载资源的场景名称数组。
 * @param {Function} onProgress(percent, finished, total) 加载进度的回调函数。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var progressbar = this.win.findChildByType("ui-progressbar");
 *     function onProgress(percent, finished, total) {
 *         progressbar.setPercent(percent);
 *         console.log("finished=" + finished + " total=" + total);
 *     }
 *     this.loadAssets(["scene", "scene-1"], onProgress);
 *
 */

/**
 * @method clearAssetsCache
 *
 * @param {Function} check(url) (可选) 本函数对资源进行检查，返回false的资源的缓存将被清除。
 *
 *     @example small frame
 *     var progressbar = this.win.findChildByType("ui-progressbar");
 *     function onProgress(percent, finished, total) {
 *         progressbar.setPercent(percent);
 *         console.log("finished=" + finished + " total=" + total);
 *     }
 *     this.clearAssetsCache();
 *     this.loadAssets(["scene", "scene-1"], onProgress);
 */

/*
 * File:   ui-group.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Group
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGroup
 * @extends UIElement
 * 分组控件。可以拖放分组控件来创建，也可以把几个控件组合起来。
 *
 * 可以在属性页中设置背景和边框的颜色，如果不需要背景和边框的颜色，把相应的颜色删除就行了。
 *
 */
function UIGroup() {
	return;
}

UIGroup.prototype = new UIElement();
UIGroup.prototype.isUIGroup = true;

UIGroup.prototype.initUIGroup = function(type, w, h, img) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	this.setCanRectSelectable(false, false);
	this.addEventNames(["onInit"]);
	this.style.lineColor = "rgba(0,0,0,0)";
	this.style.fillColor = "rgba(0,0,0,0)";
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UIGroup.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar || shape.isUIWindow || shape.isUIListItem) {
		return false;
	}

	return true;
}

UIGroup.prototype.onPointerUpEditing = function(point, beforeChild) {

	return;
}

UIGroup.prototype.fixChildPosition = function(child) {
}

UIGroup.prototype.fixChildSize = function(child) {
}

UIGroup.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		canvas.beginPath();
		drawRoundRect(canvas, this.w, this.h, this.roundRadius);
		
		if(!this.isFillColorTransparent()) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fill();
		}

		if(!this.isStrokeColorTransparent()) {
			canvas.lineWidth = this.style.lineWidth;
			canvas.strokeStyle = this.style.lineColor;
			canvas.stroke();	
		}
	}

	return;
}

UIGroup.prototype.onPositionChanged = function() {
	var children = this.children;
	var n = children.length;

	for(var i = 0; i < n; i++) {
		var iter = children[i];
		if(iter.isUIBody || iter.isUIGroup){
			iter.onPositionChanged();
		}
	}

	return;
}


function UIGroupCreator(w, h, img) {
	var args = ["ui-group", "ui-group", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGroup();

		return g.initUIGroup(this.type, w, h, img);
	}
	
	return;
}

UIGroup.create = function() {
	var g = new UIGroup();
	
	g.initUIGroup("ui-group", 200, 200, null);
	g.state = Shape.STAT_NORMAL;

	return g;
}

/*
 * File:   ui-window.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Window
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWindow
 * @extends UIElement
 * 窗口是普通窗口和对话框的基类。
 *
 */
function UIWindow() {
	return;
}

/**
 * @event onLoad 
 * 此事件在第一批资源加载完成时触发。发生在onSystemInit事件之后，onBeforeOpen事件之前。
 *
 * 注意：由于窗口并未打开，请不要使用界面上的控件。
 */

/**
 * @event onSystemInit
 * 系统初始化事件，UI数据加载完成，但其它资源尚未加载。
 *
 * 注意：由于窗口并未打开，请不要使用界面上的控件。
 */

/**
 * @event onBeforeOpen
 * 窗口已经创建，但是还没有显示出来。
 * @param {Object} initData 初始化参数，此参数是从openWindow方法传过来的。
 *
 */

/**
 * @event onOpen
 * 窗口打开事件。
 * @param {Object} initData 初始化参数，此参数是从openWindow方法传过来的。
 *
 * 打开窗口：
 *
 *     @example small frame
 *     var initData = "abcd";
 *     this.openWindow("win-test", function (retCode) {console.log("window closed.");}, false, initData);
 *
 * onOpen事件处理代码：
 *
 *     @example small frame
 *     console.log(initData);
 *
 */

/**
 * @event onClose
 * 窗口关闭。
 * @param {Object} retInfo 由closeWindow函数传递过来。
 *
 */

/**
 * @event onSwitchToBack
 * 打开新窗口，当前窗口切换到后台时，当前窗口触发本事件。
 *
 */

/**
 * @event onSwitchToFront
 * 关闭当前窗口，前一个窗口切换到前台时，前一个窗口触发本事件。
 */

/**
 * @event onSwipeLeft
 * 手势向左滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeRight
 * 手势向右滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeUp
 * 手势向上滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeDown
 * 手势向下滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */


/**
 * @event onKeyDown
 * Key Down事件。
 * @param {Number} code 按键的代码。
 *
 * 代码影射表：
 *
 *     @example small frame
 *
 *     var KeyEvent = {
 *        DOM_VK_CANCEL: 3,
 *        DOM_VK_HELP: 6,
 *        DOM_VK_BACK_SPACE: 8,
 *        DOM_VK_TAB: 9,
 *        DOM_VK_CLEAR: 12,
 *        DOM_VK_RETURN: 13,
 *        DOM_VK_ENTER: 14,
 *        DOM_VK_SHIFT: 16,
 *        DOM_VK_CONTROL: 17,
 *        DOM_VK_ALT: 18,
 *        DOM_VK_PAUSE: 19,
 *        DOM_VK_CAPS_LOCK: 20,
 *        DOM_VK_ESCAPE: 27,
 *        DOM_VK_SPACE: 32,
 *        DOM_VK_PAGE_UP: 33,
 *        DOM_VK_PAGE_DOWN: 34,
 *        DOM_VK_END: 35,
 *        DOM_VK_HOME: 36,
 *        DOM_VK_LEFT: 37,
 *        DOM_VK_UP: 38,
 *        DOM_VK_RIGHT: 39,
 *        DOM_VK_DOWN: 40,
 *        DOM_VK_PRINTSCREEN: 44,
 *        DOM_VK_INSERT: 45,
 *        DOM_VK_DELETE: 46,
 *        DOM_VK_0: 48,
 *        DOM_VK_1: 49,
 *        DOM_VK_2: 50,
 *        DOM_VK_3: 51,
 *        DOM_VK_4: 52,
 *        DOM_VK_5: 53,
 *        DOM_VK_6: 54,
 *        DOM_VK_7: 55,
 *        DOM_VK_8: 56,
 *        DOM_VK_9: 57,
 *        DOM_VK_SEMICOLON: 59,
 *        DOM_VK_EQUALS: 61,
 *        DOM_VK_A: 65,
 *        DOM_VK_B: 66,
 *        DOM_VK_C: 67,
 *        DOM_VK_D: 68,
 *        DOM_VK_E: 69,
 *        DOM_VK_F: 70,
 *        DOM_VK_G: 71,
 *        DOM_VK_H: 72,
 *        DOM_VK_I: 73,
 *        DOM_VK_J: 74,
 *        DOM_VK_K: 75,
 *        DOM_VK_L: 76,
 *        DOM_VK_M: 77,
 *        DOM_VK_N: 78,
 *        DOM_VK_O: 79,
 *        DOM_VK_P: 80,
 *        DOM_VK_Q: 81,
 *        DOM_VK_R: 82,
 *        DOM_VK_S: 83,
 *        DOM_VK_T: 84,
 *        DOM_VK_U: 85,
 *        DOM_VK_V: 86,
 *        DOM_VK_W: 87,
 *        DOM_VK_X: 88,
 *        DOM_VK_Y: 89,
 *        DOM_VK_Z: 90,
 *        DOM_VK_CONTEXT_MENU: 93,
 *        DOM_VK_NUMPAD0: 96,
 *        DOM_VK_NUMPAD1: 97,
 *        DOM_VK_NUMPAD2: 98,
 *        DOM_VK_NUMPAD3: 99,
 *        DOM_VK_NUMPAD4: 100,
 *        DOM_VK_NUMPAD5: 101,
 *        DOM_VK_NUMPAD6: 102,
 *        DOM_VK_NUMPAD7: 103,
 *        DOM_VK_NUMPAD8: 104,
 *        DOM_VK_NUMPAD9: 105,
 *        DOM_VK_MULTIPLY: 106,
 *        DOM_VK_ADD: 107,
 *        DOM_VK_SEPARATOR: 108,
 *        DOM_VK_SUBTRACT: 109,
 *        DOM_VK_DECIMAL: 110,
 *        DOM_VK_DIVIDE: 111,
 *        DOM_VK_BACK_BUTTON: 115, 
 *        DOM_VK_MENU_BUTTON: 118, 
 *        DOM_VK_SEARCH_BUTTON: 120, 
 *        DOM_VK_F1: 112,
 *        DOM_VK_F2: 113,
 *        DOM_VK_F3: 114,
 *        DOM_VK_F4: 115,
 *        DOM_VK_F5: 116,
 *        DOM_VK_F6: 117,
 *        DOM_VK_F7: 118,
 *        DOM_VK_F8: 119,
 *        DOM_VK_F9: 120,
 *        DOM_VK_F10: 121,
 *        DOM_VK_F11: 122,
 *        DOM_VK_F12: 123,
 *        DOM_VK_F13: 124,
 *        DOM_VK_F14: 125,
 *        DOM_VK_F15: 126,
 *        DOM_VK_F16: 127,
 *        DOM_VK_F17: 128,
 *        DOM_VK_F18: 129,
 *        DOM_VK_F19: 130,
 *        DOM_VK_F20: 131,
 *        DOM_VK_F21: 132,
 *        DOM_VK_F22: 133,
 *        DOM_VK_F23: 134,
 *        DOM_VK_F24: 135,
 *        DOM_VK_NUM_LOCK: 144,
 *        DOM_VK_SCROLL_LOCK: 145,
 *        DOM_VK_COMMA: 188,
 *        DOM_VK_PERIOD: 190,
 *        DOM_VK_SLASH: 191,
 *        DOM_VK_BACK_QUOTE: 192,
 *        DOM_VK_OPEN_BRACKET: 219,
 *        DOM_VK_BACK_SLASH: 220,
 *        DOM_VK_CLOSE_BRACKET: 221,
 *        DOM_VK_QUOTE: 222,
 *        DOM_VK_META: 224,
 *        DOM_VK_BACK: 225
 *      }
 *
 * 用法示例：
 *
 *     @example small frame
 *     var win = this.getWindow();
 *     var image = win.find("image");
 *     switch (code) {
 *         case KeyEvent.DOM_VK_UP:
 *             image.y -= 5;
 *             break;
 *         case KeyEvent.DOM_VK_DOWN:
 *             image.y += 5;
 *             break;
 *         case KeyEvent.DOM_VK_LEFT:
 *             image.x -= 5;
 *             break;
 *         case KeyEvent.DOM_VK_RIGHT:
 *             image.x += 5;
 *             break;
 *         default:
 *             break;
 *     }
 */

/**
 * @event onKeyUp
 * Key Up事件。
 * @param {Number} code 按键的代码。
 */

/**
 * @event onMultiTouch
 * 多点触摸事件。
 * @param {String} action "touchstart", "touchmove", "touchend"
 * @param {Array} points 点的数组。坐标是根据Canvas的缩放比例转换过的，相对当前窗口的坐标。
 * @param {Object} event 原始Touch事件。
 */

UIWindow.serialNo = 0;
UIWindow.prototype = new UIElement();
UIWindow.prototype.isUIWindow = true;
UIWindow.prototype.saveProps = ["openAnimationDuration", "closeAnimationDuration", "animHint", "windowType",
"closeWhenPointerUpOutside", "refLinesV", "refLinesH", "windowNameToBeOpen", "preloadWindows", "isUILoadingWindowV2", "isUILoadingWindow", "sceneId"];

UIWindow.prototype.fromJson = function(json) {
	if(json.isUILoadingWindow) {
		RShape.prototype.fromJson.call(this, json);
	}
	else {
		this.jsonData = json;
		this.name = json.name;

        Object.keys(json.events).forEach(function(ev) {
            this.events[ev] = json.events[ev];
        }, this);
	}

	return this;
}

UIWindow.prototype.fromJsonNow = function(json) {
	RShape.prototype.fromJson.call(this, json);

	return this;
}

UIWindow.prototype.onGesture = function(gesture) {
	if(this.mode != Shape.MODE_EDITING) {
		this.callOnGestureHandler(gesture);
	}

	return;
}

UIWindow.prototype.onMultiTouch = function(action, points, event) {
	this.callOnMultiTouchHandler(action, points, event);
}

UIWindow.prototype.isMainWindow = function() {
	var wm = this.getWindowManager();
	var index = wm.history[0];
	var firstWin = wm.children[index];

	return firstWin === this;
}

UIWindow.prototype.getTimeScale = function() {
	return this.timeScale;
}

UIWindow.prototype.setTimeScale = function(timeScale) {
	this.timeScale = timeScale;

	return this;
}

UIWindow.prototype.initUIWindow = function(type, x, y, w, h, bg) {
	this.initUIElement(type);	

	this.timeScale = 1;
	this.setLeftTop(x, y);
	this.settings = {};
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setName("window-" + UIWindow.serialNo++);

	if(!bg) {
		this.style.setFillColor("White");
	}

	this.addEventNames(["onSystemInit", "onLoad", "onOpen", "onBeforeOpen",
			"onClose", "onSwitchToBack", "onSwitchToFront", "onGesture", "onKeyDown", "onKeyUp"]);

	this.setAnimHint("htranslate");
	this.oldHitTest = this.hitTest;

	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.intervals = [];
	this.timeouts = [];

	return this;
}

UIWindow.prototype.setAnimHint = function(animHint) {
	this.animHint = animHint;

	return true;
}

UIWindow.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar || shape.isUIWindow) {
		return false;
	}

	return true;
}

UIWindow.prototype.onModeChanged = function() {
	if(this.mode === Shape.MODE_EDITING) {
		this.popupWindow = null;
	}

	return;
}

UIWindow.prototype.removePopupWindow = function(popup) {
	if(this.popupWindow) {
		if(this.popupWindow === popup) {
			this.popupWindow = null;
			this.targetShape = null;

			return true;
		}

		return this.popupWindow.removePopupWindow(popup);
	}

	return false;
}

UIWindow.prototype.setPopupWindow = function(popup) {
	if(this.popupWindow) {
		return this.popupWindow.setPopupWindow(popup);
	}
	else {
		this.popupWindow = popup;
	}

	return true;
}

UIWindow.prototype.getPopupWindow =function() {
	if(this.popupWindow) {
		return this.popupWindow.getPopupWindow();
	}

	return this.isUIPopupWindow ? this : null;
}

UIWindow.prototype.isGrabElement = function(el) {
	return this.grabElement === el;
}

UIWindow.prototype.grab = function(el) {
	this.grabElement = el;

	return;
}

UIWindow.prototype.ungrab = function(el) {
	this.grabElement = null;

	return;
}

UIWindow.prototype.dispatchPointerDownToChildren = function(p) {
	if(this.grabElement) {
		this.grabElement.onPointerDown(p)
		this.setTarget(this.grabElement);
		return true;
	}
	
	return this.defaultDispatchPointerDownToChildren(p);
}

UIWindow.prototype.onPointerDownNormal = function(point) {
	if(this.popupWindow) {
		this.popupWindow.onPointerDownNormal(point)
		this.setTarget(this.popupWindow);
		this.pointerDown = false;

		return true;
	}

	return UIElement.prototype.onPointerDownNormal.call(this, point);
}

UIWindow.prototype.onDoubleClick = function(point) {
	if(this.popupWindow) {
		this.popupWindow.onDoubleClick(point)
		return true;
	}

	return UIElement.prototype.onDoubleClick.call(this, point);
}

UIWindow.prototype.onPointerMoveNormal = function(point) {
	if(this.popupWindow) {
		return this.popupWindow.onPointerMoveNormal(point)
	}

	return UIElement.prototype.onPointerMoveNormal.call(this, point);
}

UIWindow.prototype.onPointerUpNormal = function(point) {
	if(this.popupWindow) {
		return this.popupWindow.onPointerUpNormal(point)
	}
	else if(this.mode !== Shape.MODE_EDITING && this.enable) {
		var dx = this.lastPosition.x - this.pointerDownPosition.x;
		var dy = this.lastPosition.y - this.pointerDownPosition.y;
		var adx = Math.abs(dx);
		var ady = Math.abs(dy);
		var end = this.lastPosition;
		var start = this.pointerDownPosition;

		if(adx > 20 || ady > 20) {
			if((adx >> 1) > ady) {
				if(dx < 0) {
					this.callOnSwipeLeftHandler(start, end);
				}
				else {
					this.callOnSwipeRightHandler(start, end);
				}
			}
			if((ady >> 1) > adx) {
				if(dy < 0) {
					this.callOnSwipeUpHandler(start, end);
				}
				else {
					this.callOnSwipeDownHandler(start, end);
				}
			}
		}
	}

	return UIElement.prototype.onPointerUpNormal.call(this, point);
}

UIWindow.prototype.paintSelfOnly =function(canvas) {
	canvas.globalAlpha =  this.opacity;
	this.clearBackground(canvas);
	this.drawBgImage(canvas);

	return;
}

UIWindow.prototype.beforePaintChildren = function(canvas) {
	canvas.globalAlpha = 1;
}

UIWindow.prototype.paintSelf = function(canvas) {
	var timeStep = canvas.timeStep;

	canvas.timeStep = this.scaleTime(timeStep);
	if(this.mode === Shape.MODE_EDITING) {
		UIElement.prototype.paintSelf.call(this, canvas);
	}
	else {
		canvas.save();
		this.translate(canvas);
		this.paintSelfOnly(canvas);
		
		this.beforePaintChildren(canvas);
		this.paintChildren(canvas);
		this.afterPaintChildren(canvas);
		canvas.restore();
	}

	if(this.popupWindow) {
		canvas.timeStep = this.popupWindow.scaleTime(timeStep);
		this.popupWindow.paintSelf(canvas);
	}
	canvas.timeStep = timeStep;

	return;
}

UIWindow.prototype.show = function() {
	this.setVisible(true);
	this.showHTML();

	return;
}

UIWindow.prototype.hide = function() {
	this.setVisible(false);
	this.hideHTML();
	cantkHideAllInput();

	return;
}

UIWindow.prototype.setCloseWhenPointerUpOutside = function(closeWhenPointerUpOutside) {
	if(closeWhenPointerUpOutside) {
		this.hitTest = function(point) {
			var ret = this.oldHitTest(point);
			if(!ret) {
				if(this.mode != Shape.MODE_EDITING) {
					ret = Shape.HIT_TEST_MM;
				}
			}

			return ret;
		}
	}
	else {
		this.hitTest = this.oldHitTest;
	}
	this.closeWhenPointerUpOutside = closeWhenPointerUpOutside;

	return;
}

UIWindow.prototype.isAnimationEnabled = function() {
	if(CantkRT.isNative()) return false;

	return this.animHint && this.animHint !== "none";
}

UIWindow.prototype.getAnimationDuration = function(toShow) {
	return toShow ? this.openAnimationDuration : this.closeAnimationDuration;
}

UIWindow.prototype.getAnimationName = function(toShow) {
	var anim = "";
	switch(this.animHint) {
		case "fade": {
			anim = toShow ? "anim-fade-in" : "anim-fade-out";
			break;
		}
		case "scale": {
			if(this.isUIDialog) {
				anim = toShow ? "anim-scale-show-dialog" : "anim-scale-hide-dialog";
			}
			else {
				anim = toShow ? "anim-scale-show-win" : "anim-scale-hide-win";
			}
			break;
		}
		case "popup": {
			anim = toShow ? "anim-move-up" : "anim-move-down";
			break;
		}
		case "htranslate": {
			anim = toShow ? "anim-forward" : "anim-backward";
			break;
		}
		case "vtranslate": {
			anim = toShow ? "anim-upward" : "anim-downward";
			break;
		}
		default: {
			if(this.isUIDialog) {
				anim = toShow ? "anim-scale-show-dialog" : "anim-scale-hide-dialog";
			}
			else {
				if(isAndroid() || isFirefoxMobile()) {
					anim = toShow ? "anim-scale-show-win" : "anim-scale-hide-win";
				}
				else {
					anim = toShow ? "anim-forward" : "anim-backward";
				}
			}
			break;
		}
	}

	return anim;
}

UIWindow.prototype.isSplashWindow = function() {
	return this.isUINormalWindow && this.windowType === "splash";
}

UIWindow.prototype.getSupportedAnimations = function() {
	var animations = ["none", "default", "scale", "fade", "popup", "htranslate", "vtranslate"];

	return animations;
}

UIWindow.prototype.clearBackground =function(canvas) {
	var display = this.images.display;
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(image) {
		switch(display) {
			case UIElement.IMAGE_DISPLAY_TILE:
			case UIElement.IMAGE_DISPLAY_TILE_V:
			case UIElement.IMAGE_DISPLAY_TILE_H:
			case UIElement.IMAGE_DISPLAY_SCALE:
			case UIElement.IMAGE_DISPLAY_9PATCH:
			case UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO: return;
			default:break;
		}

		if(image.width >= this.w && image.height >= this.h) {
			return;
		}
	}

	if(!this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

UIWindow.prototype.defaultChildrenFromJson = UIElement.prototype.childrenFromJson;

UIWindow.prototype.loadChildren = function() {
	if(this.childrenJson) {
		this.defaultChildrenFromJson(this.childrenJson);
		delete this.childrenJson;
		delete this.pendingLoadChildren;
		console.log("Now To Load Children Of " + this.name);

		if(this.scaleInfo) {
			this.scaleForDensity(this.scaleInfo.sizeScale, this.scaleInfo.lcdDensity, true);
		}

		var wm = this.getWindowManager();
		var oldConfig = wm.oldConfig;
		var deviceConfig = wm.deviceConfig;

		if(oldConfig && deviceConfig) {
			this.notifyDeviceConfigChanged(oldConfig, deviceConfig);
		}

	}

	return;
}

UIWindow.prototype.childrenFromJson = function(js) {
	if(js.lazyLoad && !dappIsEditorApp()) {
		this.childrenJson = js;
		this.pendingLoadChildren = true;
		console.log("Delay To Load Children Of " + this.name);
	}
	else {
		delete this.pendingLoadChildren;
		this.defaultChildrenFromJson(js);	
	}

	return;
}

UIWindow.prototype.initStageOne = function() {
	this.callOnInitHandler();
	this.clearAllTimeouts();
	this.clearAllIntervals();

	this.forEach(function(iter) {
		if(iter.offset) {
			iter.offset = 0;
		}
		iter.visible = iter.runtimeVisible;

		if(iter.animatingInfo) {
			iter.animatingInfo = null;
			iter.animating = false;
		}

		if(iter.animations && iter.animations[iter.defaultAnimationName]) {
			console.log(iter.name + " has default animation, set it invisible initially.");
			iter.visible = false;
		}
	});

	return;
}

UIWindow.prototype.onInit = function() {
	this.initStageOne();

	return;
}

UIWindow.prototype.prepareForOpen = function() {
	if(!this.isUILoadingWindow && this.jsonData) {
		this.fromJsonNow(this.jsonData);
	}

	this.setMode(Shape.MODE_RUNNING, true);
	this.relayout();

	return this;
}

UIWindow.prototype.callOnBeforeOpen = function(initData) {
	this.show();
	this.init();

	return this.callOnBeforeOpenHandler(initData);
}

UIWindow.prototype.callOnOpen = function(initData) {
	delete this.openPending;
	this.getParent().pointerEventTarget = this;

	if(this.onOpen) {
		try {
			this.onOpen(initData);
		}catch(e) {
			console.log("onOpen" + e.message);
		}
	}

	this.callOnOpenHandler(initData);

	if(this.isSplashWindow()) {
		var win = this;
		var duration = win.duration ? win.duration : 3000;

		if(window.splashWinTimeID) {
			clearTimeout(window.splashWinTimeID);
			delete window.splashWinTimeID;
		}

		window.splashWinTimeID = setTimeout(function() {
			if(win.visible) {
				win.openWindow(null, null, true);
			}
		}, duration);
	}

	this.forEach(function(el) {
		el.onWindowOpen();
	});

	return true;
}

UIWindow.prototype.callOnClose = function(retInfo) {
	if(this.onClose) {
		try {
			this.onClose(retInfo);
		}
		catch(e) {
			console.log("onClose: " + e.message);
		}
	}
			
	this.callOnCloseHandler(retInfo);

	this.deinit();
	this.hide();

	if(this.destroyWhenClose) {
		this.getWindowManager().removeChild(this, true);
	}
	this.clearAllTimeouts();
	this.clearAllIntervals();

	var arr = this.children;
	this.children = [];

	setTimeout(function() {
		arr.clear(true);
	}, 100);

	return true;
}

UIWindow.prototype.callOnSwitchToBack = function(topIsPopup) {
	this.callOnSwitchToBackHandler();
	if(!topIsPopup) {
		this.hide();
	}

	return true;
}

UIWindow.prototype.callOnSwitchToFront = function(topIsPopup) {
	if(this.isUINormalWindow && (this.w != this.parentShape.w || this.h != this.parentShape.h)) {
		this.relayout();
		console.log("WindowManager Size Changed, Relayout Current Window.");
	}

	this.show();
	this.callOnSwitchToFrontHandler();

	return true;
}

/**
 * @method setTimeout
 * 是对系统setTimeout的包装，保证窗口关闭时，定时器被销毁。
 * @param {Function} func 定时器回调函数。 
 * @param {Number} dt 时长(毫秒) 
 * @return {Number} 返回timerID
 *
 */
UIWindow.prototype.setTimeout = function(func, dt) {
	if(this.mode === Shape.MODE_EDITING) {
		console.log("Can not UIWindow.prototype.setTimeout in edit mode.");
		return;
	}

	if(typeof(func) !== "function") {
		console.log("invalid func for UIWindow.prototype.setTimeout");
		return;
	}

	function callback() {
		this.timeouts.remove(id);
		func();
	}

	var id = window.setTimeout(callback.bind(this), dt);
	this.timeouts.push(id);

	return id;
}

/**
 * @method clearTimeout
 * 清除定时器。
 * @param {Number} id timerID
 *
 */
UIWindow.prototype.clearTimeout = function(id) {
	window.clearTimeout(id);
	this.timeouts.remove(id);
}

/**
 * @method setInterval
 * 是对系统setInterval的包装，保证窗口关闭时，定时器被销毁。
 * @param {Function} func 定时器回调函数。 
 * @param {Number} dt 时长(毫秒) 
 * @return {Number} 返回timerID
 *
 */
UIWindow.prototype.setInterval = function(func, dt) {
	if(this.mode === Shape.MODE_EDITING) {
		console.log("Can not UIWindow.prototype.setInterval in edit mode.");
		return;
	}
	
	if(typeof(func) !== "function") {
		console.log("invalid func for UIWindow.prototype.setInterval");
		return;
	}

	function callback() {
		func();
	}

	var id = window.setInterval(callback.bind(this), dt);
	this.intervals.push(id);

	return id;
}

/**
 * @method clearInterval
 * 清除定时器。
 * @param {Number} id timerID
 *
 */
UIWindow.prototype.clearInterval = function(id) {
	window.clearInterval(id);
	this.intervals.remove(id);
}

UIWindow.prototype.clearAllIntervals = function() {
	var arr = this.intervals;
	for(var i = 0; i < arr.length; i++) {
		var id = arr[i];
		window.clearInterval(id);
	}
	this.intervals.length = 0;
}

UIWindow.prototype.clearAllTimeouts = function() {
	var arr = this.timeouts;
	for(var i = 0; i < arr.length; i++) {
		var id = arr[i];
		window.clearTimeout(id);
	}
	this.timeouts.length = 0;
}

UIWindow.prototype.loadInitAssets = function(bar, preloadWindows) {
	var win = this;
	var wm = win.getParent();

	if(!bar) {
		bar = win.findChildByType("ui-progressbar");
	}
	
	if(!preloadWindows) {
		preloadWindows = win.preloadWindows;
	}
	
	function onProgress(percent, loadedNr, totalNr) {
		if(bar) {
			bar.setPercent(percent);
		}
		
        var initWin = wm.getInitWindow();
		if(loadedNr >= totalNr && initWin != win) {
			wm.showInitWindow(win.windowNameToBeOpen);	
		}
		
		win.postRedraw();
		console.log("Resloading:" + percent + "%(" + loadedNr + "/" + totalNr + ")");	 
	}

	var winNamesArr = preloadWindows ? preloadWindows.split(",") : null;
	wm.loadAssets(winNamesArr, onProgress, true);

	return this;
}


UIWindow.prototype.relayout = function() {
	if(!this.getWindowManager().isDeviceDirectionOK()) {
		console.log("UIWindow.prototype.relayout Reject Relayout");
		return;
	}

	UIElement.prototype.relayout.call(this);

	return this;
}

ShapeFactoryGet().addShapeCreator(new UINormalWindowCreator(null));

//////////////////////////////////////////////////////////////////////}-{

/**
 * @class UINormalWindow
 * @extends UIWindow
 * 普通窗口是全屏的窗口。
 *
 */
function UINormalWindow() {
	return;
}

UINormalWindow.prototype = new UIWindow();
UINormalWindow.prototype.isUINormalWindow = true;

function UINormalWindowCreator(bg) {
	var args = ["ui-window", "ui-window", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UINormalWindow();
		
		g.initUIWindow(this.type, 0, 0, 100, 100, bg);
		g.widthAttr = UIElement.WIDTH_FILL_PARENT;
		g.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		g.addEventNames(["onSwipeLeft", "onSwipeRight", "onSwipeUp", "onSwipeDown"]);

		return g;
	}
	
	return;
}

/*
 * File:   ui-dialog.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Dialog
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIDialog
 * @extends UIWindow
 * 通常用对话框提示信息和确认问题等。
 *
 */
function UIDialog() {
	return;
}

UIDialog.prototype = new UIWindow();
UIDialog.prototype.isUIDialog = true;
UIDialog.prototype.isUIPopupWindow = true;

UIDialog.prototype.fixChildSize = function(shape) {
	return;
}

UIDialog.prototype.fixChildPosition = function(shape) {
	return;
}

function UIDialogCreator(w, h, bg) {
	var args = ["ui-dialog", "ui-dialog", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDialog();
		g.initUIWindow(this.type, 0, 0, w, h, bg);
		
		g.setMargin(8, 8);
		g.xAttr = UIElement.X_CENTER_IN_PARENT;
		g.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
		g.images.display = UIElement.IMAGE_DISPLAY_SCALE;
		g.setAnimHint("scale");

		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDialogCreator(600, 400, null));

/*
 * File:   ui-edit.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Single Line Editor
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIEdit
 * @extends UIElement
 * 单行编辑器。
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onChanging
 * 文本正在变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onFocusIn
 * 得到输入焦点事件。
 */

/**
 * @event onFocusOut
 * 失去输入焦点事件。
 */
function UIEdit() {
	return;
}

UIEdit.prototype = new UIElement();
UIEdit.prototype.isUIEdit = true;

UIEdit.prototype.saveProps = ["leftMargin", "rightMargin", "inputType", "inputTips", "maxLength"];
UIEdit.prototype.initUIEdit = function(type, w, h, leftMargin, rightMargin, initText, bg, focusedBg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setText(initText);
	this.leftMargin = leftMargin;
	this.rightMargin = rightMargin;
	this.setSizeLimit(60, 30, 1000, 80);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setImage(UIElement.IMAGE_FOCUSED, focusedBg);
	this.setMargin(5, 5);
	this.setInputType("text");
	this.addEventNames(["onChanged", "onChanging", "onFocusIn", "onFocusOut"]);
	this.setTextAlignV("middle");
	this.setTextAlignH("left");
	this.maxLength = 1024;

	return this;
}

UIEdit.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIButton) {
		return true;
	}

	return false;
}

UIEdit.prototype.textEditable = function(point) {
	return true;
}

UIEdit.prototype.getLocaleText = function(text) {
	if(text === " ") {
		return text;
	}

	if(this.inputType === "password" && text && text === this.text) {
		var str = "";
		var n = text.length;
		for(var i = 0; i < n; i++) {
			str = str + "*";
		}

		return str;
	}
	else {
		return text;
	}
}

UIEdit.prototype.drawText = function(canvas) {
	var y = this.h >> 1;
	var x = this.leftMargin;
	var text = this.getLocaleText(this.text);
	var width = this.w - x - this.rightMargin;
	var inputTips = this.inputTips;

	if((!text && !inputTips) || this.editing) {
		return;
	}
	
	canvas.save();
	canvas.font = this.style.getFont();
	if(text) {
		canvas.fillStyle = this.style.textColor;	
	}
	else {
		text = inputTips;
		canvas.fillStyle = "#E0E0E0";
	}

	canvas.beginPath();
	canvas.rect(0, 0, this.w - this.rightMargin, this.h);
	canvas.clip();

	canvas.textAlign = "left";
	canvas.textBaseline = "middle";
	canvas.fillText(text, x, y);

	canvas.restore();

	return;
}

UIEdit.prototype.isFocused = function() {
	return this.editing;
}

UIEdit.prototype.paintSelfOnly = function(canvas) {
	var image = this.getBgImage();

	if(image) {
		return;
	}

	canvas.beginPath();
	drawRoundRect(canvas, this.w, this.h, 8);
	canvas.fillStyle = this.style.fillColor;
	canvas.fill();
	canvas.strokeStyle = this.style.lineColor;
	canvas.lineWidth = this.isFocused() ? 4 : 2;
	canvas.stroke();

	return;
}

UIEdit.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	if(this.mode !== Shape.MODE_EDITING) {
		this.editText();
	}

	return;
}

UIEdit.prototype.getWidth = function(withoutBorder) {
	var w = this.w;
	if(withoutBorder) {
		w = w - this.leftMargin - this.rightMargin;
	}

	return w;
}

UIEdit.prototype.getEditorRect = function() {
	var p = this.getPositionInView();
	var vp = this.view.getAbsPosition();
	var scale = this.view.getViewScale();
	var ox = vp.x;
	var oy = vp.y;
	var leftMargin = this.leftMargin || 0;

	var y = p.y * scale + oy;
	if(isMobile()) {
		var x = (p.x) * scale + ox;
		var w = this.getWidth() * scale;
	}
	else {
		var x = (p.x + leftMargin) * scale + ox;
		var w = this.getWidth(true) * scale;
	}
	var h = this.getHeight() * scale;

	var rect = {};
	
	scale = UIElement.getMainCanvasScale();
	rect.x = Math.round(x/scale.x);
	rect.y = Math.round(y/scale.y);
	rect.w = Math.round(Math.max(60, w) / scale.x);
	rect.h = Math.round(h/scale.y);

	if(this.mode === Shape.MODE_EDITING) {
		var radtio = window.devicePixelRatio || 1;
		rect.x *= radtio;
		rect.y *= radtio;
		rect.w *= radtio;
		rect.h *= radtio;
	}

	return rect;
}

UIEdit.prototype.editText = function(point) {
	var me = this;
	if(this.textEditable(point)) {
		var shape = this;
		var text = this.getText();
		var rect = this.getEditorRect();
		var scale = this.getRealScale() / UIElement.getMainCanvasScale().y;
		var inputType = this.inputType ? this.inputType : "text";
		var fontSize = this.style.fontSize * scale;
		var editor = cantkShowInput(inputType, fontSize, text, rect.x, rect.y, rect.w, rect.h);

		shape.editing = true;
		if(this.mode === Shape.MODE_EDITING) {
			editor.showBorder(true);
		}

		function onChanged(text) {
			if(text !== shape.text) {
				shape.setText(text, true);
				shape.postRedraw();
			}
			else {
				shape.text = text;
			}
			
			editor.setOnChangedHandler(null);
	        editor.setOnChangeHandler(null);
			editor.hide();
			delete shape.editing;
			shape.callOnFocusOutHandler();

			return;
		}

		function onChange(text) {
			shape.callOnChangingHandler(text);
		}

		editor.setMaxLength(me.maxLength || 1024);
		editor.setOnChangedHandler(onChanged);
		editor.setOnChangeHandler(onChange);

		this.callOnFocusInHandler();
	}

	return;
}

UIEdit.prototype.drawTextTips = function(canvas) {
}

function UIEditCreator(w, h, leftMargin, rightMargin, bg, focusedBg) {
	var args = ["ui-edit", "ui-edit", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIEdit();
		return g.initUIEdit(this.type, w, h, leftMargin, rightMargin, dappGetText("Edit"), bg, focusedBg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIEditCreator(120, 50, 12, 12, null, null));

/*
 * File:   ui-gauge.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Gauge
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */
function UIGauge() {
	return;
}

UIGauge.prototype = new UIElement();
UIGauge.prototype.isUIGauge = true;
UIGauge.IMAGE_POINTER = "pointer-image";

UIGauge.prototype.initUIGauge = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onInit"]);

	return this;
}

UIGauge.prototype.shapeCanBeChild = function(shape) {
	return shape.isUILedDigits || shape.isUILabel || shape.isUIGaugePointer;
}

UIGauge.prototype.afterChildAppended = function(shape) {
	var size = 20;
	var pointerNr = 0;

	if(shape.isUIGaugePointer) {
		shape.xAttr = UIElement.X_CENTER_IN_PARENT;
		shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		if(!iter.isUIGaugePointer) {
			continue;
		}

		switch(pointerNr) {
			case 0: {
				size = 100;
				break;
			}
			case 1: {
				size = 70;
				break;
			}
			case 2: {
				size = 40;
				break;
			}
		}
		pointerNr = pointerNr + 1;

		iter.setSizeLimit(size, size, size, size, 1);
		iter.setSize(size, size);
	}

	this.setSizeLimit(100, 100, 1000, 1000, 1);

	return;
}

UIGauge.prototype.paintSelfOnly = function(canvas) {

	return;
}

function UIGaugeCreator() {
	var args = ["ui-gauge", "ui-gauge", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGauge();
		return g.initUIGauge(this.type, 200, 200);
	}
	
	return;
}

///////////////////////////////////////////////////////////////////}-{

function UIGaugePointer() {
	return;
}

UIGaugePointer.prototype = new UIElement();
UIGaugePointer.prototype.isUIGaugePointer = true;

UIGaugePointer.prototype.saveProps = ["minAngle", "maxAngle", "minValue", "maxValue"];
UIGaugePointer.prototype.initUIGaugePointer = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIGauge.IMAGE_POINTER, null);
	
	this.value = 0;
	this.minAngle = 0;
	this.maxAngle = 360;
	this.minValue = 0;
	this.maxValue = 60;

	return this;
}

UIGaugePointer.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIGaugePointer.prototype.setText = function(text) {
	text = this.toText(text ? text : 0);
	try {
		this.setValue(parseInt(text));
	}catch(e) {
		console.log("UIGaugePointer.prototype.setText:" + e.message);
	}

	return this;
}

UIGaugePointer.prototype.getText = function() {
	return this.getValue() + "";
}

UIGaugePointer.prototype.setValue = function(value) {
	if(value >= this.minValue && value <= this.maxValue) {
		this.value = value;
	}
	else {
		console.log("UIGaugePointer.prototype.setValue: Out Of Range.");
	}

	return this;
}

UIGaugePointer.prototype.getValue = function() {
	return this.value;
}

UIGaugePointer.prototype.animSetValue = function(value, animHint) {
	return this.animSetValue(value, animHint);
}

UIGaugePointer.prototype.animateSetValue = function(value, animHint) {
	if(value < this.minValue) {
		value = this.minValue;
	}

	if(value > this.maxValue) {
		value = this.maxValue;
	}
	
	var pointer = this;
	var endValue = value;
	var startValue = this.getValue();
	var changeDelta = value - startValue;
	var changeAngle = Math.abs(changeDelta * (this.maxAngle - this.minAngle)/(this.maxValue - this.minValue));
	
	if(changeAngle < 5) {
		this.setValue(value);

		return;
	}

	var startTime = (new Date()).getTime();
	var duration = (animHint && animHint == "slow") ? 1000 : 500;

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;

		if(percent < 1) {
			var newValue = startValue + changeDelta * percent;	
			pointer.setValue(newValue);

			setTimeout(animStep, 10);
		}
		else {
			delete startTime;
			pointer.setValue(endValue);
		}

		delete now;
		pointer.postRedraw();
	}

	animStep();

	return;
}

UIGaugePointer.prototype.getAngle = function(canvas) {
	var rangeAngle = this.maxAngle - this.minAngle;
	var rangeValue = this.maxValue - this.minValue;
	var angle = (this.value/rangeValue) * rangeAngle + this.minAngle;

	angle = Math.PI * (angle / 180);

	return angle;
}

UIGaugePointer.prototype.paintSelfOnly = function(canvas) {
	var x = 0;
	var y = 0;
	var w = this.w;
	var h = this.h;
	var angle = this.getAngle();

	var image = this.getHtmlImageByType(UIGauge.IMAGE_POINTER);
	if(image && image.width) {
		var imageW = image.width;
		var imageH = image.height;

		canvas.translate(w/2, h/2);
		canvas.rotate(angle);
		canvas.translate(-w/2, -h/2);
		x = (w - imageW)/2;
		y = (h - imageH)/2;

		canvas.drawImage(image, x, y);
	}
	else {
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIGaugePointerCreator() {
	var args = ["ui-gauge-pointer", "ui-gauge-pointer", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGaugePointer();
		return g.initUIGaugePointer(this.type, 20, 200);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIGaugePointerCreator());
ShapeFactoryGet().addShapeCreator(new UIGaugeCreator());

/*
 * File:   ui-html.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  HTML 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIHtml
 * @extends UIElement
 * 主要用于在特殊情况下嵌入HTML代码。
 *
 * 注意：CanTK Runtime不支持HTML，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 */
function UIHtml() {
	return;
}

UIHtml.prototype = new UIElement();
UIHtml.prototype.isUIHtml = true;

UIHtml.prototype.saveProps = ["htmlContent"];
UIHtml.prototype.initUIHtml = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);

	return this;
}

UIHtml.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIHtml.prototype.drawBgImage =function(canvas) {
	if(this.mode === Shape.MODE_EDITING || this.isIcon) {
		var image = this.getBgImage();

		if(image) {
			var htmlImage = image.getImage();
			var srcRect = image.getImageRect();
			this.drawImageAt(canvas, htmlImage, this.images.display, 0, 0, this.w, this.h, srcRect);
		}
		else {
			canvas.beginPath();
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}
	}

	return;
}

UIHtml.prototype.setVisible = function(visible) {
	if(this.visible != visible) {
		if(visible) {
			this.onShowHTML();
		}
		else {
			this.onHideHTML();
		}
		this.visible = visible;
	}

	return this;
}

UIHtml.prototype.showHTMLElement = function() {
	var el = this.element;
	if(el) {
		var scale = this.getRealScale();
		var p = this.getPositionInView();
		var x = p.x * scale + this.view.getX();
		var y = p.y * scale + this.view.getY();
		var w = this.w * scale;
		var h = this.h * scale;

		UIElement.getMainCanvasScale(true);
		var scaleX = UIElement.canvasScale.x;
		var scaleY = UIElement.canvasScale.y;

		x /= scaleX;
		y /= scaleY;
		
		el.style.position = "absolute";
		el.style.left = x + "px";
		el.style.top = y + "px";
		el.style.width = w/scaleX + "px";
		el.style.height = h/scaleY + "px";
		el.style.visibility = 'visible';
		
		this.htmlVisible = true;
	}

	return;
}

UIHtml.prototype.createHTMLElement = function(name) {
	var element = null;
	if(!this.element) {
		element = document.createElement(name);
		element.id = this.type + this.name;
		document.body.appendChild(element);
		this.element = element;
	}

	return this.element;
}

UIHtml.prototype.beforeShowHTML = function() {
}

UIHtml.prototype.setScrollable = function(scrollable) {
	this.scrollable = scrollable;

	return;
}

UIHtml.prototype.onSetElementStyle = function() {
	var fontSize = Math.floor(this.scaleForCurrentDensity(14));

	this.element.style.fontSize = fontSize + "px";
	this.element.style.marginLeft = "0px";
	this.element.style.marginTop = "0px";
	this.element.style.marginBottom = "0px";
	this.element.style.marginRight = "0px";

	return;
}

UIHtml.prototype.onShowHTML = function() {
	this.reload();
}

UIHtml.prototype.reload = function() {
	if(this.mode !== Shape.MODE_EDITING) {
		this.createHTMLElement("div");
		this.element.innerHTML = this.getHtmlContent();
		this.element.style.overflow = this.scrollable ? "scroll" : "hidden";
		this.element.style.zIndex = 5;
		this.element.style["-ms-touch-action"] = "auto";

		this.onSetElementStyle();

		this.beforeShowHTML();
		this.showHTMLElement();
	}

	return;
}

UIHtml.prototype.beforeHideHTML = function() {
}

UIHtml.prototype.onHideHTML = function() {
	this.htmlVisible = false;
	if(this.element) {
		this.beforeHideHTML();
		this.element.style.visibility = 'hidden';
	}

	return;
}

UIHtml.prototype.getValue = function() {
	return this.value;
}

UIHtml.prototype.setValue = function(value) {
	this.value = value;

	return this;
}

UIHtml.prototype.setHtmlContent = function(htmlContent) {
	this.htmlContent = htmlContent;

	if(this.element) {
		this.element.innerHTML = htmlContent;
	}

	return this;
}

UIHtml.prototype.getHtmlContent = function() {
	return this.htmlContent;
}

/**
 * @property {String} innerHTML
 * html content。
 *
 *     @example small frame
 *     this.win.find("html").innerHTML = "hello";
 */
Object.defineProperty(UIElement.prototype, "innerHTML", {
	get: function () {
		return this.getHtmlContent();
	},
	set: function (value) {
		this.setHtmlContent(value);
		this.reload();
	},
	enumerable: false,
	configurable: true
});

function UIHtmlCreator(w, h) {
	var args = ["ui-html", "ui-html", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtml();
		return g.initUIHtml(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlCreator());
/*
 * File:   ui-vedio.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vedio 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIVideo
 * @extends UIElement
 * 主要用于嵌入视频。运行时可以通过setValue设置视频的URL。
 *
 * 注意：CanTK Runtime不支持视频，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 *     @example small frame
 *     var video = win.find("ui-video-general")
 *     video.setValue("http://www.w3school.com.cn/i/movie.ogg");
 *     video.reload();
 */
function UIVideo() {
	return;
}

UIVideo.prototype = new UIHtml();
UIVideo.prototype.isUIVideo = true;

UIVideo.prototype.getHtmlContent = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var src = this.value ? this.value : "";
	var loop = this.loop ? 'loop="loop" ' : "";
	var autoPlay = this.autoPlay ? 'autoplay="true" ' : "";
	var showControls = this.showControls ? 'controls="controls" ' :"";

	var html = '<video width="'+w+'" height="'+h+'" preload="true" '+ showControls + loop + autoPlay + 'src="'+src+'"></video>';

	return html;
}

UIVideo.prototype.beforeHideHTML = function() {
	video = this.getVideoElement();
	if(video.src && !video.puased) {
		video.pause();
	}

	return;
}

UIVideo.prototype.getVideoElement = function() {
	if(this.element) {
		var video = this.element.getElementsByTagName("video");
		return video.length ? video[0] : null;
	}

	return null;
}

UIVideo.prototype.setShowControls = function(value) {
	this.showControls = value;

	return;
}

UIVideo.prototype.isShowControls = function() {
	return this.showControls;
}

UIVideo.prototype.setLoop = function(value) {
	this.loop = value;

	return;
}

UIVideo.prototype.isLoop = function() {
	return this.loop;
}

UIVideo.prototype.setAutoPlay = function(value) {
	this.autoPlay = value;

	return;
}

UIVideo.prototype.isAutoPlay = function() {
	return this.autoPlay;
}

UIVideo.prototype.initUIVideo = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("http://www.w3school.com.cn/i/movie.ogg");
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIVideoCreator() {
	var args = ["ui-video", "ui-video", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVideo();
		return g.initUIVideo(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVideoCreator());

/*
 * File:   ui-flash.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Flash 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIFlash
 * @extends UIElement
 * 主要用于嵌入Flash。运行时可以通过setValue设置Flash的URL。
 *
 * 注意：CanTK Runtime不支持Flash，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 */
function UIFlash() {
	return;
}

UIFlash.prototype = new UIHtml();
UIFlash.prototype.isUIFlash = true;

UIFlash.prototype.getHtmlContent = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var src = this.value ? this.value : "";

	var html = '<object type="application/x-shockwave-flash" width="'+w+'" height="'+h+'"> <param name="movie" value="'+src+'" /> <param name="quality" value="high" /></object>';

	return html;
}

UIFlash.prototype.initUIFlash = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("test/5.swf");
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIFlashCreator() {
	var args = ["ui-flash", "ui-flash", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFlash();
		return g.initUIFlash(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIFlashCreator());

/*
 * File:   ui-html-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Html Image
 * 
 * Copyright (c) 2015 Tangram HD Inc.
 * 
 */

function UIHtmlImage() {
	return;
}

UIHtmlImage.prototype = new UIHtml();
UIHtmlImage.prototype.isUIHtmlImage = true;

UIHtmlImage.prototype.getHtmlContent = function() {
	var scale = this.getRealScale();
	var w = Math.round(scale * this.w);
	var h = Math.round(scale * this.h);
	var src = this.getImageSrcByType(UIElement.IMAGE_DEFAULT); 
	var str = '<img src="' + src + '" width=' + w + ' height=' + h + '>';

	return str;
}

UIHtmlImage.prototype.initUIHtmlImage = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIHtmlImageCreator() {
	var args = ["ui-html-image", "ui-html-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtmlImage();
		return g.initUIHtmlImage(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlImageCreator());

/*
 * File:   ui-image-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief: Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageView() {
	return;
}

UIImageView.prototype = new UIElement();
UIImageView.prototype.isUIImageView = true;

UIImageView.cachedImages = {};
UIImageView.IMAGE_STATE_PENDING = 0;
UIImageView.IMAGE_STATE_ERROR   = 1;
UIImageView.IMAGE_STATE_DONE    = 2;

imageViewInitCustomProp = function(me) {
}

imageThumbViewInitCustomProp = function(me) {
}

imageAnimationInitCustomProp = function(me) {
}

imageSlideViewInitCustomProp = function(me) {
}


UIImageView.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);
	o.userImages = this.getImages();

	return o;
}

UIImageView.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.cacheInvalid = true;

	if(js.userImages) {
		this.userImages = [];
		var arr = js.userImages.split("\n");

		var n = arr.length;
		for(var i = 0; i < n; i++) {
			var type = "image_" + (i+1);	
			var src = this.getImageSrcByType(type);
			if(src && src.length > 4) {
				this.userImages.push(src);
			}
		}
	}

	return;
}

UIImageView.prototype.initUIImageView = function(w, h) {
	this.setDefSize(w, h);
	this.userImages = [];
	
	this.onSized               = UIImageView.prototype.onSized;
	this.afterRelayout         = UIImageView.prototype.afterRelayout;
	this.setImages             = UIImageView.prototype.setImages;
	this.getImages             = UIImageView.prototype.getImages;
	this.setValue              = UIImageView.prototype.setValue;
	this.getValue              = UIImageView.prototype.getValue;
	this.ensureImages          = UIImageView.prototype.ensureImages;
	this.addUserImage          = UIImageView.prototype.addUserImage;
	this.doToJson              = UIImageView.prototype.doToJson;
	this.doFromJson            = UIImageView.prototype.doFromJson;
	this.onScaleForDensityDone = UIImageView.prototype.onScaleForDensityDone;

	imageViewInitCustomProp(this);

	return this;
}

UIImageView.createImage = function(src, onLoadDone) {
	var image = UIImageView.cachedImages[src];
	
	if(!image) {
		image = new Image();

		image.src = src;
		image.onLoadDoneListeners = [];

		function notifyImageLoadDone(image, result) {
			if(!image || !image.onLoadDoneListeners) {
				return;
			}

			for(var i = 0; i < image.onLoadDoneListeners.length; i++) {
				var onLoad = image.onLoadDoneListeners[i];
			
				onLoad(image, result);
			}

			image.onLoadDoneListeners.clear();

			return;
		}

		image.onload = function(e) {
			notifyImageLoadDone(this, true);
			this.loaded = true;
		}
		
		image.onabort = function(e) {
			notifyImageLoadDone(this, false);	
			this.failed = true;
			console.log("load " + this.src + " failed.");
		}
		
		image.onerror = function(e) {
			notifyImageLoadDone(this, false);	
			this.failed = true;
			console.log("load " + this.src + " failed.");
		}
	}
	else {
		console.log("Create Image From Cache: " + src);
	}

	if(onLoadDone) {
		if(image.loaded) {
			onLoadDone(image, true);
		}
		else if(image.failed) {
			onLoadDone(image, false);
		}
		else {
			image.onLoadDoneListeners.push(onLoadDone);
		}
	}

	return image;
}

UIImageView.drawImageAtCenter = function(ctx, image, x, y, w, h, keepRatio, clearColor) {
	if(clearColor) {
		ctx.fillStyle = clearColor;
		ctx.fillRect(x, y, w, h);
	}
	else {
		ctx.clearRect(x, y, w, h);
	}

	if(image && image.width > 0) {
		var dw = w;
		var dh = h;
		var sw = image.width;
		var sh = image.height;
		var imageW = image.width;
		var imageH = image.height;

		if(keepRatio) {
			var scaleX = dw/imageW;
			var scaleY = dh/imageH;
		
			if(scaleX < scaleY) {
				sw = Math.min(imageW, dw/scaleY);
			}
			else {
				sh = Math.min(imageH, dh/scaleX);
			}
		}

		ctx.drawImage(image, 0, 0, sw, sh, x, y, dw, dh);
	}

	return;
}

UIImageView.prototype.ensureImages = function() {
	if(!this.cacheInvalid) {
		return;
	}

	var imageview = this;
	function onLoadDone(image, result) {
		imageview.postRedraw();

		return;
	}

	this.cachedImages = [];
	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		var image = UIImageView.createImage(src, onLoadDone);

		this.cachedImages.push(image);
	}

	delete this.cacheInvalid;

	return;
}

UIImageView.prototype.afterRelayout = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.onSized = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.onScaleForDensityDone = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.addUserImage = function(src) {
	this.cacheInvalid = true;
	this.userImages.push(src);

	var key = "image_" + this.userImages.length;

	this.setImage(key, src);

	return;
}

UIImageView.prototype.getCurrentImage = function() {
	return this.curentImage;
}

UIImageView.prototype.getValue = function() {
	var image = this.getCurrentImage();

	return image ? image.src : null;
}

UIImageView.prototype.setValue = function(value) {
	//TODO
	return this;
}

UIImageView.prototype.setImages = function(srcs) {
	var display = this.images.display;
	var arr = srcs.split("\n");

	this.userImages = [];
	this.images = {};
	this.images.display = display;

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.addUserImage(iter);
		}
	}

	return;
}

UIImageView.prototype.getImages = function() {
	var srcs = "";
	var hostname = location.protocol + "//" + location.host + "/";

	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		src = src.replace(hostname, "");
		srcs = srcs + src + "\n";	
	}

	return srcs;
}
/*
 * File:   ui-scrollview.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function UIScrollView() {
	return this;
}

UIScrollView.prototype = new UIElement();
UIScrollView.prototype.isUIScrollView = true;

UIScrollView.prototype.afterChildAppended = function(shape) {
	shape.setCanRectSelectable(false, true);

	return true;
}

UIScrollView.prototype.initUIScrollView = function(type, border, bg) {
	this.initUIElement(type);	

	this.offset = 0;
	this.scrollBarOpacity = 0;
	this.setMargin(border, border);
	this.setSizeLimit(100, 100, 2000, 2000);
	this.setDefSize(300 + 2 * border, 300 + 2 * border);

	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator(2);

	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setScrollable("always");

	if(!bg) {
		this.style.setFillColor("#f0f0f0");
	}
	this.setCanRectSelectable(false, true);

	return this;
}

UIScrollView.prototype.setScrollable = function(scrollable) {
	this.scrollable = scrollable;

	return;
}

UIScrollView.prototype.fixChildSize = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.w = this.getWidth(true);
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.h = this.getHeight(true);
	}

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
		child.setUserResizable(false);
	}

	return;
}

UIScrollView.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage 
		|| shape.isUIList || shape.isUIGrid || shape.isUIProgressBar 
		|| shape.isUICheckBox || shape.isUIRadioBox || shape.isUIWaitBar 
		|| shape.isUIButtonGroup || shape.isUITips || shape.isUIGroup) {

		return true;
	}

	return false;
}

UIScrollView.prototype.onModeChanged = function() {
	this.offset = 0;

	return;
}

UIScrollView.prototype.scrollToEnd = function() {
	var range = this.getScrollRange();

	this.offset = range - this.h;

	return this;
}

UIScrollView.prototype.scrollTo = function(offset) {
	this.offset = Math.round(offset);
	
	return;
}

UIScrollView.prototype.scrollDelta = function(delta) {
	var offset = this.offset + delta;
	
	this.scrollTo(offset);

	return;
}

UIScrollView.prototype.scrollToPageDelta = function(pageOffset) {
	var pageIndex = Math.floor(this.offset/this.w) + pageOffset;
	
	this.scrollToPage(pageIndex);

	return;
}

UIScrollView.prototype.scrollToPage = function(pageIndex) {
	if(pageIndex < 0) {
		pageIndex = 0;
	}

	var offset = this.w * pageIndex;
	var distance = this.offset - offset;
	
	this.animScrollTo(distance, 300);

	return;
}


UIScrollView.prototype.isEventHandledByChild = function() {
	var status = UIElement.lastEvent.status;
	if(this.isUIVScrollView) {
		return status & UIElement.EVENT_VSCROLL_HANDLED;
	}
	else {
		return status & UIElement.EVENT_HSCROLL_HANDLED;
	}
}

UIScrollView.prototype.setEventHandled = function() {
	var status = this.isUIVScrollView ? UIElement.EVENT_VSCROLL_HANDLED : UIElement.EVENT_HSCROLL_HANDLED;
	this.setLastEventStatus(status);
	
	return this;
}

UIScrollView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	this.velocityTracker.clear();

	return;
}

UIScrollView.prototype.onDrag = function(offset) {
	return;
}

UIScrollView.prototype.isScrollable = function() {
	if(this.scrollable === "always") {
		return true;
	}
	else if(this.scrollable === "never") {
		return false;
	}
	else {
		var range = this.getScrollRange();
		var pageSize = this.getPageSize();

		return range > pageSize;
	}
}

UIScrollView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || !this.isScrollable()) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	this.scrollBarOpacity = 0;
	var delta = this.getScrollDelta(point);
	if(this.pointerDown && this.needScroll(point)) {
		this.scrollBarOpacity = 1.0;
		this.scrollDelta(-delta);
	}

	this.addMovementForVelocityTracker();
	this.onDrag(this.offset);

	return ;
}

UIScrollView.prototype.animScrollTo = function(distance, duration) {
	var scrollview = this;
	var date  = new Date();
	var startTime = date.getTime();
	var startOffset = this.offset;
	var endOffset = startOffset - distance;
	var range = this.getScrollRange();
	var pageSize = this.getPageSize();

	duration = duration < 400 ? 400 : duration;

	if(endOffset < 0) {
		duration = 600;
		distance = startOffset;
	}

	if(this.mode != Shape.MODE_EDITING) {
		if(endOffset > (range - pageSize)) {
			distance = startOffset - (range - pageSize);
		}
	}
	
	if(range <= pageSize) {
		endOffset = 0;
		distance = startOffset;
	}
	
	function scrollIt() {
		var now = new Date();
		var nowTime = now.getTime();
		var timePercent = (nowTime - startTime)/duration;
		var percent = scrollview.interpolator.get(timePercent);
		var offset = startOffset - distance * Math.min(percent, 1.0);

		if(timePercent < 1 && !scrollview.pointerDown) {
			setTimeout(scrollIt, 5);
			scrollview.scrollTo(offset);
			scrollview.scrollBarOpacity = 1 - percent;
		
		}
		else {
			var offset = startOffset - distance;
			scrollview.scrollBarOpacity = 0;
			scrollview.scrollTo(offset);
		}
		scrollview.postRedraw();

		return;
	}

	setTimeout(scrollIt, 5);

	return;
}

UIScrollView.prototype.whenScrollOutOfRange = function(offset) {
	return;
}

UIScrollView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || !this.isScrollable()) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	var delta = this.getScrolledSize();

	if(!this.needScroll(point)) {
		this.scrollBarOpacity = 0;

		return;
	}

	var duration = 0;
	var distance = 0;
	var velocity = this.getVelocity();

	var a = this.getPageSize();
	var t = velocity/a;
	var d = 0.5 * a * t * t;

	distance = Math.abs(d);
	duration = 2*distance/velocity;

	distance = delta < 0 ? -distance : distance;
	duration = Math.abs(duration);

	if(duration > 3) {
		duration = 3;
	}

	var startOffset = this.offset;
	var endOffset = startOffset - distance;
	
	var offset = this.offset;
	var bottom = offset + this.h;
	var range = this.getScrollRange();
	if(offset < 0) {
		this.whenScrollOutOfRange(offset);
	}
	else if(bottom > range) {
		this.whenScrollOutOfRange(bottom-range);
	}

	this.animScrollTo(distance, duration * 1000);

	return true;
}

UIScrollView.prototype.paintSelfOnly =function(canvas) {

	return;
}

/*
 * File:   ui-h-scroll-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Horizonal ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIHScrollView() {
	return;
}

UIHScrollView.prototype = new UIScrollView();
UIHScrollView.prototype.isUIHScrollView = true;

UIHScrollView.prototype.initUIHScrollView = function(type, border, bg) {
	this.initUIScrollView(type, border, bg);	
	this.setSizeLimit(100, 40, 2000, 2000);

	return this;
}

UIHScrollView.prototype.needScroll = function(point) {
	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	return (dx > 20 && dx > dy)  || (dx > 20 && this.mode != Shape.MODE_EDITING);
}

UIHScrollView.prototype.getScrolledSize = function() {
	return Math.floor(this.getMoveAbsDeltaX()); 
}

UIHScrollView.prototype.getScrollDelta = function(point) {
	return Math.floor(this.getMoveDeltaX()); 
}

UIHScrollView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().x;
}

UIHScrollView.prototype.getPageSize = function() {
	return this.w;
}

UIHScrollView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	var pageOffset = 0;
	var velocity = this.getVelocity();
	var delta = this.getScrolledSize();
	var absDelta = Math.abs(delta);

	if(absDelta > this.w/4 || velocity > this.w) {
		if(delta < 0) {
			pageOffset = 1;
		}
		else {
			pageOffset = -1;
		}
	}
	
	this.scrollToPageDelta(pageOffset);

	return true;
}

UIHScrollView.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left + this.offset), y : (point.y - this.top)};

	return p;
}

UIHScrollView.prototype.getScrollRange = function() {
	var range = 0;
	var r = this.calcChildrenRange();

	range = r.r - r.l;
	if(range < this.w) {
		 range = this.w;
	}
	range = Math.ceil(range/this.w) * this.w;

	return range;
}

UIHScrollView.prototype.fixChildPosition = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = this.offset + this.hMargin;	
		child.widthAttr = UIElement.WIDTH_SCALE;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = this.vMargin;
	}

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
	}

	return;
}

UIHScrollView.prototype.paintChildren = function(canvas) {
	var shape = null;
	var leftClip = this.offset;
	var rightClip = this.offset + this.w;

	canvas.save();
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.closePath();
	canvas.clip();

	canvas.beginPath();
	canvas.translate(-this.offset, 0);

	for(var i = 0; i < this.children.length; i++) {
		shape = this.children[i];
		if(!shape.visible) {
			continue;
		}
		if((shape.left + shape.w) < leftClip || shape.left > rightClip) {
			continue;
		}
		
		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}
	
	this.paintTargetShape(canvas);
	
	canvas.restore();
	
	return;
}

function UIHScrollViewCreator(border, bg) {
	var args = ["ui-h-scroll-view", "ui-h-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHScrollView();
		return g.initUIHScrollView(this.type, border, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHScrollViewCreator(0, null));

/*
 * File:   ui-v-scroll-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vertical ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollView() {
	return;
}

UIVScrollView.prototype = new UIScrollView();
UIVScrollView.prototype.isUIVScrollView = true;

UIVScrollView.prototype.initUIVScrollView = function(type, border, bg, scrollBarImg) {
	this.initUIScrollView(type, border, bg);	
	this.setSizeLimit(40, 100, 2000, 2000);
	this.setImage("scrollBarImg", scrollBarImg);
	this.rectSelectable = false;

	return this;
}


UIVScrollView.prototype.needScroll = function(point) {
	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	return (dy > 50 && dy > dx) || (dy > 50 && this.mode != Shape.MODE_EDITING);
}

UIVScrollView.prototype.getScrolledSize = function() {
	return Math.floor(this.getMoveAbsDeltaY()); 
}

UIVScrollView.prototype.getScrollDelta = function(point) {
	return Math.floor(this.getMoveDeltaY());
}

UIVScrollView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().y;
}

UIVScrollView.prototype.getPageSize = function() {
	return this.h;
}

UIVScrollView.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left), y : (point.y - this.top + this.offset)};

	return p;
}

UIVScrollView.prototype.getScrollRange = function() {
	var range = 0;
	var r = this.calcChildrenRange();

	range = r.b;
	if(range < this.h) {
		 range = this.h;
	}

	var n = (this.mode === Shape.MODE_EDITING) ? this.h : 10;

	range = Math.ceil(range/n) * n;

	return range;
}

UIVScrollView.prototype.fixChildPosition = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = this.hMargin;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = this.offset + this.vMargin;
		child.heightAttr = UIElement.HEIGHT_SCALE;
	}
	
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
	}

	return;
}

UIVScrollView.prototype.paintChildren = function(canvas) {
	var shape = null;
	var upClip = this.offset;
	var downClip = this.offset + this.h;

	canvas.save();
	canvas.beginPath();
	canvas.rect(this.getHMargin(), this.getVMargin(), this.getWidth(true), this.getHeight(true));
	canvas.closePath();
	canvas.clip();

	canvas.beginPath();
	canvas.translate(0, -this.offset);

	for(var i = 0; i < this.children.length; i++) {
		shape = this.children[i];
		if(!shape.visible) {
			continue;
		}
		if((shape.top + shape.h) < upClip || shape.top > downClip) {
			continue;
		}

		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}
	
	this.paintTargetShape(canvas);

	canvas.restore();
	
	return;
}

UIVScrollView.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);

	return;
}

UIVScrollView.prototype.drawScrollBar = function(canvas) {
	var image = this.getHtmlImageByType("scrollBarImg");

	if(!this.scrollBarOpacity || !image) {
		return;
	}

	var range = this.getScrollRange();
	var x = this.w - image.width - 2;
	var w = image.width;
	var h = this.h * this.h/range;
	var y = (this.offset / range) * this.h;

	if((y + h) > this.h) {
		h = this.h - y;
		y = this.h - h;
	}
	
	if(y < 0) {
		h = h + y;
		y = 0;
	}

	canvas.save();
	canvas.globalAlpha = this.scrollBarOpacity;
	drawNinePatchEx(canvas, image, 0, 0, image.width, image.height, x, y, w, h);
	canvas.restore();

	return;
}

function UIVScrollViewCreator(border, bg, scrollBarImg) {
	var args = ["ui-v-scroll-view", "ui-v-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollView();
		return g.initUIVScrollView(this.type, border, bg, scrollBarImg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVScrollViewCreator(0, null, null));

/*
 * File:   ui-list-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List View (Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollViewGeneral() {
	return;
}

UIVScrollViewGeneral.prototype = new UIVScrollView();
UIVScrollViewGeneral.prototype.isUIList = true;
UIVScrollViewGeneral.prototype.isUILayout = true;
UIVScrollViewGeneral.prototype.isUIVScrollViewGeneral = true;
UIVScrollViewGeneral.prototype.sortChildren = UIList.prototype.sortChildren;

UIVScrollViewGeneral.prototype.initUIVScrollViewGeneral = function(type) {
	this.initUIVScrollView(type, 0, null, null);	
	this.setTextType(Shape.TEXT_NONE);

	return this;
}

UIVScrollViewGeneral.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}
	var border = this.getVMargin();
	var n = this.children.length;
	
	var y = border;
	for(var i = 0; i < n; i++) {
		var child = this.children[i];
		if(!child.visible) {
			continue;
		}
		
		child.yAttr = UIElement.Y_FIX_TOP;
		child.heightAttr = UIElement.HEIGHT_FIX;
		child.relayout();
		child.top = y;
		
		y += child.h;
	}

	return;
}

UIVScrollViewGeneral.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);
	
	if(this.mode === Shape.MODE_EDITING) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIVScrollViewGeneralCreator() {
	var args = ["ui-g-scroll-view", "ui-g-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollViewGeneral();
		return g.initUIVScrollViewGeneral(this.type);
	}
	
	return;
}

/*
 * File:   ui-scroll-view-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scroll View X 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIScrollViewX
 * @extends UIElement
 * 滚动视图。使用时先设置虚拟高度和宽度，虚拟高度小于实际高度时，上下不滚动，虚拟宽度小于实际宽度时，左右不滚动。
 *
 * 在IDE中，拖动滚动视图是改变滚动视图的可视区，要拖动滚动视图本身请使用滚动视图下方的拖动手柄，或者使用方向键，或者直接修改它的坐标。
 *
 * 往滚动视图中添加子控件时，先将控件放到滚动视图的可视区，然后拖动到其它区域。
 */
function UIScrollViewX() {
	return;
}

UIScrollViewX.prototype = new UIElement();
UIScrollViewX.prototype.isUIScrollViewX = true;
UIScrollViewX.prototype.isUIScrollView = true;
UIScrollViewX.prototype.saveProps = ["virtualWidth", "virtualHeight", "showOutside", "scrollAnimationDuration", "scrollBgImage"];

UIScrollViewX.prototype.initUIScrollViewX = function(type) {
	this.initUIElement(type);

	this.ox = 0;
	this.oy = 0;
	this.scrollAnimationDuration = 800;
	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator(2);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.addEventNames(["onScrolling", "onScrollDone"]);

	return this;
}

UIScrollViewX.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

/**
 * @property {Number} virtualWidth 
 * 虚拟宽度。  
 */

/**
 * @property {Number} virtualHeight
 * 虚拟高度。  
 */

/**
 * @property {Number} xOffset 
 * X方向偏移量。  
 */

/**
 * @property {Number} yOffset 
 * X方向偏移量。  
 */

UIScrollViewX.prototype.setVirtualWidth = function(virtualWidth) {
	this.vw = virtualWidth;
	return this; 
}

UIScrollViewX.prototype.setVirtualHeight = function(virtualHeight) {
	this.vh = virtualHeight;
	return this;
}

UIScrollViewX.prototype.getVirtualWidth = function() {
	return Math.max(this.vw, this.w);
}

UIScrollViewX.prototype.getVirtualHeight = function() {
	return Math.max(this.vh, this.h);
}

UIScrollViewX.prototype.getXOffset = function() {
	return this.ox;
}

UIScrollViewX.prototype.getYOffset = function() {
	return this.oy;
}

UIScrollViewX.prototype.fixXOffset = function(xOffset) {
	return Math.min(Math.max(0, xOffset), this.getVirtualWidth()-this.w) >> 0;
}

UIScrollViewX.prototype.fixYOffset = function(yOffset) {
	return Math.min(Math.max(0, yOffset), this.getVirtualHeight()-this.h) >> 0;
}

UIScrollViewX.prototype.setXOffset = function(xOffset) {
	this.ox = this.fixXOffset(xOffset);

	return this;
}

UIScrollViewX.prototype.setYOffset = function(yOffset) {
	this.oy = this.fixYOffset(yOffset);

	return this;
}

UIScrollViewX.prototype.setOffset = function(xOffset, yOffset, noCheck) {
	if(noCheck) {
		this.ox = xOffset >> 0;
		this.oy = yOffset >> 0;
	}else{
		this.setXOffset(xOffset);
		this.setYOffset(yOffset);
	}
	this.callOnScrollingHandler(this.ox, this.oy);

	return this;
}

Object.defineProperty(UIScrollViewX.prototype, "xOffset", {get:UIScrollViewX.prototype.getXOffset, set:UIScrollViewX.prototype.setXOffset});
Object.defineProperty(UIScrollViewX.prototype, "yOffset", {get:UIScrollViewX.prototype.getYOffset, set:UIScrollViewX.prototype.setYOffset});
Object.defineProperty(UIScrollViewX.prototype, "virtualWidth", 
	{get:UIScrollViewX.prototype.getVirtualWidth, set:UIScrollViewX.prototype.setVirtualWidth});
Object.defineProperty(UIScrollViewX.prototype, "virtualHeight", 
	{get:UIScrollViewX.prototype.getVirtualHeight, set:UIScrollViewX.prototype.setVirtualHeight});

UIScrollViewX.prototype.dragStart = function() {
	this.saveOX = this.ox;
	this.saveOY = this.oy;

	this.velocityTracker.clear();
}

UIScrollViewX.prototype.drag = function() {
	this.addMovementForVelocityTracker();
	var ox = this.saveOX - this.getMoveAbsDeltaX();
	var oy = this.saveOY - this.getMoveAbsDeltaY();

	if(this.getVirtualWidth() <= this.w) {
		ox = 0;
	}

	if(this.getVirtualHeight() <= this.h) {
		oy = 0;
	}

	this.setOffset(ox, oy, true);

	return;
}

UIScrollViewX.prototype.dragEnd = function() {
	var duration = this.scrollAnimationDuration;
	var velocity = this.velocityTracker.getVelocity();
	
	if(!duration || duration < 10) {
		return;
	}

	var t = duration/1000;
	var vx = velocity.x;
	var vy = velocity.y;
	var xd = 0.5 * vx * t;
	var yd = 0.5 * vy * t;
	var xs = this.ox;
	var ys = this.oy;
	var xe = Math.min(Math.max(0, xs - xd), this.virtualWidth  - this.w);
	var ye = Math.min(Math.max(0, ys - yd), this.virtualHeight - this.h);

	if(Math.abs(xd) < 10 && Math.abs(yd) < 10) {
		this.callOnScrollDoneHandler(this.ox, this.oy);
		return;
	}

	this.scrollTo(xe, ye, duration);

	return;
}

/**
 * @method scrollToPercent
 * 滚动到指定位置。
 * @param {Number} xOffsetPercent X方向偏移量百分比(0,100)。
 * @param {Number} yOffsetPercent Y方向偏移量百分比(0,100)。
 * @param {Number} duration 滚动时间(毫秒)。
 * @return {UIElement} 返回控件本身。
 */
UIScrollViewX.prototype.scrollToPercent = function(xOffsetPercent, yOffsetPercent, duration) {
	var xOffset = (this.virtualWidth - this.w) * (xOffsetPercent/100);
	var yOffset = (this.virtualHeight - this.h) * (yOffsetPercent/100);

	return this.scrollTo(xOffset, yOffset, duration);
}

/**
 * @event onScrolling
 * 滚动事件。
 * @param {Number} xOffset x偏移量。
 * @param {Number} yOffset y偏移量。
 */

/**
 * @event onScrollDone
 * 滚动完成事件。
 * @param {Number} xOffset x偏移量。
 * @param {Number} yOffset y偏移量。
 */

/**
 * @method scrollTo
 * 滚动到指定位置。
 * @param {Number} xOffset X方向偏移量。
 * @param {Number} yOffset Y方向偏移量。
 * @param {Number} duration 滚动时间(毫秒)。
 * @return {UIElement} 返回控件本身。
 */
UIScrollViewX.prototype.scrollTo = function(xOffset, yOffset, duration) {
	var xs = this.ox;
	var ys = this.oy;
	var xe = this.fixXOffset(xOffset);
	var ye = this.fixYOffset(yOffset);
	
	if(!duration) {
		this.setOffset(xOffset, yOffset);
		this.callOnScrollDoneHandler(this.ox, this.oy);

		return this;
	}

	var xd = xe - xs;
	var yd = ye - ys;
	var startTime = Date.now();

	function step(now) {
		var tPercent = (now - startTime)/duration;
		if(tPercent >= 1) {
			tPercent = 1;
			this.setStepScroll(null);
		}
		if(this.pointerDown) {
			this.setStepScroll(null);
		}

		var percent = this.interpolator.get(tPercent);
		var ox = xs + xd * percent;
		var oy = ys + yd * percent;
		this.setOffset(ox, oy, true);
		
		if(tPercent >= 1) {
			this.callOnScrollDoneHandler(this.ox, this.oy);
		}
	}

	this.setStepScroll(step);

	return this;
}

UIScrollViewX.prototype.setStepScroll = function(stepScroll) {
	this.stepScroll = stepScroll;

	return this;
}

UIScrollViewX.prototype.stepAnimation = function(canvas, now) {
	UIElement.prototype.stepAnimation.call(this, canvas, now);
	if(this.stepScroll) {
		this.stepScroll(now || canvas.now || Date.now());
	}

	return this;
}

UIScrollViewX.prototype.isDraggable = function() {
	if(this.mode === Shape.MODE_EDITING) {
		return !this.getTarget() || this.view.isAltDown();
	}
	else {
		return true;
	}
}

UIScrollViewX.prototype.onPointerDownRunning = UIScrollViewX.prototype.onPointerDownEditing = function(point, beforeChild) {
	if(!beforeChild && this.isDraggable()) {
		this.dragStart();
		return true;
	}
	return false;
}

UIScrollViewX.prototype.onPointerMoveRunning = UIScrollViewX.prototype.onPointerMoveEditing = function(point, beforeChild) {
	if(!beforeChild && this.pointerDown && this.isDraggable()){ 
		this.drag();
		return true;
	}
	return false;
}

UIScrollViewX.prototype.onPointerUpRunning = UIScrollViewX.prototype.onPointerUpEditing = function(point, beforeChild) {
	if(!beforeChild && this.pointerDown && this.isDraggable()) {
		this.dragEnd();
		return true;
	}
	return false;
}

UIScrollViewX.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left + this.xOffset), y : (point.y - this.top + this.yOffset)};

	return p;
}

UIScrollViewX.prototype.onClip = function(canvas) {
	if(this.showOutside && this.mode === Shape.MODE_EDITING) {
		return this;
	}

	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.closePath();
	canvas.clip();
	canvas.beginPath();

	return this;
}

UIScrollViewX.prototype.isChildVisibleRecursive = function(child) {
	if(child.children && child.children.length) {
		return true;
	}

	return false;
}

UIScrollViewX.prototype.isChildVisible = function(canvas, child) {
	var l = this.ox;
	var r = l + this.w;
	var t = this.oy;
	var b = t + this.h;

	if(!child.visible) {
		return false;
	}
	
	if(this.showOutside) {
		return true;
	}

	if(this.isChildVisibleRecursive(child)) {
		return true;
	}

	if((child.top + child.h) < t || child.top > b || (child.left + child.w) < l || child.left > r) {
		return false;
	}

	return true;
}

UIScrollViewX.prototype.paintChildren = function(canvas) {
	var l = this.ox;
	var t = this.oy;
	var children = this.children;
	var n = children.length;

	canvas.save();
	
	canvas.translate(-l, -t);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(this.isChildVisible(canvas, iter)) {
			this.beforePaintChild(iter, canvas);
			iter.paintSelf(canvas);
			this.afterPaintChild(iter, canvas);
		}
	}
	
	canvas.restore();
	
	return;
}

UIScrollViewX.prototype.afterPaintChildren = function(canvas) {};

UIScrollViewX.prototype.dispatchPointerDownToChildren = function(p) {
	if(!this.hitTestResult && !this.showOutside) {
		return false;
	}

	if(this.mode === Shape.MODE_EDITING && this.view.isAltDown()) {
		return false;
	}

	return this.defaultDispatchPointerDownToChildren(p);
}

function UIScrollViewXCreator() {
	var args = ["ui-scroll-view-x", "ui-scroll-view-x", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScrollViewX();
		return g.initUIScrollViewX(this.type);
	}
	
	return;
}

UIScrollViewX.prototype.drawBgImageScroll = function(canvas, display, image, rect) {
	switch(display) {
		case WImage.DISPLAY_SCALE: {
			var scaleX = rect.w/this.virtualWidth;
			var scaleY = rect.h/this.virtualHeight;
			var sx = this.xOffset * scaleX;
			var sy = this.yOffset * scaleY;
			var sw = this.w * scaleX;
			var sh = this.h * scaleY;
		
			canvas.drawImage(image, sx, sy, sw, sh, 0, 0, this.w, this.h);
			break;
		}
		case WImage.DISPLAY_TILE: {
			var dx = Math.floor(this.xOffset/rect.w) * rect.w - this.xOffset;
			var dy = Math.floor(this.yOffset/rect.h) * rect.h - this.yOffset
			var dw = Math.ceil((this.w - dx)/rect.w) * rect.w;
			var dh = Math.ceil((this.h - dy)/rect.h) * rect.h;
			canvas.beginPath();
			canvas.rect(0, 0, this.w, this.h);
			canvas.clip();
			canvas.beginPath();

			WImage.draw(canvas, image, display, dx, dy, dw, dh, rect);
			break;
		}
		default:break;
	}

	return this;
}

UIScrollViewX.prototype.afterChildAppended = function(shape) {
	shape.xAttr		= UIElement.X_FIX_LEFT;
	shape.yAttr		= UIElement.Y_FIX_TOP;
	shape.widthAttr	= UIElement.WIDTH_FIX;
	shape.heightAttr= UIElement.HEIGHT_FIX;

	return true;
}

UIScrollViewX.prototype.drawBgImage = function(canvas) {
	if(this.scrollBgImage) {
		var wImage = this.getBgImage();
		if(wImage) {
			var image = wImage.getImage();
			var rect = wImage.getImageRect();
			if(image && rect) {
				this.drawBgImageScroll(canvas, this.images.display, image, rect);
			}
		}
	}
	else {
		UIElement.prototype.drawBgImage.call(this, canvas);
	}
}

ShapeFactoryGet().addShapeCreator(new UIScrollViewXCreator());

/*
 * File:   ui-grid-view-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  GridView
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGridViewX
 * @extends UIScrollViewX
 * 网格视图，里面的子控件按行列排列，每个子控件大小相同。可以水平滚动，也可以垂直滚动。
 * 
 * 设计时按住Alt可以拖动可视区，调节子控件的zIndex可以设置子控件的顺序。
 *
 */
function UIGridViewX() {
	return;
}

UIGridViewX.prototype = new UIScrollViewX();
UIGridViewX.prototype.isUILayout = true;
UIGridViewX.prototype.isUIGridViewX = true;
UIGridViewX.prototype.saveProps = UIScrollViewX.prototype.saveProps.concat(["cols","rows","isVertical"]);

UIGridViewX.prototype.initUIGridViewX = function(type) {
	this.initUIScrollViewX(type);	

	this.rows = 3;
	this.cols = 3;
	this.setMargin(0, 0);
	this.setDefSize(200, 200);

	return this;
}

/**
 * @method setVertical
 * 设置网格视图的滚动方向。
 * @param {Boolean} value true表示垂直滚动，false表示水平滚动。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setVertical = function(value) {
	this.isVertical = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getVertical
 * 获取网格视图的滚动方向。
 * @return {Boolean} 滚动方向。true表示垂直滚动，false表示水平滚动。
 *
 */
UIGridViewX.prototype.getVertical = function() {
	return this.isVertical;
}

/**
 * @method setRows
 * 设置可视区行数，主要用于控制行高。对于水平滚动的网格视图，这个行数与实际行数一致，对于垂直滚动的网格视图，这个行数与实际行数无关。
 * @param {Number} value 行数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setRows = function(value) {
	this.rows = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getRows
 * 获取行数。
 * @return {Number} 返回行数。
 *
 */
UIGridViewX.prototype.getRows = function() {
	return this.rows;
}

/**
 * @method setCols
 * 设置可视区列数，主要用于控制列宽。对于垂直滚动的网格视图，这个列数与实际列数一致，对于水平滚动的网格视图，这个列数与实际列数无关。
 * @param {Number} value 列数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setCols = function(value) {
	this.cols = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getCols
 * 获取列数。
 * @return {Number} 返回列数。
 *
 */
UIGridViewX.prototype.getCols = function() {
	return this.cols;
}

UIGridViewX.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

UIGridViewX.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var cols = this.cols;
	var rows = this.rows;
	var iw = this.w/cols;
	var ih = this.h/rows;

	var r = 0;
	var c = 0;
	var arr = this.children;
	var n = arr.length;
	for(var i = 0; i < n; i++) {
		var iter = arr[i];
		
		if(this.isVertical) {
			c = i%cols;
			r = Math.floor(i/cols);
		}
		else {
			r = i%rows;
			c = Math.floor(i/rows);
		}
		iter.left = c * iw;
		iter.top = r * ih;
		iter.w = iw;
		iter.h = ih;
		iter.z = i * 10;
		iter.setUserMovable(false);
		iter.setUserResizable(false);
	}

	if(this.isVertical) {
		this.vw = this.w;
		this.vh = Math.ceil(n/this.cols) * ih;
		if(this.mode === Shape.MODE_EDITING) {
			this.vh += ih;
		}
	}
	else {
		this.vh = this.h;
		this.vw = Math.ceil(n/this.rows) * iw;
		if(this.mode === Shape.MODE_EDITING) {
			this.vw += iw;
		}
	}

	return;
}

UIGridViewX.prototype.isChildVisibleRecursive = function(child) {
	return false;
}

UIGridViewX.prototype.isDraggable = function() {
	if(this.mode === Shape.MODE_EDITING) {
		var target = this.getTarget();
		return !target || !target.getTarget() || this.view.isAltDown();
	}
	else {
		return true;
	}
}

function UIGridViewXCreator(border) {
	var args = ["ui-grid-view-x", "ui-grid-view-x", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGridViewX();
		return g.initUIGridViewX(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridViewXCreator());

/*
 * File:   ui-shortcut.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  ShortCut 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIShortcut() {
	return;
}

UIShortcut.prototype = new UIElement();
UIShortcut.prototype.isUIShortcut = true;

UIShortcut.prototype.initUIShortcut = function(type) {
	this.initUIElement(type);	

	this.setText("#ABCDEFGHIJKLMNOPQRSTUVYWXYZ");
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIShortcut.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIShortcut.prototype.drawText = function(canvas) {
	var text = this.text;
	var n = text.length;

	if(!n) {
		return;
	}

	canvas.textBaseline = "middle";
	canvas.textAlign = "center";
	canvas.font = this.style.getFont();

	var x = this.w >> 1;
	var y = this.vMargin;
	var w = this.getWidth(true);

	var ih = this.getHeight(true)/n;
	var ihh = ih >> 1;

	canvas.lineWidth = this.style.lineWidth;
	canvas.strokeStyle = this.style.lineColor;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];

		if(this.currentItem === i) {
			canvas.rect(0, y, this.w, ih);
			if(this.pointerDown) {
				canvas.fillStyle = this.style.fillColor;
				canvas.fill();
			}
			
			canvas.stroke();
		}

		canvas.fillStyle = this.style.textColor;
		canvas.fillText(c, x, y + ihh);

		y += ih;
	}

	return;
}

UIShortcut.prototype.findItemByPoint = function(point) {
	var text = this.text;
	var vMargin = this.vMargin;
	var h = this.getHeight(true);
	var index = Math.floor(text.length * (point.y-vMargin)/h);

	return index;
}

UIShortcut.prototype.changeItemByPoint = function(point) {
	var text = this.text;
	var index = this.findItemByPoint(point);

	if(index >= 0 && index < text.length) {
		var value = text[index];

		if(this.currentItem != index) {
			this.callOnChangedHandler(value);
			this.currentItem = index;
		}
	}

	return;
}

UIShortcut.prototype.setValue = function(value) {
	var index = this.text.indexOf(value);
	if(index >= 0) {
		if(this.currentItem != index) {
			this.currentItem = index;
			this.callOnChangedHandler(value);
		}
	}

	return;
}

UIShortcut.prototype.getValue = function() {
	if(this.text && this.currentItem >= 0 && this.currentItem < this.text.length) {
		return this.text[this.currentItem];
	}
	else {
		return "";
	}
}

UIShortcut.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || !this.text) {
		return;
	}

	this.changeItemByPoint(point);

	return;
}

UIShortcut.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || !this.text) {
		return;
	}

	if(this.pointerDown) {
		this.changeItemByPoint(point);
	}

	return;
}

function UIShortcutCreator() {
	var args = ["ui-shortcut", "ui-shortcut", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIShortcut();
		return g.initUIShortcut(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIShortcutCreator());

/*
 * File:   ui-scroll-text.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scroll Text
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIScrollText() {
	return;
}

UIScrollText.prototype = new UIElement();
UIScrollText.prototype.isUIScrollText = true;

UIScrollText.prototype.initUIScrollText = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onScrollDone"]);

	return this;
}

UIScrollText.prototype.onModeChanged = function() {
	this.offsetX = 0;
	this.offsetY = 0;

	return;
}

UIScrollText.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIScrollText.prototype.getAnimationDuration = function() {
	return this.animationDuration ? this.animationDuration : 1000;
}

UIScrollText.prototype.setAnimationDuration = function(animationDuration) {
	this.animationDuration = animationDuration;

	return;
}

UIScrollText.prototype.getPauseDuration = function() {
	return this.pauseDuration ? this.pauseDuration : 0;
}

UIScrollText.prototype.setPauseDuration = function(pauseDuration) {
	this.pauseDuration = pauseDuration;

	return;
}

UIScrollText.prototype.startVScroll = function() {
	var scrolltext = this;
	var textHeight = this.getTextHeight();
	var lineHeight = this.getLineHeight(true);

	if(textHeight <= this.h) {
		return;
	}

	this.offsetX = 0;
	this.offsetY = 0;
	var startTime = 0;
	var startOffset = 0;
	var duration = this.getAnimationDuration();
	var pauseDuration = this.getPauseDuration();
	this.h = Math.floor(this.h/lineHeight) * lineHeight;

	var range = -this.h;
	var firstTime = true;
	var interpolator =  new DecelerateInterpolator();

	function animStep() {
		if(firstTime) {
			firstTime = false;
			startTime = (new Date()).getTime();
		}

		if(!scrolltext.isVisible()) {
			return;
		}
	
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = pauseDuration > 0 ? interpolator.get(timePercent) : timePercent;
		delete now;

		if(timePercent < 1) {
			scrolltext.offsetY = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			scrolltext.offsetY = startOffset + range;

			if(Math.abs(scrolltext.offsetY) < (textHeight-scrolltext.h)) {
				firstTime = true;

				startOffset = scrolltext.offsetY;
				setTimeout(animStep, pauseDuration);
			}
			else {
				delete interpolator;
				scrolltext.callOnScrollDoneHandler();
			}

			delete startTime;
		}

		delete now;
		scrolltext.postRedraw();
	}

	setTimeout(animStep, pauseDuration);

	return;
}

UIScrollText.prototype.startHScroll = function() {
	var scrolltext = this;
	var textWidth = this.textWidth;

	if(textWidth <= this.w) {
		return;
	}

	this.offsetX = 0;
	this.offsetY = 0;
	var startTime = 0;
	var startOffset = 0;
	var duration = this.getAnimationDuration();
	var pauseDuration = this.getPauseDuration();

	var range = -this.w;
	var firstTime = true;
	var interpolator =  new DecelerateInterpolator();

	function animStep() {
		if(firstTime) {
			firstTime = false;
			startTime = (new Date()).getTime();
		}

		if(!scrolltext.isVisible()) {
			return;
		}
	
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = pauseDuration > 0 ? interpolator.get(timePercent) : timePercent;

		if(timePercent < 1) {
			scrolltext.offsetX = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			scrolltext.offsetX = startOffset + range;

			if(Math.abs(scrolltext.offsetX) < (textWidth-scrolltext.w)) {
				firstTime = true;

				startOffset = scrolltext.offsetX;
				setTimeout(animStep, pauseDuration);
			}
			else {
				delete startTime;
				scrolltext.callOnScrollDoneHandler();
			}
		}

		delete now;
		scrolltext.postRedraw();
	}

	setTimeout(animStep, pauseDuration);

	return;
}

UIScrollText.prototype.startScroll = function() {
	if(!this.isVisible()) {
		return;
	}

	if(this.type === "ui-vscroll-text") {
		this.startVScroll();
	}
	else {
		this.startHScroll();
	}

	return;
}

UIScrollText.prototype.onInit = function() {
	this.offsetX = 0;
	this.offsetY = 0;

	var scrolltext = this;
	setTimeout(function() {
			scrolltext.startScroll();
		}, 1000);

	return;
}

UIScrollText.prototype.drawText = function(canvas) {
	var offsetX = this.offsetX ? this.offsetX : 0;
	var offsetY = this.offsetY ? this.offsetY : 0;

	canvas.save();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.translate(offsetX, offsetY);
    canvas.beginPath();
    canvas.font = this.style.getFont();
    canvas.fillStyle = this.style.textColor;
    canvas.strokeStyle = this.style.lineColor;
    canvas.lineWidth = 1;

	if(this.type === "ui-vscroll-text") {
		this.drawMLText(canvas, false, true);
	}
	else {
		this.textWidth = this.draw1LText(canvas, true);
	}
	canvas.restore();

	return;
}

function UIScrollTextCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScrollText();
		
		return g.initUIScrollText(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIScrollTextCreator("ui-vscroll-text", 200, 200));
ShapeFactoryGet().addShapeCreator(new UIScrollTextCreator("ui-hscroll-text", 200, 50));

/*
 * File:   ui-list.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIList
 * @extends UIElement
 * 列表。每一行是一个UIListItem控件，UIListItem的高度可以固定也可以变化。
 *
 */
function UIList() {
	return;
}

UIList.prototype = new UIElement();
UIList.prototype.isUIList = true;
UIList.prototype.isUILayout = true;

UIList.prototype.saveProps = ["spacer", "itemHeightVariable", "itemDraggable", "itemHeight"];
UIList.prototype.initUIList = function(type, border, itemHeight, bg) {
	this.initUIElement(type);	

	this.setMargin(border, border);
	this.setSizeLimit(100, 100, 1000, 1000);
	this.setDefSize(400, itemHeight * 3 + 2 * border);

	this.spacer = 0;
	this.itemHeight = itemHeight;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.rectSelectable = false;
	this.itemHeightVariable = false;
	this.addEventNames(["onInit"]);

	if(!bg) {
		this.style.setFillColor("White");
	}

	return this;
}

UIList.prototype.getItemHeight = function() {
	return this.itemHeight;
}

UIList.prototype.setItemHeight = function(itemHeight) {
	this.itemHeight = itemHeight;

	return;
}

UIList.prototype.shapeCanBeChild = function(shape) {
	if(!shape.isUIListItem) {
		return false;
	}

	return true;
}

UIList.prototype.childIsBuiltin = function(child) {
	return child.name === "ui-list-item-update-status" 
		|| child.name === "ui-list-item-update-tips"
		|| child.name === "ui-last"
		|| child.name.indexOf("prebuild") >= 0
		|| child.name.indexOf("builtin") >= 0;
}

UIList.FIRST_ITEM = -1;
UIList.LAST_ITEM =   1;
UIList.MIDDLE_ITEM = 0;
UIList.SINGLE_ITEM = 2;

UIList.prototype.fixListItemImage = function(item, position) {
	var images = item.images;
	for(var key in images) {
		var value = images[key];
		if(key != "display") {
			var src = value.getImageSrc();
			if(!src) {
				continue;
			}

			switch(position) {
				case UIList.FIRST_ITEM: {
					src = src.replace(/\.single\./, ".first.");
					src = src.replace(/\.middle\./, ".first.");
					src = src.replace(/\.last\./, ".first.");
					break;
				}
				case UIList.MIDDLE_ITEM: {
					src = src.replace(/\.single\./, ".middle.");
					src = src.replace(/\.first\./, ".middle.");
					src = src.replace(/\.last\./, ".middle.");
					break;
				}
				case UIList.LAST_ITEM: {
					src = src.replace(/\.single\./, ".last.");
					src = src.replace(/\.first\./, ".last.");
					src = src.replace(/\.middle\./, ".last.");
					break;
				}
				case UIList.SINGLE_ITEM: {
					src = src.replace(/\.first\./, ".single.");
					src = src.replace(/\.middle\./, ".single.");
					src = src.replace(/\.last\./, ".single.");
					break;
				}
			}

			value.setImageSrc(src);
		}
	}

	return;
}

UIList.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var w = this.getWidth(true);
	var itemHeight = this.getItemHeight();
	var h = itemHeight;
	var itemHeightVariable = this.itemHeightVariable;

	var i = 0;
	var spacer = this.spacer;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];

		var config = {};
		var animatable = false;
		
		if(child.removed || !child.visible) continue;

		if(itemHeightVariable || child.isHeightVariable()) {
			h = child.measureHeight(itemHeight);
		}
		else {
			h = itemHeight;
		}

		if(n === 1) {
			this.fixListItemImage(child, UIList.SINGLE_ITEM);
		}
		else if(i === 0) {
			this.fixListItemImage(child, UIList.FIRST_ITEM);	
		}
		else if(i === (n - 1)) {
			this.fixListItemImage(child, UIList.LAST_ITEM);	
		}
		else {
			this.fixListItemImage(child, UIList.MIDDLE_ITEM);	
		}

		if(this.h <= (y + vMargin + h)) {
			this.h = y + vMargin + h;
		}

		
		animatable =  (y < this.h) && (animHint || this.mode === Shape.MODE_EDITING);
		if(animatable) {
			child.setSize(w, h);
			config.xStart = child.left;
			config.yStart = child.top;
			config.wStart = child.w;
			config.hStart = child.h;
			config.xEnd = x;
			config.yEnd = y;
			config.wEnd = w;
			config.hEnd = h;

			config.delay = 10;
			config.duration = 500;
			config.element = child;
			config.onDone = function (name) {
				this.relayoutChildren();
			}
			
			child.animate(config);
		}
		else {
			child.move(x, y);
			child.setSize(w, h);
			child.relayoutChildren();
		}

		child.setUserMovable(true);
	
		child.widthAttr = UIElement.WIDTH_FILL_PARENT;
		if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
			child.heightAttr = UIElement.HEIGHT_FIX;
		}
		child.setUserResizable(itemHeightVariable || child.isHeightVariable());
		if(!this.isUIScrollView) {
			child.setDraggable(this.itemDraggable);
		}

		y += h + spacer;
		i++;
	}

	return;
}

UIList.prototype.beforePaintChildren = function(canvas) {
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	return;
}

UIList.prototype.afterPaintChildren = function(canvas) {
	return;
}

UIList.prototype.afterChildAppended = function(shape) {
	if(shape.view && this.mode === Shape.MODE_EDITING && shape.isCreatingElement()) {
		this.sortChildren();
	}
	this.moveMustBeLastItemToLast();
	shape.setUserMovable(true);
	shape.setUserResizable(false);
	shape.setCanRectSelectable(false, true);
	shape.autoAdjustHeight = this.itemHeightVariable;
	shape.setDraggable(this.itemDraggable);
	this.relayoutChildren();

	return true;
}

UIList.prototype.sortChildren = function() {}

UIList.prototype.onKeyUpRunning = function(code) {
	var targetShapeIndex = 0;

	if(!this.children.length) {
		return;
	}

	switch(code) {
		case KeyEvent.DOM_VK_UP: {
			targetShapeIndex = this.children.indexOf(this.targetShape) - 1;
			break;
		}
		case KeyEvent.DOM_VK_DOWN: {
			targetShapeIndex = this.children.indexOf(this.targetShape) + 1;
			break;
		}
		default: {
			return;
		}
	}

	var n = this.children.length;
	targetShapeIndex = (targetShapeIndex + this.children.length)%n;
	var targetShape = this.children[targetShapeIndex];

	this.setTarget(targetShape);
	this.postRedraw();

	if(this.isUIListView) {
		if(this.offset > targetShape.top) {
			this.offset = targetShape.top;
		}

		if((this.offset + this.h) < (targetShape.top + targetShape.h)) {
			this.offset = targetShape.top - (this.h - targetShape.h);
		}
	}

	return;
}

UIList.prototype.onKeyDownRunning = function(code) {
}

UIList.prototype.getValue = function() {
	var ret = null;
	var n = this.children.length;
	if(n < 1) return ret;
	
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(!iter.isUIListCheckableItem || !iter.value) continue;

		if(iter.isRadio) {
			return i;	
		}
		else {
			if(!ret) ret = [];
			ret.push(i);
		}
	}

	return ret;
}

UIList.prototype.setValue = function(value) {
	var arr = null;
	if(typeof value === "array") {
		arr = value;
	}
	else if(typeof value === "number") {
		arr = [value];
	}
	else {
		arr = [];
	}

	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var item = this.children[i];
		if(item.isUIListCheckableItem) {
			item.setValue(false);
		}
	}

	for(var i = 0; i < arr.length; i++) {
		var index = arr[i];
		if(index >= 0 && index < n) {
			var item = this.children[index];
			if(item.isUIListCheckableItem) {
				item.setChecked(true);
			}
		}
	}

	return this;
}

function UIListCreator(border, itemHeight, bg) {
	var args = ["ui-list", "ui-list", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIList();
		return g.initUIList(this.type, border, itemHeight, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListCreator(5, 114, null));

/*
 * File:   ui-list-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List View (Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIListView
 * @extends UIList
 * 列表视图。和UIList一样，只是可以滚动。
 *
 */
function UIListView() {
	return;
}

UIListView.prototype = new UIVScrollView();
UIListView.prototype.isUIList = true;
UIListView.prototype.isUILayout = true;
UIListView.prototype.isUIListView = true;
UIListView.prototype.setItemHeight = UIList.prototype.setItemHeight;
UIListView.prototype.sortChildren = UIList.prototype.sortChildren;
UIListView.prototype.initUIList = UIList.prototype.initUIList;
UIListView.prototype.shapeCanBeChild = UIList.prototype.shapeCanBeChild;
UIListView.prototype.paintSelfOnly = UIList.prototype.paintSelfOnly;
UIListView.prototype.fixListItemImage = function(item, position) {};
UIListView.prototype.afterChildAppended = UIList.prototype.afterChildAppended;
UIListView.prototype.childIsBuiltin = UIList.prototype.childIsBuiltin;
UIListView.prototype.onKeyUpRunning = UIList.prototype.onKeyUpRunning;
UIListView.prototype.onKeyDownRunning = UIList.prototype.onKeyDownRunning;
UIListView.prototype.getValue = UIList.prototype.getValue;
UIListView.prototype.setValue = UIList.prototype.setValue;

UIListView.UPDATE_STATUS_NONE = 0;
UIListView.UPDATE_STATUS_TIPS = 1;
UIListView.UPDATE_STATUS_SYNC = 2;

UIListView.prototype.saveProps = UIList.prototype.saveProps;
UIListView.prototype.beginUpdate = function() {
	this.updateStatus = UIListView.UPDATE_STATUS_SYNC;
	var statusItem = this.findChildByName("ui-list-item-update-status");
	if(statusItem) {
		var waitBox = statusItem.findChildByName("ui-wait-box");
		if(waitBox) {
			waitBox.show();
		}

		var loading = statusItem.findChildByName("ui-label-loading");
		if(loading) {
			loading.setText(dappGetText("Loading..."));
		}
	}

	return;
}

UIListView.prototype.drawBgImage = function(canvas) {
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	UIElement.prototype.drawBgImage.call(this, canvas);

	return this;
}

UIListView.prototype.endUpdate = function() {
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;
	var statusItem = this.findChildByName("ui-list-item-update-status");
	if(statusItem) {
		this.setLastUpdateTime(new Date());
	}
	this.relayoutChildren(true);

	return;
}

UIListView.prototype.initUIListView = function(type, border, itemHeight, bg) {
	this.spacer = 0;
	this.initUIList(type, border, itemHeight, bg);
	this.initUIVScrollView(type, 0, bg, null);	
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;
	this.addEventNames(["onUpdateData", "onScrollOutOfRange"]);
	this.setTextType(Shape.TEXT_INPUT);

	return this;
}

UIListView.prototype.onModeChanged = function() {
	this.offset = 0;
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;

	return;
}

UIListView.prototype.updateDone = function() {
	var list = this;

	list.endUpdate();
	setTimeout(function() {
		if(list.parentShape) {
			list.relayoutChildren();
			list.postRedraw();
		}
	}, 1000);

	return;
}

UIListView.prototype.callOnUpdateData = function() {
	this.callOnUpdateDataHandler();

	this.beginUpdate();
	var listView = this;
	setTimeout(function() {
		if(listView.parentShape) {
			listView.updateDone();
		}
	}, 10000);

	return true;
}

UIListView.prototype.setLastUpdateTime = function(lastUpdateTime) {
	var tipsItem = this.findChildByName("ui-list-item-update-tips");

	if(tipsItem && lastUpdateTime) {
		var str = "";
		var now = new Date();
		
		if(now.getFullYear() === lastUpdateTime.getFullYear() 
			&& now.getDate() === lastUpdateTime.getDate()
			&& now.getMonth() === lastUpdateTime.getMonth()) {
			
			str = dappGetText("Today");
		}
		else {
			str = lastUpdateTime.getMonth() + "-" + lastUpdateTime.getDate();
		}

		str = str + " " + lastUpdateTime.getHours() + ":" + lastUpdateTime.getMinutes();

		var updateTime = tipsItem.findChildByName("ui-label-update-time");
		if(updateTime) {
			updateTime.setText(str);
		}
		
		var updateTime = tipsItem.findChildByName("ui-label-update-time");
		if(updateTime) {
			updateTime.setText(str);
		}
		
		var updateTimeTips = tipsItem.findChildByName("ui-label-update-time-tips");
		if(updateTimeTips) {
			updateTimeTips.setText(dappGetText("Last Update:"));
		}
	}

	return;
}

UIListView.prototype.onDrag = function(offset) {
	var tipsItem = this.findChildByName("ui-list-item-update-tips");

	if(tipsItem) {
		var indicator = tipsItem.findChildByName("ui-image");
		var tips = tipsItem.findChildByName("ui-label-tips");

		if(indicator) {
			
			if(offset < -115) {
				if(indicator.rotation === 0) {
					function animationRotate() {
						var angle = indicator.rotation + 0.2 * Math.PI;
						if(angle > Math.PI) {
							angle = Math.PI;
						}
						indicator.setRotation(angle);
						if(angle < Math.PI) {
							setTimeout(animationRotate, 50);
						}
						indicator.postRedraw();

						return;
					}
					
					animationRotate();
					if(tips) {
						tips.setText(dappGetText("Release To Update."));
					}
				}
			}
			else {
				indicator.setRotation(0);
				if(tips) {
					tips.setText(dappGetText("Pull To Update."));
				}
			}
		}
	}

	return;
}

UIListView.prototype.whenScrollOutOfRange = function(offset) {

	if(offset < -115) {
		this.callOnUpdateData();
		this.relayoutChildren();
	}

	this.callOnScrollOutOfRangeHandler(offset);

	return;
}

UIListView.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var w = this.getWidth(true);
	var h = this.itemHeight;
	var itemHeightVariable = this.itemHeightVariable;
	var range = this.getScrollRange();
	var pageSize = this.getPageSize();
	var userMovable = true;

	
	var i = 0;
	var spacer = this.spacer || 0;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];
		
		var config = {};
		var isBuiltin = false;
		if(child.removed || !child.visible) continue;
		
		if(itemHeightVariable || child.isHeightVariable()) {
			h = child.measureHeight(this.itemHeight);
		}
		else {
			h = this.itemHeight;
		}

		if(child.name === "ui-list-item-update-tips") {
			if(this.mode !== Shape.MODE_EDITING) {
				child.move(x, -h);
				child.left = x;
				child.top = -h;
				child.w = w;
				child.h = h;
				child.setUserMovable(false);
				child.setUserResizable(false);
				child.setVisible(this.updateStatus !== UIListView.UPDATE_STATUS_TIPS);

				continue;
			}
			else {
				child.setVisible(true);
			}
			isBuiltin = true;
		}
		else if(child.name === "ui-list-item-update-status") {
			if(this.mode !== Shape.MODE_EDITING) {
				if(this.updateStatus !== UIListView.UPDATE_STATUS_SYNC) {
					child.setVisible(false);
				}else {
					child.setVisible(true);
				}
			}
			else {
				child.setVisible(true);
			}
			isBuiltin = true;
		}
		
		if(!child.visible) {
			continue;
		}

		animatable =  child.isVisible() && !isBuiltin && (y < this.h) && (animHint || this.mode === Shape.MODE_EDITING);
		if(animatable && (x != child.left || y != child.top || w != child.w || h != child.h)) {
			child.setSize(w, h);

			config.xStart = child.left;
			config.yStart = child.top;
			config.wStart = child.w;
			config.hStart = child.h;
			config.xEnd = x;
			config.yEnd = y;
			config.wEnd = w;
			config.hEnd = h;

			config.delay = 10;
			config.duration = 1000;
			config.element = child;
			config.onDone = function (name) {
				this.relayoutChildren();
			}
			child.animate(config);
		}
		else {
			child.move(x, y);
			child.setSize(w, h);
			child.relayoutChildren();
		}

		child.widthAttr = UIElement.WIDTH_FILL_PARENT;
		if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
			child.heightAttr = UIElement.HEIGHT_FIX;
		}
		child.setUserMovable(userMovable);
		child.setUserResizable(itemHeightVariable || child.isHeightVariable());

		y += h + spacer;
		i++;
	}

	return;
}

UIListView.prototype.drawText = UIList.prototype.drawText;

UIListView.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);
	
	if(this.mode === Shape.MODE_EDITING) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIListViewCreator(border, itemHeight, bg) {
	var args = ["ui-list-view", "ui-list-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListView();
		return g.initUIListView(this.type, border, itemHeight, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListViewCreator(5, 114, null));

/*
 * File:   ui-list-item.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List Item
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIListItem
 * @extends UIElement
 * UIListItem是一个简单的容器，它是UIList/UIListView唯一能容纳的子控件。
 *
 */
function UIListItem() {
	return;
}

UIListItem.prototype = new UIElement();
UIListItem.prototype.isUIListItem = true;

UIListItem.prototype.saveProps = ["heightVariable", "slideToRemove", "isTemplate", "roundRadius"];
UIListItem.prototype.initUIListItem = function(type) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(200, 120);
	this.setTextType(Shape.TEXT_NONE);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.setImage(UIElement.IMAGE_FOCUSED, null);
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.setImage(UIElement.IMAGE_POINTER_OVER, null);
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.addEventNames(["onLongPress", "onRemoved"]);

	return this;
}

UIListItem.prototype.dragMove = function(dx, dy) {
	this.top = this.top + dy;
	this.onDragging();

	return;
}

UIListItem.prototype.getDeleteItemIcon = function() {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DELETE_ITEM);

	return image;
}

UIListItem.prototype.shapeCanBeChild = function(shape) {

	if(shape.isUIMenu || shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar 
		|| shape.isUIWindow || shape.isUIPageManager || shape.isUIPage || shape.isUIListItem) {
		return false;
	}

	return true;
}

UIListItem.prototype.onUserResized = function() {
	var list = this.parentShape;
	if(list) {
		list.relayoutChildren();
	}

	return;
}

UIListItem.prototype.setSlideToRemove = function(value) {
	this.slideToRemove = value;

	return this;
}

UIListItem.prototype.setHeightVariable = function(value) {
	this.heightVariable = value;
	
	return this;
}

UIListItem.prototype.isHeightVariable = function() {
	return this.heightVariable;
}

UIListItem.prototype.measureHeight = function(height) {
	return this.h;
}

UIListItem.prototype.ANIM_DRAW_LINE = 1;
UIListItem.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || !this.slideToRemove) {
		return;
	}

	var dx = this.getMoveAbsDeltaX();
	var dy = this.getMoveAbsDeltaY();
	
	if(Math.abs(dx) < this.w/2 || (Math.abs(dy) > this.h)) {
		return;
	}

	var item = this;
	var duration = 300;
	var startTime = (new Date()).getTime();
	
	item.animateState = this.ANIM_DRAW_LINE;
	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.style.setTextColor("#C0C0C0");
	}

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;
	
		if(percent < 1) {
			item.animatePercent = percent;
			setTimeout(animStep, 10);
		}
		else {
			item.animatePercent = 1;

			setTimeout(function() {
				delete startTime;
				delete item.animatePercent;
				delete item.animateState;

				var parentShape = item.parentShape;
				parentShape.removeChild(item);
				parentShape.relayoutChildren("default");
				parentShape.postRedraw();
			}, 300);
		}

		delete now;
		item.postRedraw();
	}

	animStep();

	return;
}

UIListItem.prototype.getFillColor = function(canvas) {
	var fillColor;
	if(this.pointerDown) {
		var dy = Math.abs(this.getMoveAbsDeltaY());
		if(dy < 5) {
			var deltaTime = Date.now() - this.pointerDownTime;
			if(deltaTime < 50 && this.getParent().isUIListView) {
				fillColor = this.style.fillColor;
				this.postRedraw();
			}
			else {
				fillColor = this.style.textColor; 
			}
		}
		else {
			fillColor = this.style.fillColor;
		}
	}
	else if(this.isPointerOverShape()) {
		fillColor = this.style.overFillColor ? this.style.overFillColor : this.style.fillColor;
	}
	else if(this.isFocused()) {
		fillColor = this.style.focusedFillColor ? this.style.focusedFillColor : this.style.fillColor;
	}
	else {
		fillColor = this.style.fillColor;
	}

	return fillColor;
}

UIListItem.prototype.paintSelfOnly = function(canvas) {
	if(this.getBgHtmlImage()) {
		return;
	}

	var parentShape = this.parentShape;
	var fillColor = this.getFillColor();
	var lineColor = this.style.lineColor;
	var lineWidth = this.style.lineWidth;

	canvas.beginPath();
	if(!parentShape || parentShape.isUIListView || parentShape.isUIMenu) {
		if(!Shape.isTransparentColor(fillColor)) {
			canvas.fillStyle = fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}

		if(!Shape.isTransparentColor(lineColor)) {
			canvas.moveTo(0, this.h);
			canvas.lineTo(this.w, this.h);
			canvas.lineWidth = lineWidth;
			canvas.strokeStyle = lineColor;
			canvas.stroke();
		}

		return;
	}

	var r = this.roundRadius;
	var isFirst = (this === parentShape.children[0]);
	var isLast  = (this === parentShape.children[parentShape.children.length-1]);
	if(isFirst && isLast) {
		drawRoundRect(canvas, this.w, this.h, r);
	}
	else if(isFirst) {
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.TL | RoundRect.TR);
	}
	else if(isLast) {
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.BL | RoundRect.BR);
	}
	else {
		canvas.rect(0, 0, this.w, this.h);
	}

	if(!Shape.isTransparentColor(fillColor)) {
		canvas.fillStyle = fillColor;
		canvas.fill();
	}
	
	if(!Shape.isTransparentColor(lineColor)) {
		canvas.lineWidth = lineWidth;
		canvas.strokeStyle = lineColor;
		canvas.stroke();
	}

	return;
}

UIListItem.prototype.afterPaintChildren = function(canvas) {
	if(!this.animateState) {
		return;
	}

	var image = this.getDeleteItemIcon();
	if(this.animateState === this.ANIM_DRAW_LINE && image && image.width > 0) {
		var margin = 20;
		var percent = this.animatePercent;
		var w = (this.w - margin ) * percent - image.width;

		if(w > margin) {
			canvas.lineWidth = 1;
			canvas.strokeStyle = "#D0D0D0";
			canvas.moveTo(margin, this.h/2);
			canvas.lineTo(w, this.h/2);
			canvas.stroke();

			if(percent > 0.9) {
				var y = (this.h - image.height)/2;
				var x = this.w - image.width - margin;

				canvas.drawImage(image, x, y);
			}
		}
	}

	return;
}

UIListItem.prototype.afterChildAppended = function(shape) {
	if(shape.isUIButton || shape.isUICheckBox) {
		this.setImage(UIElement.IMAGE_ACTIVE, this.getImageByType(UIElement.IMAGE_NORMAL).getImageSrc());
		this.setImage(UIElement.IMAGE_FOCUSED, this.getImageByType(UIElement.IMAGE_NORMAL).getImageSrc());
	}

	return true;
}

function UIListItemCreator() {
	var args = ["ui-list-item", "ui-list-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListItem();
		g.initUIListItem(this.type);
	
		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListItemCreator(null, null, null, null));

/*
 * File:   ui-list-checkable-item.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Checkable List Item 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIListCheckableItem() {
	return;
}

UIListCheckableItem.prototype = new UIListItem();
UIListCheckableItem.prototype.isUIListCheckableItem = true;

UIListCheckableItem.prototype.initUIListCheckableItem = function(type) {
	this.initUIListItem(type);

	this.isUIListRadioBoxItem = (type === "ui-list-radiobox-item");
	this.isUIListCheckBoxItem = (type === "ui-list-checkbox-item");
	this.setImage(UIElement.IMAGE_CHECKED_FG, null);
	this.setImage(UIElement.IMAGE_UNCHECK_FG, null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIListCheckableItem.prototype.getValue = function() {
	return this.value;
}

UIListCheckableItem.prototype.setValue = function(value) {
	if(this.value != value) {
		this.value = value;
		this.callOnChangedHandler(this.value);
	}

	return;
}

UIListCheckableItem.prototype.setChecked = function() {
	var parentShape = this.parentShape;
	if(parentShape) {
		for(var i = 0; i < parentShape.children.length; i++) {
			var shape = parentShape.children[i];
			if(shape.isUIListCheckableItem) {
				shape.setValue(false);
			}
		}
	}

	this.setValue(true);

	return;
}

UIListCheckableItem.prototype.setParent = function(parentShape) {
	this.parentShape = parentShape;

	if(this.value) {
		this.setChecked();
	}

	return;
}

UIListCheckableItem.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	if(this.isUIListRadioBoxItem) {
		this.setChecked();
	}
	else {
		this.setValue(!this.value);
	}

	return;
}

UIListCheckableItem.prototype.drawFgImage = function(canvas) {
	var image = this.getHtmlImageByType(this.value ? UIElement.IMAGE_CHECKED_FG : UIElement.IMAGE_UNCHECK_FG);

	if(image) {
		var x = this.w - image.width - 20;
		var y = (this.h - image.height)/2;

		canvas.drawImage(image, 0, 0, image.width, image.height, x, y, image.width, image.height);
	}

	return;
}

function UIListCheckBoxItemCreator() {
	var args = ["ui-list-checkbox-item", "ui-list-checkbox-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListCheckableItem();
		g.initUIListCheckableItem(this.type);
		return g;
	}
	
	return;
}

function UIListRadioBoxItemCreator() {
	var args = ["ui-list-radiobox-item", "ui-list-radiobox-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListCheckableItem();
		g.initUIListCheckableItem(this.type);
		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListCheckBoxItemCreator());
ShapeFactoryGet().addShapeCreator(new UIListRadioBoxItemCreator());

/*
 * File:   ui-select.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scrollable Select
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISelect
 * @extends UIElement
 * 提供多个选项给用户，让用户选择其中一个。可以用getValue来获取用户选择的值。
 *
 */

/**
 * @event onChanged
 * 用户选择选项时触发本事件。
 * @param {String} value 当前的选项。
 */

function UISelect() {
	return;
}

UISelect.prototype = new UIElement();
UISelect.prototype.isUISelect = true;

UISelect.prototype.saveProps = ["visibleItems", "isVertical"];
UISelect.prototype.initUISelect = function(type, w, h) {
	this.initUIElement(type);
	
	this.offset = 0;
	this.options = [];
	this.visibleItems = 5;	
	this.setDefSize(w, h);
	this.isVertical = true;
	this.addEventNames(["onChanged"]);
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setCanRectSelectable(false, true);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UISelect.prototype.getItemSize = function() {
	var s = this.isVertical ? this.h : this.w;

	return Math.round(s/this.visibleItems);
}

UISelect.prototype.getVisibleItems = function() {
	return this.visibleItems;
}

UISelect.prototype.setVisibleItems = function(visibleItems) {
	if(visibleItems <= 3) {
		this.visibleItems = 3;
	}
	else {
		this.visibleItems = 5;
	}
}

UISelect.prototype.scrollTo = function(offsetEnd) {
	var itemSize = this.getItemSize();

	offsetEnd = Math.round(offsetEnd/itemSize) * itemSize;

	var me = this;
	var duration = 500;
	var offsetStart = this.offset;
	var range = offsetEnd - offsetStart;
	var startTime = (new Date()).getTime();
	var interpolator =  new DecelerateInterpolator();

	this.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);

		if(timePercent < 1) {
			me.setOffset(Math.floor(offsetStart + percent * range));
			setTimeout(animStep, 10);
		}
		else {
			me.setOffset(offsetStart + range, true);
			delete startTime;
			delete interpolator;
			delete me.animating;
		}

		delete now;
	}

	setTimeout(function() {
		animStep();
	}, 10);

	return;
}

UISelect.prototype.setOffset = function(offset, triggerOnChanged) {
	this.offset = offset;
	this.postRedraw();

	if(triggerOnChanged) {
		var value = this.getValue();
		this.callOnChangedHandler(value);
	}

	return;
}

UISelect.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	if(!this.velocityTracker) {
		this.velocityTracker = new VelocityTracker();
	}
	this.velocityTracker.clear();
	this.saveOffset = this.offset;

	return true;
}

UISelect.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}
	
	this.addMovementForVelocityTracker();

	var delta = this.isVertical ? this.getMoveAbsDeltaY() : this.getMoveAbsDeltaX();
	this.setOffset(this.saveOffset + delta);

	return;
}

UISelect.prototype.getMaxOffset = function() {
	var n = Math.floor(0.5 * this.visibleItems);

	return n * this.getItemSize();
}

UISelect.prototype.getMinOffset = function() {
	var itemSize = this.getItemSize();

	var n = Math.round(0.5 * this.visibleItems);

	if(this.options.length <= n) {
		return 0;
	}
	else {
		return -(this.options.length-n)  * itemSize;
	}
}
	
UISelect.prototype.handleClicked = function(point) {
	var itemSize = this.getItemSize();
	var s = this.isVertical ? this.h : this.w;
	var m = Math.floor((s/2 - this.offset)/itemSize);
	var i = Math.floor(((this.isVertical ? point.y : point.x) - this.offset)/itemSize);

	var d = (i - m) * itemSize;
	var offset = this.offset-d;
	var minOffset = this.getMinOffset();
	var maxOffset = this.getMaxOffset();

	if(offset < minOffset) {
		offset = minOffset;
	}

	if(offset > maxOffset) {
		offset = maxOffset;
	}
	
	this.scrollTo(offset);

	return;
}

UISelect.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	var v = this.velocityTracker.getVelocity();
	var velocity = this.isVertical ? v.y : v.x;
	var delta = this.isVertical ? this.getMoveAbsDeltaY() : this.getMoveAbsDeltaX();
	if((Date.now() - this.pointerDownTime) > 400) {
		velocity = 0;
	}

	var distance = delta + velocity/2;

	if(Math.abs(distance) < 10) {
		this.setOffset(this.saveOffset);
		this.handleClicked(point);

		return;
	}

	var minOffset = this.getMinOffset();
	var maxOffset = this.getMaxOffset();
	var offset = this.saveOffset + delta + velocity;

	if(offset < minOffset) {
		offset = minOffset;
	}

	if(offset > maxOffset) {
		offset = maxOffset;
	}

	this.scrollTo(offset);

	return;
}

UISelect.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UISelect.prototype.setText =function(text) {
	text = this.toText(text);
	if(text) {
		this.options = text.split("\n");
		this.options.remove("");
	}
	else {
		this.options = [];
	}

	this.text = text;

	return this;
}

UISelect.prototype.drawText = function(canvas) {
	return;
}

UISelect.prototype.drawImage = function(canvas) {
	var w = this.w;
	var h = this.h;
	var itemSize = this.getItemSize();

	canvas.beginPath();
	canvas.rect(0, 0, w, h);
	canvas.clip();
	this.drawBgImage(canvas);

	var n = this.options.length;
	this.style.setTextB(false);
	var normalFont = this.style.getFont();
	var normalTxtColor = this.style.textColor;
	
	this.style.setTextB(true);
	var highlightFont = this.style.getFont();
	var highlightTextColor = this.style.textColorHighlight;

	canvas.textAlign = "center";
	canvas.textBaseline = "middle";

	var m = 0;
	var o = 0;
	var offset = this.offset;
	var isVertical = this.isVertical;
	var y = isVertical ? 0 : h >> 1;
	var x = isVertical ? w >> 1 : 0;
	var yOffset = isVertical ? offset : 0;
	var xOffset = isVertical ? 0 : offset;

	canvas.translate(xOffset, yOffset);
	if(isVertical) {
		m = Math.floor((0.5 * h - yOffset)/itemSize);
	}
	else {
		m = Math.floor((0.5 * w - xOffset)/itemSize);
	}

	var b = 0;
	var r = 0;
	for(var i = 0; i < n; i++) {
		var text = this.options[i];

		if(isVertical) {
			y = i * itemSize;
			b = y + itemSize;

			o = -offset;
			if(b < o && y < o) {
				continue;
			}

			o = -(offset - h);
			if(b > o && y > o) {
				continue;
			}
			y = y + (itemSize >> 1);
		}
		else {
			x = i * itemSize;
			r = x + itemSize;
			o = -offset;
			if(r < o && x < o) {
				continue;
			}

			o = -(offset - w);
			if(r > o && x > o) {
				continue;
			}
			x = x + (itemSize >> 1);
		}

		if(m == i) {
			canvas.font = highlightFont;
			canvas.fillStyle = highlightTextColor;
		}
		else {
			canvas.font = normalFont;
			canvas.fillStyle = normalTxtColor;
		}

		canvas.fillText(text, x, y, w);
	}

	return;
}

UISelect.prototype.getValue = function() {
	var offset = this.offset;
	var itemSize = this.getItemSize();
	var s = this.isVertical ? this.h : this.w;
	var i = Math.floor((0.5 * s - offset)/itemSize);

	var value = (i < this.options.length) ? this.options[i] : "";

	return value;
}

UISelect.prototype.setValueByIndex = function(index, animate) {
	var i = index;
	var itemSize = this.getItemSize();

	if(i >= 0) {
		var offset = -(i - (this.getVisibleItems()>> 1)) * itemSize;

		if(animate) {
			this.scrollTo(offset);
		}
		else {
			this.setOffset(offset, true);
		}
	}

	return this;
}

UISelect.prototype.setValue = function(value, notify, animate) {
	var i = this.options.indexOf(value.toString());

	this.setValueByIndex(i, animate);
	if(notify) {
		this.callOnChangedHandler(this.getValue());
	}

	return this;
}

function UISelectCreator(w, h) {
	var args = ["ui-select", "ui-select", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISelect();
		return g.initUISelect(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISelectCreator("ui-select", 300, 50));

/*
 * File:   ui-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */


/**
 * @class UIImage
 * @extends UIElement
 * 用来显示一张图片。UIImage可以设置多张图片，但只有一张是当前显示的图片，其它图片是备用图片(目前为15张，可以增加)。可以用setValue把指定的备用图片设置为当前图片。
 *
 * 注意：getValue返回setValue设置的值，如果没有调用过setValue，getValue返回-1。
 *
 * 把第一张备用图片设置为当前图片(可以在UIImage的图片属性页中设置备用图片)：
 *
 *     @example small frame
 *     this.setImage(0);
 *
 * 或者：
 *
 *     @example small frame
 *     this.setValue(0);
 *
 */
function UIImage() {
	return;
}

UIImage.prototype = new UIElement();
UIImage.prototype.isUIImage = true;

UIImage.prototype.saveProps = ["keepSizeWithImage"];
UIImage.prototype.initUIImage = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onUpdateTransform"]);

	return this;
}

UIImage.prototype.setValue = function(value) {
	this.v = value;
	return this.setImageSrc(value);
}

UIImage.prototype.getValue = function() {
	return (this.v !== undefined) ? this.v : -1;
}

UIImage.prototype.setImageSrc = function(value) {
	this.setImage(UIElement.IMAGE_DEFAULT, value);

	return this;
}

UIImage.prototype.getImageSrc = function(type) {
	return this.getImageSrcByType(type ? type : UIElement.IMAGE_DEFAULT);
}

UIImage.prototype.getHtmlImage = function(type) {
	return this.getHtmlImageByType(type ? type : UIElement.IMAGE_DEFAULT);
}

UIImage.prototype.getImageSrcRect = function() {
	var image = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(this.srcRect) {
		return this.srcRect;
	}
	else if(image) {
		return image.getImageRect();
	}
	else {
		return null;
	}
}

UIImage.prototype.setImageSrcRect = function(x, y, w, h) {
	this.srcRect = {};
	this.srcRect.x = x;
	this.srcRect.y = y;
	this.srcRect.w = w;
	this.srcRect.h = h;

	return;
}

UIImage.prototype.fitToImage = function() {
	var srcRect = this.getImageSrcRect();
	if(srcRect && srcRect.w && srcRect.h) {
		this.w = srcRect.rw || srcRect.w;
		this.h = srcRect.rh || srcRect.h;
	}

	return;
}

UIImage.prototype.fixChildSize = function() {
	return;
}

UIImage.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

function UIImageCreator(type) {
	var args = [type, "ui-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImage();
		return g.initUIImage(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageCreator("ui-image"));
ShapeFactoryGet().addShapeCreator(new UIImageCreator("ui-icon"));

//for compatible
UIImage.prototype.setBorderStyle = function(borderColor, borderWidth) {
	return;
}

UIImage.prototype.setClickedStyle = function(type, param) {

	return;
}

/*
 * File:   ui-label.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Label
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UILabel
 * @extends UIElement
 * 用来显示文字内容。
 *
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */
function UILabel() {
	return;
}

UILabel.prototype = new UIElement();
UILabel.prototype.isUILabel = true;

UILabel.prototype.saveProps = ["hTextAlign", "vTextAlign"];

UILabel.prototype.initUILabel = function(type) {
	this.initUIElement(type);	

	this.setText("");
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onChanged", "onUpdateTransform"]);


	return this;
}

/**
 * @method setTextAlign
 * 设置控件上文本水平对齐方式。
 * @param {String} textAlign 水平对齐方式。可选值有"left","center","right"。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.setTextAlign = function(textAlign) {
	this.hTextAlign = textAlign;

	return this;
}

/**
 * @method setTextBaseline
 * 设置控件上文本垂直对齐方式。
 * @param {String} textBaseline 垂直对齐方式。可选值有"top","middle","bottom"。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.setTextBaseline = function(textBaseline) {
	this.vTextAlign = textBaseline;

	return this;
}

/**
 * @method getTextAlign
 * 获取控件上文本水平对齐方式。
 * @return {String} 返回水平对齐方式。
 */
UILabel.prototype.getTextAlign = function() {
	return this.hTextAlign;
}

/**
 * @method getTextBaseline
 * 获取控件上文本垂直对齐方式。
 * @return {String} 返回垂直对齐方式。
 */
UILabel.prototype.getTextBaseline = function() {
	return this.vTextAlign;
}

UILabel.prototype.shapeCanBeChild = function(shape) {
	return shape.isUILabel || shape.isUIImage;
}

UILabel.prototype.setText = function(text) {
	this.text = this.toText(text);
	this.textNeedRelayout = true;

	this.callOnChangedHandler(text);

	return this;
}

UILabel.prototype.drawText = function(canvas) {
	this.layoutText(canvas);
	
	this.defaultDrawText(canvas);

	return;
}

UILabel.prototype.fitToTextContent = function() {
	if(!this.text) {
		this.w = 30;
		this.h = 30;

		return;
	}

	var canvas = this.getCanvasContext2D();
	this.layoutText(canvas);

	var n = this.lines.length;
	var w = this.w;
	var h = this.getTextHeight() + this.vMargin * 2;

	if(n === 1) {
		var str = this.lines[0];
		w = canvas.measureText(str).width + 2 * this.hMargin;
	}

	this.w = w;
	this.h = h;

	return this;
}

function UILabelCreator() {
	var args = ["ui-label", "ui-label", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILabel();
		return g.initUILabel(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UILabelCreator());

/*
 * File:   ui-tips.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Tips
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UITips() {
	return;
}

UITips.prototype = new UILabel();
UITips.prototype.isUITips = true;

UITips.prototype.saveProps = ["clickable", "triangleSize", "hTextAlign", "vTextAlign"];
UITips.prototype.initUITips = function(type) {
	this.initUILabel(type);	

	this.roundRadius = 8;
	this.triangleSize = 16;
	this.setMargin(20, 20);
	this.setClickable(true);
	this.setDefSize(200, 200);
	this.setSizeLimit(40, 40);
	this.handle = {x:-20, y:-20};

	return this;
}

UITips.prototype.getMoreSelectMark = function(type, point) {
	if(type === Shape.HIT_TEST_HANDLE) {
		point.x = this.handle.x;
		point.y = this.handle.y;

		return true;
	}

	return false;
}

UITips.prototype.getPointer = function() {
	return this.handle;
}

UITips.prototype.moveHandle = function(dx, dy) {
	return this.setPointer(this.handle.x + dx, this.handle.y + dy);
}

UITips.prototype.setPointer = function(x, y) {
	this.handle.x = x;
	this.handle.y = y;

	return this;
}

UITips.prototype.setClickable = function(clickable) {
	this.clickable = clickable;

	return this;
}

UITips.prototype.fitToTextContent = function() {
	UILabel.prototype.fitToTextContent.call(this);
	var r = this.roundRadius;
	var triangleSize = this.triangleSize;

	var minSize = r + r + triangleSize;
	this.w = Math.max(this.w, minSize);
	this.h = Math.max(this.h, minSize);

	return this;
}

UITips.prototype.drawPath = function(canvas) {
	var x = 0;
	var y = 0;
	var r = this.roundRadius;
	var triangleSize = this.triangleSize;
	var px = this.handle.x;
	var py = this.handle.y;
	var hMargin = this.hMargin;
	var vMargin = this.vMargin;
	var minSize = r + r + triangleSize;
	this.w = Math.max(this.w, minSize);
	this.h = Math.max(this.h, minSize);

	var w = this.w;
	var h = this.h;
	var delta =  triangleSize >> 1;
	
	canvas.beginPath();
	function drawToRight() {
		canvas.lineTo(w-r, 0);
		canvas.arc(w-r, r, r, 1.5 * Math.PI, 2*Math.PI, false);
	}
	
	function drawToBottom() {
		canvas.lineTo(w, h-r);	
		canvas.arc(w-r, h-r, r, 0, 0.5*Math.PI, false);
	}

	function drawToLeft() {
		canvas.lineTo(r, h);	
		canvas.arc(r, h-r, r, 0.5*Math.PI, Math.PI, false);
	}

	function drawToTop() {
		canvas.lineTo(0, r);
		canvas.arc(r, r, r, Math.PI, 1.5*Math.PI, false);
	}

	function drawTLArc() {
		canvas.arc(r, r, r, Math.PI, 1.5*Math.PI, false);
	}

	function drawTRArc() {
		canvas.arc(w-r, r, r, 1.5 * Math.PI, 2*Math.PI, false);
	}

	function drawBLArc() {
		canvas.arc(r, h-r, r, 0.5*Math.PI, Math.PI, false);
	}

	function drawBRArc() {
		canvas.arc(w-r, h-r, r, 0, 0.5*Math.PI, false);
	}

	canvas.moveTo(px, py);
	if(px < r) {
		if(py < (r + delta)) {
			canvas.lineTo(r, 0);
			drawToRight();
			drawToBottom();
			drawToLeft();
			canvas.lineTo(0, r);
		}else if(py > (h-r-delta)) {
			canvas.lineTo(0, h-r);
			drawToTop();
			drawToRight();
			drawToBottom();
			canvas.lineTo(r, h);	
		}else {
			canvas.lineTo(0, py-delta);
			drawToTop();
			drawToRight();
			drawToBottom();
			drawToLeft();
			canvas.lineTo(0, py+delta);	
		}
	} else if(px < (w - r)) {
		if(py < r) {
			canvas.lineTo(px+delta, 0);
			drawToRight();
			drawToBottom();
			drawToLeft();
			drawToTop();
			canvas.lineTo(px-delta, 0);
		}
		else {
			canvas.lineTo(px-delta, h);
			drawToLeft();
			drawToTop();
			drawToRight();
			drawToBottom();
			canvas.lineTo(px+delta, h);
		}
	}else{
		if(py < (r + delta)) {
			canvas.lineTo(w, r);
			drawToBottom();
			drawToLeft();
			drawToTop();
			canvas.lineTo(w-r, 0);
		}else if(py > (h-r-delta)) {
			canvas.lineTo(w-r, h);
			drawToLeft();
			drawToTop();
			drawToRight();
			canvas.lineTo(w, h-r);	
		}else {
			canvas.lineTo(w, py+delta);
			drawToBottom();
			drawToLeft();
			drawToTop();
			drawToRight();
			canvas.lineTo(w, py-delta);	
		}
	}
	canvas.closePath();

	return;
}

UITips.prototype.paintSelfOnlyByColor = function(canvas) {
	this.drawPath(canvas);

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(!this.isStrokeColorTransparent()) {
		canvas.strokeStyle = this.style.lineColor;
		canvas.lineWidth = (this.pointerDown && this.clickable) ? 4 : 2;
		canvas.stroke();
	}

	return;
}

UITips.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		this.paintSelfOnlyByColor(canvas);
	}

	return;
}

UITips.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage;
}

function UITipsCreator() {
	var args = ["ui-tips", "ui-tips", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITips();
		return g.initUITips(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITipsCreator());

/*
 * File:   ui-menu.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Menu
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIMenu
 * @extends UIElement
 * 菜单。菜单缺省时是隐藏的，只在特定情况才显示出来。菜单是一个容器，里面可以放按钮，列表项，文字和图片等控件。
 *
 * 菜单在显示或隐藏时，可以开启或关闭动画，动画可以是缺省的，也可以是自定义的。
 *
 * 对于自定义动画：显示动画名称必须是"show",隐藏动画名称必须是"hide"。
 *
 *     @example small frame
 *     this.win.find("menu").setVisible(true);
 */
function UIMenu() {
	return;
}

UIMenu.FREE_LAYOUT = 0;
UIMenu.ARC_LAYOUT = 1;
UIMenu.VLINEAR_LAYOUT = 2;
UIMenu.HLINEAR_LAYOUT = 3;

UIMenu.prototype = new UITips();
UIMenu.prototype.isUIMenu = true;

UIMenu.prototype.saveProps = ["autoHideWhenClicked", "childrenAnimation", "enableShowAnimation", "enableHideAnimation", "spacer", "menuItemNr", "animDuration", "layoutType", "originPoint"];
UIMenu.prototype.initUIMenu = function(type) {
	this.initUITips(type, null);

	this.spacer = 2;
	this.menuItemNr = 2;
	this.roundRadius = 5;
	this.animDuration = 600;
	this.setTextType(Shape.TEXT_NONE);
	this.layoutType = UIMenu.FREE_LAYOUT;
	this.originPoint = UIElement.ORIGIN_RIGHT;
	this.setCanRectSelectable(false, false);
	this.enableHideAnimation = true;
	this.enableShowAnimation = true;

	return this;
}

UIMenu.prototype.relayoutChildrenHLL = function() {
	var n = this.children.length;
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var originPoint = this.originPoint;
	
	var nr = Math.max(n, this.menuItemNr);
	var itemW = Math.round((w - spacer * (nr - 1))/nr);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.h = h;
		iter.w = itemW;
		iter.left = x;
		iter.top = y;
		x += itemW + spacer;
		iter.relayoutChildren();
	}

	return this;
}

UIMenu.prototype.relayoutChildrenVLL = function() {
	var n = this.children.length;
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var originPoint = this.originPoint;

	var nr = Math.max(n, this.menuItemNr);
	var itemH = Math.round((h - spacer * (nr - 1))/nr);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.w = w;
		iter.h = itemH;
		iter.left = x;
		iter.top = y;
		y += itemH + spacer;
		iter.relayoutChildren();
	}

	return this;
}

UIMenu.prototype.getChildPositionOfArc = function(originInfo, r, index, n) {
	var p = {};
	var nr = originInfo.angleRange > (Math.PI * 1.9) ? n : n - 1;
	var angle = originInfo.angleStart + (originInfo.angleRange*index)/nr;

	p.x = originInfo.x + r * Math.cos(angle);
	p.y = originInfo.y + r * Math.sin(angle);

	return p;
}

UIMenu.prototype.relayoutChildrenARC = function() {
	var n = this.children.length;
	var originInfo = this.getOrigin();
	var r = originInfo.r;
	var w = this.w;
	var h = this.h;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		var p = this.getChildPositionOfArc(originInfo, r, i, n);
		iter.left = p.x - (iter.w >> 1);
		iter.top = p.y - (iter.h >> 1);
		iter.relayoutChildren();
	}

	return;
}

UIMenu.prototype.relayoutChildren = function() {
	var n = this.children.length;
	if(this.disableRelayout || !n) {
		return;
	}

	switch(this.layoutType) {
		case UIMenu.HLINEAR_LAYOUT: {
			this.relayoutChildrenHLL();
			break;
		}
		case UIMenu.VLINEAR_LAYOUT: {
			this.relayoutChildrenVLL();
			break;
		}
		case UIMenu.ARC_LAYOUT: {
			this.relayoutChildrenARC();
			break;
		}
		default: {
			for(var i = 0; i < n; i++) {
				this.children[i].relayout();
			}
			break;
		}
	}

	return;
}

UIMenu.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		this.paintSelfOnlyByColor(canvas);
	}

	return;
}

UIMenu.prototype.prepareShowChildAnimation = function(child, origin) {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";
	config.xStart = origin.x - (child.w >> 1);
	config.xEnd = child.left;
	config.yStart = origin.y - (child.h >> 1);
	config.yEnd = child.top;
	config.scaleXStart = 0;
	config.scaleXEnd = 1;
	config.scaleYStart = 0;
	config.scaleYEnd = 1;
	config.opacityStart = 0;
	config.opacityEnd = 1;
	config.rotationStart = 0;
	config.rotationEnd = 2 * Math.PI;

	return config;
}

UIMenu.prototype.prepareHideChildAnimation = function(child, origin) {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";

	config.xStart = child.left;
	config.xEnd = origin.x - (child.w >> 1);
	config.yStart = child.top;
	config.yEnd = origin.y - (child.h >> 1);

	config.opacityStart = 1;
	config.opacityEnd = 0;
	config.scaleXStart = 1;
	config.scaleXEnd = 0;
	config.scaleYStart = 1;
	config.scaleYEnd = 0;
	config.rotationStart = Math.PI * 2;
	config.rotationEnd = 0;

	return config;
}

UIMenu.prototype.animateShowChildren = function() {
	var me = this;
	var n = this.children.length;
	var origin = this.getOrigin();

	this.busy = n;
	this.visible = true;
	for(var i = 0; i < n; i++) {
		var config = null;
		var iter = this.children[i];
		if(iter.animations) {
			config = iter.animations['show'];
		}
		if(!config) {
			config = this.prepareShowChildAnimation(iter, origin);
		}
		else {
			console.log("Use child show animation.");
		}

//		this.busy++;
		iter.animate(config, function() {
			me.busy--;
		});
	}

	return this;
}

UIMenu.prototype.animateHideChild = function(child, config) {
	var me = this;
	var x = child.left;
	var y = child.top;
	var w = child.w;
	var h = child.h;

//	this.busy++;
	child.animate(config, function() {
		child.left = x;
		child.top = y;
		child.w = w;
		child.h = h;
		
		child.opacity = 1;
		child.visible = false;

		me.busy--;
		if(!me.busy) {
			me.visible = false;
		}
	});

	return;
}

UIMenu.prototype.animateHideChildren = function() {
	var me = this;
	var n = this.children.length;
	var origin = this.getOrigin();

	this.busy = n;
	this.visible = true;
	for(var i = 0; i < n; i++) {
		var config = null;
		var iter = this.children[i];
		if(iter.animations) {
			config = iter.animations['hide'];
		}

		if(!config) {
			config = this.prepareHideChildAnimation(iter, origin);
		}
		else {
			console.log("Use child hide animation.");
		}

		this.animateHideChild(iter, config);
	}

	return this;
}

UIMenu.prototype.prepareShowAnimation = function() {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";

	config.scaleXStart = 0.5;
	config.scaleXEnd = 1;
	config.scaleYStart = 0.5;
	config.scaleYEnd = 1;
	config.opacityStart = 0;
	config.opacityEnd = 1;

	return config;
}

UIMenu.prototype.prepareHideAnimation = function() {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "a";
	config.scaleXStart = 1;
	config.scaleXEnd = 0.5;
	config.scaleYStart = 1;
	config.scaleYEnd = 0.5;
	config.opacityStart = 1;
	config.opacityEnd = 0;

	return config;
}

UIMenu.prototype.animateShowSelf = function() {
	var me = this;
	me.busy = true;
	var config = null;
	if(this.animations) {
		config = this.animations["show"];
	}

	if(!config) {
		config = this.prepareShowAnimation();
	}

	this.animate(config, function() {
		me.visible = true;
		me.busy = false;
	});
}

UIMenu.prototype.animateHideSelf = function() {
	var me = this;
	me.busy = true;
	this.visible = true;
	var config = null;
	if(this.animations) {
		config = this.animations["hide"];
	}

	if(!config) {
		config = this.prepareHideAnimation();
	}

	this.animate(config, function() {
		me.visible = false;
		me.busy = false;
	});

	return this;
}

UIMenu.prototype.show = function() {
	if(this.busy) return;
	if(this.autoHideWhenClicked) {
		this.getWindow().grab(this);
	}

	if(!this.enableShowAnimation) {
		this.visible = true;
		return;
	}

	if(this.childrenAnimation) {
		this.animateShowChildren();
	}
	else {
		this.animateShowSelf();
	}
}

UIMenu.prototype.hide = function() {
	if(this.busy) return;
	if(this.autoHideWhenClicked) {
		this.getWindow().ungrab(this);
	}
	
	if(!this.enableHideAnimation) {
		this.visible = false;
		return;
	}

	if(this.childrenAnimation) {
		return this.animateHideChildren();
	}
	else {
		return this.animateHideSelf();
	}
}

UIMenu.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	if(this.autoHideWhenClicked) {
		this.hide();
	}

	return;
}

UIMenu.prototype.setVisible = function(visible) {
	if(this.visible === visible || this.busy) {
		return this;
	}

	return visible ? this.show() : this.hide();
}

UIMenu.prototype.getOrigin = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var hMargin = this.hMargin;
	var vMargin = this.vMargin;

	var p = {x:hMargin, y:vMargin};

	switch(this.originPoint) {
		case UIElement.ORIGIN_UP: {
			p.x = this.w >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = 0;
			p.r = w >> 1;
			break;
		}
		case UIElement.ORIGIN_DOWN: {
			p.x = this.w >> 1;
			p.y = this.h - vMargin;
			p.angleRange = Math.PI;		
			p.angleStart = Math.PI;
			p.r = w >> 1;
			break;
		}
		case UIElement.ORIGIN_LEFT: {
			p.x = hMargin;
			p.y = this.h >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = - Math.PI * 0.5;
			p.r = h >> 1;
			break;
		}
		case UIElement.ORIGIN_RIGHT: {
			p.x = this.w - hMargin;
			p.y = this.h >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = Math.PI * 0.5;
			p.r = h >> 1;
			break;
		}
		case UIElement.ORIGIN_UP_LEFT: {
			p.angleRange = Math.PI * 0.5;
			p.angleStart = 0;
			p.r = Math.min(w,h);

			break;
		}
		case UIElement.ORIGIN_UP_RIGHT: {
			p.x = this.w - hMargin;
			p.angleStart = 0.5 * Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_DOWN_LEFT: {
			p.x = hMargin;
			p.y = this.h - vMargin;
			p.angleStart = - 0.5 * Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_DOWN_RIGHT: {
			p.x = this.w - hMargin;
			p.y = this.h - vMargin;
			p.angleStart = Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_MIDDLE_CENTER: {
			p.x = this.w >> 1;
			p.y = this.h >> 1;
			p.angleStart = -0.5 * Math.PI;
			p.angleRange = Math.PI * 2;
			p.r = Math.min(w,h) >> 1;
			break;
		}
		default:break;
	}

	return p;
}

UIMenu.prototype.applyTransform = function(canvas) {
	if(this.mode === Shape.MODE_EDITING) return;

	var origin = this.getOrigin();

	if(canvas.globalAlpha != this.opacity) {
		canvas.globalAlpha =  this.opacity;
	}

	if(this.offsetX) {
		canvas.translate(this.offsetX, 0);
	}

	if(this.offsetY) {
		canvas.translate(0, this.offsetY);
	}

	var scaleX = this.getScaleX();
	var scaleY = this.getScaleY();
	if(this.rotation || (scaleX && scaleX !== 1) || (scaleY && scaleY !== 1)) {
		var hw = origin.x;
		var hh = origin.y;

		canvas.translate(hw, hh);
		if(scaleX && scaleY) {
			canvas.scale(scaleX, scaleY);
		}
		
		if(this.rotation) {
			canvas.rotate(this.rotation);
		}
		canvas.translate(-hw, -hh);
	}

	return;
}


UIMenu.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIListItem || shape.isUIButton || shape.isUIImage;
}

function UIMenuCreator() {
	var args = ["ui-menu", "ui-menu", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMenu();
		return g.initUIMenu(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMenuCreator());

/*
 * File:   ui-page.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  TabPage
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPage
 * @extends UIElement
 * 标签控件里的一个页面。
 *
 */
function UIPage() {
	return;
}

UIPage.prototype = new UIElement();
UIPage.prototype.isUIPage = true;

UIPage.prototype.initUIPage = function(type, bg) {
	this.initUIElement(type);	

	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;

	if(!bg) {
		this.style.setFillColor("Gold");
	}

	return this;
}

UIPage.prototype.show = function() {
	this.setVisible(true);
	this.showHTML();

	return;
}

UIPage.prototype.hide = function() {
	this.setVisible(false);
	this.hideHTML();
	cantkHideAllInput();

	return;
}

UIPage.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar 
		|| shape.isUIWindow || shape.isUIPage) {
		return false;
	}

	if(shape.isUIPageIndicator && !this.isUIPageExt) {
		return false;
	}

	return true;
}

UIPage.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIPageCreator(bg) {
	var args = ["ui-page", "ui-page", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPage();

		return g.initUIPage(this.type, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPageCreator(null));

/*
 * File:   ui-circle-layout.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Circle Layout
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UICircleLayout() {
	return;
}

UICircleLayout.prototype = new UIElement();
UICircleLayout.prototype.isUILayout = true;
UICircleLayout.prototype.isUICircleLayout = true;
UICircleLayout.O_CENTER = "c";
UICircleLayout.O_TOP_LEFT = "tl";
UICircleLayout.O_TOP_MIDDLE = "tm";
UICircleLayout.O_TOP_RIGHT = "tr";
UICircleLayout.O_LEFT_MIDDLE = "lm";
UICircleLayout.O_RIGHT_MIDDLE = "rm";
UICircleLayout.O_BOTTOM_LEFT = "bl";
UICircleLayout.O_BOTTOM_MIDDLE = "bm";
UICircleLayout.O_BOTTOM_RIGHT = "br";

UICircleLayout.prototype.initUICircleLayout = function(type, w, h, img) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;
	this.setCanRectSelectable(false, false);
	this.addEventNames(["onInit"]);
	this.origin =  UICircleLayout.O_CENTER;
	this.setSizeLimit(120, 120, 1000, 1000, 1);

	return this;
}

UICircleLayout.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIImage || shape.isUIButton) {
		return true;
	}

	return false;
}

UICircleLayout.prototype.paintSelfOnly = function(canvas) {
	if(this.mode === Shape.MODE_EDITING) {
		canvas.lineWidth = this.style.lineWidth;

		switch(this.origin) {
			case UICircleLayout.O_CENTER: {
				var ox = this.w >> 1;
				var oy = this.h >> 1;
				var r = (this.w >> 1) - 30;
				var n = this.children.length ? this.children.length : 6;
				var angle = n > 1 ? (2 * Math.PI/(n-1)) : 0;

				canvas.beginPath();
				canvas.fillStyle = this.style.fillColor;
				canvas.strokeStyle = this.style.lineColor;
				canvas.arc(ox, oy, r, 0, Math.PI * 2);
				canvas.stroke();

				var deltaA = -0.5 * Math.PI;
				for(var i = 0; i < n; i++) {
					canvas.beginPath();

					if(i == 0) {
						canvas.arc(ox, oy, 10, 0, Math.PI * 2);
						canvas.stroke();
					}
					else {
						var a = angle * (i - 1) + deltaA;
						var x = ox + r * Math.cos(a);
						var y = oy + r * Math.sin(a);
						canvas.arc(x, y, 10, 0, Math.PI * 2);
						canvas.stroke();
					}
				}
				
				canvas.stroke();
				break;
			}
			default:break;
		}
	}

	return;
}


UICircleLayout.prototype.moveShapeToCenter = function(shape, x, y) {
	x = x - (shape.w >> 1);
	y = y - (shape.h >> 1);

	shape.move(x, y);

	return;
}

UICircleLayout.prototype.relayoutChildren = function() {
	if(this.disableRelayout) {
		return;
	}

	switch(this.origin) {
		case UICircleLayout.O_CENTER: {
			var ox = this.w >> 1;
			var oy = this.h >> 1;
			var r = (this.w >> 1) - 30;
			var n = this.children.length - 1;
			var angle = n > 0 ? (2 * Math.PI/n) : 0;

			var deltaA = -0.5 * Math.PI;
			for(var i = 0; i < this.children.length; i++) {
				var iter = this.children[i];
				if(i == 0) {
					this.moveShapeToCenter(iter, ox, oy);
				}
				else {
					var a = angle * (i - 1) + deltaA;
					var x = ox + r * Math.cos(a);
					var y = oy + r * Math.sin(a);
					this.moveShapeToCenter(iter, x, y);
				}
			}
			break;
		}
		default:break;
	}

	return;
}

UICircleLayout.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_FIX_TOP;
	shape.xAttr = UIElement.X_FIX_LEFT;
	shape.widthAttr = UIElement.WIDTH_SCALE;
	shape.heightAttr = UIElement.HEIGHT_SCALE;
	shape.setUserMovable(true);
	shape.setUserResizable(true);
	shape.setCanRectSelectable(false, true);
	this.relayoutChildren();

	return true;
}

function UICircleLayoutCreator(w, h, img) {
	var args = ["ui-circle-layout", "ui-circle-layout", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICircleLayout();

		return g.initUICircleLayout(this.type, w, h, img);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICircleLayoutCreator(400, 400));

/*
 * File:   ui-grid.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Grid
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGrid
 * @extends UIElement
 * 网格容器，里面的子控件按行列排列，每个子控件大小相同。
 *
 */
function UIGrid() {
	return;
}

UIGrid.prototype = new UIElement();
UIGrid.prototype.isUIGrid = true;
UIGrid.prototype.isUILayout = true;

UIGrid.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.cols = this.cols;
	o.rows = this.rows;
	o.spacer = this.spacer;
	o.scrollDirection = this.scrollDirection;

	return o;
}

UIGrid.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.cols = js.cols;
	this.rows = js.rows;
	this.spacer = js.spacer;
	this.scrollDirection = js.scrollDirection;

	return js;
}

UIGrid.prototype.initUIGrid = function(type) {
	this.initUIElement(type);	

	this.spacer = 0;
	this.offset = 0;
	this.setMargin(0, 0);
	this.setDefSize(200, 200);

	this.rows = 3;
	this.cols = 3;
	this.checkable = false;
	this.rectSelectable = false;
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.setImage(UIElement.IMAGE_CHECKED_ITEM, null);
	this.addEventNames(["onChildDragged", "onChildDragging", "onInit"]);

	return this;
}

/**
 * @method setRows
 * 设置行数。
 * @param {Number} value 行数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setRows = function(value) {
	this.rows = value;

	return this;
}

/**
 * @method getRows
 * 获取行数。
 * @return {Number} 返回行数。
 *
 */
UIGrid.prototype.getRows = function() {
	return this.rows;
}

/**
 * @method setCols
 * 设置列数。
 * @param {Number} value 列数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setCols = function(value) {
	this.cols = value;

	return this;
}

/**
 * @method getCols
 * 获取列数。
 * @return {Number} 返回列数。
 *
 */
UIGrid.prototype.getCols = function() {
	return this.cols;
}

/**
 * @method isCheckable
 * 检查是否进入勾选模式。
 * @return {Boolean} 是否进入勾选模式。
 *
 */
UIGrid.prototype.isCheckable = function(value) {
	return this.checkable;
}

/**
 * @method setCheckable
 * 设置是否进入勾选模式。进入勾选模式后可以勾选子控件。
 * (记得在IDE中设置网格的勾选子项的图标)
 * @param {Boolean} value 是否进入勾选模式。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setCheckable = function(value) {
	this.checkable = value;

	return this;
}

/**
 * @method setChildChecked
 * 勾选指定的子控件。
 * @param {Number} index 子控件的索引。
 * @param {Boolean} checked 是否勾选。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setChildChecked = function(index, checked) {
	if(index >= 0 && index < this.children.length) {
		this.children[index].checked = checked; 
	}

	return this;
}

/**
 * @method isChildChecked
 * 检查指定的子控件是否勾选。
 * @param {Number} index 子控件的索引。
 * @return {Boolean} 返回子控件是否勾选。
 *
 */
UIGrid.prototype.isChildChecked = function(index) {
	if(index < this.children.length) {
		return this.children[index].checked; 
	}

	return false;
}

/**
 * @method getChildByRowCol
 * 通过行列数获取对应的子控件。
 * @param {Number} row 行数。
 * @param {Number} col 列数。
 * @return {UIElement} 返回子控件。
 *
 */
UIGrid.prototype.getChildByRowCol = function(row, col) {
	var cols = this.getCols();
	var index = row * cols + col;

	if(index < this.children.length) {
		return this.children[index];
	}
	else {
		return null;
	}
}

/**
 * @method getChildRow
 * 获取指定子控件所在的行数。
 * @param {UIElement} child 子控件。
 * @return {Number} 返回行数。
 *
 */
UIGrid.prototype.getChildRow = function(child) {
	var cols = this.getCols();
	var index = this.children.indexOf(child);

	return Math.floor(index/cols);
}

/**
 * @method getChildCol
 * 获取指定子控件所在的列数。
 * @param {UIElement} child 子控件。
 * @return {Number} 返回列数。
 *
 */
UIGrid.prototype.getChildCol = function(child) {
	var cols = this.getCols();
	var index = this.children.indexOf(child);

	return index%cols;
}

/**
 * @method exchangeTwoChildren
 * 交换两个子控件的位置。
 * @param {Number} child1Index 子控件1的索引。
 * @param {Number} child2Index 子控件2的索引。
 * @param {Boolean} enableAnimation 是否启用动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.exchangeTwoChildren = function(child1Index, child2Index, enableAnimation) {
	var n = this.children.length;
	if(child1Index < 0 || child1Index >= n || child2Index < 0 || child2Index >= n) {
		return this;
	}

	var child = this.children[child1Index];
	this.children[child1Index] = this.children[child2Index];
	this.children[child2Index] = child;

	this.relayoutChildren(enableAnimation);

	return this;
}

UIGrid.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

UIGrid.prototype.childIsBuiltin = function(child) {
	return child.name === "ui-last";
}

UIGrid.prototype.calcItemSize = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);

	var iw = Math.floor(w/this.cols);
	var ih = Math.floor(h/this.rows);

	return {w:iw, h:ih, cols:this.cols, rows:this.rows};
}

UIGrid.prototype.sortChildren = function() {}

UIGrid.prototype.getChildIndexByPoint = function(point) {
	var border = this.getHMargin();
	var itemSize = this.calcItemSize();
	
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var itemW = itemSize.w + spacer;
	var itemH = itemSize.h + spacer;
	var cols = Math.floor(w/itemW);
	var rows = Math.floor(h/itemH);

	var r = Math.floor((point.y - border)/itemSize.h);
	var c = Math.floor((point.x - border)/itemSize.w);

	var index = r * cols + c;

	return index;
}

UIGrid.prototype.onChildDragging = function(child, point) {
	var targetChildIndex = this.getChildIndexByPoint(point);
	var sourceChildIndex = this.getIndexOfChild(child);
	
	this.callOnChildDraggingHandler(sourceChildIndex, targetChildIndex);

	return;
}

UIGrid.prototype.onChildDragged = function(child, point) {
	var targetChildIndex = this.getChildIndexByPoint(point);
	var sourceChildIndex = this.getIndexOfChild(child);
	
	this.callOnChildDraggedHandler(sourceChildIndex, targetChildIndex);
	
	this.relayoutChildren("default");

	return;
}

UIGrid.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var r = 0;
	var c = 0;
	var x = 0;
	var y = 0;
	var cols = this.cols;
	var rows = this.rows;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var iw = Math.floor((w - (cols-1)*spacer)/cols);
	var ih = Math.floor((h - (rows-1)*spacer)/rows);
	var itemW = iw + spacer;
	var itemH = ih + spacer;

	var vMargin = (this.h - rows * itemH) >> 1;
	var hMargin = (this.w - cols * itemW) >> 1;

	var i = 0;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];
		child.z = k;
		if(child.removed || !child.visible) continue;

		r = Math.floor(i/cols);
		c = Math.floor(i%cols);
	
		x = hMargin + c * itemW;
		y = vMargin + r * itemH;

		child.setSize(iw, ih);
		if(animHint || this.mode === Shape.MODE_EDITING) {
			child.animMove(x, y, animHint);
		}
		else {
			child.move(x, y);
		}

		child.xAttr = UIElement.X_FIX_LEFT;
		child.yAttr = UIElement.Y_FIX_TOP;
		child.widthAttr = UIElement.WIDTH_FIX;
		child.heightAttr = UIElement.HEIGHT_FIX;
		child.setUserMovable(true);
		child.setUserResizable(false);
		child.relayoutChildren();
		if(!this.isUIScrollView) {
			child.setDraggable(this.itemDraggable);
		}

		i++;
	}

	return;
}

UIGrid.prototype.afterChildAppended = function(shape) {
	if(this.mode === Shape.MODE_EDITING && !this.disableRelayout) {
		this.sortChildren();
	}

	this.moveMustBeLastItemToLast();
	shape.setUserMovable(true);
	shape.setUserResizable(false);
	shape.setCanRectSelectable(false, true);
	shape.setDraggable(this.itemDraggable);

	shape.xAttr = UIElement.X_FIX_LEFT;
	shape.yAttr = UIElement.Y_FIX_TOP;
	shape.widthAttr = UIElement.WIDTH_FIX;
	shape.heightAttr = UIElement.HEIGHT_FIX;

	if(this.mode === Shape.MODE_EDITING && !this.disableRelayout) {
		this.relayoutChildren();
	}

	return true;
}

UIGrid.prototype.triggerDeleteMode = function() {
	if(this.mode === Shape.MODE_EDITING) {
		return;
	}

	this.deleteMode = !this.deleteMode;

	var grid = this;
	function redrawGrid() {
		grid.postRedraw();

		if(grid.deleteMode) {
			setTimeout(redrawGrid, 20);
		}
	}

	redrawGrid();

	return;
}

UIGrid.prototype.isInDeleteMode = function() {
	return this.deleteMode && this.mode != Shape.MODE_EDITING;
}

UIGrid.prototype.beforePaintChild = function(child, canvas) {
	if(this.isInDeleteMode()) {
		canvas.save();
		var cx = child.left + child.w/2;
		var cy = child.top + child.h/2;
		var t = canvas.now/1000;
		var angle = 0.03 * Math.cos(20*t);

		canvas.translate(cx, cy);
		canvas.rotate(angle);
		canvas.translate(-cx, -cy);
	}

	return;
}

UIGrid.prototype.afterPaintChild = function(child, canvas) {
	if(this.isInDeleteMode()) {
		var wImage = this.getImageByType(UIElement.IMAGE_DELETE_ITEM);
		if(WImage.isValid(wImage)) {
			var image = wImage.getImage();
			var srcRect = wImage.getImageRect();
			var y = child.top + child.vMargin;
			var x = child.left + child.w - srcRect.w - child.hMargin;

			canvas.drawImage(image, x, y);
			WImage.draw(canvas, image, WImage.DISPLAY_CENTER, x, y, srcRect.w, srcRect.h, srcRect);
		}

		canvas.restore();

		return;
	}

	if(this.checkable) {
		if(child.checked) {
			var wImage = this.getImageByType(UIElement.IMAGE_CHECKED_ITEM);
			if(WImage.isValid(wImage)) {
				var image = wImage.getImage();
				var srcRect = wImage.getImageRect();
				WImage.draw(canvas, image, WImage.DISPLAY_AUTO_SIZE_DOWN, child.left, child.top, child.w, child.h, srcRect);
			}
		}
	}

	return;
}

function UIGridCreator(border) {
	var args = ["ui-grid", "ui-grid", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGrid();
		return g.initUIGrid(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridCreator());

/*
 * File:   ui-grid-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Grid View(Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGridView
 * @extends UIGrid
 * UIGridView和UIGrid类似，只是它可以垂直滚动。
 *
 */
function UIGridView() {
	return;
}

UIGridView.prototype = new UIVScrollView();
UIGridView.prototype.isUIGrid = true;
UIGridView.prototype.isUILayout= true;
UIGridView.prototype.isUIGridView = true;
UIGridView.prototype.doToJson = UIGrid.prototype.doToJson;
UIGridView.prototype.doFromJson = UIGrid.prototype.doFromJson;
UIGridView.prototype.sortChildren = UIGrid.prototype.sortChildren;
UIGridView.prototype.initUIGrid = UIGrid.prototype.initUIGrid;
UIGridView.prototype.shapeCanBeChild = UIGrid.prototype.shapeCanBeChild;
UIGridView.prototype.childIsBuiltin = UIGrid.prototype.childIsBuiltin;
UIGridView.prototype.paintSelfOnly = UIGrid.prototype.paintSelfOnly;
UIGridView.prototype.calcItemSize = UIGrid.prototype.calcItemSize;
UIGridView.prototype.relayoutChildren = UIGrid.prototype.relayoutChildren;
UIGridView.prototype.afterChildAppended = UIGrid.prototype.afterChildAppended;
UIGridView.prototype.isInDeleteMode = UIGrid.prototype.isInDeleteMode;
UIGridView.prototype.beforePaintChild = UIGrid.prototype.beforePaintChild;
UIGridView.prototype.afterPaintChild = UIGrid.prototype.afterPaintChild;
UIGridView.prototype.triggerDeleteMode = UIGrid.prototype.triggerDeleteMode;
UIGridView.prototype.setCheckable = UIGrid.prototype.setCheckable;
UIGridView.prototype.setChildChecked = UIGrid.prototype.setChildChecked;
UIGridView.prototype.isChildChecked = UIGrid.prototype.isChildChecked;

UIGridView.prototype.initUIGridView = function(type) {
	this.initUIGrid(type);
	this.initUIVScrollView(type, 0, null, null);	
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.setImage(UIElement.IMAGE_CHECKED_ITEM, null);

	return this;
}

UIGridView.prototype.onModeChanged = function() {
	this.offset = 0;

	return;
}

function UIGridViewCreator() {
	var args = ["ui-grid-view", "ui-grid-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGridView();
		return g.initUIGridView(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridViewCreator());

/*
 * File:   ui-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Use image to present a value, such as sound volume/battery status.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIImageValue
 * @extends UIElement
 * 用图片来表示数值。调用setValue来切换图片。
 */
function UIImageValue() {
	return;
}

UIImageValue.prototype = new UIImage();
UIImageValue.prototype.isUIImageValue = true;

UIImageValue.prototype.initUIImageValue = function(type, w, h) {
	this.initUIImage(type, w, h, null);	
	this.value = 0;

	return this;
}

UIImageValue.prototype.getImageSrcByValue = function(value) {
	var type = "option_image_" + value; 

	return this.getImageSrcByType(type);
}

UIImageValue.prototype.getValue = function() {
	return this.value;
}

UIImageValue.prototype.setValue = function(value) {
	var src = this.getImageSrcByValue(value);

	if(src) {
		this.value = value;
		this.setImage(UIElement.IMAGE_DEFAULT, src);
	}

	return this.value;
}

UIImageValue.prototype.inc = function() {
	var value = this.value + 1;

	return this.setValue(value);	
}

UIImageValue.prototype.dec = function() {
	var value = this.value - 1;

	return this.setValue(value);	
}

UIImageValue.prototype.getImages = function() {
	var str = "";
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter && iter.src) {
			str += iter.src + "\n";
		}
	}

	return str;
}

UIImageValue.prototype.setImages = function(value) {
	var display = this.images.display;
	this.images = {};
	this.images.display = display;

	if(value) {
		var i = 0;
		var k = 0;
		var arr = value.split("\n");

		for(var i = 0; i < arr.length; i++) {
			var iter = arr[i];
			if(!iter) continue;

			if(iter.indexOf("/") === 0) {
				iter = iter.substr(1);
			}

			var name = "option_image_" + (k++);
			this.setImage(name, iter);
		}

		this.setValue(this.value);
	}
	
	return this;
}

UIImageValue.prototype.shapeCanBeChild = function(shape) {
	return false;
}


function UIImageValueCreator(w, h, defaultImage) {
	var args = ["ui-image-value", "ui-image-value", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageValue();
		return g.initUIImageValue(this.type, w, h, defaultImage);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageValueCreator(200, 200, null));
/*
 * File:   ui-image-thumb-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Thumb Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageThumbView() {
	return;
}

UIImageThumbView.prototype = new UIImageView();
UIImageThumbView.prototype.isUIImageThumbView = true;

UIImageThumbView.prototype.saveProps = ["keepRatio", "itemSize"];
UIImageThumbView.prototype.initUIImageThumbView = function(w, h) {
	this.userImages = [];
	this.imageProxies = [];

	this.itemSize = 0;
	this.setDefSize(w, h);
	this.initUIImageView(w, h);

	this.setItemSize = UIImageThumbView.prototype.setItemSize;
	this.getCacheCanvas        = UIImageThumbView.prototype.getCacheCanvas;
	this.getCacheCanvasContext = UIImageThumbView.prototype.getCacheCanvasContext;
	this.setValue              = UIImageThumbView.prototype.setValue;
	this.getCurrentImage       = UIImageThumbView.prototype.getCurrentImage;
	this.getCurrentImageSrc    = UIImageThumbView.prototype.getCurrentImageSrc;

	imageThumbViewInitCustomProp(this);
	this.errorImage = UIImageView.createImage("drawapp8/images/common/failed.png", null);
	this.loadingImage = UIImageView.createImage("drawapp8/images/common/loading.png", null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIImageThumbView.prototype.setItemSize = function(itemSize) {
	this.itemSize = itemSize ? itemSize : 100;

	if(itemSize) {
		this.setSizeLimit(100, itemSize + 10, 2000, 2000);
	}

	return;
}

UIImageThumbView.prototype.setKeepRatio = function(keepRatio) {
	if(this.keepRatio != keepRatio) {
		this.cacheInvalid = true;
	}

	this.keepRatio = keepRatio;

	return;
}

UIImageThumbView.prototype.getCacheCanvasContext = function(w, h) {
	if(!this.cacheImagesCanvas) {
		canvas = document.createElement("canvas");
		canvas.width = w;
		canvas.height = h;

		this.cacheImagesCanvas = canvas;
	}

	if(canvas.width != w) {
		canvas.width = w;
	}

	if(canvas.height != h) {
		canvas.height = h;
	}

	var ctx = canvas.getContext("2d");

	ctx.clearRect(0, 0, w, h);

	return ctx;
}

UIImageThumbView.prototype.getCurrentImageSrc = function() {
	return this.currentImageProxy ? this.currentImageProxy.src : null;
}

UIImageThumbView.prototype.getCurrentImage = function() {
	return this.currentImageProxy ? this.currentImageProxy.image : null;
}

UIImageThumbView.prototype.setValue = function(src) {
	for(var i = 0; i < this.imageProxies.length; i++) {
		var iter = this.imageProxies[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			this.currentImageProxy = iter;
			return this;
		}
	}

	return this;
}

UIImageThumbView.createImageProxy = function(thumbview, src, loadingImage, errorImage, ctxToDraw, x, y, w, h) {
	var imageProxy = {};

	imageProxy.x = x;
	imageProxy.y = y;
	imageProxy.w = w;
	imageProxy.h = h;
	imageProxy.src = src;
	imageProxy.imageState = UIImageView.IMAGE_STATE_PENDING;

	function onLoadDone(image, result) {
		var keepRatio = thumbview.keepRatio;

		if(result) {
			imageProxy.imageState = UIImageView.IMAGE_STATE_DONE;
			UIImageView.drawImageAtCenter(ctxToDraw, image, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
		}
		else {
			imageProxy.imageState = UIImageView.IMAGE_STATE_ERROR;
			UIImageView.drawImageAtCenter(ctxToDraw, errorImage, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
		}

		console.log("onLoadDone: " + image.src);
		thumbview.postRedraw();	
	}

	imageProxy.image = UIImageView.createImage(src, onLoadDone);

	if(imageProxy.imageState === UIImageView.IMAGE_STATE_PENDING) {
		var keepRatio = thumbview.keepRatio;	
		UIImageView.drawImageAtCenter(ctxToDraw, loadingImage, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
	}

	return imageProxy;
}

UIImageThumbView.prototype.createCacheCanvas = function() {
	
}

UIImageThumbView.prototype.getCacheCanvas = function() {
	if(this.cacheInvalid || !this.cacheImagesCanvas) {
		this.createCacheCanvas();
	}

	return this.cacheImagesCanvas;
}

/////////////////////////////////////////////////////////////////////////}-{

function UIImageThumbViewTape() {
	return;
}

UIImageThumbViewTape.prototype = new UIHScrollView();

UIImageThumbViewTape.prototype.isUIImageView = true;
UIImageThumbViewTape.prototype.isUIImageThumbView = true;
UIImageThumbViewTape.prototype.isUIImageThumbViewTape = true;

UIImageThumbViewTape.prototype.initUIImageView = UIImageView.prototype.initUIImageView;
UIImageThumbViewTape.prototype.initUIImageThumbView = UIImageThumbView.prototype.initUIImageThumbView;

UIImageThumbViewTape.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIImageThumbViewTape.prototype.initUIImageThumbViewTape = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	
	this.initUIImageThumbView (w, h);

	this.heightAttr = UIElement.HEIGHT_FIX;

	return this;
}

UIImageThumbViewTape.prototype.getSpaceBetweenImages = function() {
	return this.spaceBetweenImages ? this.spaceBetweenImages : 2;
}

UIImageThumbViewTape.prototype.createCacheCanvas = function() {
	var space = this.getSpaceBetweenImages();
	var w = this.w;
	var h = this.h;
	var size = (this.itemSize > 0 && this.itemSize < h) ? this.itemSize : h;

	var canvas = this.cacheImagesCanvas;
	var n = this.userImages.length;
	
	delete this.cacheInvalid;
	this.imageProxies.clear();
	this.currentImageProxy = null;

	if(!n) {
		return;
	}

	w = n * (size + space);

	var x = 0; 
	var y = Math.floor((h - size)/2);
	var errorImage = this.errorImage;
	var loadingImage = this.loadingImage;
	var ctx = this.getCacheCanvasContext(w, h);

	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		
		var imageProxy = UIImageThumbView.createImageProxy(this, src, loadingImage, errorImage, ctx, x, y, size, size);
		this.imageProxies.push(imageProxy);
		
		x = x + size + space;
	}

	return;
}

UIImageThumbViewTape.prototype.getScrollRange = function() {
	var size = this.h;
	var space = this.getSpaceBetweenImages();
	var range = this.userImages.length * (size + space) + space;

	return range;
}

UIImageThumbViewTape.prototype.paintChildren = function(canvas) {
	return;
}

UIImageThumbViewTape.prototype.getCacheCanvasOffset = function() {
	var offset = Math.max(0, (this.w - this.cacheImagesCanvas.width)/2);

	return offset;
}

UIImageThumbViewTape.prototype.onClick = function(point, beforeChild) {
	if(!this.imageProxies || !this.imageProxies.length || beforeChild) {
		return;
	}

	this.currentImageProxy = null;
	var x = point.x - this.getCacheCanvasOffset();

	for(var i = 0; i < this.imageProxies.length; i++) {
		var iter = this.imageProxies[i];
		if(x >= iter.x && x < (iter.x + iter.w)) {
			this.currentImageProxy = iter;	
		}
	}
	
	this.callOnClickHandler(point);
	this.callOnChangedHandler(this.getCurrentImageSrc());

	return;
}

UIImageThumbViewTape.prototype.paintSelfOnly = function(canvas) {
	if(!this.userImages || !this.userImages.length || !this.getCacheCanvas()) {
		canvas.rect(0, 0, this.w, this.h);
		canvas.stroke();

		return;
	}

	var w = 0;
	var y = 0;
	var h = this.h;
	var selfW = this.w;
	var cacheCanvas = this.getCacheCanvas();
	var cacheCanvasOffset = this.getCacheCanvasOffset();
	var x = cacheCanvasOffset;

	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	if(this.offset >= 0) {
		if(x > this.offset) {
			x = x-this.offset;
			var w = cacheCanvas.width;
			canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, x, y, w, h);
			cacheCanvasOffset = x;
		}
		else {
			var offset = this.offset - x; 
			var w = Math.min(selfW, cacheCanvas.width-offset);
			canvas.drawImage(this.cacheImagesCanvas, offset, 0, w, h, 0, y, w, h);
			cacheCanvasOffset = -offset;
		}
	}
	else {
		x = x-this.offset;
		var w = Math.min(selfW+this.offset, cacheCanvas.width);
		canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, x, y, w, h);
		cacheCanvasOffset = x;
	}

	if(this.currentImageProxy) {
		x = cacheCanvasOffset + this.currentImageProxy.x;
		y = this.currentImageProxy.y;

		canvas.lineWidth = 3;
		canvas.rect(x, y, this.currentImageProxy.w, this.currentImageProxy.h);
		canvas.stroke();
	}

	return;
}

function UIImageThumbViewTapeCreator() {
	var args = ["ui-image-thumb-view-tape", "ui-image-thumb-view-tape", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageThumbViewTape();

		return g.initUIImageThumbViewTape(this.type, 300, 100);
	}
	
	return;
}

/////////////////////////////////////////////////////////////////////////}-{

function UIImageThumbViewGrid() {
	return;
}

UIImageThumbViewGrid.prototype = new UIHScrollView();

UIImageThumbViewGrid.prototype.isUIImageView = true;
UIImageThumbViewGrid.prototype.isUIImageThumbView = true;
UIImageThumbViewGrid.prototype.isUIImageThumbViewGrid = true;

UIImageThumbViewGrid.prototype.initUIImageView = UIImageView.prototype.initUIImageView;
UIImageThumbViewGrid.prototype.initUIImageThumbView = UIImageThumbView.prototype.initUIImageThumbView;

UIImageThumbViewGrid.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIImageThumbViewGrid.prototype.initUIImageThumbViewGrid = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	
	this.initUIImageThumbView (w, h);
	this.setSizeLimit(100, 40, 2000, 2000);

	this.rows = 4;
	this.cols = 3;
	this.pageNr = 1;
	this.itemSize = 100;

	return this;
}

UIImageThumbViewGrid.prototype.calcSize = function() {
	if(!this.userImages) {
		return;
	}

	if(this.isIcon) {
		this.cols = 3;
		this.rows = 4;
		this.pageNr = 1;

		return;
	}

	var n = this.userImages.length;
	var deviceConfig = this.getDeviceConfig();
	var density = deviceConfig ? deviceConfig.lcdDensity : "hdpi";
	var densityScale = this.getDensitySizeByName(density)/160;
	var w = this.w/densityScale;
	var h = this.h/densityScale;

	var cols = Math.round(w/this.itemSize);
	var rows = Math.round(h/this.itemSize);

	this.cols = cols;
	this.rows = rows;
	this.pageNr = Math.ceil(n/(rows*cols));

	return;
}

UIImageThumbViewGrid.prototype.getSpaceBetweenImages = function() {
	return this.spaceBetweenImages ? this.spaceBetweenImages : 2;
}

UIImageThumbViewGrid.prototype.createCacheCanvas = function() {
	var n = this.userImages.length;
	var space = this.getSpaceBetweenImages();

	delete this.cacheInvalid;
	this.imageProxies.clear();
	this.currentImageProxy = null;

	this.calcSize();

	if(!n) {
		return;
	}

	var x = 0;
	var y = 0;
	var k = 0;
	var h = this.h;
	var w = this.pageNr * this.w;
	var ctx = this.getCacheCanvasContext(w, h);
	var itemW = Math.floor((this.w-space)/this.cols) - space;
	var itemH = Math.floor((this.h-space)/this.rows) - space;

	var errorImage = this.errorImage;
	var loadingImage = this.loadingImage;

	for(var i = 0; i < this.pageNr; i++) {
		y = space;
		for(var r = 0; r < this.rows; r++) {
			x = i * this.w + space;
			for(var c = 0; c < this.cols; c++, k++) {
				if(k >= n) {
					break;
				}

				var src = this.userImages[k];
				var imageProxy = UIImageThumbView.createImageProxy(this, src, loadingImage, errorImage, ctx, x, y, itemW, itemH);

				this.imageProxies.push(imageProxy);

				x = x + itemW + space;
			}
			y = y + itemH + space;
		}
	}

	return;
}

UIImageThumbViewGrid.prototype.getScrollRange = function() {
	var range = this.pageNr * this.w;

	return range;
}

UIImageThumbViewGrid.prototype.paintChildren = function(canvas) {
	return;
}

UIImageThumbViewGrid.prototype.getCacheCanvasOffset = function() {
	return this.getSpaceBetweenImages();
}

UIImageThumbViewGrid.prototype.onClick = function(point, beforeChild) {
	if(!this.imageProxies || !this.imageProxies.length || beforeChild) {
		return;
	}

	var x = point.x;
	var y = point.y;
	var n = this.imageProxies.length;

	var page = Math.floor(x/this.w);
	var row = Math.floor(y*this.rows/this.h) ;
	var col = Math.floor((x%this.w) * this.cols/this.w);
	var i = page * this.rows * this.cols + row * this.cols + col;

	if(i < n) {
		this.currentImageProxy = this.imageProxies[i];
	}

	this.callOnClickHandler(point);
	this.callOnChangedHandler(this.getCurrentImageSrc());

	return this.callOnClickHandler(point);
}

UIImageThumbViewGrid.prototype.paintSelfOnly = function(canvas) {
	var space = this.getSpaceBetweenImages();
	if(!this.userImages || !this.userImages.length || !this.getCacheCanvas()) {
		canvas.rect(0, 0, this.w, this.h);
		canvas.stroke();

		return;
	}

	var w = 0;
	var selfW = this.w;
	var offset = this.offset;
	var cacheCanvas = this.getCacheCanvas();

	var h = cacheCanvas.height;
	var canvasWidth = cacheCanvas.width;

	if(offset >= 0) {
		var w = Math.min(selfW, canvasWidth-offset);
		canvas.drawImage(this.cacheImagesCanvas, offset, 0, w, h, 0, 0, w, h);
	}
	else {
		var w = Math.min(canvasWidth+offset, selfW);
		canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, -offset, 0, w, h);
	}

	if(this.currentImageProxy) {
		y = this.currentImageProxy.y;
		x = this.currentImageProxy.x - offset;

		canvas.rect(x, y, this.currentImageProxy.w, this.currentImageProxy.h);
		canvas.lineWidth = 3;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();

	}

	return;
}

UIImageThumbViewGrid.prototype.saveProps = UIImageThumbView.prototype.saveProps;
UIImageThumbViewTape.prototype.saveProps = UIImageThumbView.prototype.saveProps;

function UIImageThumbViewGridCreator() {
	var args = ["ui-image-thumb-view-grid", "ui-image-thumb-view-grid", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageThumbViewGrid();

		return g.initUIImageThumbViewGrid(this.type, 300, 100);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIImageThumbViewTapeCreator());
ShapeFactoryGet().addShapeCreator(new UIImageThumbViewGridCreator());

/*
 * File:   ui-layout.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Layout
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

function UILayout() {
	return;
}

UILayout.prototype = new UIElement();
UILayout.prototype.isUILayout = true;

UILayout.prototype.initUILayout = function(type, w, h) {
	this.initUIElement(type);	

	this.spacer = 10;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);
	this.vLayout = (this.type === "ui-v-layout");
	this.addEventNames(["onInit"]);

	return this;
}

UILayout.prototype.relayoutChildren = function() {
	if(this.disableRelayout) {
		return;
	}

	var w = this.w;
	var h = this.h;
	var x = this.hMargin;
	var y = this.vMargin;
	var vLayout = this.vLayout;
	var spacer = this.spacer ? this.spacer : 0;

	var n = this.children.length;
	var children = this.children;
	for(var i = 0; i < n; i++) {
		var iter = children[i];

		if(!iter.isVisible()) {
			continue;
		}

		if(vLayout) {
			iter.top = y;
			iter.left = (w - iter.w) >> 1;

			if(iter.heightAttr === UIElement.HEIGHT_SCALE) {
				iter.h = iter.heightParam * h; 
			}
			y += iter.h + spacer;
		}
		else {
			iter.left = x;
			iter.top = (h - iter.h) >> 1;
			if(iter.widthAttr === UIElement.WIDTH_SCALE) {
				iter.w = iter.widthParam * w;
			}

			x += iter.w + spacer;
		}
		
		iter.relayoutChildren();
	}
	
	return;
}

function UILayoutCreator(type) {
	var args = [type, type, null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILayout();

		return g.initUILayout(this.type, 100, 100);
	}
	
	return;
}

UILayout.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

ShapeFactoryGet().addShapeCreator(new UILayoutCreator("ui-v-layout"));
ShapeFactoryGet().addShapeCreator(new UILayoutCreator("ui-h-layout"));

/*
 * File:   ui-frames.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Frames
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIFrames
 * @extends UIElement
 * 用来管理多个子控件，但是只有一个显示出来。
 *
 */
function UIFrames() {
	return;
}

UIFrames.prototype = new UIElement();
UIFrames.prototype.isUIFrames = true;
UIFrames.prototype.saveProps = ["current"];

UIFrames.prototype.initUIFrames = function(type) {
	this.initUIElement(type);	

	this.current = 0;
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.addEventNames(["onChanged"]);

	return this;
}

UIFrames.preparseBackendCanvas = function(leftWin, RightWin) {
	var w = leftWin.w;
	var h = leftWin.h;
	var backendCanvas = Animation.getBackendCanvas(2 * w, h);
	var context = backendCanvas.getContext("2d");
	context.now = Date.now();
	context.timeStep = 0;
	context.clearRect(0, 0, 2*w, h);
	context.save();
	leftWin.paint(context);
	context.translate(w, 0);
	RightWin.paint(context);
	context.restore();

	return backendCanvas;
}

UIFrames.prototype.getStatusString = function() {
	var str = "";
	var current = this.current + 1;
	var n = this.children.length;
	var frame = this.getCurrentFrame();

	current = current <= n ? current : n;
	if(frame && frame.name) {
		str = frame.name + "(" + current + "/" + n + ")";
	}
	else {
		str = current + "/" + n;
	}

	return str;
}

/**
 * @method getCurrent
 * 获取当前显示的子控件的索引。
 * @return {Number} 当前显示的子控件的索引。
 *
 */
UIFrames.prototype.getCurrent = function() {
	return this.current;
}


/**
 * @method setCurrent
 * 设置当前显示的子控件。
 * @param {Number} current 当前显示的子控件的索引。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrames.prototype.setCurrent = function(current) {
	if(this.current !== current) {
		this.current = current;
		
		if(this.mode != Shape.MODE_EDITING) {
			this.callOnChangedHandler(current);
		}
	}

	return this;
}

UIFrames.prototype.getCurrentFrame = function() {
	if(this.children.length < 1) {
		return null;
	}

	if(this.current < 0 || !this.current) {
		this.current = 0;
	}

	if(this.current >= this.children.length) {
		this.current = this.children.length - 1;
	}

	return this.children[this.current];
}

UIFrames.prototype.fixChildSize = function(child) {
	return;
}

UIFrames.prototype.fixChildPosition = function(child) {
	var x = child.left;
	var y = child.top;
	var h = child.h;
	var w = child.w;

	if(child.freePosition) {
		return;
	}
	
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		x = this.getHMargin();
		w = this.getWidth(true);
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		y = this.getVMargin();
		h = this.getHeight(true);
	}
	
	child.left = x;
	child.top = y;
	child.h = h;
	child.w = w;

	return;
}

UIFrames.prototype.setTarget = function(shape) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(!shape) {
			child.setSelected(false);
			continue;
		}

		if(child != shape && child != shape.popupWindow) {
			child.setSelected(false);
		}
	}

	this.targetShape = shape;
	this.selected = !shape;

	return;
}
UIFrames.prototype.dispatchPointerDownToChildren = function(p) {
	var child = null;

	if(this.children.length < 1) {
		return false;
	}

	child = this.getCurrentFrame();

	if(child.onPointerDown(p)) {
		this.setTarget(child);

		return true;
	}

	return false;
}

UIFrames.prototype.addShapeIntoChildren = function(shape, p) {
	var child = null;

	if(this.children.length < 1) {
		return false;
	}

	child = this.getCurrentFrame();

	return child.addShape(shape, true, p);
}

UIFrames.prototype.paintChildren = function(canvas) {
	var child = this.getCurrentFrame();
	
	if(child) {
		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}
	
	return;
}

UIFrames.prototype.showNextFrame = function() {
	this.showFrame(this.current+1);
	this.relayoutChildren();

	return;
}

UIFrames.prototype.getFrame = function(index) {
	if(index < 0 || index >= this.children.length) {
		return null;
	}

	return this.children[index];
}

UIFrames.prototype.getFrameIndex = function(frame) {
	return this.getIndexOfChild(frame);
}

UIFrames.prototype.getFrames = function() {
	return this.children.length;
}

UIFrames.prototype.showPrevFrame = function() {
	this.showFrame(this.current-1);
	this.relayoutChildren();

	return;
}

UIFrames.prototype.showFrame = function(index) {
	var current = (index + this.children.length)%this.children.length;
	this.setCurrent(current);
	
	var currentFrame = this.children[this.current];
	if(currentFrame) {
		currentFrame.show(true);
	}

	return;
}

UIFrames.prototype.shapeCanBeChild = function(shape) {
	return true;
}

UIFrames.prototype.relayoutChildren = function() {

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];

		iter.left = 0;
		iter.top = 0;
		iter.w = this.w;
		iter.h = this.h;
		iter.widthAttr = UIElement.WIDTH_FILL_PARENT;
		iter.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		iter.relayoutChildren();
	}

	return;
}

UIFrames.prototype.afterChildAppended = function(shape) {
	this.current = this.children.length - 1;

	return;
}

UIFrames.prototype.onChildRemoved = function(shape) {
	return;
}

UIFrames.prototype.afterChildRemoved = function(shape) {
	if(this.children.length === 0) {
		this.current = 0;
	}
	else if(this.current >= this.children.length) {
		this.current--;
	}

	this.onChildRemoved(shape);

	return;
}

UIFrames.prototype.findChildByPoint = function(point, recursive) {
	var p = this.translatePoint(point);
	var curFrame = this.getCurrentFrame();

	if(curFrame) {
		return curFrame.findChildByPoint(p, recursive);	
	}

	return this;
}


function UIFramesCreator() {
	var args = ["ui-frames", "ui-frames", null, 0];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFrames();

		return g.initUIFrames(this.type);
	}
	
	return;
}
/*
 * File:   ui-check-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Check Box
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICheckBox
 * @extends UIElement
 * 多选按钮。可以用setValue来勾选/去勾选，用getValue来判断是否勾选。
 *
 */

/**
 * @event onChanged
 * 勾选状态变化时触发本事件。
 * @param {Boolean} value true表示勾选，false表示未勾选。
 */
function UICheckBox() {
	return;
}

UICheckBox.prototype = new UIElement();
UICheckBox.prototype.isUICheckBox = true;

UICheckBox.prototype.initUICheckBox = function(type) {
	this.initUIElement(type);	

	this.setDefSize(100, 100);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	this.setImage(UIElement.IMAGE_CHECKED_FG, null);
	this.setImage(UIElement.IMAGE_UNCHECK_FG, null);

	this.addEventNames(["onChanged", "onUpdateTransform"]);
	this.value = false;

	return this;
}

UICheckBox.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIImage || shape.isUILabel;
}

UICheckBox.prototype.getValue = function() {
	return this.value;
}

UICheckBox.prototype.setValue = function(value, notify) {
	if(this.value != value) {
		this.value = value;
		if(notify) {
			this.callOnChangedHandler(this.value);
		}
	}

	return this;
}

UICheckBox.prototype.getBgImage = function() {
	return this.getImageByType(this.getValue() ? UIElement.IMAGE_CHECKED_FG : UIElement.IMAGE_UNCHECK_FG);
}

UICheckBox.prototype.getTextColor = function(canvas) {
	return this.getValue() ? this.style.textColorOn : this.style.textColor;
}

UICheckBox.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	this.setValue(!this.getValue(), true);
	this.callOnClickHandler(point);

	return;
}

function UICheckBoxCreator() {
	var args = ["ui-checkbox", "ui-checkbox", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICheckBox();
		return g.initUICheckBox(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICheckBoxCreator());

/*
 * File:   ui-switch.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Switch
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISwitch() {
	return;
}

UISwitch.prototype = new UICheckBox();
UISwitch.prototype.isUISwitch = true;

UISwitch.prototype.initUISwitch = function(type, w, h, maskWidth, img) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	
	this.value = true;
	this.imageWidth = 412;
	this.maskWidth = maskWidth;
	this.offsetImage = maskWidth;
	this.addEventNames(["onChanged"]);
	this.interpolator =  new DecelerateInterpolator(2);

	return this;
}

UISwitch.prototype.updateImageSize = function(imageWidth) {
	this.imageWidth = imageWidth;
	this.maskWidth = Math.floor(imageWidth * 0.373786);

	if(!this.animating) {
		this.offsetImage = this.value ? this.maskWidth : (this.imageWidth - this.maskWidth);
	}

	return;
}

UISwitch.prototype.animateChange = function() {
	var switcher = this;
	var date  = new Date();
	var startTime = date.getTime();
	var startOffset = this.offsetImage;
	var endOffset = this.value ? this.maskWidth : (this.imageWidth - this.maskWidth);
	var range = endOffset - startOffset;
	this.animating = true;
	var duration = 500;
	function offsetIt() {
		var now = new Date();
		var nowTime = now.getTime();
		var timePercent = (nowTime - startTime)/duration;
		var percent = switcher.interpolator.get(timePercent);
		var offset = startOffset + range * percent;	

		if(timePercent < 1) {
			switcher.offsetImage = offset;
			setTimeout(offsetIt, 10);
		}
		else {
			switcher.offsetImage = endOffset;
			delete this.animating;
		}
		switcher.postRedraw();
		delete now;

		return;
	}
	
	setTimeout(offsetIt, 30);

	return;
}

UISwitch.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.mode !== Shape.MODE_EDITING) {
		return;
	}
	this.setValue(!this.value);

	return;
}

UISwitch.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.pointerDownPosition = point;

	return;
}

UISwitch.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	var dx = point.x - this.pointerDownPosition.x;
	if(Math.abs(dx) < 5) {
		this.setValue(!this.value);
	}
	else {
		this.setValue(dx > 0);
	}

	return;
}

UISwitch.prototype.setValue = function(value) {
	if(this.value != value) {
		this.value = value;
		this.callOnChangedHandler(this.value);
		this.animateChange();
	}

	return this;
}

UISwitch.prototype.drawBgImage =function(canvas) {
	return;
}

UISwitch.prototype.drawFgImage =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(image) {
		this.updateImageSize(image.width);
		var h = image.height;
		var w = this.maskWidth;
		var dx = (this.w - w)/2;
		var dy = (this.h - h)/2;

		this.imageWidth = image.width;
		canvas.drawImage(image, this.offsetImage, 0, w, h, dx, dy, w, h);

		/*draw mask Image*/
		canvas.drawImage(image, 0, 0, w, h, dx, dy, w, h);
	}

	return;
}

function UISwitchCreator(w, h, maskWidth, img) {
	var args = ["ui-switch", "ui-switch", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISwitch();
		return g.initUISwitch(this.type, w, h, maskWidth, img);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISwitchCreator(154, 54, 154, null));

/*
 * File:   ui-simple-html.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Simple HTML View
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISimpleHTML() {
	return;
}

UISimpleHTML.prototype = new UIVScrollView();
UISimpleHTML.prototype.isUISimpleHTML = true;

UISimpleHTML.prototype.saveProps = ["scrollable"];
UISimpleHTML.prototype.initUISimpleHTML = function(type, initText, bg) {
	this.initUIVScrollView(type, 10, bg, null);	

	this.setText(initText);
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);

	return this;
}

UISimpleHTML.prototype.extractHtmlElements = function(el, indexInParent) {
	var i = 0;
	var node = null;
	var simpleHtml = this;
	var tag = el.localName;
	var n = el.childNodes.length;
	var childNodes = el.childNodes;

	function createNode(type) {
		var newNode = {x:0, y:0};
		newNode.type = type;

		return newNode;
	}

	if(tag === "b") {
		this.bold = this.bold + 1;	
	}
	else if(tag === "i") {
		this.italic = this.italic + 1;	
	}
	else if(tag === "u") {
		this.underline = this.underline + 1;	
	}
	else if(tag === "a") {
		this.anchor = this.anchor + 1;	
	}
	else if(tag === "ol" || tag === "ul") {
		if(indexInParent > 0) {
			node = createNode("newline");
		}
	}
	else if(tag === "li") {
		node = createNode("text");
		if(el.parentNode.localName === "ol") {
			node.value = "    " + (indexInParent+1) + ". ";
		}
		else {
			node.value = "    o. ";
		}
		node.bold = true;
		node.color = "gray";
		node.fontStyle = "bold ";
	}

	var color = null;

	if(el.style && el.style.color) {
		color = el.style.color;
	}
	if(!color && el.getAttribute) {
		color = el.getAttribute("color");
	}
	if(!color && this.colors.length) {
		color = this.colors[this.colors.length - 1];
	}
	this.colors.push(color || "black");

	if(node) {
		node.tag = tag;
		this.elements.push(node);
		node = null;
	}

	for(var i = 0; i < n; i++) {
		var iter = childNodes[i];
		this.extractHtmlElements(iter, i);
	}
	
	if(tag === "img" && el.src) {
		var src = el.src;
		var image = new Image();
		
		image.onload = function (e) {
			node.imageLoaded = true;
			simpleHtml.textNeedRelayout = true;

			return;
		};
	
		image.onerror = function (e) {
			node.imageLoaded = false;
			if(src) {
				console.log("load " + src + " failed.");
			}
		};

		image.onabort = function (e) {
			node.imageLoaded = false;
			if(src) {
				console.log("load " + src + " failed(abort).");
			}
		};
		
		image.src = src;
		node = createNode("img");
		node.value = image;
		node.displayWidth = el.width;
		node.displayHeight = el.height;
	}
	else if(!n && el.textContent) {
		var str = el.textContent.replace(/(\t|\n|\r)+/g, '');		
		var text = str.replace(/ +/g, ' ');

		if(text) {
			node = createNode("text");
			node.value = text;
			node.bold = this.bold;
			node.italic = this.italic;
			node.underline = this.underline;
			node.anchor = this.anchor;
			node.fontStyle = "";
			if(this.colors.length) {
				node.color = this.colors[this.colors.length-1];
			}

			if(node.bold) {
				node.fontStyle = node.fontStyle + "bold ";
			}

			if(node.italic) {
				node.fontStyle = node.fontStyle + "italic ";
			}
		}
	}

	if(tag === "b") {
		this.bold = this.bold - 1;	
	}
	if(tag === "i") {
		this.italic = this.italic - 1;	
	}
	if(tag === "u") {
		this.underline = this.underline - 1;	
	}
	if(tag === "a") {
		node = createNode("a");
		node.href = el.href;
		this.anchor = this.anchor - 1;	
	}

	if(tag === "p" || (el.style != null && el.style.display === "block")) {
		node = createNode("newblock");
	}
	else if(tag === "li" || tag === "br" || tag === "hr" || tag === "dd") {
		node = createNode("newline");
	}

	this.colors.pop();

	if(node) {
		node.tag = tag;
		this.elements.push(node);
	}

	return;
}


UISimpleHTML.prototype.getNodeByPoint = function(point) {
	var i = 0;
	var x = point.x;
	var y = point.y;
	var node = null;
	var next = null;
	var rect = {};
	var n = this.elements.length;
	var elements = this.elements;
	
	for(i = 0; i < n; i++) {
		node = elements[i];
		next = ((i + 1) < n) ?  elements[i+1] : null;		
		
		if(y < node.y) {
			continue;
		}
		
		if(next && (y > next.y && node.y < next.y)) {
			continue;
		}

		if(node.type === "text") {
			var k = 0;
			var m = node.lines.length;

			rect.h = node.lineHeight;
			for(k = 0; k < m; k++) {
				rect.x = 0;
				rect.y = node.y + k * node.lineHeight;

				if(k === 0) {
					rect.x = node.x;
					rect.w = node.firstLineWidth;
				}
				else if((k + 1) === m) {
					rect.w = node.lastLineWidth;
				}
				else {
					rect.w = this.w;
				}

				if(isPointInRect(point, rect)) {
					return node;
				}
			}
		}
		else if(node.type === "img") {
			rect.x = node.x;
			rect.y = node.y;
			rect.w = node.w;
			rect.h = node.h;

			if(isPointInRect(point, rect)) {
				return node;
			}
		}
	}

	return node;
}

UISimpleHTML.prototype.layoutHtmlElements = function(canvas) {
	var i = 0;
	var offsetX = 0;
	var offsetY = 0;
	var node = null;
	var lineWidth = 0;
	var lineInfo = null;
	var n = this.elements.length;
	var elements = this.elements;
	var width = this.getWidth(true);
	var fontSize = this.style.fontSize;
	var textLayout = new TextLayout(canvas);
	var fontStr = fontSize + "pt " + this.style.fontFamily; 
	var lineGap = fontSize * 2;
	
	canvas.font = fontStr;

	for(i = 0; i < n; i++) {
		node = elements[i];
		
		if(node.type === "text") {
			node.lines = [];
			node.x = offsetX;
			node.y = offsetY;
			node.firstLineWidth = 0;
			canvas.font = node.fontStyle + fontStr;
			node.lineHeight = lineGap;
			textLayout.setText(node.value);

			while(true) {
				lineWidth = width - offsetX;
				
				if(textLayout.hasNext()) {
					lineInfo = textLayout.nextLine(lineWidth, fontSize);
					node.lines.push(lineInfo.text);
					if(node.lines.length === 1) {
						node.firstLineWidth = lineInfo.width;
					}

					if(textLayout.hasNext()) {
						offsetX = 0;
						offsetY = offsetY + lineGap;
					}
					else {
						offsetX = offsetX + lineInfo.width;
						node.lastLineWidth = lineInfo.width;
						break;
					}
				}
				else {
					break;
				}
			}
		}
		else if(node.type === "newline") {
			node.x = offsetX;
			node.y = offsetY; 
			
			offsetX = 0;
			offsetY = offsetY + lineGap;
		}
		else if(node.type === "newblock") {
			node.x = offsetX;
			node.y = offsetY; 
			
			offsetX = 0;
			offsetY = offsetY + lineGap * 1.5;
		}
		else if(node.type === "img") {
			if(node.imageLoaded) {
				var image = node.value;
				var ratio = image.height/image.width;
				var imageW = node.displayWidth ? node.displayWidth : image.width;
				var imageH = node.displayHeight ? node.displayHeight : image.height;

				node.y = offsetY + lineGap * 0.5;
				
				if(imageW < width) {
					node.w = imageW;
					node.x = Math.floor((width - imageW)/2);
					node.h = Math.floor(node.w * ratio);
				}
				else {
					node.x = 0;
					node.w = width;
					node.h = Math.floor(node.w * ratio);
				}
			
				offsetY = node.y + node.h;
				offsetY = offsetY + 0.5 * lineGap;
			}
			else {
				offsetY = offsetY + lineGap;
			}
			offsetX = 0;
		}

		this.scrollRange = offsetY;
	}

	return;
}

UISimpleHTML.prototype.getScrollRange = function() {
	return this.scrollRange ? this.scrollRange : this.h;	
}


UISimpleHTML.prototype.loadUrl = function(dataUrl, onLoadDone) {
	var rInfo = {};
	var shape = this;

	rInfo.method = "GET";
	rInfo.url = dataUrl;
	rInfo.headers = {"Cache-Control":"no-cache", "Pragma":"no-cache"};

	rInfo.onDone = function(result, xhr, respContent) {
		var success = (xhr.status === 200);
		if(xhr.status === 200) {
			var data = respContent;
			try {
				shape.setText(data);
				console.log("loadUrl: done");
			}
			catch(e) {
				success = false;
				console.log("loadUrl: failed" + e.message);
			}
		}
		
		if(onLoadDone) {
			onLoadDone(success);
		}

		return;
	}

	httpDoRequest(rInfo);

	return;
}

UISimpleHTML.prototype.setText = function(text) {
	this.text = this.toText(text);

	this.elements = [];
	var el = document.createElement("div");
	el.innerHTML = this.text;
	
	this.bold = 0;
	this.anchor = 0;
	this.italic = 0;
	this.underline = 0;
	this.strong = 0;
	this.colors = [];
	
	this.extractHtmlElements(el, 0);

	delete this.colors;
	delete this.anchor;
	delete this.bold;
	delete this.italic;
	delete this.underline;
	delete this.strong;

	this.textNeedRelayout = true;

	return;
}

UISimpleHTML.prototype.layoutHtml = function(canvas) {
	if(!this.textNeedRelayout) {
		return;
	}

	if(!this.text) {
		return;
	}

	this.layoutHtmlElements(canvas);

	this.textNeedRelayout = false;

	return;
}

UISimpleHTML.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UISimpleHTML.prototype.paintSelfOnly = function(canvas) {
	var i = 0;
	var x = 0;
	var y = 0;
	var b = 0;
	var h = this.h;
	var w = this.w;
	var node = null;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var fontSize = this.style.fontSize;	
	var lineGap = 2 * fontSize;
	var offsetX = this.hMargin;
	var offsetY = -this.offset + this.vMargin;
	var fontStr = fontSize + "pt " + this.style.fontFamily; 

	this.layoutHtml(canvas);

	canvas.save();
	canvas.rect(0, 0, w, h);
	canvas.clip();

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}
	canvas.beginPath();

	canvas.font = fontStr;
	canvas.textAlign = "left";
	canvas.textBaseline = "top";
	canvas.fillStyle = this.style.textColor;	

	var n = this.elements.length;
	var elements = this.elements;

	for(i = 0; i < n; i++) {
		node = elements[i];
		if(node.type === "text" && node.lines && node.lines.length) {
			var size = node.lines.length;
			canvas.font = node.fontStyle + fontStr;
			
			if(node.color) {
				canvas.fillStyle = node.color;
			}
			else if(node.anchor) {
				canvas.fillStyle = "Blue";
			}
			else {
				canvas.fillStyle = this.style.textColor;	
			}

			for(k = 0; k < size; k++) {
				if(k === 0) {
					x = node.x;
					y = node.y;
				}
				else {
					x = 0;
					y = node.y + k * (lineGap);
				}

				x = x + offsetX;
				y = y + offsetY;
				b = y + fontSize;
				if(y < h && b >=0) {
					width = w - x - hMargin;
					canvas.fillText(node.lines[k], x, y, width);
				}
			}
		}
		else if(node.type === "img" && node.imageLoaded) {
			var image = node.value;
			var imageW = image.width;
			var imageH = image.height;

			x = node.x + offsetX;
			y = node.y + offsetY;
			
			b = y + node.h;
			if(y < h && b >=0) {
				canvas.drawImage(image, 0, 0, imageW, imageH, x, y, node.w, node.h);
			}
		}
	}
	canvas.restore();

	return;
}

function UISimpleHTMLCreator() {
	var args = ["ui-simple-html", "ui-simple-html", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISimpleHTML();
		var initDoc = 'Simpe HTML';

		return g.initUISimpleHTML(this.type, initDoc, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISimpleHTMLCreator());

/*
 * File:   ui-html-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  HTML View
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIHtmlView() {
	return;
}

UIHtmlView.prototype = new UIHtml();
UIHtmlView.prototype.isUIHtmlView = true;

UIHtmlView.prototype.getHtmlContent = function() {
	var html = "<p>hello html view";
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var url = this.getUrl();
	var content = this.getValue();

	if(url) {
		html = '<iframe seamless="seamless" scrolling="yes" width="'+w+'" height="'+h+'" src="'+url+'"></iframe>';
	}
	else if(content) {
		html = content;
	}

	return html;
}

UIHtmlView.prototype.setText = function(text) {
	this.text = text;

	return;
}


UIHtmlView.prototype.getValue = function() {
	return this.text ? this.text : "";
}

UIHtmlView.prototype.setValue = function(text) {
	this.text = text;

	return;
}

UIHtmlView.prototype.getUrl = function() {
	return this.url ? this.url : "";
}

UIHtmlView.prototype.setUrl = function(url) {
	this.url = url;

	return;
}

UIHtmlView.prototype.paintSelfOnly = function(canvas) {
	if(!this.htmlVisible) {
		var x = this.w >> 1;
		var y = this.h >> 1;
		var str = dappGetText("HtmlView");
		canvas.textBaseline = "middle";
		canvas.textAlign = "center";
		canvas.font = this.style.getFont();
		canvas.fillStyle = this.style.textColor;
		canvas.fillText(str, x, y);
	}

	return;
}

UIHtmlView.prototype.initUIHtmlView = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("<p>hello html view");
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setScrollable(true);

	return this;
}

function UIHtmlViewCreator() {
	var args = ["ui-html-view", "ui-html-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtmlView();
		return g.initUIHtmlView(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlViewCreator());


/*
 * File:   ui-button-group.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Button Group
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIButtonGroup() {
	return;
}

UIButtonGroup.prototype = new UIElement();
UIButtonGroup.prototype.isUIButtonGroup = true;

UIButtonGroup.prototype.initUIButtonGroup = function(type, border, buttonMaxWidth, bg) {
	this.initUIElement(type);	

	this.setMargin(border, border);
	this.setDefSize(300, 60);
	this.setSizeLimit(100, 40, 1000, 120);

	this.buttonMaxWidth = buttonMaxWidth;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.rectSelectable = false;
	this.addEventNames(["onInit"]);

	if(!bg) {
		this.style.setFillColor("White");
	}

	return this;
}

UIButtonGroup.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton || shape.isUIGroup || shape.isUIRadioBox || shape.isUICheckBox) {
		return true;
	}

	return false;
}

UIButtonGroup.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

UIButtonGroup.prototype.relayoutChildren = function() {
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();
	var n = this.children.length;

	if(n === 0 || this.disableRelayout) {
		return;
	}

	var x = hMargin;
	var y = vMargin;

	var h = this.h - 2 * vMargin;
	var maxWidth = this.buttonMaxWidth;
	var defaultWidth = Math.floor((this.w - 2 * hMargin)/n);
	var w = Math.min(defaultWidth, maxWidth);

	for(var i = 0; i < n; i++) {
		var child = this.children[i];
		
		x = i * defaultWidth + (defaultWidth - w)/2 + hMargin;

		child.setLeftTop(x, y);
		child.setSize(w, h);
		child.setUserMovable(false);
		child.setUserResizable(false);
		child.relayoutChildren();
	}
	
	this.w = defaultWidth * n + 2 * hMargin;

	return;
}

UIButtonGroup.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return true;
}

function UIButtonGroupCreator(border, buttonMaxWidth, bg) {
	var args = ["ui-button-group", "ui-button-group", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIButtonGroup();
		return g.initUIButtonGroup(this.type, border, buttonMaxWidth, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIButtonGroupCreator(5, 200, null));

/*
 * File:   ui-page-indicator.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Page Indicator
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPageIndicator
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
/**
 * @class UIPageIndicatorLine
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
/**
 * @class UIPageIndicatorRect
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
/**
 * @class UIPageIndicatorCircle
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
/**
 * @class UIPageIndicatorNumber
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
/**
 * @class UIPageIndicatorNormal
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */
function UIPageIndicator() {
	return;
}

UIPageIndicator.prototype = new UIHScrollView();
UIPageIndicator.prototype.isUIPageIndicator = true;
UIPageIndicator.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIPageIndicator.prototype.isScrollable = function() {
	return this.getPages() > this.getVisibleTabs();
}

UIPageIndicator.prototype.setVisibleTabs = function(visibleTabs) {
	this.visibleTabs = visibleTabs;
	
	return;
}

UIPageIndicator.prototype.getVisibleTabs = function() {
	return this.visibleTabs ? this.visibleTabs : 6;
}

UIPageIndicator.prototype.getTabWidth = function() {
	var n = this.getPages();
	var visibleTabs = this.getVisibleTabs();

	if(n < visibleTabs) {
		return this.w/n;
	}
	else {
		return this.w/visibleTabs;
	}
}

UIPageIndicator.prototype.getScrollRange = function() {
	var visibleTabs = this.getVisibleTabs();

	if(visibleTabs < 6) {
		return this.w;
	}
	else {
		var n = this.getPages();
		return this.getTabWidth() * n;
	}
}

UIPageIndicator.prototype.initUIPageIndicator = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setCanRectSelectable(false, false);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UIPageIndicator.prototype.getViewPager = function() {
	if(!this.getParent()) {
		return;
	}

	if(this.viewPager && !this.viewPager.parentShape) {
		this.viewPager = null
	}

	if(!this.viewPager) {
		this.viewPager = this.getParent().findChildByType("ui-view-pager", true);
		if(!this.viewPager && this.isUIPageIndicatorSimple) { 
			this.viewPager = this.getWindow().findChildByType("ui-view-pager", true);
		}
	}

	if(this.viewPager) {
		this.viewPager.setShowIndicator(false);
	}

	return this.viewPager;
}

UIPageIndicator.prototype.getViewPagerOffset = function() {
	var viewPager = this.getViewPager();

	return viewPager ? viewPager.offset/viewPager.w : 0;
}

UIPageIndicator.prototype.getPages = function() {
	var viewPager = this.getViewPager();

	if(viewPager) {
		viewPager.pageIndicator = this;
	}

	return viewPager ? viewPager.getFrames() : 3;
}

UIPageIndicator.prototype.getCurrent = function() {
	var viewPager = this.getViewPager();
	
	return viewPager ? viewPager.getCurrent() : 0;
}

UIPageIndicator.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {
	canvas.beginPath();
	canvas.arc(x+w/2, y+h/2, 10, 0, 2 * Math.PI);
	canvas.fill();
	if(isCurrent) {
		canvas.stroke();
	}

	return;
}

UIPageIndicator.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPageIndicator.prototype.paintOneIndicatorCircle = function(canvas, isCurrent, index, x, y, w, h) {
	var r = Math.floor(Math.max(5, h/4));

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;

	canvas.beginPath();
	canvas.arc(x+w/2, y+h/2, r, 0, 2 * Math.PI);
	canvas.fill();
	canvas.stroke();

	return;
}

UIPageIndicator.prototype.paintOneIndicatorNumber = function(canvas, isCurrent, index, x, y, w, h) {
	var r = Math.floor(Math.max(5, h/4));
	var ox = Math.floor(x+w/2);
	var oy = Math.floor(y+h/2);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;

	canvas.beginPath();
	canvas.arc(ox, oy, r, 0, 2 * Math.PI);
	canvas.fill();
	canvas.stroke();

	canvas.font = r < 20 ? "16px sans" : "22px sans";
	canvas.textAlign = "center";
	canvas.textBaseline = "middle";
	canvas.fillStyle = this.style.textColor;
	canvas.fillText(index+1, ox, oy);
	
	return;
}

UIPageIndicator.prototype.paintOneIndicatorRect = function(canvas, isCurrent, index, x, y, w, h) {
	var size = 10;
	if(w > h) {
		size = Math.max(20, h/4);
	}
	else {
		size = Math.max(20, w/4);
	}
	size = Math.floor(size);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;
	
	var dx = (w - size)/2;
	var dy = (h - size)/2;

	canvas.beginPath();
	canvas.rect(x+dx, y+dy, size, size);
	canvas.fill();
	canvas.stroke();

	return;
}

UIPageIndicator.prototype.paintOneIndicatorLine = function(canvas, isCurrent, index, x, y, w, h) {
	var size = 4;
	if(w > h) {
		size = Math.max(4, h/4);
	}
	else {
		size = Math.max(4, w/4);
	}
	size = Math.floor(size);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;
	
	var dx = (w - size)/2;
	var dy = (h - size)/2;

	canvas.beginPath();
	if(w > h) {
		canvas.rect(x, y+dy, w, size);
	}
	else {
		canvas.rect(x+dx, y, size, h);
	}
	
	canvas.fill();
	canvas.stroke();

	return;
}


UIPageIndicator.prototype.onClickItem = function(index) {
	var viewPager = this.getViewPager();
	if(viewPager) {
		viewPager.setCurrent(index);
	}

	return;
}

UIPageIndicator.prototype.findItemByPoint = function(point) {
	var n = this.getPages();

	if(this.w > this.h) {
		var itemW = this.getTabWidth();

		for(var i = 0; i < n; i++) {
			if(point.x > i * itemW && point.x < (i+1) * itemW) {
				return i;
			}
		}
	}
	else {
		var itemH = this.h/n;
		for(var i = 0; i < n; i++) {
			if(point.y > i * itemH && point.y < (i+1) * itemH) {
				return i;
			}
		}
	}

	return -1;
}

UIPageIndicator.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	var index = this.findItemByPoint(point);
	
	if(index >= 0) {
		this.onClickItem(index);
	}

	this.callOnClickHandler(point);

	return;
}

UIPageIndicator.prototype.paintBackground = function(canvas) {
	var n = this.getPages();
	if(!n) {
		canvas.lineWidth = 1;
		canvas.strokeStyle = "Red";
		canvas.rect(0, 0, this.w, this.h)
		canvas.stroke();
	}
}

UIPageIndicator.prototype.paintSelfOnly = function(canvas) {
	var n = this.getPages();
	var current = this.getCurrent();
	var point = {};
	point.x = this.lastPosition.x - this.left;
	point.y = this.lastPosition.y - this.top;

	this.pointerOnItem = this.findItemByPoint(point);

	this.paintBackground(canvas);

	canvas.translate(-this.offset, 0);
	if(this.w > this.h) {
		var itemH = this.h;
		var itemW = this.getTabWidth();
		var offset = Math.floor(this.getViewPagerOffset() * itemW);

		for(var i = 0; i < n; i++) {
			var dx = i*itemW;
			this.paintOneIndicator(canvas, i === current, i, dx, 0, itemW, itemH);
		}
	}
	else {
		var itemW = this.w;
		var itemH = this.h / n;

		for(var i = 0; i < n; i++) {
			var dy = i*itemH; 
			this.paintOneIndicator(canvas, i === current, i, 0, dy, itemW, itemH);
		}
	}
	canvas.translate(this.offset, 0);
	delete this.pointerOnItem;

	return;
}

function UIPageIndicatorCreator() {
	var args = ["ui-page-indicator", "ui-page-indicator", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicator();

		return g.initUIPageIndicator(this.type, 200, 60);
	}
	
	return;
}

////////////////////////////////////////////////////////////////////}-{
function UIPageIndicatorSimple() {
	
	return;
}

UIPageIndicatorSimple.prototype.isScrollable = function() {
	return this.getPages() > this.getVisibleTabs();
}

UIPageIndicatorSimple.prototype = new UIPageIndicator();
UIPageIndicatorSimple.prototype.isUIPageIndicatorSimple = true;

UIPageIndicatorSimple.prototype.initUIPageIndicatorSimple = function(type, w, h) {
	this.initUIPageIndicator(type, w, h);	
	this.style.fillColorOfCurrent = "Gray";
	this.style.lineColorOfCurrent = "Black";
	this.setAlwaysOnTop(true);
	this.setVisibleTabs(12);

	return this;
}

UIPageIndicatorSimple.prototype.setLineColorOfCurrent = function(value) {
	this.style.lineColorOfCurrent = value;

	return;
}

UIPageIndicatorSimple.prototype.setFillStyleOfCurrent = function(value) {
	this.style.fillColorOfCurrent = value;

	return;
}

function UIPageIndicatorCircleCreator() {
	var args = ["ui-page-indicator-circle", "ui-page-indicator-circle", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		g.paintOneIndicator = UIPageIndicator.prototype.paintOneIndicatorCircle;

		return g.initUIPageIndicatorSimple(this.type, 200, 60);
	}
	
	return;
}

function UIPageIndicatorNumberCreator() {
	var args = ["ui-page-indicator-number", "ui-page-indicator-number", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		g.paintOneIndicator = UIPageIndicator.prototype.paintOneIndicatorNumber;

		return g.initUIPageIndicatorSimple(this.type, 200, 60);
	}
	
	return;
}

function UIPageIndicatorRectCreator() {
	var args = ["ui-page-indicator-rect", "ui-page-indicator-rect", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		g.paintOneIndicator = UIPageIndicator.prototype.paintOneIndicatorRect;

		return g.initUIPageIndicatorSimple(this.type, 200, 60);
	}
	
	return;
}

function UIPageIndicatorLineCreator() {
	var args = ["ui-page-indicator-line", "ui-page-indicator-line", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		g.paintOneIndicator = UIPageIndicator.prototype.paintOneIndicatorLine;

		return g.initUIPageIndicatorSimple(this.type, 200, 60);
	}
	
	return;
}

////////////////////////////////////////////////////////////////////}-{
function UIPageIndicatorNormal() {
	
	return;
}

UIPageIndicatorNormal.prototype = new UIPageIndicator();
UIPageIndicatorNormal.prototype.isUIPageIndicatorNormal = true;

UIPageIndicatorNormal.prototype.saveProps = ["enableAnimatePage", "strItemImages", "strItemTexts", "strItemImagesOfCurrent"];
UIPageIndicatorNormal.prototype.initUIPageIndicatorNormal = function(type, w, h) {
	this.initUIPageIndicator(type, w, h);	

	this.itemTexts = [];
	this.itemImages = [];
	this.imagePosition = "left";
	this.itemImagesOfCurrent = [];

	this.setMargin(5, 5);
	this.setAlwaysOnTop(false);
	this.setImage(UIElement.ITEM_BG_NORMAL, null);
	this.setImage(UIElement.ITEM_BG_ACTIVE, null);
	this.setImage(UIElement.ITEM_BG_CURRENT_NORMAL, null);
	this.setImage(UIElement.ITEM_BG_CURRENT_ACTIVE, null);

	return this;
}

UIPageIndicatorNormal.prototype.onInit = function() {
	this.syncImages();
}

UIPageIndicatorNormal.prototype.syncImages = function() {
	this.itemImages = [];
	this.itemImagesOfCurrent = [];

	for(var key in this.images) {
		if(key === "display") continue;
		var image = this.images[key];
		if(key.indexOf("current-item-images-") === 0) {
			this.itemImagesOfCurrent.push(image);	
		}
		else if(key.indexOf("item-images-") === 0) {
			this.itemImages.push(image);	
		}
	}

	return;
}

UIPageIndicatorNormal.prototype.setEnableAnimatePage = function(value) {
	this.enableAnimatePage = value;

	return;
}

UIPageIndicatorNormal.prototype.setItemImagesByStr = function(str) {
	var arr = str.split("\n");
	var name = "item-images-";

	var n = this.itemImages.length;
	for(var i = 0; i < n; i++) {
		this.setImage(name + i, null);
	}

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.setImage(name + i, iter);
		}
	}

	this.syncImages();
	this.strItemImages = str;

	return;
}

UIPageIndicatorNormal.prototype.setItemImagesOfCurrentByStr = function(str) {
	var arr = str.split("\n");
	var name = "current-item-images-";

	var n = this.itemImagesOfCurrent.length;
	for(var i = 0; i < n; i++) {
		this.setImage(name + i, null);
	}

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.setImage(name + i, iter);
		}
	}

	this.syncImages();
	this.strItemImagesOfCurrent = str;

	return;
}

UIPageIndicatorNormal.prototype.setItemTextsByStr = function(str) {
	this.strItemTexts = str;
	this.itemTexts = str.split("\n");

	return;
}

UIPageIndicatorNormal.prototype.setImagePosition = function(value) {
	this.imagePosition = value;

	return;
}

UIPageIndicatorNormal.prototype.getItemImagesStr = function() {
	return this.strItemImages ? this.strItemImages : "";
}

UIPageIndicatorNormal.prototype.getItemImagesStrOfCurrent = function() {
	return this.strItemImagesOfCurrent ? this.strItemImagesOfCurrent : "";
}

UIPageIndicatorNormal.prototype.getItemImages = function() {
	if(!this.itemImages.length) {
		this.syncImages();
	}

	return this.itemImages;
}

UIPageIndicatorNormal.prototype.getItemImagesOfCurrent = function() {
	if(!this.itemImagesOfCurrent.length) {
		this.syncImages();
	}

	return this.itemImagesOfCurrent;
}

UIPageIndicatorNormal.prototype.getItemTextsStr = function() {
	return this.strItemTexts ? this.strItemTexts : "";
}

UIPageIndicatorNormal.prototype.getItemTexts = function() {
	if(!this.itemTexts.length && this.strItemTexts) {
		this.setItemTextsByStr(this.strItemTexts);
	}

	return this.itemTexts;
}

UIPageIndicatorNormal.prototype.getItemImage = function(index, isCurrent) {
	var images = isCurrent ? this.getItemImagesOfCurrent() : this.getItemImages();
	if(images && index < images.length) {
		return images[index];
	}

	return null;
}

UIPageIndicatorNormal.prototype.getBackgroundImage = function(index, isCurrent) {
	var type = "";
	var active = this.pointerDown && this.pointerOnItem === index;
	if(isCurrent) {
		type = active ? UIElement.ITEM_BG_CURRENT_ACTIVE : UIElement.ITEM_BG_CURRENT_NORMAL;
	}
	else {
		type = active ? UIElement.ITEM_BG_ACTIVE : UIElement.ITEM_BG_NORMAL;
	}

	return this.getImageByType(type);
}

UIPageIndicatorNormal.prototype.paintOneIndicatorBackground = function(canvas, isCurrent, index, x, y, w, h) {
	var wImage = this.getBackgroundImage(index, isCurrent);
	if(!wImage || !wImage.getImage()) {
		return;
	}

	var image = wImage.getImage();
	var srcRect = wImage.getImageRect();

	this.drawImageAt(canvas, image, this.images.display, x, y, w, h, srcRect);

	return;
}

UIPageIndicatorNormal.prototype.setItemTextColorOfCurrent = function(value) {
	this.style.textColorOfCurrent = value;

	return;
}

UIPageIndicatorNormal.prototype.getItemTextColorOfCurrent = function() {
	return this.style.textColorOfCurrent ? this.style.textColorOfCurrent : "green";
}

UIPageIndicatorNormal.prototype.paintBackground = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_NORMAL);

	if(!image) {
		canvas.fillStyle = this.style.fillColor;
		canvas.rect(0, 0, this.w, this.h);
		canvas.fill();
	}

	return;
}

UIPageIndicatorNormal.prototype.getItemLocaleText= function(index) {
	var str = null;
	var texts = this.getItemTexts();
	
	if(texts && index < texts.length) {
		str = webappGetText(texts[index]);
		if(!str) {
			str = texts[index];
		}
	}

	return str;
}

UIPageIndicatorNormal.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {
	var wImage = this.getItemImage(index, isCurrent);
	this.paintOneIndicatorBackground(canvas, isCurrent, index, x, y, w, h);

	var gap = 8;
	var fontSize = this.style.fontSize;
	var str = this.getItemLocaleText(index);

	canvas.font = this.style.getFont();
	canvas.fillStyle = isCurrent ? this.getItemTextColorOfCurrent() : this.style.textColor; 
	
	if(wImage && wImage.getImage()) {
		var image = wImage.getImage();
		var srcRect = wImage.getImageRect();

		var hMargin = this.hMargin;
		var vMargin = this.vMargin;

		if(str) {
			var fontSize = this.style.fontSize;
			var dx = x + hMargin;
			var dy = y + vMargin;
			var dw = w - 2 * hMargin;
			var dh = h - fontSize - 2 * vMargin - gap;

			this.drawImageAt(canvas, image,UIElement.IMAGE_DISPLAY_AUTO, dx, dy, dw, dh, srcRect);

			dx = x + (w >> 1);
			dy = y + h - vMargin; 
			canvas.textAlign = "center";
			canvas.textBaseline = "bottom";
			canvas.fillText(str, dx, dy);
		}
		else {
			var dx = x + hMargin;
			var dy = y + vMargin;
			var dw = w - 2 * hMargin;
			var dh = h - 2 * vMargin;

			this.drawImageAt(canvas, image,UIElement.IMAGE_DISPLAY_AUTO, dx, dy, dw, dh, srcRect);
		}
	}
	else {
		if(str) {
			canvas.textAlign = "center";
			canvas.textBaseline = "middle";
			canvas.fillText(str, Math.floor(x+w/2), Math.floor(y+h/2));
		}
	}

	return;
}

UIPageIndicator.prototype.onClickItem = function(index) {
	var viewPager = this.getViewPager();
	if(viewPager) {
		if(this.enableAnimatePage) {
			viewPager.switchTo(index);
		}
		else {
			viewPager.setCurrent(index);
		}
	}

	return;
}

function UIPageIndicatorNormalCreator() {
	var args = ["ui-page-indicator-normal", "ui-page-indicator-normal", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorNormal();

		return g.initUIPageIndicatorNormal(this.type, 200, 60);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPageIndicatorNormalCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorCircleCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorNumberCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorRectCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorLineCreator());

/*
 * File:   ui-color-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Color Bar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIColorBar
 * @extends UIElement
 * 颜色线条，一般用于装饰。
 *
 */
function UIColorBar() {
	return;
}

UIColorBar.prototype = new UIElement();
UIColorBar.prototype.isUIButton = false;
UIColorBar.prototype.isUIColorBar = true;

UIColorBar.prototype.saveProps = ["barPosition"];
UIColorBar.prototype.initUIColorBar = function(type, w, h) {
	this.initUIElement(type);	

	this.setBarPosition(0);
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);
	this.barDierction = 0;

	return this;
}

UIColorBar.prototype.setBarDirection = function(direction) {
	this.barDirection = direction;

	return this;
}

UIColorBar.prototype.getBarDirection = function() {
	return this.barDirection;
}

UIColorBar.prototype.setBarPosition = function(position) {
	this.barPosition = position;

	return this;
}

UIColorBar.prototype.getBarPosition = function() {
	return this.barPosition;
}

UIColorBar.prototype.shapeCanBeChild = function(shape) {

	return shape.isUIImage || shape.isUIColorTile || shape.isUILabel;
}

UIColorBar.prototype.paintSelfOnly =function(canvas) {
	var ox = 0;
	var oy = 0;
	var v = this.barDirection;
	var n = this.style.lineWidth;
	
	canvas.beginPath();
	switch(this.barPosition) {
		case -1:	{
			break;
		}
		case 1:	{
			if(v) {
				ox = this.w - n;
			}
			else {
				oy = this.h - n;
			}
			break;
		}
		default: {
			if(v) {
				ox = Math.floor((this.w - n)>>1);
			}
			else {
				oy = Math.floor((this.h - n)>>1);
			}
		}
	}

	if(v) {
		canvas.moveTo(ox, 0);
		canvas.lineTo(ox, this.h);
	}
	else {
		canvas.moveTo(0, oy);
		canvas.lineTo(this.w, oy);
	}
	
	canvas.lineWidth = this.style.lineWidth;
	canvas.strokeStyle = this.style.lineColor;
	canvas.stroke();

	return;
}

function UIColorBarCreator(w, h) {
	var args = ["ui-color-bar", "ui-color-bar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorBar();

		return g.initUIColorBar(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIColorBarCreator(100, 10));

/*
 * File:   ui-image-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Animation.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageAnimation() {
	return;
}

UIImageAnimation.prototype = new UIImageView();
UIImageAnimation.prototype.isUIImageAnimation = true;

UIImageAnimation.prototype.saveProps = ["frameRate"];
UIImageAnimation.prototype.initUIImageAnimation = function(type, w, h) {
	this.initUIElement(type);	
	this.initUIImageView(w, h);
	
	this.addEventNames(["onChanged"]);
	this.setTextType(Shape.TEXT_NONE);
	imageAnimationInitCustomProp(this);

	return this;
}

UIImageAnimation.prototype.setCurrent = function(current) {
	if(this.userImages.length) {
		current = current%this.userImages.length;
	}

	if(this.currFrame != current) {
		this.callOnChangedHandler(current);
	}

	this.currFrame = current;

	return this;
}

UIImageAnimation.prototype.setValue = function(src) {
	for(var i = 0; i < this.cachedImages.length; i++) {
		var iter = this.cachedImages[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			return this.setCurrent(i);
		}
	}
	
	return this;
}

UIImageAnimation.prototype.getCurrentImage = function() {
	var image = this.cachedImages[this.currFrame];

	return image;
}

UIImageAnimation.prototype.onInit = function() {
	var imageAnim = this;

	this.currFrame = 0;

	function nextFrame() {
		if(imageAnim.isVisible()) {
			var duration = 1000/imageAnim.getFrameRate();
			
			imageAnim.postRedraw();
			setTimeout(nextFrame, duration);
			imageAnim.setCurrent(imageAnim.currFrame + 1);
		}
	}

	var duration = 1000/this.getFrameRate();
	setTimeout(nextFrame, duration);

	return;
}

UIImageAnimation.prototype.getFrameRate = function() {
	return this.frameRate ? this.frameRate : 5;
}

UIImageAnimation.prototype.setFrameRate = function(frameRate) {
	this.frameRate = Math.max(1, Math.min(frameRate, 30));

	return;
}

UIImageAnimation.prototype.drawImage = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currFrame = (this.currFrame ? this.currFrame : 0)%this.userImages.length;
	var image = this.cachedImages[currFrame];

	if(image && image.width > 0) {
		this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h);
	}

	return;
}


UIImageAnimation.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIImageAnimationCreator() {
	var args = [ "ui-image-animation", "ui-image-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageAnimation();
		return g.initUIImageAnimation(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageAnimationCreator());

/*
 * File: ui-call-events-handler.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: call events handler 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

///////////////////////////////////////////////////////////////
UIElement.eventsStoped = {};
UIElement.prototype.callOnUpdateTransformHandler = function(canvas) {
	if(this.mode === Shape.MODE_EDITING || !this.events) return true;

	if(!this.handleOnUpdateTransform) {
		var sourceCode = this.events["onUpdateTransform"];
		if(sourceCode) {
			sourceCode = "this.handleOnUpdateTransform = function(canvas) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUpdateTransform eval", e)
			}
		}
	}

	if(this.hasEventListener("updatetransform")) {
		var event = this.createEvent("updatetransform");
		event.canvas = canvas;

		this.dispatchEvent(event);
	}

	if(this.handleOnUpdateTransform) {
		try {
			this.handleOnUpdateTransform(canvas);
		}catch(e) {
			UIElement.logError("this.handleOnUpdateTransform", e)
		}
	}

	return;
}

UIElement.prototype.callOnPointerDownHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.click = false;
		UIElement.eventsStoped.pointerDown = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerDown) {
		return false;
	}
	
	if(this.hasEventListener("pointerdown")) {
		var event = this.createEvent("pointerdown");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerDown = true;
			return true;
		}
	}

	if(!this.handlePointerDown) {
		var sourceCode = this.events["onPointerDown"];
		if(sourceCode) {
			sourceCode = "this.handlePointerDown = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerDown eval", e)
			}
		}
	}

	if(this.handlePointerDown) {
		try {
			if(this.handlePointerDown(point, beforeChild)) {
				UIElement.eventsStoped.pointerDown = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerDown", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPointerMoveHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.pointerMove = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerMove) {
		return false;
	}

	if(this.hasEventListener("pointermove")) {
		var event = this.createEvent("pointermove");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerMove = true;
			return true;
		}
	}

	if(!this.handlePointerMove) {
		var sourceCode = this.events["onPointerMove"];
		if(sourceCode) {
			sourceCode = "this.handlePointerMove = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerMove eval", e)
			}
		}
	}

	if(this.handlePointerMove) {
		try {
			if(this.handlePointerMove(point, beforeChild)) {
				UIElement.eventsStoped.pointerMove = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerMove", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPointerUpHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.pointerUp = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerUp) {
		return false;
	}

	if(this.hasEventListener("pointerup")) {
		var event = this.createEvent("pointerup");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerUp = true;
			return true;
		}
	}

	if(!this.handlePointerUp) {
		var sourceCode = this.events["onPointerUp"];
		if(sourceCode) {
			sourceCode = "this.handlePointerUp = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerUp eval", e)
			}
		}
	}

	if(this.handlePointerUp) {
		try{
			if(this.handlePointerUp(point, beforeChild)) {
				UIElement.eventsStoped.pointerUp = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerUp", e)
		}
	}
	
	return true;
}

UIElement.prototype.callOnClickHandler = function(point) {
	if(!this.enable || !this.events || this.mode === Shape.MODE_EDITING) {
		return false;
	}

	if(UIElement.eventsStoped.click) {
		return true;
	}

	if(this.hasEventListener("click")) {
		var event = this.createEvent("click");
		event.point = point;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.click = true;
			return true;
		}
	}

	if(!this.handleClick) {
		var sourceCode = this.events["onClick"];
		if(sourceCode) {
			sourceCode = "this.handleClick = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleClick eval", e)
			}
		}
	}

	if(this.handleClick) {
		try {
			if(this.handleClick(point)) {
				UIElement.eventsStoped.click = true;
			}
		}catch(e) {
			UIElement.logError("this.handleClick", e)
		}
	}

	return true;
}

UIElement.prototype.callOnDoubleClickHandler = function(point) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.doubleClick = false;
	}

	if(!this.enable || !this.events || this.mode === Shape.MODE_EDITING) {
		return false;
	}

	if(UIElement.eventsStoped.doubleClick) {
		return false;
	}

	if(!this.handleDoubleClick) {
		var sourceCode = this.events["onDoubleClick"];
		if(sourceCode) {
			sourceCode = "this.handleDoubleClick = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDoubleClick eval", e)
			}
		}
	}

	if(this.handleDoubleClick) {
		try {
			if(this.handleDoubleClick(point)) {
				UIElement.eventsStoped.doubleClick = true;
			}
		}catch(e) {
			UIElement.logError("this.handleDoubleClick", e)
		}
	}

	this.hitTestResult = 0;

	return true;
}

UIElement.prototype.callOnLongPressHandler = function(point) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleLongPress) {
		var sourceCode = this.events["onLongPress"];
		if(sourceCode) {
			sourceCode = "this.handleLongPress = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleLongPress eval", e)
			}
		}
	}

	if(this.handleLongPress) {
		try {
			this.handleLongPress(point);
		}catch(e) {
			UIElement.logError("this.handleLongPress", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPaintHandler = function(canvas2dCtx) {
	if(this.mode === Shape.MODE_EDITING) {
		return true;
	}
	
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handlePaint) {
		var sourceCode = this.events["onPaint"];
		if(sourceCode) {
			sourceCode = "this.handlePaint = function(canvas2dCtx) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePaint eval", e)
			}
		}
	}

	if(this.handlePaint) {
		try {
			this.handlePaint(canvas2dCtx);
		}catch(e) {
			UIElement.logError("this.handlePaint", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollDoneHandler = function(xOffset, yOffset) {
	if(!this.enable || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("scrolldone")) {
		var event = this.createEvent("scrolldone");
		event.xOffset = xOffset;
		event.yOffset = yOffset;

		if(this.dispatchEvent(event)) {
			return true;
		}
	}

	if(!this.handleOnScrollDone) {
		var sourceCode = this.events["onScrollDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrollDone = function(xOffset, yOffset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrollDone eval", e)
			}
		}
	}

	if(this.handleOnScrollDone) {
		try {
			this.handleOnScrollDone(xOffset, yOffset);
		}catch(e) {
			UIElement.logError("this.handleOnScrollDone", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollingHandler = function(xOffset, yOffset) {
	if(!this.enable || !this.events || this.mode === Shape.MODE_EDITING) {
		return false;
	}
	
	if(this.hasEventListener("scrolling")) {
		var event = this.createEvent("scrolling");
		event.xOffset = xOffset;
		event.yOffset = yOffset;

		if(this.dispatchEvent(event)) {
			return true;
		}
	}

	if(!this.handleOnScrolling) {
		var sourceCode = this.events["onScrolling"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrolling = function(xOffset, yOffset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrolling eval", e)
			}
		}
	}

	if(this.handleOnScrolling) {
		try {
			this.handleOnScrolling(xOffset, yOffset);
		}catch(e) {
			UIElement.logError("this.handleOnScrolling", e)
		}
	}

	return true;
}

UIElement.prototype.callOnRemovedHandler = function() {
	if(!this.enable || !this.events || this.mode === Shape.MODE_EDITING) {
		return false;
	}

	if(!this.handleOnRemoved) {
		var sourceCode = this.events["onRemoved"];
		if(sourceCode) {
			sourceCode = "this.handleOnRemoved = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
				UIElement.logError("this.handleOnRemoved eval", e)
			}
		}
	}
	
	if(this.hasEventListener("removed")) {
		var event = this.createEvent("removed");

		this.dispatchEvent(event);
	}

	if(this.handleOnRemoved) {
		try {
			this.handleOnRemoved();
		}catch(e) {
			UIElement.logError("this.handleOnRemoved", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChildDraggingHandler = function(sourceChildIndex, targetChildIndex) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnChildDragging) {
		var sourceCode = this.events["onChildDragging"];
		if(sourceCode) {
			sourceCode = "this.handleOnChildDragging = function(sourceChildIndex, targetChildIndex) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChildDragging eval", e)
			}
		}
	}

	if(this.handleOnChildDragging) {
		try {
			this.handleOnChildDragging(sourceChildIndex, targetChildIndex);
		}catch(e) {
			UIElement.logError("this.handleOnChildDragging", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChildDraggedHandler = function(sourceChildIndex, targetChildIndex) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnChildDragged) {
		var sourceCode = this.events["onChildDragged"];
		if(sourceCode) {
			sourceCode = "this.handleOnChildDragged = function(sourceChildIndex, targetChildIndex) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChildDragged eval", e)
			}
		}
	}

	if(this.handleOnChildDragged) {
		try {
			this.handleOnChildDragged(sourceChildIndex, targetChildIndex);
		}catch(e) {
			UIElement.logError("this.handleOnChildDragged", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChangingHandler = function(value) {
	if(!this.enable || this.mode === Shape.MODE_EDITING || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("changing")) {
		var event = this.createEvent("changing");
		event.value = value;
		this.dispatchEvent(event);
	}

	if(!this.handleOnChanging) {
		var sourceCode = this.events["onChanging"];
		if(sourceCode) {
			sourceCode = "this.handleOnChanging = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChanging eval", e)
			}
		}
	}

	if(this.handleOnChanging) {
		try {
			this.handleOnChanging(value);
		}catch(e) {
			UIElement.logError("this.handleOnChanging", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChangedHandler = function(value) {
	if(!this.enable || this.mode === Shape.MODE_EDITING || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("change")) {
		var event = this.createEvent("change");
		event.value = value;
		this.dispatchEvent(event);
	}

	if(this.onChanged) {
		this.onChanged(value);

		return;
	}

	if(!this.handleOnChanged) {
		var sourceCode = this.events["onChanged"];
		if(sourceCode) {
			sourceCode = "this.handleOnChanged = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChanged eval", e)
			}
		}
	}

	if(this.handleOnChanged) {
		try {
			this.handleOnChanged(value);
		}catch(e) {
			UIElement.logError("this.handleOnChanged", e)
		}
	}

	return true;
}

UIElement.prototype.callOnInitHandler = function() {
	if(!this.events) return;

	if(!this.handleOnInit) {
		var sourceCode = this.events["onInit"];
		if(sourceCode) {
			sourceCode = "this.handleOnInit = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnInit eval", e)
			}
		}
	}

	if(this.handleOnInit) {
		try {
			this.handleOnInit();
		}catch(e) {
			UIElement.logError("this.handleOnInit", e)
		}
	}

	return true;
}

UIElement.prototype.callOnFocusInHandler = function() {
	if(this.onFocusIn) {
		try {
			this.onFocusIn();
		}
		catch(e) {
			console.log("onFocusIn:" + e.message);
		}
	}

	if(!this.events) return;
	if(!this.handleOnFocusIn) {
		var sourceCode = this.events["onFocusIn"];
		if(sourceCode) {
			sourceCode = "this.handleOnFocusIn = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnFocusIn eval", e)
			}
		}
	}

	if(this.handleOnFocusIn) {
		try {
			this.handleOnFocusIn();
		}catch(e) {
			UIElement.logError("this.handleOnFocusIn", e)
		}
	}

	return true;
}

UIElement.prototype.callOnFocusOutHandler = function() {
	if(this.onFocusOut) {
		try {
			this.onFocusOut();
		}
		catch(e) {
			UIElement.logError("this.onFocusOut ", e)
		}
	}

	if(!this.events) return;
	if(!this.handleOnFocusOut) {
		var sourceCode = this.events["onFocusOut"];
		if(sourceCode) {
			sourceCode = "this.handleOnFocusOut = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.onFocusOut eval", e)
			}
		}
	}

	if(this.handleOnFocusOut) {
		try {
			this.handleOnFocusOut();
		}catch(e) {
			UIElement.logError("this.onFocusOut", e)
		}
	}

	return true;
}

/////////////////////////////////////////////////////////

UIElement.prototype.callOnUpdateDataHandler = function() {
	if(!this.events) return;
	if(!this.handleOnUpdateData) {
		var sourceCode = this.events["onUpdateData"];
		if(sourceCode) {
			sourceCode = "this.handleOnUpdateData = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUpdateData eval", e)
			}
		}
	}

	if(this.handleOnUpdateData) {
		try {
			this.handleOnUpdateData();
		}catch(e) {
			UIElement.logError("this.handleOnUpdateData", e)
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////

UIElement.prototype.callOnGestureHandler = function(gesture) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnGesture) {
		var sourceCode = this.events["onGesture"];
		if(sourceCode) {
			sourceCode = "this.handleOnGesture = function(gesture) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnGesture eval", e)
			}
		}
	}

	if(this.handleOnGesture) {
		try {
			this.handleOnGesture(gesture);
		}catch(e) {
			UIElement.logError("this.handleOnGesture", e)
		}
	}
	
	console.log("callOnGestureHandler: scale=" + gesture.scale + " rotation=" + gesture.rotation);

	return true;
}

UIElement.prototype.callOnBeforeOpenHandler = function(initData) {
	if(!this.events) return;
	if(!this.handleOnBeforeOpen) {
		var sourceCode = this.events["onBeforeOpen"];
		if(sourceCode) {
			sourceCode = "this.handleOnBeforeOpen = function(initData) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBeforeOpen eval", e)
			}
		}
	}

	if(this.handleOnBeforeOpen) {
		try {
			this.handleOnBeforeOpen(initData);
		}catch(e) {
			UIElement.logError("this.handleOnBeforeOpen", e)
		}
	}

	return true;
}

UIElement.prototype.callOnOpenHandler = function(initData) {
	if(!this.events) return;
	if(!this.handleOnOpen) {
		var sourceCode = this.events["onOpen"];
		if(sourceCode) {
			sourceCode = "this.handleOnOpen = function(initData) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnOpen eval", e)
			}
		}
	}
	
	if(this.hasEventListener("open")) {
		var event = this.createEvent("open");
		event.initData = initData;

		this.dispatchEvent(event);
	}

	if(this.handleOnOpen) {
		try {
			this.handleOnOpen(initData);	
		}catch(e) {
			UIElement.logError("this.handleOnOpen", e)
		}
	}

	return true;
}

UIElement.prototype.callOnCloseHandler = function(retInfo) {
	if(!this.events) return;
	if(!this.handleOnClose) {
		var sourceCode = this.events["onClose"];
		if(sourceCode) {
			sourceCode = "this.handleOnClose = function(retInfo) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnClose eval", e)
			}
		}
	}

	if(this.hasEventListener("close")) {
		var event = this.createEvent("close");
		event.retInfo = retInfo;

		this.dispatchEvent(event);
	}

	if(this.handleOnClose) {
		try {
			this.handleOnClose(retInfo);
		}
		catch(e) {
			UIElement.logError("this.handleOnClose", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwitchToBackHandler =function() {
	if(!this.events) return;
	if(!this.handleOnSwitchToBack) {
		var sourceCode = this.events["onSwitchToBack"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwitchToBack = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwitchToBack eval", e)
			}
		}
	}

	if(this.handleOnSwitchToBack) {
		try {
			this.handleOnSwitchToBack();
		}
		catch(e) {
			UIElement.logError("this.handleOnSwitchToBack", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwitchToFrontHandler = function() {
	if(!this.events) return;
	if(!this.handleOnSwitchToFront) {
		var sourceCode = this.events["onSwitchToFront"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwitchToFront = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwitchToFront eval", e)
			}
		}
	}

	if(this.handleOnSwitchToFront) {
		try {
			this.handleOnSwitchToFront();
		}
		catch(e) {
			UIElement.logError("this.handleOnSwitchToFront", e)
		}
	}

	return true;
}

UIElement.prototype.callOnLoadHandler =function() {
	if(!this.events) return;
	if(!this.handleOnLoad) {
		var sourceCode = this.events["onLoad"];
		if(sourceCode) {
			sourceCode = "this.handleOnLoad = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnLoad eval", e)
			}
		}
	}

	if(this.handleOnLoad) {
		try {
			this.handleOnLoad();
		}
		catch(e) {
			UIElement.logError("this.handleOnLoad", e)
		}
	}

	return true;
}

UIElement.prototype.callOnUnloadHandler =function() {
	if(!this.events) return;
	if(!this.handleOnUnload) {
		var sourceCode = this.events["onUnload"];
		if(sourceCode) {
			sourceCode = "this.handleOnUnload = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUnload eval", e)
			}
		}
	}

	if(this.handleOnUnload) {
		try {
			this.handleOnUnload();
		}
		catch(e) {
			UIElement.logError("this.handleOnUnload", e)
		}
	}

	return true;
}

/////////////////////////////////////////////////////////////

UIElement.prototype.callOnMovedHandler = function() {
 	if(this.cameraFollowMe) {
		this.getWindow().cameraFollow(this);
	} 
	if(this.handleOnMoved) {
		this.handleOnMoved();
	    
        return;
    }

   	if(!this.events || !this.events["onMoved"]) return;
	if(!this.handleOnMoved) {
		var sourceCode = this.events["onMoved"];
		if(sourceCode) {
			sourceCode = "this.handleOnMoved = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnMoved eval", e)
			}
		}
	}
	
	if(this.hasEventListener("moved")) {
		var event = this.createEvent("moved");

		this.dispatchEvent(event);
	}

	if(this.handleOnMoved) {
		try {
			this.handleOnMoved();
		}catch(e) {
			UIElement.logError("this.handleOnMoved", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPreSolveHandler = function(body, contact, oldManifold) {
	if(!this.events || !this.events["onPreSolve"]) return;
	if(!this.handleOnPreSolve) {
		var sourceCode = this.events["onPreSolve"];
		if(sourceCode) {
			sourceCode = "this.handleOnPreSolve = function(body, contact, oldManifold) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnPreSolve eval", e)
			}
		}
	}

	if(this.handleOnPreSolve) {
		try {
			this.handleOnPreSolve(body, contact, oldManifold);
		}catch(e) {
			UIElement.logError("this.handleOnPreSolve", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPostSolveHandler = function(body, contact, impulse) {
	if(!this.events || !this.events["onPostSolve"]) return;
	if(!this.handleOnPostSolve) {
		var sourceCode = this.events["onPostSolve"];
		if(sourceCode) {
			sourceCode = "this.handleOnPostSolve = function(body, contact, impulse) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnPostSolve eval", e)
			}
		}
	}

	if(this.handleOnPostSolve) {
		try {
			this.handleOnPostSolve(body, contact, impulse);
		}catch(e) {
			UIElement.logError("this.handleOnPostSolve", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBeginContactHandler = function(body, contact) {
	if(this.onBeginContact) {
		this.onBeginContact(body, contact);

		return;
	}
	
	if(this.hasEventListener("begincontact")) {
		var event = this.createEvent("begincontact");
		event.body = body;
		event.contact = contact;

		this.dispatchEvent(event);
	}

	if(!this.events || !this.events["onBeginContact"]) return;
	if(!this.handleOnBeginContact) {
		var sourceCode = this.events["onBeginContact"];
		if(sourceCode) {
			sourceCode = "this.handleOnBeginContact = function(body, contact) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBeginContact eval", e)
			}
		}
	}

	if(this.handleOnBeginContact) {
		try {
			this.handleOnBeginContact(body, contact);
		}catch(e) {
			UIElement.logError("this.handleOnBeginContact", e)
		}
	}

	return true;
}

UIElement.prototype.callOnEndContactHandler = function(body, contact) {
	if(this.onEndContact) {
		this.onEndContact(body, contact);

		return;
	}
	
	if(this.hasEventListener("endcontact")) {
		var event = this.createEvent("endcontact");
		event.body = body;
		event.contact = contact;

		this.dispatchEvent(event);
	}

	if(!this.events || !this.events["onEndContact"]) return;
	if(!this.handleOnEndContact) {
		var sourceCode = this.events["onEndContact"];
		if(sourceCode) {
			sourceCode = "this.handleOnEndContact = function(body, contact) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnEndContact eval", e)
			}
		}
	}

	if(this.handleOnEndContact) {
		try {
			this.handleOnEndContact(body, contact);
		}catch(e) {
			UIElement.logError("this.handleOnEndContact", e)
		}
	}

	return true;
}

UIElement.prototype.callOnAnimateDoneHandler = function(name) {
	if(!this.events) return;
	if(!this.handleOnAnimateDone) {
		var sourceCode = this.events["onAnimateDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnAnimateDone = function(name) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnAnimateDone eval", e)
			}
		}
	}

	if(this.handleOnAnimateDone) {
		try {
			this.handleOnAnimateDone(name);
		}
		catch(e) {
			UIElement.logError("this.handleOnAnimateDone", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeLeftHandler = function(start, end) {
	if(!this.events) return;
	if(!this.handleOnSwipeLeft) {
		var sourceCode = this.events["onSwipeLeft"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeLeft = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeLeft eval", e)
			}
		}
	}

	if(this.handleOnSwipeLeft) {
		try {
			this.handleOnSwipeLeft(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeLeft", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeRightHandler = function(start, end) {
	if(!this.events) return;
	if(!this.handleOnSwipeRight) {
		var sourceCode = this.events["onSwipeRight"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeRight = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeRight eval", e)
			}
		}
	}

	if(this.handleOnSwipeRight) {
		try {
			this.handleOnSwipeRight(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeRight", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeUpHandler = function(start, end) {
	if(!this.events) return;
	if(!this.handleOnSwipeUp) {
		var sourceCode = this.events["onSwipeUp"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeUp = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeUp eval", e)
			}
		}
	}

	if(this.handleOnSwipeUp) {
		try {
			this.handleOnSwipeUp(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeUp", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeDownHandler = function(start, end) {
	if(!this.events) return;
	if(!this.handleOnSwipeDown) {
		var sourceCode = this.events["onSwipeDown"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeDown = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeDown eval", e)
			}
		}
	}

	if(this.handleOnSwipeDown) {
		try {
			this.handleOnSwipeDown(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeDown", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBecomeZeroHandler = function() {
	if(!this.events) return;
	if(!this.handleOnBecomeZero) {
		var sourceCode = this.events["onBecomeZero"];
		if(sourceCode) {
			sourceCode = "this.handleOnBecomeZero = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBecomeZero eval", e)
			}
		}
	}
	
	if(this.hasEventListener("becomezero")) {
		var event = this.createEvent("becomezero");
		this.dispatchEvent(event);
	}

	if(this.handleOnBecomeZero) {
		try {
			this.handleOnBecomeZero();
		}catch(e) {
			UIElement.logError("this.handleOnBecomeZero", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBecomeFullHandler = function() {
	if(!this.events) return;
	if(!this.handleOnBecomeFull) {
		var sourceCode = this.events["onBecomeFull"];
		if(sourceCode) {
			sourceCode = "this.handleOnBecomeFull = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBecomeFull eval", e)
			}
		}
	}

	if(this.hasEventListener("becomefull")) {
		var event = this.createEvent("becomefull");
		this.dispatchEvent(event);
	}

	if(this.handleOnBecomeFull) {
		try {
			this.handleOnBecomeFull();
		}catch(e) {
			UIElement.logError("this.handleOnBecomeFull", e)
		}
	}

	return true;
}

UIElement.prototype.callOnTimeoutHandler = function() {
	if(!this.events) return;
	if(!this.handleOnTimeout) {
		var sourceCode = this.events["onTimeout"];
		if(sourceCode) {
			sourceCode = "this.handleOnTimeout = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnTimeout eval", e)
			}
		}
	}
	
	if(this.hasEventListener("timer")) {
		var event = this.createEvent("timer");
		this.dispatchEvent(event);
	}

	if(this.handleOnTimeout) {
		try {
			this.handleOnTimeout();
		}catch(e) {
			UIElement.logError("this.handleOnTimeout", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSystemInitHandler = function() {
	if(!this.events) return;
	if(!this.handleOnSystemInit) {
		var sourceCode = this.events["onSystemInit"];
		if(sourceCode) {
			sourceCode = "this.handleOnSystemInit = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSystemInit eval", e)
			}
		}
	}

	if(this.handleOnSystemInit) {
		try {
			this.handleOnSystemInit();
		}catch(e) {
			UIElement.logError("this.handleOnSystemInit", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollOutOfRangeHandler = function(offset) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(this.onScrollOutOfRange) {
		this.onScrollOutOfRange(offset);

		return;
	}

	if(!this.handleOnScrollOutOfRange) {
		var sourceCode = this.events["onScrollOutOfRange"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrollOutOfRange = function(offset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrollOutOfRange eval", e)
			}
		}
	}

	if(this.handleOnScrollOutOfRange) {
		try {
			this.handleOnScrollOutOfRange(offset);
		}catch(e) {
			UIElement.logError("this.handleOnScrollOutOfRange", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBirthedHandler = function() {
	if(this.onBirthed) {
		this.onBirthed();
	}

	if(!this.events) return;
	if(!this.handleOnBirthed) {
		var sourceCode = this.events["onBirthed"];
		if(sourceCode) {
			sourceCode = "this.handleOnBirthed = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBirthed eval", e)
			}
		}
	}

	if(this.handleOnBirthed) {
		try {
			this.handleOnBirthed();
		}catch(e) {
			UIElement.logError("this.handleOnBirthed", e)
		}
	}

	return true;
}

UIElement.prototype.callOnDeviceOrientation = function(x, y, z, evt) {
	if(!this.events) return;
	if(!this.handleOnDeviceOrientation) {
		var sourceCode = this.events["onDeviceOrientation"];
		if(sourceCode) {
			sourceCode = "this.handleOnDeviceOrientation = function(x, y, z, event) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnDeviceOrientation eval", e)
			}
		}
	}

	if(this.handleOnDeviceOrientation) {
		try {
			this.handleOnDeviceOrientation(x, y, z, evt);
		}catch(e) {
			UIElement.logError("this.handleOnDeviceOrientation", e)
		}
	}

	return true;
}

UIElement.prototype.dispatchCustomEvent = function(eventName, args) {
	if(!this.events) return;
	if(!this.customEventHandler) {
		this.customEventHandler = {};
	}

	var handleCustomEvent = this.customEventHandler[eventName];
	if(!handleCustomEvent) {
		var sourceCode = this.events[eventName];
		if(sourceCode) {
			sourceCode = "this.handleCustomEvent = function(args) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleCustomEvent eval", e)
			}
		}

		if(this.handleCustomEvent) {
			handleCustomEvent = this.handleCustomEvent;
			this.customEventHandler[eventName] = handleCustomEvent;
			this.handleCustomEvent = null;
		}
	}

	if(handleCustomEvent) {
		try {
			handleCustomEvent.call(this, args);
		}catch(e) {
			UIElement.logError("this.handleCustomEvent", e)
		}
	}

	return true;
}

UIWindow.prototype.callOnMultiTouchHandler = function(action, points, event) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(this.mode === Shape.MODE_EDITING) {
		return false;
	}
	
	if(!this.handleMultiTouch) {
		var sourceCode = this.events["onMultiTouch"];
		if(sourceCode) {
			sourceCode = "this.handleMultiTouch = function(action, points, event) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleMultiTouch eval", e)
			}
		}
	}

	if(!this.children.length) {
		console.log("clicked: " + this.type + "(" + this.name + ")");
	}

	if(this.handleMultiTouch) {
		try {
			this.handleMultiTouch(action, points, event);
		}catch(e) {
			UIElement.logError("this.handleMultiTouch", e)
		}
	}

	return;
}

UIElement.prototype.callOnDragStartHandler = function() {
	if(!this.enable || !this.events || !this.events["onDragStart"]) {
		return false;
	}

	if(!this.handleDragStart) {
		var sourceCode = this.events["onDragStart"];
		if(sourceCode) {
			sourceCode = "this.handleDragStart = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragStart eval", e)
			}
		}
	}

	if(this.handleDragStart) {
		try {
			this.handleDragStart();
		}catch(e) {
			UIElement.logError("this.handleDragStart", e)
		}
	}

	return;
}

UIElement.prototype.callOnDragEndHandler = function() {
	if(!this.enable || !this.events || !this.events["onDragEnd"]) {
		return false;
	}

	if(!this.handleDragEnd) {
		var sourceCode = this.events["onDragEnd"];
		if(sourceCode) {
			sourceCode = "this.handleDragEnd = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragEnd eval", e)
			}
		}
	}

	if(this.handleDragEnd) {
		try {
			this.handleDragEnd();
		}catch(e) {
			UIElement.logError("this.handleDragEnd", e)
		}
	}

	return;
}

UIElement.prototype.callOnDraggingHandler = function() {
	if(!this.enable || !this.events || !this.events["onDragging"]) {
		return false;
	}

	if(!this.handleDragging) {
		var sourceCode = this.events["onDragging"];
		if(sourceCode) {
			sourceCode = "this.handleDragging = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragging eval", e)
			}
		}
	}

	if(this.handleDragging) {
		try {
			this.handleDragging();
		}catch(e) {
			UIElement.logError("this.handleDragging", e)
		}
	}

	return;
}
/*
 * File:   ui-v-scroll-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vertical Scrollable Image
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollImage() {
	return;
}

UIVScrollImage.prototype = new UIVScrollView();

UIVScrollImage.prototype.initUIVScrollImage = function(type) {
	this.initUIVScrollView(type, 0, null, null);	
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.widthAttr = UIElement.WIDTH_SCALE;
	this.heightAttr = UIElement.HEIGHT_SCALE;
	this.setSize(200, 200);
	
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);

	return this;
}

UIVScrollImage.prototype.drawBgImage = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	if(!image || !image.height) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
		return;
	}
	var scale = this.w/image.width;
	var range = image.height * scale;

	var x = 0; 
	var y = this.offset/scale;
	var w = image.width;
	var h = Math.min(this.h/scale, image.height-y);
	var dx = 0; 
	var dy = 0;
	var dw = this.w; 
	var dh = h * scale;

	canvas.drawImage(image, x, y, w, h, dx, dy, dw, dh);

	return;
}

UIVScrollImage.prototype.getScrollRange = function() {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	if(image && image.height && image.width) {
		var scale = this.w/image.width;

		return scale * image.height + 60;
	}
	else {
		return this.h;
	}
}

UIVScrollImage.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);

	if(this.mode === Shape.MODE_EDITING) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIVScrollImageCreator() {
	var args = ["ui-v-scroll-image", "ui-v-scroll-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollImage();
		return g.initUIVScrollImage(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVScrollImageCreator());
/*
 * File:   ui-page-manager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  TabPage Manager
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPageManager() {
}

UIPageManager.prototype = new UIFrames();
UIPageManager.prototype.isUIPageManager = true;

UIPageManager.prototype.initUIPageManager = function(type) {
	return this.initUIFrames(type);
}

UIPageManager.prototype.beforeAddShapeIntoChildren = function(shape) {
	return !shape.isUIPage;
}

UIPageManager.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIPage;
}

UIPageManager.prototype.relayoutChildren = function() {
	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.left = 0;
		iter.top = 0;
		iter.w = this.w;
		iter.h = this.h;
		iter.relayoutChildren();
		iter.setUserMovable(false);
		iter.setUserResizable(false);
	}

	return;
}

UIPageManager.prototype.showHTML = function() {
	var child = this.getCurrentFrame();
	
	if(child) {
		child.showHTML();
	}

	return;
}

UIPageManager.prototype.hideHTML = function() {
	var child = this.getCurrentFrame();
	
	if(child) {
		child.hideHTML();
	}

	return;
}


UIPageManager.prototype.switchTo = function(index) {
	var pageManager = this;
	var curFrame = this.getCurrentFrame();
	var newFrame = this.getFrame(index);
	var current = this.current;

	if(curFrame) {
		curFrame.hideHTML();
	}

	if(current < 0 || current === index || !curFrame || !newFrame) {
		this.showFrame(index);

		if(newFrame) {
			newFrame.showHTML();
		}

		return;
	}

	function showNewFrame() {
		pageManager.showFrame(index);
		pageManager.postRedraw();

		return;
	}

	if(!this.isTopWindow()) {
		showNewFrame();	
		return;
	}

	var animation = null;
	var backendCanvas = null;
	var p = this.getPositionInScreen();

	if(index < current) {
		animation = AnimationFactory.create("anim-backward"); 
		backendCanvas = UIFrames.preparseBackendCanvas(newFrame, curFrame);
	}
	else {
		animation = AnimationFactory.create("anim-forward"); 
		backendCanvas = UIFrames.preparseBackendCanvas(curFrame, newFrame);
	}

//	window.open(backendCanvas.toDataURL(), "_blank");
	animation.setScale(this.getRealScale());
	animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, showNewFrame);
	animation.run();

	return;
}

function UIPageManagerCreator() {
	var args = ["ui-page-manager", "ui-page-manager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageManager();

		g.initUIPageManager(this.type);

		return g;
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIPageManagerCreator());

/*
 * File:   ui-wait-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Wait Bar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWaitBar
 * @extends UIElement
 * 等待动画。
 */

/**
 * @class UIWaitBox
 * @extends UIElement
 * 等待动画。
 */

function UIWaitBar() {
	return;
}

UIWaitBar.TILES = 8;
UIWaitBar.prototype = new UIElement();

UIWaitBar.prototype.initUIWaitBar = function(type, w, h) {
	this.initUIElement(type);	

	this.offset = 0;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

UIWaitBar.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIWaitBar.prototype.step = function() {
	if(this.isVisible() && this.getParent()) {
		this.offset++;
	
		if(this.isUIWaitBar) {
			this.offset = (this.offset)%UIWaitBar.TILES;
		}

		this.postRedraw();
	}

	return this;
}

UIWaitBar.prototype.drawBgImage = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	
	if(!image) {
		return;
	}

	if(this.isUIWaitBar) {
		this.drawBgImageBar(canvas, image);
	}
	else {
		this.drawBgImageBox(canvas, image);
	}

	return;
}

UIWaitBar.prototype.drawBgImageBox =function(canvas, image) {
	var angle = 0.05*Math.PI*this.offset;
	this.setRotation(angle);

	UIElement.prototype.drawBgImage.call(this, canvas);

	return;
}

UIWaitBar.prototype.onInit = function() {
	UIElement.prototype.onInit.call(this);

	var me = this;
	function stepIt() {
		me.step();
		if(me.getParent()) {
			setTimeout(stepIt, 50);
		}
	}

	stepIt();

	return;
}

UIWaitBar.prototype.drawBgImageBar = function(canvas, image) {
	var imageWidth = image.width;
	var imageHeight = image.height;
	var tileHeight = Math.round(imageHeight/UIWaitBar.TILES);
	var yOffset = this.offset * tileHeight;

	var rect = {x:0, y:yOffset, w:imageWidth, h:tileHeight};

	UIElement.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, rect);

	return;
}

function UIWaitBarCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWaitBar();
		g.isUIWaitBar = true;

		return g.initUIWaitBar(this.type, w, h);
	}
	
	return;
}

function UIWaitBoxCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWaitBar();
		g.isUIWaitBox = true;

		return g.initUIWaitBar(this.type, w, h);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIWaitBarCreator("ui-wait-bar", 200, 24));
ShapeFactoryGet().addShapeCreator(new UIWaitBoxCreator("ui-wait-box", 60, 60));

/*
 * File:   ui-static-map.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Static Map 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIStaticMap() {
	return;
}

UIStaticMap.prototype = new UIImage();
UIStaticMap.prototype.isUIStaticMap = true;

UIStaticMap.prototype.initUIStaticMap = function(type) {
	this.initUIImage(type, 200, 200, null);

	return this;
}

UIStaticMap.prototype.setMapProvider = function(value) {
	this.mapProvider = value;

	return;
}

UIStaticMap.prototype.setMapType = function(value) {
	this.mapType = value;

	return;
}

UIStaticMap.prototype.setMapZoom = function(value) {
	this.mapZoom = value;

	return;
}

UIStaticMap.prototype.setMapCenter = function(value) {
	this.mapCenter = value;

	return;
}

UIStaticMap.prototype.setMapWidth = function(value) {
	this.mapWidth = value;

	return;
}

UIStaticMap.prototype.setMapHeight = function(value) {
	this.mapHeight = value;

	return;
}

UIStaticMap.prototype.setMapExtraParams = function(value) {
	this.mapEtraParams = value;

	return;
}

UIStaticMap.prototype.getMapType = function() {
	return this.mapType ? this.mapType : "";
}

UIStaticMap.prototype.getMapProvider = function() {
	return this.mapProvider ? this.mapProvider : "google";
}

UIStaticMap.prototype.getMapZoom = function() {
	return this.mapZoom ? this.mapZoom : 10;
}

UIStaticMap.prototype.getMapWidth = function() {
	return this.mapWidth ? this.mapWidth : 600;
}

UIStaticMap.prototype.getMapHeight = function() {
	return this.mapHeight ? this.mapHeight : 600;
}

UIStaticMap.prototype.getMapCenter = function() {
	if(!this.mapCenter && this.currentLocation) {
		return this.currentLocation;
	}
	else {
		return this.mapCenter ? this.mapCenter : "China";
	}
}

UIStaticMap.prototype.getMapExtraParams = function() {
	return this.mapEtraParams ? this.mapEtraParams : "";
}

//http://developer.baidu.com/map/staticimg.htm
//https://developers.google.com/maps/documentation/staticmaps/?hl=zh-CN&csw=1

UIStaticMap.prototype.getMapURL = function() {
	var url = "";
	if(this.mapProvider === "baidu") {
		url = "http://api.map.baidu.com/staticimage?center="+this.getMapCenter()
			+ "&width=" + this.getMapWidth()
			+ "&height="+ this.getMapHeight()
			+ "&zoom=" + this.getMapZoom()
			+ this.getMapExtraParams();
	}
	else if(this.mapProvider === "google"){
		url = "http://maps.googleapis.com/maps/api/staticmap?center="+this.getMapCenter()
			+ "&size=" + this.getMapWidth() + "x"+this.getMapHeight()
			+ "&zoom=" + this.getMapZoom()
			+ "&maptype=" + this.getMapType() + "&sensor=true"
			+ this.getMapExtraParams();
	}

	console.log("Map URL:" + url);

	return url;
}

UIStaticMap.prototype.updateMap = function() {
	var url = this.getMapURL();

	this.setImageSrc(url);

	return;
}

UIStaticMap.prototype.onInit = function() {
	var map = this;
	
	function onCurrentLocation(position) {
		map.currentLocation = position.coords.latitude+","+position.coords.longitude;
		map.updateMap();

		return;
	}

	if (navigator.geolocation) {
		navigator.geolocation.getCurrentPosition(onCurrentLocation);
	}
	this.updateMap();

	return;
}

UIStaticMap.prototype.drawImage =function(canvas) {

	this.drawBgImage(canvas);

	return;
}

function UIStaticMapCreator() {
	var args = ["ui-static-map", "ui-static-map", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStaticMap();
		return g.initUIStaticMap(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIStaticMapCreator());

/*
 * File:   ui-status-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Status Bar 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIStatusBar() {
	return;
}

UIStatusBar.prototype = new UIElement();
UIStatusBar.prototype.isUIStatusBar = true;

UIStatusBar.prototype.initUIStatusBar = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;

	return this;
}

UIStatusBar.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton) {
		return true;
	}

	return false;
}

UIStatusBar.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
	if(this.type === "ui-menu-bar") {
		shape.hideSelectMark = true;
		shape.textType = Shape.TEXT_NONE;
		this.hideSelectMark = true;
	}

	return true;
}

UIStatusBar.prototype.beforeRelayoutChild = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return true;
}

function UIStatusBarCreator(type, w, h, bg) {
	var args = [type, "ui-status-bar", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStatusBar();
		return g.initUIStatusBar(this.type, w, h, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIStatusBarCreator("ui-status-bar", 640, 40, null));
ShapeFactoryGet().addShapeCreator(new UIStatusBarCreator("ui-menu-bar", 640, 96, null));


/*
 * File:   ui-unkown.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  There are two conditions that shape factory can not find creator for a type: 
 *           1.The creator is not loaded yet.
 *           2.There is not such creator.
 *         For the first condition, we create a proxy first, try it create the real element later.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIUnkown() {
	return;
}

UIUnkown.prototype = new UIElement();
UIUnkown.prototype.isUIUnkown = true;

UIUnkown.prototype.initUIUnkown = function(type) {
	this.initUIElement(type);	

	return this;
}

function UIUnkownCreator() {
	var args = ["ui-unkown", "ui-unkown", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIUnkown();
		return g.initUIUnkown(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIUnkownCreator());

/*
 * File:   ui-suggestion.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Suggestion Input
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function SuggestionProvider() {
	this.query = function(key, onDone) {
	}

	this.init = function(options) {
	}

	return;
}

function StaticSuggestionProvider() {
	this.init = function(options) {
		if(typeof options == "string") {
			options = options.split("\n");
		}

		this.options = options;
		if(this.options) {
			this.options.sort();
		}

		return;
	}

	this.query = function(key, onDone) {
		if(!key || !this.options) {
			onDone([]);
			return;
		}

		function compareStr(str1, str2) {
			if(str1.indexOf(str2) == 0) {
				return 0;
			}

			if(str1 < str2) {
				return -1;
			}
			else {
				return 1;
			}
		}

		var arr = [];
		var start = this.options.binarySearch(key, compareStr);
		
		if(start >= 0) {
			var n = this.options.length;
			
			for(;start >= 0; start--) {
				var iter = this.options[start];
				if(iter.indexOf(key) !== 0) {
					start = start+1;
					break;
				}
			}

			for(var i = start; i < n; i++) {
				var iter = this.options[i];
				if(iter.indexOf(key) === 0) {
					arr.push(iter);
				}
				else {
					break;
				}
			}
		}

		onDone(arr);

		return;
	}

	return;
}

function createSuggestionProvider(type, args) {
	var suggestionProvider = null;
	if(type === "static") {
		suggestionProvider = new StaticSuggestionProvider();
	}

	if(suggestionProvider) {
		suggestionProvider.init(args);
	}

	return suggestionProvider;
}

function UISuggestion() {
	return;
}

UISuggestion.prototype = new UIListView();
UISuggestion.prototype.isUISuggestion = true;

UISuggestion.prototype.initUISuggestion = function(type) {
	this.initUIListView(type, 5, 100, null);	
	this.maxSuggestionItems = 10;
	this.suggestionProviderParams = "";
	this.suggestionProviderName = "static";

	return this;
}

UISuggestion.prototype.onInit = function() {
	this.suggestionProvider = createSuggestionProvider(this.suggestionProviderName, this.suggestionProviderParams);

	return;
}

UISuggestion.prototype.setSuggestionProvider = function(suggestionProvider) {
	this.suggestionProvider = suggestionProvider;

	return;
}

UISuggestion.prototype.getSuggestionProvider = function() {
	return this.suggestionProvider;
}

//override this.
UISuggestion.prototype.onSuggestionSelected = function(str) {

}

UISuggestion.prototype.showSuggestion = function(suggestions) {
	var data = {children:[]};
	
	if(suggestions.length > this.maxSuggestionItems) {
		suggestions.length = this.maxSuggestionItems;
	}

	for(var i = 0; i < suggestions.length; i++) {
		var item = {children:[]};
		var value = suggestions[i];
		item.children.push({text: value});
		data.children.push(item);
	}
		
	this.bindData(data, null, true);

	return;

}

UISuggestion.prototype.onSuggestionShow = function() {
}

UISuggestion.prototype.query = function(key) {
	var me = this;
	this.suggestionProvider.query(key, function(arr) {
		me.showSuggestion(arr);
		me.onSuggestionShow();
	});
}

function UISuggestionCreator() {
	var args = ["ui-suggestion", "ui-suggestion", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISuggestion();
		return g.initUISuggestion(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISuggestionCreator());

/*
 * File:   ui-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIButton
 * @extends UIElement
 * 按钮。被点击后触发一个回调函数。可以设置按钮在不同状态下的图片。
 *
 * * UIElement.IMAGE_NORMAL 正常时的图片。
 * * UIElement.IMAGE_ACTIVE 按下时的图片。
 * * UIElement.IMAGE_FOCUSED 得到焦点时的图片。
 * * UIElement.IMAGE_DISABLE 禁用时的图片。
 * * "option_image_0" 备用图片0
 * * "option_image_1" 备用图片1
 * * "option_image_2" 备用图片2
 * * "option_image_3" 备用图片3
 * ...
 * * "option_image_14" 备用图片14
 *
 * 注：备用图片在IDE的图片属性页的图片用途里显示为"图片_X"
 *
 */

function UIButton() {
	return;
}

UIButton.prototype = new UIElement();
UIButton.prototype.isUIButton = true;

UIButton.prototype.initUIButton = function(type, w, h) {
	this.initUIElement(type);	

	this.setMargin(5, 5);
	this.setDefSize(w, h);
	this.setSizeLimit(20, 20);
	this.setAutoScaleFontSize(true);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIButton.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIBitmapFontText) {
		return true;
	}

	return false;
}

UIButton.prototype.paintSelfOnly =function(canvas) {
	if(this.pointerDown) {
		var image = this.getHtmlImageByType(UIElement.IMAGE_ACTIVE);

		if(!image) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}
	}

	return;
}

function UIButtonCreator(w, h) {
	var args = ["ui-button", "ui-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIButton();
		return g.initUIButton(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIButtonCreator(120, 60));

/*
 * File:   ui-mledit.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Multi Line Editor
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIMLEdit
 * @extends UIElement
 * 单行编辑器。
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onFocusIn
 * 得到输入焦点事件。
 */

/**
 * @event onFocusOut
 * 失去输入焦点事件。
 */
function UIMLEdit() {
	return;
}

UIMLEdit.prototype = new UIElement();
UIMLEdit.prototype.isUIMLEdit = true;

UIMLEdit.prototype.saveProps = ["inputTips"];
UIMLEdit.prototype.initUIMLEdit = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setText("");
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_FOCUSED, null);
	this.setMargin(12, 12);
	this.addEventNames(["onChanged", "onFocusIn", "onFocusOut"]);
	this.setTextAlignV("top");
	this.setTextAlignH("left");

	return this;
}

UIMLEdit.prototype.drawText = function(canvas) {
	if(!this.text || this.editing) {
		return;
	}

	return this.defaultDrawText(canvas);
}

UIMLEdit.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIMLEdit.prototype.textEditable = function(point) {
	return true;
}

UIMLEdit.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	if(this.mode !== Shape.MODE_EDITING) {
		this.editText();
	}

	return;
}

UIMLEdit.prototype.isFocused = function() {
	return this.editing;
}

UIMLEdit.prototype.getEditorRect = function() {
	var p = this.getPositionInView();
	var vp = this.view.getAbsPosition();
	var scale = this.view.getViewScale();
	var ox = vp.x;
	var oy = vp.y;

	var x = (p.x) * scale + ox;
	var y = (p.y) * scale + oy;
	var w = this.getWidth() * scale;
	var h = this.getHeight() * scale;
	
	var rect = {};

	scale = UIElement.getMainCanvasScale();
	rect.x = Math.round(x/scale.x);
	rect.y = Math.round(y/scale.y);
	rect.w = Math.round(w/scale.x);
	rect.h = Math.round(h/scale.y);
	
	if(this.mode === Shape.MODE_EDITING) {
		var radtio = window.devicePixelRatio || 1;
		rect.x *= radtio;
		rect.y *= radtio;
		rect.w *= radtio;
		rect.h *= radtio;
	}

	return rect;
}

UIMLEdit.prototype.editText = function(point) {
	if(this.textEditable(point)) {
		var shape = this;
		var rect = this.getEditorRect();
		var scale = this.getRealScale() / UIElement.getMainCanvasScale().y;
		var inputType = this.inputType ? this.inputType : "text";
		var fontSize = this.style.fontSize * scale; 
		var editor = cantkShowTextArea(this.getText(), fontSize, rect.x, rect.y, rect.w, rect.h);
		
		shape.editing = true;
		if(this.mode === Shape.MODE_EDITING) {
			editor.showBorder(true);
		}
		function onChanged(text) {
			if(text !== shape.text) {
				shape.setText(text, true);
				shape.postRedraw();
			}
			else {
				shape.text = text;
			}
			
			editor.setOnChangedHandler(null);
	        editor.setOnChangeHandler(null);
			editor.hide();
			delete shape.editing;
			shape.callOnFocusOutHandler();

			return;
		}

		function onChange(text) {
			shape.callOnChangingHandler(text);
		}

		editor.setOnChangedHandler(onChanged);
		editor.setOnChangeHandler(onChange);
		
		this.callOnFocusInHandler();
	}

	return;
}

UIMLEdit.prototype.getTextTipsPosition = function() {
	var pos = {};

	pos.x = this.hMargin;
	pos.y = this.vMargin;
	pos.textAlign = "left";
	pos.textBaseline = "top";

	return pos;
}

function UIMLEditCreator(w, h) {
	var args = ["ui-mledit", "ui-mledit", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMLEdit();
		return g.initUIMLEdit(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMLEditCreator(300, 300));

/*
 * File:   ui-toolbar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Toolbar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIToolBar
 * @extends UIElement
 * 通常是放在窗口的顶部或底部的一个容器，里面放窗口的标题和导航的按钮。
 *
 */
function UIToolBar() {
	return;
}

UIToolBar.prototype = new UIElement();
UIToolBar.prototype.isUIToolBar = true;

UIToolBar.prototype.initUIToolBar = function(type, atTop, h, bg) {
	this.initUIElement(type);	

	this.xAttr = UIElement.X_LEFT_IN_PARENT;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.yAttr = atTop ? UIElement.Y_TOP_IN_PARENT : UIElement.Y_BOTTOM_IN_PARENT;

	this.setDefSize(200, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setSizeLimit(100, 50, 2000, 200);

	return this;
}

UIToolBar.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton || shape.isUIGroup 
	|| shape.isUIButtonGroup || shape.isUIEdit || shape.isUIImageButton
	|| shape.isUICheckBox || shape.isUIRadioBox || shape.isUIProgressBar || shape.isUISwitch 
	|| shape.isUILedDigits || shape.isUIGroup || shape.isUILayout || shape.isUIWaitBar || shape.isUIColorBar) {
		return true;
	}

	return false;
}

UIToolBar.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIToolBarCreator(type, atTop, h, bg) {
	var args = [type, "ui-toolbar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIToolBar();
		return g.initUIToolBar(type, atTop, h, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIToolBarCreator("ui-toolbar", true, 85, null));

/*
 * File:   ui-placeholder.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Place Holder
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPlaceholder() {
	return;
}

UIPlaceholder.prototype = new UIElement();
UIPlaceholder.prototype.isUIPlaceholder = true;
UIPlaceholder.prototype.initUIPlaceholder = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);

	return this;
}

UIPlaceholder.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPlaceholder.prototype.paintSelfOnly = function(canvas) {
	if(this.mode === Shape.MODE_EDITING) {
		var x = this.vMargin;
		var y = this.hMargin;
		var w = this.getWidth(true);
		var h = this.getHeight(true);

		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		drawDashedRect(canvas, x, y, w, h);
		canvas.stroke();
	}

	return;
}

function UIVPlaceholderCreator(w, h) {
	var args = ["ui-v-placeholder", "ui-placeholder", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPlaceholder();

		g.initUIPlaceholder(this.type, w, h);
		g.widthAttr = UIElement.WIDTH_FILL_PARENT;
		g.MIN_SIZE = 4;
		g.setSizeLimit(20, 4);

		return g;
	}
	
	return;
}

function UIHPlaceholderCreator(w, h) {
	var args = ["ui-h-placeholder", "ui-placeholder", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPlaceholder();

		g.initUIPlaceholder(this.type, w, h);
		g.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		g.MIN_SIZE = 4;
		g.setSizeLimit(4, 20);

		return g;
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIVPlaceholderCreator(100, 20));
ShapeFactoryGet().addShapeCreator(new UIHPlaceholderCreator(20, 100));

/*
 * File:   ui-radio-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Radio Box
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIRadioBox
 * @extends UICheckBox
 * 单选按钮。可以用setValue来勾选/去勾选，用getValue来判断是否勾选。
 *
 */
function UIRadioBox() {
	return;
}

UIRadioBox.prototype = new UICheckBox();
UIRadioBox.prototype.isUIRadioBox = true;

UIRadioBox.prototype.initUIRadioBox = function(type) {
	return this.initUICheckBox(type)
}

UIRadioBox.prototype.setParent = function(parentShape) {
	UIElement.prototype.setParent.call(this, parentShape);

	if(this.value) {
		this.setChecked();
	}

	return this;
}

UIRadioBox.prototype.onFromJsonDone = function() {
	if(this.value) {
		this.setChecked();
	}

	return this;
}

UIRadioBox.prototype.setChecked = function() {
	var parentShape = this.getParent();

	if(parentShape) {
		for(var i = 0; i < parentShape.children.length; i++) {
			var shape = parentShape.children[i];
			if(shape.isUIRadioBox) {
				shape.setValue(false);
			}
		}
	}

	this.setValue(true);

	return this;
}

UIRadioBox.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	this.setChecked();
	
	return this.callOnClickHandler(point);
}

function UIRadioBoxCreator(w, h) {
	var args = ["ui-radiobox", "ui-radiobox", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIRadioBox();
		g.initUIRadioBox(this.type);

		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIRadioBoxCreator(50, 50, null, null, null, null, null, null));

/*
 * File:   ui-led-digits.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  LED Digits 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UILedDigits() {
	return;
}

UILedDigits.prototype = new UIElement();
UILedDigits.prototype.isUILedDigits = true;

UILedDigits.prototype.initUILedDigits = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);

	return this;
}

UILedDigits.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UILedDigits.prototype.setText = function(text) {
	this.text = "";

	text = this.toText(text); 
	for(var i = 0; i < text.length; i++) {
		var c = text[i];

		switch(c) {
			case '.':
			case ':':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'E':
			case 'F':
			case 'F': {
				this.text = this.text + c;
			}
			default:break;
		}
	}

	return;
}

UILedDigits.prototype.drawBarVL = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(0, h);
	canvas.lineTo(w, h-w);
	canvas.lineTo(w, w);
	canvas.lineTo(0, 0);

	return;
}

UILedDigits.prototype.drawBarVR = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(w, 0);
	canvas.lineTo(w, h);
	canvas.lineTo(0, h-w);
	canvas.lineTo(0, w);
	canvas.lineTo(w, 0);

	return;
}

UILedDigits.prototype.drawBarHT = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(w, 0);
	canvas.lineTo(w-h, h);
	canvas.lineTo(h, h);
	canvas.lineTo(0, 0);

	return;
}

UILedDigits.prototype.drawBarHM = function(canvas, w, h) {
	canvas.beginPath();
	var space = Math.round(h/3);
	w = w - 2 * space;
	canvas.translate(space, 0);
	canvas.moveTo(0, h/2);
	canvas.lineTo(h/2, 0);
	canvas.lineTo(w-h/2, 0);
	canvas.lineTo(w, h/2);
	canvas.lineTo(w-h/2, h);
	canvas.lineTo(h/2, h);
	canvas.lineTo(0, h/2);
	canvas.translate(-space, 0);

	return;
}
UILedDigits.prototype.drawBarHB = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, h);
	canvas.lineTo(w, h);
	canvas.lineTo(w-h, 0);
	canvas.lineTo(h, 0);
	canvas.lineTo(0, h);

	return;
}

UILedDigits.prototype.drawBar = function(canvas, w, h) {
	if(w < h) {
		this.drawBarV(canvas, w, h);
	}
	else {
		this.drawBarH(canvas, w, h);
	}

	return;
}

UILedDigits.prototype.drawDot = function(canvas, w, h, dot) {
	var size = (w/4 + h/8)/2;

	if(dot === ".") {
		canvas.fillRect((w-size)/2, 0.75*h - size/2, size, size);
	}
	else if(dot = ":") {
		canvas.fillRect((w-size)/2, 0.25*h - size/2, size, size);
		canvas.fillRect((w-size)/2, 0.75*h - size/2, size, size);
	}

	return;
}

UILedDigits.prototype.map = {
	"0":0x7d,
	"1":0x60,
	"2":0x37,
	"3":0x67,
	"4":0x6a,
	"5":0x4f,
	"6":0x5f,
	"7":0x61,
	"8":0x7f,
	"9":0x6f,
	"E":0x1f,
	"F":0x1b,
	"H":0x7a
};

UILedDigits.prototype.fillBar = function(canvas, light) {
	if(light) {
		canvas.fillStyle = this.style.textColor;
		canvas.fill();
	}
	else {
		canvas.lineWidth = 1;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}

UILedDigits.prototype.drawDigit = function(canvas, w, h, digit) {
	var hBarHeight = Math.max(3, Math.round(h/10));
	var vBarWidht = Math.max(3, Math.round(w/10));
	var size = Math.round((vBarWidht + hBarHeight)/2);

	var space = 1;
	var hBarWidth = w - 2 * space;
	var vBarHeight = Math.floor(h/2 - 2 * space);
	var mask = this.map[digit];

	canvas.translate(space, 0);
	this.drawBarHT(canvas, hBarWidth, size);
	canvas.translate(-space, 0);
	this.fillBar(canvas, mask & 0x01);

	var yOffset = Math.floor((h-hBarHeight)/2);
	canvas.translate(space, yOffset);
	this.drawBarHM(canvas, hBarWidth, size);
	canvas.translate(-space, -yOffset);
	this.fillBar(canvas, (mask >> 1) & 0x01);

	var yOffset = h-hBarHeight;
	canvas.translate(space, yOffset);
	this.drawBarHB(canvas, hBarWidth, size);
	canvas.translate(-space, -yOffset);
	this.fillBar(canvas, (mask >> 2) & 0x01);

	canvas.translate(0, space);
	this.drawBarVL(canvas, size, vBarHeight);
	canvas.translate(0, -space);
	this.fillBar(canvas, (mask >> 3) & 0x01);

	var yOffset = Math.round(2*space + (h-hBarHeight)/2)+space;
	canvas.translate(0, yOffset);
	this.drawBarVL(canvas, size, vBarHeight);
	canvas.translate(0, -yOffset);
	this.fillBar(canvas, (mask >> 4) & 0x01);

	canvas.translate((w-size), space);
	this.drawBarVR(canvas, size, vBarHeight);
	canvas.translate(-(w-size), -space);
	this.fillBar(canvas, (mask >> 5) & 0x01);

	canvas.translate((w-size), yOffset);
	this.drawBarVR(canvas, size, vBarHeight);
	canvas.translate(-(w-size), -yOffset);
	this.fillBar(canvas, (mask >> 6) & 0x01);
	
	return;
}

UILedDigits.prototype.drawDigits = function(canvas) {
	var dots = 0;
	var text = this.text
	var n = text.length;

	if(!n) {
		return;
	}

	for(var i = 0; i < n; i++) {
		var d = text[i];
		if(d === "." || d === ":") {
			dots = dots + 1;
		}
	}

	var space = this.w/n * 0.2;
	var w = this.w/n - space;
	var h = this.h;

	canvas.save();
	canvas.translate(w/4 * dots, 0);
	for(var i = 0; i < n; i++) {
		var d = text[i];
		if(d === "." || d === ":") {
			this.drawDot(canvas, w/2, h, text[i]);
			canvas.translate(w/2+space, 0);
		}
		else {
			this.drawDigit(canvas, w, h, text[i]);
			canvas.translate(w+space, 0);
		}
	}
	canvas.restore();

	return;
}

UILedDigits.prototype.paintSelfOnly = function(canvas) {
	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	canvas.fillStyle = this.style.lineColor;
	this.drawDigits(canvas);

	return;
}

function UILedDigitsCreator(w, h) {
	var args = ["ui-led-digits", "ui-led-digits", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILedDigits();
		return g.initUILedDigits(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UILedDigitsCreator(100, 100));

/*
 * File:   ui-canvas.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Canvas
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICanvas
 * @extends UIElement
 * 画布控件。
 *
 * 注意：UICanvas其实与其它控件共享一个画布，只是把画布的接口暴露出来，所以每次窗口重绘时，里面的内容都被清除，需要重新绘制。
 *
 */

/**
 * @event onPaint(canvas2dCtx) 
 * 绘图事件。
 * @param {Object} canvas2dCtx 画布的2d Context。
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var image = this.getImageByType(0);
 *     var img = image.getImage();
 *     var rect = image.getImageRect();
 *
 *     canvas2dCtx.drawImage(img, rect.x, rect.y, rect.w, rect.h, 0, 0, this.w, this.h);
 *
 *     canvas2dCtx.moveTo(0, 0);
 *     canvas2dCtx.lineTo(this.w, this.h);
 *     canvas2dCtx.lineWidth = 2;
 *     canvas2dCtx.strokeStyle = "red";
 *     canvas2dCtx.stroke();
 *
 */

function UICanvas() {
	return;
}

UICanvas.prototype = new UIElement();
UICanvas.prototype.isUICanvas = true;

UICanvas.prototype.initUICanvas = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.addEventNames(["onPaint", "onPointerDown", "onPointerMove", "onPointerUp", "onKeyDown", 
		"onKeyUp"]);

	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	
	return this;
}

UICanvas.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIImage || shape.isUIButton || shape.isUIGroup || shape.isUILabel;
}

UICanvas.prototype.paintSelfOnly = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	
	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	canvas.beginPath();
	this.callOnPaintHandler(canvas);

	return;
}

function UICanvasCreator(w, h) {
	var args = ["ui-canvas", "ui-canvas", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICanvas();
		return g.initUICanvas(this.type, w, h);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UICanvasCreator(200, 200));

/*
 * File:   ui-color-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Color Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIColorButton
 * @extends UIElement
 * 颜色按钮。不同状态下可以设置不同的颜色，可以是矩形，圆角矩形或圆形。
 *
 */

/**
 * @property {Number} roundRadius
 * 控件的圆角半径。0表示不圆角。
 */

function UIColorButton() {
	return;
}

UIColorButton.prototype = new UIElement();
UIColorButton.prototype.isUIButton = true;
UIColorButton.prototype.isUIColorButton = true;

UIColorButton.prototype.initUIColorTile = function(type, w, h) {
	this.initUIColorButton(type, w, h);
	this.isUIButton = false;
	this.isUIColorButton = false;
	this.isUIColorTile = true;
	this.setAutoScaleFontSize(true);
	this.addEventNames(["onUpdateTransform"]); 
	this.style.roundStyle = 'a';

	return this;
}

UIColorButton.prototype.initUIColorButton = function(type, w, h) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_INPUT);
	this.setCanRectSelectable(false, false);
	this.setMargin(0, 0);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIColorButton.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

/**
 * @method setRoundStyle
 * 设置控件的圆角风格。
 * @param {String} roundStyle 圆角风格。'l'表示左边圆角, 'r'表示右边圆角, 't'表示顶部圆角, 'b'表示底部圆角, 'a'表示全部圆角。
 * @return {UIElement} 返回控件本身。
 *
 */
UIColorButton.prototype.setRoundStyle = function(roundStyle) {
	this.style.roundStyle = roundStyle;

	return this;
}

/**
 * @method getRoundStyle
 * 获取控件的圆角风格。
 * @return {UIElement} 返回圆角风格。
 *
 */
UIColorButton.prototype.getRoundStyle = function() {
	return this.style.roundStyle;
}

/**
 * @method setActiveFillColor
 * 设置控件按下时的填充颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */
UIColorButton.prototype.setActiveFillColor = function(color) {
	this.style.activeFillColor = color;
	
	return this;
}

UIColorButton.prototype.getRoundStyleValue =function() {
	var roundStyle = this.style.roundStyle;

	if(roundStyle === 't') {
		return RoundRect.TL | RoundRect.TR;
	}
	else if(roundStyle === 'l') {
		return RoundRect.TL | RoundRect.BL;
	}
	else if(roundStyle === 'r') {
		return RoundRect.TR | RoundRect.BR;
	}
	else if(roundStyle === 'b') {
		return RoundRect.BL | RoundRect.BR;
	}
	else {
		return RoundRect.TL | RoundRect.TR | RoundRect.BL | RoundRect.BR; 
	}
}

UIColorButton.prototype.paintSelfOnly =function(canvas) {
	var roundStyle = this.getRoundStyleValue();
	var fillColor = this.style.fillColor;
	var lineColor = this.style.lineColor;

	if(this.pointerDown && this.style.activeFillColor) {
		fillColor = this.style.activeFillColor;
	}

	var fillIt = !Shape.isTransparentColor(fillColor);
	var strokeIt = !Shape.isTransparentColor(lineColor);
		
	if(!fillIt && !strokeIt) {
		return;
	}

	canvas.save();
	canvas.beginPath();

	canvas.translate(this.hMargin, this.vMargin);
	drawRoundRect(canvas, this.w-2*this.hMargin, this.h-2*this.vMargin, this.roundRadius, roundStyle);

	if(fillIt) {
		canvas.fillStyle = fillColor;
		canvas.fill();
	}

	if(strokeIt) {
		if(this.isUIColorButton && this.pointerDown) {
			canvas.lineWidth = this.style.lineWidth + 1;
		}
		else {
			canvas.lineWidth = this.style.lineWidth;
		}

		canvas.strokeStyle = lineColor;
		canvas.stroke();
	}

	canvas.restore();

	return;
}

function UIColorTileCreator(w, h) {
	var args = ["ui-color-tile", "ui-color-tile", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorButton();

		return g.initUIColorTile(this.type, w, h);
	}
	
	return;
}

function UIColorButtonCreator(w, h) {
	var args = ["ui-color-button", "ui-color-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorButton();

		return g.initUIColorButton(this.type, w, h);
	}
	
	return;
}

/**
 * @class UIColorTile
 * @extends UIColorButton
 * 颜色块，可以是矩形，圆角矩形或圆形。
 *
 */
ShapeFactoryGet().addShapeCreator(new UIColorTileCreator(80, 80));
ShapeFactoryGet().addShapeCreator(new UIColorButtonCreator(80, 80));

/*
 * File:   ui-view-pager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  View Page (AKA Tab Control)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIViewPager
 * @extends UIFrames
 * 标签控件。
 *
 */
function UIViewPager() {
	return;
}

UIViewPager.prototype = new UIPageManager();
UIViewPager.prototype.isUIViewPager = true;

UIViewPager.prototype.saveProps = ["slideToChange", "showIndicator"];
UIViewPager.prototype.initUIViewPager = function(type) {
	this.initUIPageManager(type);	

	this.current = 0;
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	this.velocityTracker = new VelocityTracker();

	return this;
}

UIViewPager.prototype.getFrameIndicatorParams = function() {
	var n = this.children.length;
	var itemSize = Math.min((0.5 * this.w)/n, 40);
	var indicatorWidth = itemSize * n;

	var dx = (this.w - indicatorWidth)/2;
	var dy = 0.8 * this.h;

	return {offsetX:dx, offsetY:dy, itemSize:itemSize, n:n};
}

UIViewPager.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	if(!this.needShowIndicator()) {
		return;
	}

	var params = this.getFrameIndicatorParams();

	var x = point.x;
	var y = point.y;
	var n = params.n;
	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;

	if(y < dy || y > (dy + itemSize) || x < dx || x > (dx + n * itemSize)) {
		return;
	}

	for(var i = 0; i < n; i++) {
		if(x > dx && x < (dx + itemSize)) {
			this.setCurrent(i);	
			break;
		}

		dx += itemSize;
	}

	return;
}

UIViewPager.prototype.drawFrameIndicator = function(canvas, currFrame) {
	var params = this.getFrameIndicatorParams();

	var n = params.n;
	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;

	dx += itemSize/2;
	dy += itemSize/2;

	var r = 15;
	canvas.fillStyle = this.style.fillColor;
	for(var i = 0; i < n; i++) {
		canvas.beginPath();
		canvas.arc(dx, dy, r, 0, Math.PI * 2);
		dx += itemSize;
	
		if(i === currFrame) {
			canvas.save();
			canvas.shadowColor = this.style.lineColor;
			canvas.shadowBlur = 5;
			canvas.shadowOffsetX = 0;
			canvas.shadowOffsetY = 0;

			canvas.fill();
			canvas.stroke();
			canvas.restore();
		}
		else {
			canvas.fill();
		}
	}

	return;
}

UIViewPager.prototype.needShowIndicator = function() {
	if(this.pageIndicator) {
		return false;
	}

	if(this.mode === Shape.MODE_EDITING || this.showIndicator) {
		return true;
	}

	return false;
}

UIViewPager.prototype.afterPaintChildren = function(canvas) {
	if(this.needShowIndicator()) {
		this.drawFrameIndicator(canvas, this.current);
	}

	return;
}

UIViewPager.prototype.getPrevFrame = function() {
	var n = this.children.length;
	var index = (this.current - 1 + n)%n;

	return this.children[index];
}

UIViewPager.prototype.getNextFrame = function() {
	var n = this.children.length;
	var index = (this.current + 1)%n;

	return this.children[index];
}

UIViewPager.prototype.animScrollTo = function(range, newFrame) {

	var duration = 1000;
	var slideview = this;
	var startOffset = this.offset;
	var startTime = (new Date()).getTime();
	var interpolator = new DecelerateInterpolator(2);

	if(slideview.animating) {
		return;
	}

	slideview.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);
		
		if(timePercent < 1) {
			slideview.offset = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			slideview.offset = 0;
			slideview.setCurrent(newFrame);
			delete startTime;
			delete interpolator;
			delete slideview.animating;
		}

		delete now;
		slideview.postRedraw();
	}

	animStep();

	return;
}

UIViewPager.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || this.animating || !this.slideToChange) {
		return;
	}
	
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	this.velocityTracker.clear();

	return true;
}

UIViewPager.prototype.isEventHandledByChild = function() {
	var status = UIElement.lastEvent.status;
	return status & UIElement.EVENT_HSCROLL_HANDLED;
}

UIViewPager.prototype.setEventHandled = function() {
	this.setLastEventStatus(UIElement.EVENT_HSCROLL_HANDLED);
	
	return this;
}

UIViewPager.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(!this.slideToChange || beforeChild || !this.pointerDown) {
		return;
	}
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.current;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	if(dx > dy && dx > 10) {
		this.offset = this.getMoveAbsDeltaX();
	}
	else {
		this.offset = 0;
	}

	this.addMovementForVelocityTracker();

	return;
}
	
UIViewPager.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(!this.slideToChange || beforeChild || !this.pointerDown) {
		return;
	}

	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.current;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var range = 0;
	var offsetX = this.offset;
	var newFrame = this.current;
	var dy = Math.abs(this.getMoveAbsDeltaY());
	var velocity = this.velocityTracker.getVelocity().x;

	if(Math.abs(offsetX) < 5 || dy > 60) {
		this.offset = 0;

		return;
	}

	var n = this.children.length;
	var distance = offsetX + velocity;

	if(Math.abs(distance) > this.w/3) {
		if(offsetX > 0) {
			range = this.w - offsetX;	
			newFrame = (this.current - 1 + n)%n;
		}
		else {
			range = -this.w - offsetX;
			newFrame = (this.current + 1)%n;
		}
	}
	else {
		range = -offsetX;
	}

	this.animScrollTo(range, newFrame);

	return;
}

UIViewPager.prototype.paintChildrenAnimating = function(canvas) {
	var currFrame = this.getCurrentFrame();
	var prevFrame = this.getPrevFrame();
	var nextFrame = this.getNextFrame();

	canvas.save();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();

	if(this.offset > 0) {
		var offsetX = this.w-this.offset;
		prevFrame.x = -offsetX;
		prevFrame.paintSelf(canvas);
		offsetX = this.offset;
		currFrame.x = offsetX;
		currFrame.paintSelf(canvas);
	}
	else {
		currFrame.x = this.offset;
		currFrame.paintSelf(canvas);
		nextFrame.x = this.w + this.offset;
		nextFrame.paintSelf(canvas);
	}
	currFrame.x = 0;
	nextFrame.x = 0;
	prevFrame.x = 0;
	canvas.restore();

	return;
}

UIViewPager.prototype.paintChildrenNormal = function(canvas) {
	var child = this.getCurrentFrame();
	
	if(child) {
		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}
	
	return;
}

UIViewPager.prototype.paintChildren = function(canvas) {
	if(this.offset && this.children.length > 1) {
		this.paintChildrenAnimating(canvas);
	}
	else {
		this.paintChildrenNormal(canvas);
	}

	return;
}

UIViewPager.prototype.setSlideToChange = function(value) {
	this.slideToChange = value;

	return;
}

UIViewPager.prototype.setShowIndicator = function(value) {
	this.showIndicator = value;

	return;
}

UIViewPager.prototype.onModeChanged = function() {
	this.setCurrent(0);

	return;
}

function UIViewPagerCreator() {
	var args = ["ui-view-pager", "ui-view-pager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIViewPager();

		return g.initUIViewPager(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIViewPagerCreator());

/*
 * File:   ui-sliding-menu.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Sliding Menu
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISlidingMenu() {
	return;
}

UISlidingMenu.prototype = new UIElement();
UISlidingMenu.prototype.isUISlidingMenu = true;

UISlidingMenu.prototype.initUISlidingMenu = function(type, w, h) {
	this.initUIElement(type);	

	this.offset = 0;
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setCanRectSelectable(false, false);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UISlidingMenu.prototype.onAppendedInParent = function() {
	var menu = this.getMenu();

	if(!menu) {
		return;
	}

	if(this.offset) {
		this.setOffset(menu.w);
	}
	else {
		this.setOffset(0);
	}

	return;
}

UISlidingMenu.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIPage && this.children.length < 2;
}

UISlidingMenu.prototype.afterChildAppended = function(shape) {
	shape.setUserMovable(false);

	if(this.children.length > 1 && this.mode == Shape.MODE_EDITING) {
		var menu = this.getMenu();
		this.setOffset(menu.w);
	}

	return;
}

UISlidingMenu.prototype.onDoubleClick = function(point, beforeChild) {
	if(beforeChild || this.mode != Shape.MODE_EDITING) {
		return;
	}

	if(this.offset) {
		this.hideMenu();
	}
	else {
		this.showMenu();
	}

	return;
}

UISlidingMenu.prototype.getMenu = function() {
	if(this.children.length > 0) {
		return this.children[0];
	}

	return null;
}

UISlidingMenu.prototype.getContent = function() {
	if(this.children.length >  1) {
		return this.children[1];
	}

	return null;
	
}

UISlidingMenu.prototype.showMenu = function() {
	var menu = this.getMenu();

	if(menu) {
		this.scrollTo(menu.w);
	}

	return;
}

UISlidingMenu.prototype.hideMenu = function() {
	var menu = this.getMenu();

	if(menu) {
		this.scrollTo(0);
	}

	return;
}

UISlidingMenu.prototype.relayoutChildren = function() {
	var menu = null;
	var content = null;
	var n = this.children.length;

	if(!n) {
		return;
	}

	if(n === 1) {
		menu = this.children[0];

		menu.y = 0;
		menu.x = 0;
		menu.h = this.h;
		menu.xAttr = UIElement.X_FIX_LEFT;
		menu.yAttr = UIElement.Y_FIX_TOP;
		menu.widthAttr = UIElement.WIDTH_SCALE;
		menu.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		menu.relayout();
		
		return;
	}
	else {
		menu = this.children[0];
		content = this.children[1];

		var oldMenuW = menu.w;

		menu.y = 0;
		menu.h = this.h;
		menu.xAttr = UIElement.X_FIX_LEFT;
		menu.yAttr = UIElement.Y_FIX_TOP;
		menu.widthAttr = UIElement.WIDTH_SCALE;
		menu.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		menu.relayout();
		
		if(oldMenuW === this.offset) {
			this.offset = menu.w;
		}

		var ratio = this.offset/menu.w;
		menu.x = -Math.round(0.5 * ((1-ratio) * menu.w));
	
		content.y = 0;
		content.x = this.offset;
		content.h = this.h;
		content.w = this.w;
		content.xAttr = UIElement.X_FIX_LEFT;
		content.widthAttr = UIElement.WIDTH_FIX;
		content.heightAttr = UIElement.HEIGHT_FILL_PARENT;

		menu.relayoutChildren();
		content.relayoutChildren();
	}

	return;
}

UISlidingMenu.prototype.getMinOffset = function() {
	return 0;
}

UISlidingMenu.prototype.getMaxOffset = function() {
	var menu = this.getMenu();

	return menu ? menu.w : 0;
}

UISlidingMenu.prototype.scrollTo = function(offsetEnd) {
	var me = this;
	var duration = 500;
	var offsetStart = this.offset;
	var range = offsetEnd - offsetStart;
	var startTime = (new Date()).getTime();
	var interpolator =  new DecelerateInterpolator();

	this.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);

		if(timePercent < 1) {
			me.setOffset(Math.floor(offsetStart + percent * range));
			setTimeout(animStep, 10);
		}
		else {
			me.setOffset(offsetStart + range);
			delete startTime;
			delete interpolator;
			delete me.animating;
		}

		delete now;
	}

	setTimeout(function() {
		animStep();
	}, 10);

	return;
}

UISlidingMenu.prototype.setOffset = function(offset) {
	var menu = this.getMenu();
	this.offset = offset;

	if(menu) {
		if(this.offset < 0) {
			this.offset = 0;
		}

		if(this.offset > menu.w) {
			this.offset = menu.w;
		}
	}

	this.relayoutChildren();
	this.postRedraw();

	return;
}

UISlidingMenu.prototype.isEventHandledByChild = function() {
	var status = UIElement.lastEvent.status;
	return status & UIElement.EVENT_HSCROLL_HANDLED;
}

UISlidingMenu.prototype.setEventHandled = function() {
	this.setLastEventStatus(UIElement.EVENT_HSCROLL_HANDLED);
	
	return this;
}

UISlidingMenu.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}
	
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	if(!this.velocityTracker) {
		this.velocityTracker = new VelocityTracker();
	}
	this.velocityTracker.clear();
	this.saveOffset = this.offset;

	return true;
}

UISlidingMenu.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}

	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();
	
	this.addMovementForVelocityTracker();

	var dx = this.getMoveAbsDeltaX();
	var dy = this.getMoveAbsDeltaY();

	if(Math.abs(dx) > Math.abs(dy)) {
		this.setOffset(this.saveOffset + dx);
	}

	return;
}
	
UISlidingMenu.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	var dx = this.getMoveAbsDeltaX();
	var dy = this.getMoveAbsDeltaY();

	if(Math.abs(dx) < Math.abs(dy)) {
		return;
	}

	var velocity = this.velocityTracker.getVelocity().x;
	var distance = dx + velocity/2;

	if(Math.abs(distance) < 10) {
		var menu = this.getMenu();
		if(this.offset > 10 && menu && (point.x > (menu.x + menu.w))) {
			this.hideMenu();
		}
		else {
			this.setOffset(this.saveOffset);
		}

		return;
	}

	var minOffset = this.getMinOffset();
	var maxOffset = this.getMaxOffset();
	var offset = this.saveOffset + dx + velocity;

	if(offset < minOffset) {
		offset = minOffset;
	}

	if(offset > maxOffset) {
		offset = maxOffset;
	}

	if(this.saveOffset > (minOffset + maxOffset)/2) {
		if(offset <= minOffset) {
			offset = minOffset;
		}
		else {
			offset = maxOffset;
		}
	}
	else {
		if(offset >= maxOffset) {
			offset = maxOffset;
		}
		else {
			offset = minOffset;
		}
	}

	this.scrollTo(offset);

	return;
}

UISlidingMenu.prototype.onInit = function() {
	if(this.offset) {
		var menu = this.getMenu();
		if(menu) {
			this.setOffset(menu.w);
		}
	}
	else {
		this.setOffset(0);
	}

	return;
}

UISlidingMenu.prototype.dispatchPointerDownToChildren = function(p) {
	var menu = this.getMenu();
	var content = this.getContent();

	var child = this.offset ? menu : content;

	if(menu && content && menu.x == content.x && menu.x == 0) {
		this.setOffset(0);
	}

	if(child && child.visible && child.onPointerDown(p)) {
		this.setTarget(child);

		return true;
	}

	return false;
}

UISlidingMenu.prototype.paintChildren = function(canvas) {
	canvas.save();	
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	this.defaultPaintChildren(canvas);

	canvas.restore();

	return;
}

function UISlidingMenuCreator() {
	var args = ["ui-sliding-menu", "ui-sliding-menu", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISlidingMenu();

		return g.initUISlidingMenu(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISlidingMenuCreator());

/*
 * File:   ui-progressbar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Slider/ProgressBar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIProgressBar
 * @extends UIElement
 * 进度条。可以用setValue/getValue来设置/获取进度。缺省进度取值范围0-100，也可以用setRange来设置它的取值范围。
 *
 * 在进度条上放一张图片，可以把进度条变成一个滑块控件。
 *
 * 进度条有3种表现形式：
 * 
 * 1.宽度大于高度时为水平进度条。

 * 2.宽度小于高度时为垂直进度条。
 * 
 * 3.宽度约等于高度时为环状进度条。
 *
 *     @example small frame
 *     this.win.find("progressbar").setValue(50, true, true);
 *
 */

/**
 * @event onChanged
 * 进度变化时触发本事件。
 * @param {Number} value 当前的进度。
 */

/**
 * @event onChanging
 * 进度正在变化时触发本事件。只有做为滑块控件时，拖动滑块才会触发本事件。
 * @param {Number} value 当前的进度。
 */
function UIProgressBar() {
	return;
}

UIProgressBar.prototype = new UIElement();
UIProgressBar.prototype.isUIProgressBar = true;
UIProgressBar.prototype.saveProps = ["stepSize", "minValue", "maxValue"];
UIProgressBar.prototype.initUIProgressBar = function(type, w, h, interactive) {
	this.initUIElement(type);	

	this.setRange(0, 100);
	this.setPercent(50);
	this.setDefSize(w, h);
	this.setStepSize(0);
	this.roundRadius = 0;
	this.setInteractive(interactive);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_NORMAL_FG, null);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	if(interactive) {
		this.addEventNames(["onChanged"]);
		this.addEventNames(["onChanging"]);
	}

	return this;
}

UIProgressBar.prototype.shapeCanBeChild = function(shape) {
	if(this.dragger) {
		return false;
	}

	return (shape.isUIImage || shape.isUILabel || shape.isUIColorTile);
}

UIProgressBar.prototype.updateDraggerParams =function() {
	var shape = this.dragger;
	if(!shape) return;

	if(this.w < this.h) {
		shape.yAttr = UIElement.Y_FIX_TOP;
		shape.xAttr = UIElement.X_CENTER_IN_PARENT;
		shape.widthAttr = UIElement.WIDTH_FILL_PARENT;
		shape.heightAttr = UIElement.HEIGHT_FIX;
	}
	else {
		shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
		shape.xAttr = UIElement.X_FIX_LEFT;
		shape.widthAttr = UIElement.WIDTH_FIX;
		shape.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	}
}

UIProgressBar.prototype.relayoutChildren = function() {
	if(!this.dragger) {
		return;
	}

	if(this.w > this.h) {
		var x = this.value * this.w - (this.dragger.w>>1);	
		var maxX = this.w - this.dragger.w;
		this.dragger.setLeft(Math.max(0, Math.min(maxX, x)));
	}
	else {
		var y = (1-this.value) * this.h - (this.dragger.h >> 1);
		var maxY = this.h - this.dragger.h;
		this.dragger.setTop(Math.max(0, Math.min(maxY, y)))
	}

	UIElement.prototype.relayoutChildren.call(this);

	return;
}

UIProgressBar.prototype.resizeDragger =function() {
	if(this.dragger) {
		var w = this.dragger.w;
		var h = this.dragger.h;
		if(this.w > this.h) {
			h = this.h;
			w = Math.min(this.h, w);
		}
		else {
			w = this.w;
			h = Math.min(this.w, h);
		}
		this.dragger.setSize(w, h);
	}

	return this;
}

/**
 * @method setStepSize
 * 设置Slider的步长。
 * @param {Number} stepSize 取值范围0-50，0表示平滑移动。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var win = this.win;
 *     var slider = win.find("slider");
 *     slider.setStepSize(20);
 */
UIProgressBar.prototype.setStepSize = function(stepSize) {
	var range = this.maxValue - this.minValue;
	this.stepSize = Math.max(0, Math.min(stepSize, range));

	return this;
}

/**
 * @method setRange 
 * 设置进度条的取值范围。
 * @param {Number} minValue 最小值。
 * @param {Number} maxValue 最大值。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var win = this.win;
 *     var slider = win.find("slider");
 *     slider.setRange(0, 5);
 *     slider.setStepSize(1);
 */
UIProgressBar.prototype.setRange = function(minValue, maxValue) {
	this.minValue = Math.max(0, Math.min(minValue, maxValue));
	this.maxValue = Math.max(0, Math.max(minValue, maxValue));

	if(this.minValue === this.maxValue) {
		this.minValue = 0;
		this.maxValue = 100;
	}

	return this;
}

/**
 * @method getStepSize
 * 获取Slider的步长。
 * @return {Number} Slider的步长。
 */
UIProgressBar.prototype.getStepSize = function() {
	return this.stepSize || 0;
}

/**
 * @method getMinValue
 * 获取范围的最小值。可以用setRange来设置取值范围。
 * @return {Number} 范围的最小值。
 */
UIProgressBar.prototype.getMinValue = function() {
	return this.minValue;
}

/**
 * @method getMaxValue
 * 获取范围的最大值。可以用setRange来设置取值范围。
 * @return {Number} 范围的最大值。
 */
UIProgressBar.prototype.getMaxValue = function() {
	return this.maxValue;
}

UIProgressBar.prototype.afterChildAppended =function(shape) {
	var bar = this;
	
	this.dragger = shape;
	this.updateDraggerParams();
	this.setTextType(Shape.TEXT_NONE);

	bar.onPointerDownRunning = bar.onPointerMoveRunning = function(point, beforeChild) {
		if(beforeChild) {
			return;
		}

		var hw = this.dragger.w >> 1;
		var hh = this.dragger.h >> 1;
		if(this.pointerDown && this.dragger) {
			var x = point.x - hw;
			var y = point.y - hh;
			x = Math.min(Math.max(-2, x), this.w - hw + 2);
			y = Math.min(Math.max(-2, y), this.h - hh + 2);

			this.dragger.move(x, y);
		}
		
		return;
	}

	bar.onPointerUpRunning = function(point, beforeChild) {
		if(beforeChild) {
			return;
		}

		if(this.changed) {
			this.changed = false;
			this.callOnChangedHandler(this.getValue());
		}

		return;
	}

	bar.onSized = function() {
		var size = Math.min(this.w, this.h);
		this.updateLayoutParams();
		this.setPercent(this.getPercent());
		this.resizeDragger();
		this.updateDraggerParams();

		return;
	}

	shape.onSized = function() {
		bar.resizeDragger();
	}

	shape.onMoved = function() {
		var percent = 0;
		if(bar.w > bar.h) {
			var value = (this.left + (this.w >> 1))/bar.w;
			percent = value * 100;
			if(this.left <= 0) {
				percent = 0;
			}
			if((this.left + this.w) >= bar.w) {
				percent = 100;
			}
		}
		else {
			var value = (bar.h - (this.top + (this.h >> 1)))/bar.h;
			percent = value * 100;
			if(this.top <= 0) {
				percent = 100;
			}
			if((this.top + this.h) >= bar.h) {
				percent = 0;
			}
		}

		bar.changed = true;
		bar.setPercentOnly(percent);
		bar.callOnChangingHandler(bar.getValue());

		return;
	}
	
	return;
}

UIProgressBar.prototype.setInteractive = function(value) {
	this.interactive = value;

	return this;
}

UIProgressBar.prototype.fixPercent = function(percent, stepSize) {
	var fixedPercent = percent;

	if(stepSize && percent < 100) {
		var range = this.maxValue - this.minValue;
		var value = Math.round(((percent/100) * range)/stepSize) * stepSize;
		fixedPercent = (value/range) * 100;
	}

	return fixedPercent;
}

UIProgressBar.prototype.setPercentOnly = function(percent, notify, animation) {
	var stepSize = this.stepSize;
	var newValue = (this.fixPercent(percent, this.stepSize)%101)/100;
	
	if(!animation) {
		this.value = newValue;
		this.relayoutChildren();
	}

	if(this.mode === Shape.MODE_EDITING || !this.isVisible()) {
		return this;
	}

	if(!animation) {
		if(notify) {
			this.callOnChangedHandler(this.getValue());
		}
	}
	else {
		if(this.value == newValue) return this;
		this.setupAnimation({
			notify: notify,
			valueStart: this.value,
			valueEnd: newValue
		});
	}

	return this;
}

UIProgressBar.prototype.setupAnimation = function(config) {
	var me = this;
	var def = {
		duration: 300,
		actionWhenBusy: 'replace',
		onStep: function(ui, timePercent, config) {
			me.value = config.value;
			me.relayoutChildren();
			return true;
		},
		onDone: function(ui, aniName) {
			me.value = config.valueEnd;
			if(config.notify) {
				me.callOnChangedHandler(me.getValue());	
			}
		}
	};

	if(!config) {
		config = def;
	}
	else {
		var keys = Object.keys(def);
		for(var i = 0, len = keys.length; i < len; i++) {
			var k = keys[i];
			if(!config[k]) {
				config[k] = def[k];
			}
		}
	}

	this.animate(config);

	return this;
}

UIProgressBar.prototype.setPercent = function(value, notify, animation) {
	value = Math.max(0, Math.min(value, 100));

	this.setPercentOnly(value, notify, animation);
	this.relayoutChildren();

	return this;
}

UIProgressBar.prototype.getPercent = function() {
	return this.value * 100;
}

UIProgressBar.prototype.getValue = function() {
	var range = this.maxValue - this.minValue;
	var value = this.minValue + this.value * range;
	var stepSize = this.stepSize;

	if(stepSize) {
		value = Math.round((value/stepSize)) * stepSize;
	}

	return Math.round(value);
}

UIProgressBar.prototype.setValue = function(value, notify, animation) {
	var range = this.maxValue - this.minValue;
	var percent = 100 * ((value-this.minValue)/range);

	this.setPercent(percent, notify, animation);

	return this;
}

UIProgressBar.prototype.drawText = function(canvas) {
	var text = Math.round(this.getPercent()) + "%";

	if(!this.isTextColorTransparent()) {
		canvas.font = this.style.getFont();
		canvas.fillStyle = this.getTextColor();
		canvas.textBaseline = "middle";
		canvas.textAlign = "center";

		canvas.fillText(text, this.w >> 1, this.h >> 1);
	}

	return;
}

UIProgressBar.prototype.paintSelfOnly = function(canvas) {
}

UIProgressBar.prototype.drawBgImageV = function(canvas) {
	var image = null;
	var w = this.w >> 1;
	var x = (this.w - w)>> 1;
	var fgColor = this.style.lineColor;
	var bgColor = this.style.fillColor;
	var r = this.roundRadius ? this.roundRadius : 0;
	var wImage = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		
		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, x, 0, w, this.h, rect);
		}
	}
	else if(!Shape.isTransparentColor(bgColor)) {
		canvas.beginPath();
		canvas.translate(x, 0);
		drawRoundRect(canvas, w, this.h, r);
		canvas.translate(-x, 0);
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);

	var h = Math.round(this.h * this.value);
	var y = this.h - h;

	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		image = wImage.getImage();

		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			var tmph = rect.h;
			var tmpy = rect.y;
			var tmprh = rect.rh;
			var ih = Math.round(tmph*this.value);
			rect.h = ih;
			rect.y = rect.y + tmph - ih;
			rect.h = ih;
			rect.rh = Math.round(tmprh*this.value);  
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, y, this.w, h, rect);
			rect.y = tmpy;
			rect.h = tmph;
			rect.rh = tmprh;
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, x, y, w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(fgColor)) {
		if(h > 2 * r) {
			canvas.beginPath();
			canvas.translate(x, y);
			drawRoundRect(canvas, w, h, r);
			canvas.fillStyle = this.style.lineColor;
			canvas.fill();
		}
	}

	return;
}

UIProgressBar.prototype.drawBgImageH = function(canvas) {
	var image = null;
	var h = this.h >> 1;
	var y = (this.h - h)>> 1;
	var fgColor = this.style.lineColor;
	var bgColor = this.style.fillColor;
	var r = this.roundRadius ? this.roundRadius : 0;

	var wImage = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		
		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, 0, y, this.w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(bgColor)) {
		canvas.beginPath();
		canvas.translate(0, y);
		drawRoundRect(canvas, this.w, h, r);
		canvas.translate(0, -y);
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	var w = Math.round(this.w * this.value);
	var wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();

		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			var tmpw = rect.w;
			var tmprw = rect.rw;
			rect.w = Math.round(rect.w*this.value);
			rect.rw = Math.round(rect.rw*this.value);
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, w, this.h, rect);
			rect.w = tmpw; 
			rect.rw= tmprw;
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, 0, y, w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(fgColor)) {
		if(w > 2 * r) {
			canvas.beginPath();
			canvas.translate(0, y);
			drawRoundRect(canvas, w, h, r);
			canvas.fillStyle = this.style.lineColor;
			canvas.fill();
		}
	}

	return;
}

UIProgressBar.prototype.drawCircle = function(canvas) {
	var cx = this.w >> 1;
	var cy = this.h >> 1;
	var r = Math.min(cx, cy);
	var angle = Math.PI * 2 * this.value - 0.5 * Math.PI;
	var lineWidth = Math.min(r, Math.max(this.style.lineWidth, 5));
	
	var fgImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);
	var bgImage = this.getImageByType(UIElement.IMAGE_DEFAULT);

	if(bgImage && bgImage.getImage()) {
		var image = bgImage.getImage();
		var rect = bgImage.getImageRect();
		WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
	}
	else if(!this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.arc(cx, cy, r, 0, Math.PI * 2);
		
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(fgImage && fgImage.getImage()) {
		canvas.beginPath();
		canvas.moveTo(r, r);
		canvas.lineTo(r, 0)
		canvas.arc(cx, cy, r, -Math.PI * 0.5, angle);
		canvas.lineTo(r, r)
		canvas.clip();

		var image = fgImage.getImage();
		var rect = fgImage.getImageRect();
		WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
	}
	else if(!this.isStrokeColorTransparent()) {
		r = r - (lineWidth >> 1);
		
		canvas.beginPath();
		canvas.lineCap = 'round';
		canvas.lineWidth = lineWidth;
		canvas.arc(cx, cy, r, -Math.PI * 0.5, angle);
		
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}

UIProgressBar.prototype.drawBgImage = function(canvas) {
	canvas.save();
	if(Math.abs(this.w - this.h) < 10) {
		this.drawCircle(canvas);
	}
	else if(this.w > this.h) {
		this.drawBgImageH(canvas);
	}
	else {
		this.drawBgImageV(canvas);
	}
	canvas.restore();
}

UIProgressBar.prototype.onFromJsonDone = function() {
	this.setPercent(this.getPercent());

	return;
}

function UIProgressBarCreator(w, h, interactive) {
	var type = interactive ? "ui-slider" : "ui-progressbar";
	var args = [type, "ui-progressbar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIProgressBar();
		return g.initUIProgressBar(this.type, w, h, interactive);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIProgressBarCreator(200, 45, false));
ShapeFactoryGet().addShapeCreator(new UIProgressBarCreator(200, 45, true));

/*
 * File:   ui-window-manager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Window Manager
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWindowManager
 * @extends UIFrames
 * 管理着所有窗口，并提供管理窗口的函数，如打开和关闭窗口。但通常您并不需要直接调用窗口管理器的函数，因为这些函数已经封装到UIElement了，在事件处理程序中，通过this直接去访问这些函数就行了。
 *
 */

function UIWindowManager() {
}

UIWindowManager.prototype = new UIFrames();
UIWindowManager.prototype.isUIWindowManager = true;

UIWindowManager.prototype.saveProps = ["current", "sceneIdIndex"];
UIWindowManager.prototype.initUIWindowManager = function(type) {
	this.settings = {};
	this.initUIFrames(type);
	this.history = new Array();

	this.showLoadingProgress = true;
	this.setImage("force-landscape-tips", null);
	this.setImage("force-portrait-tips", null);

	this.soundMusicAutoPlay = true;
	this.setSoundEffectsEnable(true);

	return this;
}

UIWindowManager.prototype.fromJson = function(json) {
	this.jsonData = json;

	return RShape.prototype.fromJson.call(this, json);
}

UIWindowManager.prototype.onImageLoadDone = function(img, src) {
    if(!img) {
        return;
    }
	console.log("onImageLoadDone:" + img.src.substr(0, 256));
}

UIWindowManager.prototype.onImageLoadErr = function(src) {
	console.log("onImageLoadErr:" + src);
}

UIWindowManager.prototype.onJsonLoadDone = function(obj, src) {
	console.log("onJsonLoadDone:" + src);
}

UIWindowManager.prototype.onJsonLoadErr = function(src) {
	console.log("onJsonLoadErr:" + src);
}

UIWindowManager.prototype.loadElementAssets = function(el) {
	if(el.images) {
		for(var key in el.images) {
			var url = el.images[key];
			if(typeof url === "string") {
				WImage.create(url, this.onImageLoadDone.bind(this));
			}
		}
	}

	var jsonAssets = UIElement.jsonAssets;
	for(var i = 0; i < jsonAssets.length; i++) {
		var key = jsonAssets[i];
		var url = el[key];
		if(url) {
			if(url.endWith(".json")) {
				ResLoader.loadJson(url, this.onJsonLoadDone.bind(this), this.onJsonLoadErr.bind(this));
			}
			else {
				ResLoader.loadData(url, this.onJsonLoadDone.bind(this), this.onJsonLoadErr.bind(this));
			}
		}
	}
	
	var imagesAssets = UIElement.imagesAssets;
	for(var i = 0; i < imagesAssets.length; i++) {
		var key = imagesAssets[i];
		var url = el[key];
		if(url) {
			WImage.create(url, this.onImageLoadDone.bind(this));
		}
	}

	var children = el.children;
	for(var i = 0; i < children.length; i++) {
		var iter = children[i];
		this.loadElementAssets(iter);	
	}

	return this;
}

UIWindowManager.prototype.clearAssetsCache = function(check) {
	WImage.clearCache(check);
	ResLoader.clearCache(check);

	return this;
}

UIWindowManager.prototype.loadAssets = function(winList, onProgress) {
	function onAssetsLoadProgress(event) {
		if(onProgress) {
			onProgress(event.percent, event.finished, event.total);
		}

		if(event.finished >= event.total) {
			ResLoader.removeEventListener(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, onAssetsLoadProgress);
		}
	}

	var children = this.jsonData.children;
	for(var i = 0; i < children.length; i++) {
		var win = children[i];
		if(!winList || winList.indexOf(win.name) >= 0) {
			this.loadElementAssets(win);	
			console.log("loadElementAssets:" + win.name);
		}
	}

	if(onProgress) {
		if(ResLoader.isLoadCompleted()) {
			setTimeout(function() {
				onProgress(100, 1, 1);
			}, 10);
		}
		else {
			ResLoader.addEventListener(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, onAssetsLoadProgress);
		}
	}

	return this;
}

UIWindowManager.prototype.onFromJsonDone = function() {
	this.designWidth = this.w;
	this.designHeight = this.h;
	this.forcePortrait = false;
	this.forceLandscape = false;

	return;
}

UIWindowManager.prototype.beforeAddShapeIntoChildren = function(shape) {
	return !shape.isUIWindow;
}

UIWindowManager.prototype.getMainWindow = function() {
	var windows = this.children;
	var n = windows.length;

	for(var i = 0; i < n; i++) {
		var win = windows[i];
		if(win.isUILoadingWindow) continue;

		if(win.isUINormalWindow && win.windowType === "main") {
			return win;
		}
	}
	
	for(var i = 0; i < n; i++) {
		var win = windows[i];
		
		if(win.isUILoadingWindow) continue;

		if(win.isUINormalWindow) {
			return win;
		}
	}

	return null;
}

UIWindowManager.prototype.getWindowNames = function(excludeWin) {
	var names = [];
	var children = this.children;
	var n = children.length;

	for(var i = 0; i < n; i++) {
		var win = children[i];
		if(win !== excludeWin) {
			names.push(win.name);
		}
	}

	return names;
}

UIWindowManager.prototype.setInitWindow = function(initWindowIndex) {
	if(initWindowIndex === null || initWindowIndex === undefined) {
		this.initWindowIndex = null;
	}
	else {
		this.initWindowIndex = Math.max(0, Math.min(initWindowIndex, this.children.length-1));
	}

	return this;
}

UIWindowManager.prototype.getInitWindow = function() {
	var initWin = null;

	if(this.children.length > 1) {
		if(this.initWindowIndex || this.initWindowIndex === 0) {
			initWin = this.children[this.initWindowIndex];	
		}

		if(!initWin) {
			var initWinName = cantkGetQueryParam("initwin");
			if(initWinName) {	
				initWin = this.find(initWinName);
			}
		}

		if(!initWin) {
			var initWinName = this.preferInitWindow;
			if(initWinName) {	
				initWin = this.find(initWinName);
			}
		}

		if(!initWin) {
			initWin = this.getMainWindow();
		}
	}

	return initWin;
}

UIWindowManager.prototype.waitDeviceRotate = function() {
	var wm = this;
	if(this.isDeviceDirectionOK()) {
		this.doShowInitWindow();
	}
	else {
		setTimeout(function() {
			wm.waitDeviceRotate();
		}, 100);
	}
}

UIWindowManager.prototype.showInitWindow = function(preferInitWindow) {
	this.preferInitWindow = preferInitWindow;

	this.waitDeviceRotate();
}

UIWindowManager.prototype.doShowInitWindow = function() {
	this.history.clear();
	var initWin = this.getInitWindow();

	if(initWin) {
		this.targetShape = initWin;
		initWin.prepareForOpen();
		index = this.getFrameIndex(initWin);
		this.showFrame(index);
		initWin.callOnBeforeOpen();
		initWin.callOnOpen();
		this.history.push(index);
		this.postRedraw();
		
		console.log("showInitWindow: set targetShape:" + this.targetShape.name);
	}
	else {
		console.log("Not Found Init Window.");
	}

	return true;
}

UIWindowManager.prototype.callOnLoad = function() {
	this.resLoadDone = true;

	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];

		try {
			win.callOnLoadHandler();
		}catch(e) {
			console.log("Call onLoad fail:" + e.message);
		}
	}

	return true;
}

UIWindowManager.prototype.callOnUnload = function() {
	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];

		win.callOnUnloadHandler();
	}

	return true;
}

UIWindowManager.prototype.onResLoadDone = function() {
	this.callOnLoad();
	this.showInitWindow();

	return;
}

UIWindowManager.prototype.getResLoadingWindow = function() {
	var windows = this.children;
	var n = windows.length;

	for(var i = 0; i < n; i++) {
		var win = windows[i];
		if(win.isUINormalWindow && (win.isUILoadingWindow || win.name === "win-loading")) {
			win.isUILoadingWindow = true;
			return win;
		}
	}

	return null;
}

UIWindowManager.prototype.showResLoadingWindow = function() {
	this.resLoadDone = false;
	this.loadSoundEffects();
	this.loadSoundMusic();

	var resWin = this.getResLoadingWindow();

	if(resWin) {
		if(!resWin.isUILoadingWindowV2) {
			this.loadAssets(null, null);
			console.log("old version, load all assets.");
		}

		this.openWindow(resWin.name);	
	}
	else {
		this.loadAssets(null, null);
		this.showInitWindow();
		console.log("no loading window, load all assets.");
	}

	return;
}

UIWindowManager.prototype.systemInit = function() {
	UIElement.animTimerID = null;
	this.callOnSystemInitHandler();

	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];
		win.callOnSystemInitHandler();
	}

	var me = this;
	this.showResLoadingWindow();
	ResLoader.setOnLoadFinishListener(function() {
		me.callOnLoad();
	});

	return;
}

UIWindowManager.prototype.systemExit = function() {
	console.log("systemExit: ");
	var n = this.history.length;
	
	for(var i = 0; i < n; i++) {
		this.closeCurrentWindow(0, true);
	}

	this.history.length = 0;

	this.stopSoundMusic();
	this.callOnUnload();

	return;
}

UIWindowManager.prototype.openWindow = function(name, onClose, closeCurrent, initData, options) {
	var newWin = null;
	options = options ? options : {closeOldIfOpened:true};

	if(name) {
		newWin = this.find(name);
	}
	else {
		newWin = this.getMainWindow();
	}

	if(!newWin || !newWin.isUIWindow) {
		alert("Can not find window: " + name);
		return;
	}

	if(newWin.pendingLoadChildren) {
		newWin.loadChildren();
	}

	if(this.isWindowOpen(newWin)) {
		if(options.closeOldIfOpened) {
			newWin.callOnClose({});
			this.history.remove(newWin.getIndex());
		}
		else if(options.openNewIfOpened) {
			var newWin = this.dupChild(newWin.name);
			newWin.destroyWhenClose = true;
		}
		else {
			console.log(newWin.name + " is open already.");
			return false;
		}
	}

	if(newWin.openPending) {
		newWin.openPending = false;
		console.log("This window is already open:" + name);
		return false;
	}
	
	newWin.prepareForOpen();
	newWin.openPending = true;
	newWin.initData = initData;
	newWin.onClose = onClose;
	newWin.callOnBeforeOpen(initData);

	this.targetShape = newWin;
	this.setPointerEventTarget(newWin);

	console.log("openWindow: set targetShape:" + this.targetShape.name);

	if(newWin.isUINormalWindow) {
		return this.openNormalWindow(newWin, closeCurrent);
	}
	else {
		return this.openPopupWindow(newWin, closeCurrent);
	}
}

UIWindowManager.prototype.openPopupWindow = function(newWin, closeCurrent) {
	if(closeCurrent) {
		this.closeCurrentWindow(0, true);
	}

	var wm = this;
	var curWin = this.getCurrentFrame();

	function openPopupWindow() {
		if(!newWin.app)  {
			console.log("may be exited preview mode");
			return;
		}
		newWin.show();
		curWin.setPopupWindow(newWin);
		wm.postRedraw();
		newWin.callOnOpen(newWin.initData);
	}

	if(curWin) {
		curWin.callOnSwitchToBack(true);
		if(newWin.isAnimationEnabled()) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(newWin.getAnimationName(true), newWin.getAnimationDuration(true)); 
			var backendCanvas = UIFrames.preparseBackendCanvas(curWin, newWin);
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, openPopupWindow);
			animation.setRectOfFront(newWin.x, newWin.y, newWin.w, newWin.h);
			animation.run();
		}
		else {
			openPopupWindow();
		}
	}

	return true;
}

UIWindowManager.prototype.openNormalWindow = function(newWin, closeCurrent) {
	if(closeCurrent) {
		this.closeCurrentWindow(0, true);
	}

	var wm = this;
	var index = 0;

	var curWin = this.getCurrentFrame();
	function closeAndOpenWindow() {
		if(!newWin.app)  {
			console.log("may be exited preview mode");
			return;
		}

		index = wm.getFrameIndex(newWin);
		wm.showFrame(index);
		wm.history.push(index);
		curWin = wm.getCurrentFrame();
		wm.postRedraw();
		newWin.callOnOpen(newWin.initData);

		return;
	}

	if(curWin) {
		curWin.callOnSwitchToBack();
		if(newWin.isAnimationEnabled()) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(newWin.getAnimationName(true), newWin.getAnimationDuration(true)); 
			var backendCanvas = UIFrames.preparseBackendCanvas(curWin, newWin);
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, closeAndOpenWindow);
			animation.run();
		}
		else {
			closeAndOpenWindow();
		}
	}
	else {
		closeAndOpenWindow();
	}
	
	return true;
}

UIWindowManager.prototype.getCurrentWindow = function() {
	var curWin = this.getCurrentFrame();
	if(!curWin) {
		return null;
	}

	var childWin = curWin.getPopupWindow();

	return childWin ? childWin : curWin; 
}

UIWindowManager.prototype.backToHomeWin = function() {
	var history = this.history;
	var n = history.length - 1;
	var curWin = this.getCurrentWindow();

	if(!n) {
		if(curWin.isUIPopupWindow) {
			this.closeCurrentWindow(0);
		}

		return;
	}

	if(n === 1) {
		if(curWin.isUIPopupWindow) {
			this.closeCurrentWindow(0, true);
			this.closeCurrentWindow(0);
		}
		else {
			this.closeCurrentWindow(0);
		}

		return;
	}
	
	var mainWinIndex = history[0];
	var lastWin = this.getFrame(mainWinIndex);
	
	if(curWin.isAnimationEnabled()) {
		var p = this.getPositionInScreen();
		var animation = AnimationFactory.create(curWin.getAnimationName(false), curWin.getAnimationDuration(false)); 
		var backendCanvas = UIFrames.preparseBackendCanvas(lastWin, curWin);
		animation.setScale(this.getRealScale());
		animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, function() {});
		animation.run();
	}

	for(var i = 0; i < n; i++) {
		this.closeCurrentWindow(0, true);
	}

	return;
}

UIWindowManager.prototype.closeCurrentWindow = function(retInfo, syncClose) {
	var curWin = this.getCurrentWindow();

	if(!curWin || curWin.mode === Shape.MODE_EDITING) {
		return  false;
	}
	
	if(curWin.isUINormalWindow) {
		return this.closeCurrentNormalWindow(curWin, retInfo, syncClose);
	} 
	else {
		return this.closeCurrentPopupWindow(curWin, retInfo, syncClose);
	}
}

UIWindowManager.prototype.closeCurrentPopupWindow = function(popupWin, retInfo, syncClose) {
	var wm = this;
	var curWin = this.getCurrentFrame();

	if(curWin) {
		function closePopupWindow() {
			if(!popupWin.app)  {
				console.log("may be exited preview mode");
				return;
			}
			curWin.removePopupWindow(popupWin);
			curWin.callOnSwitchToFront(true);
			wm.postRedraw();

			popupWin.callOnClose(retInfo);
		}

		if(curWin === popupWin) {
			syncClose = true;
		}
		if(popupWin.isAnimationEnabled() && !syncClose) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(popupWin.getAnimationName(false), popupWin.getAnimationDuration(false)); 

			curWin.removePopupWindow(popupWin);
			var backendCanvas = UIFrames.preparseBackendCanvas(curWin, popupWin);
			curWin.setPopupWindow(popupWin);
		
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, closePopupWindow);
			animation.setRectOfFront(popupWin.x, popupWin.y, popupWin.w, popupWin.h);
			animation.run();
		}
		else {
			closePopupWindow();
		}
	}

	return true;
}

UIWindowManager.prototype.closeAll = function() {
	var wins = [];

	for(var i = 0; i < this.history.length; i++) {
		var index = this.history[i];
		var win = this.getFrame(index);
		for(var iter = win; iter; iter = iter.popupWindow) {
			wins.push(iter);
		}
	}

	for(var i = wins.length-1; i >= 0; i--) {
		var win = wins[i];
		win.popupWindow = null;
		win.targetShape = null;
		win.callOnClose({});
	}

	this.history = [];

	return;
}

UIWindowManager.prototype.closeCurrentNormalWindow = function(curWin, retInfo, syncClose) {
	var wm = this;
	var lastWin = null;

	if(this.history.length < 2) {
		if(syncClose && this.history.length) {
			wm.history.remove(wm.current);
			curWin.callOnClose(retInfo);
		}

		return false;
	}

	lastWinIndex = this.history[this.history.length-2];
	lastWin = this.getFrame(lastWinIndex);

	function showLastWindow() {
		if(!lastWin.app)  {
			console.log("may be exited preview mode");
			return;
		}
		wm.showFrame(lastWinIndex);
		lastWin.callOnSwitchToFront();
		
		wm.postRedraw();
		curWin.callOnClose(retInfo);

		return;
	}
	
	wm.history.remove(wm.current);
	if(syncClose) {
		showLastWindow();
	}
	else if(curWin.isAnimationEnabled()) {
		var p = this.getPositionInScreen();
		var animation = AnimationFactory.create(curWin.getAnimationName(false), curWin.getAnimationDuration(false)); 
		var backendCanvas = UIFrames.preparseBackendCanvas(lastWin, curWin);
		animation.setScale(this.getRealScale());
		animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, showLastWindow);
		animation.run();
	}
	else {
		setTimeout(showLastWindow, 10);
	}

	return;
}

UIWindowManager.prototype.isWindowOpen = function(win) {
	for(var i = 0; i < this.history.length; i++) {
		var index = this.history[i];
		var iter = this.children[index];
		for(var w = iter; w != null; w = w.popupWindow) {
			if(w === win) return true;
		}
	}

	return false;
}

UIWindowManager.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIWindow) {
		if(this.mode == Shape.MODE_EDITING) {
			var win = this.findChildByName(shape.name);
			if(win) {
				shape.name = shape.name + this.children.length;
			}
		}

		return true;
	}

	return false;
}

UIWindowManager.prototype.onChildrenChanged = function() {
}

UIWindowManager.prototype.afterChildAppended = function(shape) {
	if(this.mode !== Shape.MODE_RUNNING && !this.isUnpacking) {
		var index = this.getFrameIndex(shape);
		this.showFrame(index);
	}

	this.onChildrenChanged();

	return;
}

UIWindowManager.prototype.onChildRemoved = function(shape) {
	this.onChildrenChanged();

	return;
}

UIWindowManager.prototype.scaleForDensity = function(sizeScale, lcdDensity, recuresive) {
	if(!sizeScale || sizeScale === 1) {
		return;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];

		if(!iter.lcddensity || iter.lcddensity === "all") {
			if(iter.pendingLoadChildren) {
				iter.scaleInfo = {};
				iter.scaleInfo.sizeScale = sizeScale;
				iter.scaleInfo.lcdDensity = lcdDensity;
			}
			else {
				iter.scaleForDensity(sizeScale, lcdDensity, recuresive);
			}
		}
	}

	return;
}

UIWindowManager.prototype.resize = function(w, h) {
	var x = 0;
	var y = 0;
	var fixWidth = this.screenScaleMode === "fix-width";
	var fixHeight = this.screenScaleMode === "fix-height";
	var fixResolution = this.screenScaleMode === "fix-resolution";
	var isInDevice = this.parentShape != null;

	if(this.mode === Shape.MODE_RUNNING && (fixWidth || fixHeight || fixResolution) && !isInDevice) {
		var canvas = this.view.getCanvas();

		var screenWidth = canvas.width;
		var screenHeight = canvas.height;
		var designWidth = this.designWidth;
		var designHeight = this.designHeight;
		var canvasStyleSizeSupported = true;//!(isWeiBo() || isPhoneGap());
		var sizeIsRight = (screenWidth > screenHeight && designWidth > designHeight) 
			|| (screenWidth < screenHeight && designWidth < designHeight);

		canvas.style.width = screenWidth + "px";
		canvas.style.height = screenHeight + "px";
		if(canvasStyleSizeSupported && sizeIsRight) {

			if(fixWidth) {
				var scale = designWidth/screenWidth;
				canvas.width = designWidth;
				canvas.height = screenHeight * scale;
				w = canvas.width;
				h = canvas.height;
			}
			else if(fixHeight) {
				var scale = designHeight/screenHeight;
				canvas.height = designHeight;
				canvas.width = screenWidth * scale;
				w = canvas.width;
				h = canvas.height;
			}
			else {
				var scaleW = designWidth/screenWidth;
				var scaleH = designHeight/screenHeight;
				var scale = Math.max(scaleW, scaleH);
				if(Math.abs(scaleW - scaleH) < 0.10) {
					canvas.width = designWidth;
					canvas.height = designHeight;
					
					x = 0;
					y = 0;
					w = canvas.width;
					h = canvas.height;
				}
				else {
					canvas.width = screenWidth * scale;
					canvas.height = screenHeight * scale;
					
					x = (canvas.width - designWidth)>>1; 
					y = (canvas.height - designHeight)>>1;
					w = designWidth;
					h = designHeight;
				}
			}
			var xInputScale = canvas.width/screenWidth;
			var yInputScale = canvas.height/screenHeight;
			WWindowManager.setInputScale(xInputScale, yInputScale);
		}
		else {
			canvas.width = screenWidth;
			canvas.height = screenHeight;
			WWindowManager.setInputScale(1, 1);
			w = canvas.width;
			h = canvas.height;
		}

		var vp = cantkGetViewPort();	
		this.app.onCanvasSized(canvas.width, canvas.height);

		console.log("Canvas Size: w =" + canvas.width + " h=" + canvas.height);
		console.log("ViewPort Size: w =" + vp.width + " h=" + vp.height);
		console.log("Canvas Style Size: w =" + canvas.style.width + " h=" + canvas.style.height);
	}

	this.lastWin = null;
	this.setLeftTop(x, y);
	this.setSizeLimit(w, h, w, h);
	UIElement.prototype.resize.call(this, w, h);

	return;
}

UIWindowManager.prototype.setDeviceConfig = function(deviceConfig) {
	var screenScaleMode = this.screenScaleMode;
	if(screenScaleMode === "fix-resolution" || screenScaleMode === "fix-width" || screenScaleMode === "fix-height") {
		this.oldConfig = this.deviceConfig;

		return;
	}

	var oldConfig = this.deviceConfig;
	
	this.oldConfig = this.deviceConfig;
	this.deviceConfig = deviceConfig;

	if(oldConfig && deviceConfig) {
		if(oldConfig.lcdDensity != deviceConfig.lcdDensity) {
			var sizeScale = this.getSizeScale(oldConfig.lcdDensity, deviceConfig.lcdDensity);
			this.scaleForDensity(sizeScale, deviceConfig.lcdDensity, true);
		}
		this.notifyDeviceConfigChanged(oldConfig, deviceConfig);
		console.log("call this.notifyDeviceConfigChanged: " + this.type);
	}

	console.log("setDeviceConfig platform:" + deviceConfig.platform);
	return;
}

UIWindowManager.prototype.getDeviceConfig = function() {
	if(this.deviceConfig) {
		return this.deviceConfig;
	}
	else {
		var device = this.getDevice();
		if(device) {
			return device.config;
		}
	}

	return null;
}

UIWindowManager.prototype.paintChildren = function(canvas) {
	if(this.mode != Shape.MODE_EDITING) {
		if(this.forcePortrait && this.w > this.h) {
			var image = this.getHtmlImageByType("force-portrait-tips");	

			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);	
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, this.w, this.h);

			return;
		}
		else if(this.forceLandscape && this.w < this.h) {
			var image = this.getHtmlImageByType("force-landscape-tips");	
			
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);	
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, this.w, this.h);

			return;
		}
	}

	var child = this.getCurrentFrame();
	if(child) {
		if(child.isUIDialog) {
			canvas.fillStyle = "white";
			canvas.fillRect(0, 0, this.w, this.h);
		}

		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}

	return;
}

UIWindowManager.prototype.paintSelf = function(canvas) {
	canvas.save();
	this.translate(canvas);
	this.paintSelfOnly(canvas);

	this.beforePaintChildren(canvas);
	this.paintChildren(canvas);
	this.afterPaintChildren(canvas);
	canvas.restore();

	return;
}

UIWindowManager.prototype.paintSelfOnly = function(canvas) {
	if(this.mode === Shape.MODE_EDITING) {
		this.setThisAsCurrentWindowManager();
		canvas.fillStyle = "white";
		canvas.fillRect(0, 0, this.w, this.h);

		UIWindowManager.updateWindowThumbView(this.current);
	}

	return;
}

UIWindowManager.prototype.isDeviceDirectionOK = function() {
	if(this.mode === Shape.MODE_EDITING) {
		return true;
	}

	if((this.forcePortrait && this.w > this.h)
		|| (this.forceLandscape && this.w < this.h)) {
		console.log("Device Direction Incorrect.");
		return false;
	}

	return true;
}

UIWindowManager.prototype.relayout = function() {
	if(this.isDeviceDirectionOK()) {
		UIElement.prototype.relayout.call(this);
	}
	else {
		console.log("isDeviceDirectionNotOK ignore relayout");
	}

	return this;
}

UIWindowManager.prototype.relayoutChildren = function() {
	if(!this.isDeviceDirectionOK()) {
		console.log("isDeviceDirectionNotOK ignore relayout");

		return;
	}

	var curWin = this.getCurrentFrame();

	if(this.mode === Shape.MODE_EDITING) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			iter.relayout();
		}
	}
	else {
		if(curWin) {
			curWin.relayout();
			
			var childWin = curWin.getPopupWindow();
			if(childWin) {
				childWin.relayout();
			}
		}
	}

	return;
}

UIWindowManager.prototype.onKeyDown= function(code) {
	var win = this.getCurrentWindow();

	return win && win.onKeyDown(code);
}

UIWindowManager.prototype.onKeyUp= function(code) {
	var win = this.getCurrentWindow();

	return win && win.onKeyUp(code);
}

UIWindowManager.prototype.setSoundEffectURLs = function(soundEffectURLs) {
	this.soundEffectURLs = soundEffectURLs;

	return this;
}

UIWindowManager.prototype.getSoundEffectURLs = function() {
	return this.soundEffectURLs;
}

UIWindowManager.prototype.getSoundEffectNames = function() {
	if(!this.soundEffectURLs) {
		return [];
	}

	var names = this.soundEffectURLs.split("\n");
	for(var i = 0; i < names.length; i++) {
		names[i] = decodeURI(basename(names[i]));
	}

	return names;
}

UIWindowManager.prototype.getSoundEnable = function() {
	return this.soundMusicsEnalbe || this.soundEffectsEnalbe;
}

UIWindowManager.prototype.setSoundEnable = function(enable) {
	this.setSoundEffectsEnable(enable);
	this.setSoundMusicsEnable(enable);

	return this;
}

UIWindowManager.prototype.setSoundEffectsEnable = function(enable) {
	this.soundEffectsEnalbe = enable;

	return this;
}

UIWindowManager.prototype.setSoundMusicsEnable = function(enable) {
	if(this.soundMusicsEnalbe !== enable) {
		this.soundMusicsEnalbe = enable;
		if(enable) {
			this.playSoundMusic();
		}
		else {
			this.stopSoundMusic();
		}
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffects = function() {
	UIWindowManager.soundEffects = {};

	if(!this.soundEffectURLs) {
		return;
	}

	if(CantkRT.isCantkRTCordova()) {
		console.log("Native Audio supported: load native Audio")
		this.loadSoundEffectsNative();
	}
	else if(isWebAudioSupported()) {
		console.log("WebAudio supported: load Web Audio")
		this.loadSoundEffectsWebAudio();
	}
	else {
		console.log("WebAudio not supported: load HTML5 Audio")
		this.loadSoundEffectsHtml5Audio();
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsHtml5Audio = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];

		ResLoader.loadAudio(iter, function(audio) {
			var info = {audio:audio};
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
			var name = decodeURI(basename(audio.src));
			UIWindowManager.soundEffects[name] = info;
        });
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsNative = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];

		CantkRT.createSoundEffect(iter, function(audio) {
			var info = {audio:audio};
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
			var name = decodeURI(basename(audio.src));
			UIWindowManager.soundEffects[name] = info;
			console.log("loadSoundEffectsNative success.");
		}, function() {
			console.log("loadSoundEffectsNative fail.");
		});
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsWebAudio = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		var config = {src: [iter], autoplay: false, loop: false, volume: 0.8};
		var name = decodeURI(basename(iter));
		var info = {audio:new Howl(config), playing: false};

        UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
		UIWindowManager.soundEffects[name] = info;
	}

	return this;
}

UIWindowManager.prototype.stopSoundEffect = function(name) {
	for(var key in UIWindowManager.soundEffects) {
		if(name === key || !name) {
			var info = UIWindowManager.soundEffects[key];
			if(info && info.audio) {
				if(info.audio.stop) {
					info.audio.stop();
				}
				else {
					info.audio.pause();
				}
				info.playing = false;
			}
		}
	}

	return this;
}

UIWindowManager.prototype.stopAllSound = function() {
	try {
		this.stopSoundMusic().stopSoundEffect();
	}catch(e) {
		console.log(e.message);
	}

	return this;
}

UIWindowManager.soundMusicVolume = 0.8
UIWindowManager.soundEffectVolume = 0.8;

UIWindowManager.prototype.setSoundEffectVolume = function(volume) {
	UIWindowManager.soundEffectVolume = volume;

	return this;
}

UIWindowManager.prototype.setSoundMusicVolume = function(volume) {
	UIWindowManager.soundMusicVolume = volume;
	
	var info = this.lastAudioInfo;
	if(info && info.audio) {
		UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
	}


	return this;
}

UIWindowManager.setVolumeOfAudio = function(audio, volume) {
	if(typeof(audio.volume) === "function") {
		audio.volume(volume);
	}
	else {
		audio.volume = volume;
	}
}

UIWindowManager.prototype.playSoundEffect = function(name, onDone) {
	if(!this.soundEffectsEnalbe) {
		console.log("this.soundEffectsEnalbe is disable ");
		return this;
	}

	var info = UIWindowManager.soundEffects[name];
	if(!info || !info.audio) {
		console.log("not found: " + name);
		return this;
	}

	if(onDone) {
		if(info.audio.once) {
			info.audio.once("end", onDone);
		}
		else {
			info.audio.addEventListener('ended', function (e) {
				onDone();
			});
		}
	}

	UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
	info.audio.play();
	console.log("playSoundEffect:" + name);

	return this;
}

//////////////////////////////////////////////////////////////////////

UIWindowManager.prototype.onMultiTouch = function(action, points, event) {
	var win = this.getCurrentWindow();
	if(win) {
		var ox = this.left + win.left;
		var oy = this.top + win.top;

		for(var i = 0; i < points.length; i++) {
			var p = points[i];
			p.x -= ox;
			p.y -= oy;
		}

		win.onMultiTouch(action, points, event);
	}
}

UIWindowManager.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(this.autoPlayPending) {
		this.playSoundMusic();
		this.autoPlayPending = false;
	}

	if(!beforeChild || this.popupWindow || !this.pointerDown) {
		return;
	}

	return this.callOnPointerDownHandler(point);
}

UIWindowManager.prototype.setSoundMusicURLs = function(soundMusicURLs) {
	this.soundMusicURLs = soundMusicURLs;

	return this;
}

UIWindowManager.prototype.getSoundMusicURLs = function() {
	return this.soundMusicURLs;
}

UIWindowManager.prototype.loadSoundMusicHTML5 = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");
	
    this.setSoundMusicsEnable(autoPlay);

	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		ResLoader.loadAudio(iter, function(audio) {
			var info = {audio:audio};
			var name = decodeURI(basename(audio.src));
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
			
			if(loop) {	
				audio.loop = "loop";
			}
			if(autoPlay) {
				audio.play();
				autoPlay = false;
			}
			me.autoPlayPending = true;
			UIWindowManager.soundMusic[name] = info;
        });
	}

	return;
}

UIWindowManager.prototype.loadSoundMusicWebAudio = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");
	
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		var config = {src: [iter], autoplay: autoPlay, loop:loop, volume: 0.8};
		var name = decodeURI(basename(iter));
		var info = {audio:new Howl(config), playing: autoPlay};

        UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
		if(autoPlay) {
			this.lastAudioInfo = info;
		}
		autoPlay = false;
		UIWindowManager.soundMusic[name] = info;
	}

	return;
}

UIWindowManager.prototype.loadSoundMusicNative = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");
	
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		CantkRT.createSoundMusic(iter, function(audio) {
			var info = {audio:audio};
			var name = decodeURI(basename(audio.src));
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
			if(loop) {	
				audio.loop = "loop";
			}
			if(autoPlay) {
				audio.play();
				this.lastAudioInfo = info;
				autoPlay = false;
			}
			UIWindowManager.soundMusic[name] = info;
        });
	}

	return;
}

UIWindowManager.prototype.loadSoundMusic = function() {
	UIWindowManager.soundMusic = {};
	
    if(!this.soundMusicURLs) {
		return;
	}

	if(CantkRT.isCantkRTCordova()) {
		console.log("Native Audio supported: load native Audio")
		this.loadSoundMusicNative();
	}
	else if(isWebAudioSupported()) {
		console.log("WebAudio supported: load Web Audio")
		this.loadSoundMusicWebAudio();
	}
	else {
		this.loadSoundMusicHTML5();
	}

	this.soundMusicsEnalbe = this.soundMusicAutoPlay;
	this.soundMusicsPlaying = this.soundMusicAutoPlay;

	return this;
}

UIWindowManager.prototype.isSoundMusicPlaying = function(name) {
	var playing = false;
	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				if(info.playing) {
					playing = true;
					break;
				}
			}
		}
	}

	return playing;
}

/*
UIWindowManager.prototype.getSceneIds = function() {
    var ids = [];
    this.children.forEach(function(scene) {
        ids.push(scene.Id);
    });
    
    return ids;
}

UIWindowManager.prototype.getSceneJsonById = function(id) {
    var scenes = this.children;
    for(var i = 0; i < scenes.length; i++) {
        var scene = scenes[i];
        if(id === scene.id) {
            return scene.toJson();
        }  
    }
    return null;
}
*/

UIWindowManager.prototype.stopSoundMusic = function(name) {
	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				info.audio.pause();
				info.playing = false;
				this.soundMusicsPlaying = false;
			}
		}
	}

	return this;
}

UIWindowManager.prototype.playSoundMusic = function(name, onDone) {
	if(this.soundMusicsPlaying) {
		this.stopSoundMusic();
	}

	if(!this.soundMusicsEnalbe) {
		console.log("this.soundMusicsEnalbe is disable ");
		return this;
	}

	if(!name && this.lastAudioInfo && this.lastAudioInfo.audio) {
		var info = this.lastAudioInfo;

		UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
		info.audio.play();
		info.playing = true;
		this.soundMusicsPlaying = true;

		return this;
	}

	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				if(onDone) {
				    if(info.audio.once) {
                    	info.audio.once("end", onDone);
                    } else {
                        info.audio.addEventListener("ended", function(e) {
                            onDone();
                        });
                    }
				}
				UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
				info.audio.play();
				info.playing = true;
				this.lastAudioInfo = info;
				this.soundMusicsPlaying = true;

				console.log("UIWindowManager.prototype.playSoundMusic");
				break;
			}
		}
	}

	console.log("playSoundMusic:" + name);

	return this;
}

UIWindowManager.prototype.getSoundMusicNames = function() {
	if(!this.soundMusicURLs) {
		return [];
	}

	var names = this.soundMusicURLs.split("\n");
	for(var i = 0; i < names.length; i++) {
		names[i] = basename(names[i]);
	}

	return names;
}

function UIWindowManagerCreator() {
	var args = ["ui-window-manager", "ui-window-manager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWindowManager();

		return g.initUIWindowManager(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIWindowManagerCreator());

/*
 * File:   ui-image-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageButton() {
	return;
}

UIImageButton.prototype = new UIElement();
UIImageButton.prototype.isUIImageButton = true;

UIImageButton.prototype.initUIImageButton = function(type, w, h) {
	this.initUIElement(type, w, h);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIImageButton.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIImageButtonCreator(w, h) {
	var args = ["ui-image-button", "ui-image-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageButton();
		return g.initUIImageButton(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageButtonCreator(120, 90));

/*
 * File:   ui-image-normal-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Normal Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageNormalView() {
	return;
}

UIImageNormalView.prototype = new UIImageView();
UIImageNormalView.prototype.isUIImageNormalView = true;

UIImageNormalView.prototype.initUIImageNormalView = function(type, w, h) {
	this.userImages = [];
	this.cachedImages = [];

	this.initUIElement(type);
	this.initUIImageView(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.current = 0;
	this.offsetX = 0;
	this.offsetY = 0;
	this.imageScale = 1;

	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator();
	this.errorImage = UIImageView.createImage("drawapp8/images/common/failed.png", null);
	this.loadingImage = UIImageView.createImage("drawapp8/images/common/loading.png", null);
	
	return this;
}

UIImageNormalView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.velocityTracker.clear();

	return;
}

UIImageNormalView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.offsetX = this.offsetX + this.getMoveDeltaX();
	this.offsetY = this.offsetY + this.getMoveDeltaY();

	this.addMovementForVelocityTracker();

	return ;
}

UIImageNormalView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().x;
}

UIImageNormalView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	var velocity = this.velocityTracker.getVelocity();
	var xa = this.w;
	var ya = this.h;
	var xt = velocity.x/xa;
	var yt = velocity.y/ya;
	var t = Math.max(xt, yt);

	var xd = 0.5 * xa * xt * xt;
	var yd = 0.5 * ya * yt * yt;

	xd = velocity.x > 0 ? xd : -xd;
	yd = velocity.y > 0 ? yd : -yd;
	this.scrollTo(xd, yd, t * 1000);

	return true;
}

UIImageNormalView.prototype.scrollTo = function(xd, yd, t) {
	var imageview = this;
	var duration = Math.max(500, Math.min(t, 1000));
	
	var startTime = (new Date()).getTime();
	var offsetXStart = this.offsetX;
	var offsetYStart = this.offsetY;
	var currentImage = this.cachedImages[this.current];

	var dx = Math.min(currentImage.width/2, xd);
	var dy = Math.min(currentImage.height/2, yd);

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;
		
		if(percent < 1) {
			imageview.offsetX = offsetXStart + percent * dx;
			imageview.offsetY = offsetYStart + percent * dy;

			setTimeout(animStep, 10);
		}
		else {
			delete startTime;
			imageview.offsetX = offsetXStart + dx;
			imageview.offsetY = offsetYStart + dy;
		}

		delete now;
		imageview.postRedraw();
	}

	animStep();

	return;
}

UIImageNormalView.prototype.switchTo = function(offset) {
	var current = this.current;
	var n = this.userImages.length;
	if(offset > 0) {
		if((this.current+offset) < n) {
			current = this.current + offset;	
		}
	}
	else {
		if((this.current+offset) > 0) {
			current = this.current + offset;
		}
	}
}

UIImageNormalView.prototype.calcImageDefaultOffset = function() {
	var index = this.current;
	if(index < 0 || index >= this.cachedImages.length) {
		return;
	}

	var image = this.cachedImages[index];
	if(!image || !image.width) {
		return;
	}

	this.imageScale = Math.min(this.w/image.width, this.h/image.height);
	
	var w = this.imageScale * image.width;
	var h = this.imageScale * image.height;

	this.offsetX = (this.w-w)/2;
	this.offsetY = (this.h-h)/2;

	return;
}

UIImageNormalView.prototype.setCurrentImage = function(index) {
	if(index < 0 || index >= this.userImages.length) {
		return;
	}

	this.current = index;
	this.calcImageDefaultOffset();

	return;
}

UIImageNormalView.prototype.onDoubleClick = function(point, beforeChild) {
	this.calcImageDefaultOffset();
	return this.callOnDoubleClickHandler(point);
}

UIImageNormalView.prototype.paintSelfOnly = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currentImage = this.cachedImages[this.current];
	if(!currentImage || !currentImage.width) {
		return;
	}

	this.imageScale = 1;
	canvas.save();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();

	canvas.translate(this.offsetX, this.offsetY);
	canvas.scale(this.imageScale, this.imageScale);
	canvas.drawImage(currentImage, 0, 0);
	canvas.restore();

	return;
}

function UIUIImageNormalViewCreator() {
	var args = ["ui-image-normal-view", "ui-image-normal-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageNormalView();

		return g.initUIImageNormalView(this.type, 300, 300);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIUIImageNormalViewCreator());

/*
 * File:   ui-image-slide-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Slide View.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */
function UIImageSlideView() {
	return;
}

UIImageSlideView.prototype = new UIImageView();
UIImageSlideView.prototype.isUIImageSlideView = true;

UIImageSlideView.prototype.saveProps = ["showIndicator", "frameDuration"];
UIImageSlideView.prototype.initUIImageSlideView = function(type, w, h) {
	this.initUIElement(type);	
	this.initUIImageView(w, h);
	
	this.offset = 0;
	this.addEventNames(["onChanged"]);
	this.setTextType(Shape.TEXT_NONE);
	imageSlideViewInitCustomProp(this);

	return this;
}

UIImageSlideView.prototype.onInit = function() {
	var slideview = this;

	this.currFrame = 0;

	function nextFrame() {
		if(slideview.mode != Shape.MODE_EDITING && slideview.isVisible()) {
			var duration = slideview.getFrameDuration();
			
			slideview.postRedraw();
			setTimeout(nextFrame, duration);

			var newFrame = slideview.currFrame + 1;
			slideview.animScrollTo(-slideview.w, newFrame);
		}
	}

	var duration = this.getFrameDuration();
	setTimeout(nextFrame, duration);

	return;
}

UIImageSlideView.prototype.getFrameDuration = function() {
	return this.frameDuration ? this.frameDuration : 5000;
}

UIImageSlideView.prototype.setFrameDuration = function(frameDuration) {
	this.frameDuration = Math.max(1000, Math.min(frameDuration, 300000));

	return;
}

UIImageSlideView.prototype.setShowIndicator = function(value) {
	this.showIndicator = value;

	return;
}

UIImageSlideView.prototype.getFrameIndicatorParams = function() {
	var n = this.userImages.length;
	var itemSize = Math.min((0.5 * this.w)/n, 40);
	var indicatorWidth = itemSize * n;

	var dx = (this.w - indicatorWidth)/2;
	var dy = 0.8 * this.h;

	return {offsetX:dx, offsetY:dy, itemSize:itemSize, n:n};
}

UIImageSlideView.prototype.getCurrent = function() {
	return this.currFrame;
}

UIImageSlideView.prototype.getCurrentImage = function() {
	var image = this.cachedImages[this.currFrame];

	return image;
}

UIImageSlideView.prototype.setValue = function(src) {
	for(var i = 0; i < this.cachedImages.length; i++) {
		var iter = this.cachedImages[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			return this.setCurrent(i);	
		}
	}

	return this;
}

UIImageSlideView.prototype.setCurrent = function(currFrame) {
	this.setCurrentFrame(currFrame);

	return this;
}

UIImageSlideView.prototype.setCurrentFrame = function(currFrame) {
	this.offset = 0;
	this.currFrame = (currFrame + this.userImages.length)%this.userImages.length;
	this.postRedraw();

	this.callOnChangedHandler(this.currFrame);

	return this;
}

UIImageSlideView.prototype.animScrollTo = function(range, newFrame) {
	var duration = 1000;
	var slideview = this;
	var startOffset = this.offset;
	var startTime = (new Date()).getTime();
	var interpolator = new DecelerateInterpolator(2);

	if(slideview.animating) {
		return;
	}

	slideview.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);
		
		if(timePercent < 1) {
			slideview.offset = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			slideview.offset = 0;
			slideview.setCurrentFrame(newFrame);
			delete startTime;
			delete interpolator;
			delete slideview.animating;
		}

		delete now;
		slideview.postRedraw();
	}

	animStep();

	return;
}

UIImageSlideView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	if(!this.velocityTracker) {
		this.velocityTracker = new VelocityTracker();
	}
	this.velocityTracker.clear();

	return true;
}

UIImageSlideView.prototype.isEventHandledByChild = function() {
	var status = UIElement.lastEvent.status;
	return status & UIElement.EVENT_HSCROLL_HANDLED;
}

UIImageSlideView.prototype.setEventHandled = function() {
	this.setLastEventStatus(UIElement.EVENT_HSCROLL_HANDLED);
	
	return this;
}

UIImageSlideView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.currFrame;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	this.offset = dx;
	this.addMovementForVelocityTracker();

	return;
}

UIImageSlideView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	
	var frames = this.getFrames();
	var currFrame = this.currFrame;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var range = 0;
	var offsetX = this.offset;
	var newFrame = this.currFrame;
	var velocity = this.velocityTracker.getVelocity().x;
	var distance = offsetX + velocity;

	//console.log("offsetX: " + offsetX + "velocity:" + velocity + " distance:" + distance );
	if(Math.abs(offsetX) < 10) {
		this.offset = 0;

		return;
	}

	if(Math.abs(distance) > this.w/3) {
		if(offsetX > 0) {
			range = this.w - offsetX;	
			newFrame = this.currFrame - 1;
		}
		else {
			range = -this.w - offsetX;
			newFrame = this.currFrame + 1;
		}
	}
	else {
		range = -offsetX;
	}

	this.animScrollTo(range, newFrame);

	return;
}

UIImageSlideView.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	var params = this.getFrameIndicatorParams();

	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;
	var n = params.n;
	var x = point.x;
	var y = point.y;

	if(y < dy || y > (dy + itemSize) || x < dx || x > (dx + n * itemSize)) {
		return;
	}

	for(var i = 0; i < n; i++) {
		if(x > dx && x < (dx + itemSize)) {
			this.setCurrentFrame(i);	
			break;
		}

		dx += itemSize;
	}

	return;
}

UIImageSlideView.prototype.drawFrameIndicator = function(canvas, currFrame) {
	var params = this.getFrameIndicatorParams();

	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;
	var n = params.n;

	dx += itemSize/2;
	dy += itemSize/2;

	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;

	for(var i = 0; i < n; i++) {
		canvas.beginPath();
		canvas.arc(dx, dy, 10, 0, Math.PI * 2);
		dx += itemSize;
	

		if(i === currFrame) {
			canvas.save();
			canvas.shadowColor = this.style.lineColor;
			canvas.shadowBlur = 5;
			canvas.shadowOffsetX = 0;
			canvas.shadowOffsetY = 0;

			canvas.fill();
			canvas.stroke();
			canvas.restore();
		}
		else {
			canvas.fill();
		}
	}

	return;
}

UIImageSlideView.prototype.getPrevFrame = function() {
	var index = (this.currFrame - 1 + this.userImages.length)%this.userImages.length;

	return this.cachedImages[index];
}

UIImageSlideView.prototype.getFrames = function() {
	return this.userImages.length;
}

UIImageSlideView.prototype.getNextFrame = function() {
	var index = (this.currFrame + 1) % this.userImages.length;

	return this.cachedImages[index];
}

UIImageSlideView.prototype.drawOneImage = function(canvas, image) {
	var fillColor = this.style.fillColor;

	if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
		canvas.drawImage(image, 0, 0, image.width, image.height, 0, 0, this.w, this.h);
	}
	else if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO) {
		var rect = {x:0, y:0};
		rect.w = image.width;
		rect.h = image.height;

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO, 0, 0, this.w, this.h, rect);
	}
	else {
		UIImageView.drawImageAtCenter(canvas, image, 0, 0, this.w, this.h, true, fillColor);
	}

	return;
}

UIImageSlideView.prototype.drawImage = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currFrame = (this.currFrame ? this.currFrame : 0)%this.userImages.length;
	var image = this.cachedImages[currFrame];

	if(image && image.width > 0) {
		canvas.save();
		canvas.rect(0, 0, this.w, this.h);
		canvas.clip();
		canvas.beginPath();

		canvas.translate(this.offset, 0);

		this.drawOneImage(canvas, image);

		var offset = Math.abs(this.offset);
		if(this.offset < 0) {
			image = this.getNextFrame();
			if(image && image.width > 0) {
				canvas.translate(this.w, 0);
				this.drawOneImage(canvas, image);
			}
		}
		else if(offset > 0) {
			image = this.getPrevFrame();
			if(image && image.width > 0) {
				canvas.translate(-this.w, 0);
				this.drawOneImage(canvas, image);
			}
		}
		canvas.restore();

		if(this.showIndicator) {
			this.drawFrameIndicator(canvas, currFrame);
		}
	}

	return;
}


UIImageSlideView.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage;
}

function UIImageSlideViewCreator() {
	var args = [ "ui-image-slide-view", "ui-image-slide-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageSlideView();
		return g.initUIImageSlideView(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageSlideViewCreator());

function cantkRegisterUIElements() {
	return;
}

////////////////////////////////////empty functions///////////////////////}-{
UIWindowManager.prototype.setThisAsCurrentWindowManager = function() {
}

UIWindowManager.updateWindowThumbView = function(index) {
}

UIWindowManager.drawWindowThumbView = function(canvas, index) {
}

UIElement.prototype.setsd = function(data) {
	return this;
}

UIElement.prototype.sendsd = function(str) {
	return this;
}
/*
* Matrix2D
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * @module EaselJS
 */

// namespace:
// this.createjs = this.createjs||{};

this.Matrix2D = (function() {
	"use strict";


// constructor:
	/**
	 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
	 *
	 * This matrix can be visualized as:
	 *
	 * 	[ a  c  tx
	 * 	  b  d  ty
	 * 	  0  0  1  ]
	 *
	 * Note the locations of b and c.
	 *
	 * @class Matrix2D
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @constructor
	 **/
	function Matrix2D(a, b, c, d, tx, ty) {
		this.setValues(a,b,c,d,tx,ty);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
	
		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
	
		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
	
		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
	
		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property tx
		 * @type Number
		 **/
	
		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
	}
	var p = Matrix2D.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
	 * @property DEG_TO_RAD
	 * @static
	 * @final
	 * @type Number
	 * @readonly
	 **/
	Matrix2D.DEG_TO_RAD = Math.PI/180;


// static public properties:
	/**
	 * An identity matrix, representing a null transformation.
	 * @property identity
	 * @static
	 * @type Matrix2D
	 * @readonly
	 **/
	Matrix2D.identity = null; // set at bottom of class definition.
	

// public methods:
	/**
	 * Sets the specified values on this instance. 
	 * @method setValues
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @return {Matrix2D} This instance. Useful for chaining method calls.
	*/
	p.setValues = function(a, b, c, d, tx, ty) {
		// don't forget to update docs in the constructor if these change:
		this.a = (a == null) ? 1 : a;
		this.b = b || 0;
		this.c = c || 0;
		this.d = (d == null) ? 1 : d;
		this.tx = tx || 0;
		this.ty = ty || 0;
		return this;
	};

	/**
	 * Appends the specified matrix properties to this matrix. All parameters are required.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method append
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.append = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		if (a != 1 || b != 0 || c != 0 || d != 1) {
			this.a  = a1*a+c1*b;
			this.b  = b1*a+d1*b;
			this.c  = a1*c+c1*d;
			this.d  = b1*c+d1*d;
		}
		this.tx = a1*tx+c1*ty+this.tx;
		this.ty = b1*tx+d1*ty+this.ty;
		return this;
	};

	/**
	 * Prepends the specified matrix properties to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * All parameters are required.
	 * @method prepend
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prepend = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;

		this.a  = a*a1+c*this.b;
		this.b  = b*a1+d*this.b;
		this.c  = a*c1+c*this.d;
		this.d  = b*c1+d*this.d;
		this.tx = a*tx1+c*this.ty+tx;
		this.ty = b*tx1+d*this.ty+ty;
		return this;
	};

	/**
	 * Appends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method appendMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendMatrix = function(matrix) {
		return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Prepends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = o.getMatrix();
	 * 	while (o = o.parent) {
	 * 		// prepend each parent's transformation in turn:
	 * 		o.prependMatrix(o.getMatrix());
	 * 	}
	 * @method prependMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependMatrix = function(matrix) {
		return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
	 * For example, you can use this to generate a matrix representing the transformations of a display object:
	 * 
	 * 	var mtx = new createjs.Matrix2D();
	 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
	 * @method appendTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (skewX || skewY) {
			// TODO: can this be combined into a single append operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
		} else {
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		
		if (regX || regY) {
			// append the registration offset:
			this.tx -= regX*this.a+regY*this.c; 
			this.ty -= regX*this.b+regY*this.d;
		}
		return this;
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = new createjs.Matrix2D();
	 * 	do  {
	 * 		// prepend each parent's transformation in turn:
	 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	 * 	} while (o = o.parent);
	 * 	
	 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
	 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
	 * @method prependTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (regX || regY) {
			// prepend the registration offset:
			this.tx -= regX; this.ty -= regY;
		}
		if (skewX || skewY) {
			// TODO: can this be combined into a single prepend operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
		} else {
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		return this;
	};

	/**
	 * Applies a clockwise rotation transformation to the matrix.
	 * @method rotate
	 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.rotate = function(angle) {
//		angle = angle*Matrix2D.DEG_TO_RAD;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var a1 = this.a;
		var b1 = this.b;

		this.a = a1*cos+this.c*sin;
		this.b = b1*cos+this.d*sin;
		this.c = -a1*sin+this.c*cos;
		this.d = -b1*sin+this.d*cos;
		return this;
	};

	/**
	 * Applies a skew transformation to the matrix.
	 * @method skew
	 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @param {Number} skewY The amount to skew vertically in degrees.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.skew = function(skewX, skewY) {
		skewX = skewX*Matrix2D.DEG_TO_RAD;
		skewY = skewY*Matrix2D.DEG_TO_RAD;
		this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		return this;
	};

	/**
	 * Applies a scale transformation to the matrix.
	 * @method scale
	 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
	 * @param {Number} y The amount to scale vertically.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.scale = function(x, y) {
		this.a *= x;
		this.b *= x;
		this.c *= y;
		this.d *= y;
		//this.tx *= x;
		//this.ty *= y;
		return this;
	};

	/**
	 * Translates the matrix on the x and y axes.
	 * @method translate
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.translate = function(x, y) {
		this.tx += this.a*x + this.c*y;
		this.ty += this.b*x + this.d*y;
		return this;
	};

	/**
	 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
	 * @method identity
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.identity = function() {
		this.a = this.d = 1;
		this.b = this.c = this.tx = this.ty = 0;
		return this;
	};

	/**
	 * Inverts the matrix, causing it to perform the opposite transformation.
	 * @method invert
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.invert = function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1*d1-b1*c1;

		this.a = d1/n;
		this.b = -b1/n;
		this.c = -c1/n;
		this.d = a1/n;
		this.tx = (c1*this.ty-d1*tx1)/n;
		this.ty = -(a1*this.ty-b1*tx1)/n;
		return this;
	};

	/**
	 * Returns true if the matrix is an identity matrix.
	 * @method isIdentity
	 * @return {Boolean}
	 **/
	p.isIdentity = function() {
		return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
	};
	
	/**
	 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
	 * @method equals
	 * @param {Matrix2D} matrix The matrix to compare.
	 * @return {Boolean}
	 **/
	p.equals = function(matrix) {
		return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
	};

	/**
	 * Transforms a point according to this matrix.
	 * @method transformPoint
	 * @param {Number} x The x component of the point to transform.
	 * @param {Number} y The y component of the point to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
	 * @return {Point} This matrix. Useful for chaining method calls.
	 **/
	p.transformPoint = function(x, y, pt) {
		pt = pt||{};
		pt.x = x*this.a+y*this.c+this.tx;
		pt.y = x*this.b+y*this.d+this.ty;
		return pt;
	};

	/**
	 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
	 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
	 * results.
	 * @method decompose
	 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
	 * @return {Object} The target, or a new generic object with the transform properties applied.
	*/
	p.decompose = function(target) {
		// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
		if (target == null) { target = {}; }
		target.x = this.tx;
		target.y = this.ty;
		target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

		var skewX = Math.atan2(-this.c, this.d);
		var skewY = Math.atan2(this.b, this.a);

		var delta = Math.abs(1-skewX/skewY);
		if (delta < 0.00001) { // effectively identical, can use rotation:
			target.rotation = skewY/Matrix2D.DEG_TO_RAD;
			if (this.a < 0 && this.d >= 0) {
				target.rotation += (target.rotation <= 0) ? 180 : -180;
			}
			target.skewX = target.skewY = 0;
		} else {
			target.skewX = skewX/Matrix2D.DEG_TO_RAD;
			target.skewY = skewY/Matrix2D.DEG_TO_RAD;
		}
		return target;
	};
	
	/**
	 * Copies all properties from the specified matrix to this matrix.
	 * @method copy
	 * @param {Matrix2D} matrix The matrix to copy properties from.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.copy = function(matrix) {
		return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Returns a clone of the Matrix2D instance.
	 * @method clone
	 * @return {Matrix2D} a clone of the Matrix2D instance.
	 **/
	p.clone = function() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
	};

	// this has to be populated after the class is defined:
	Matrix2D.identity = new Matrix2D();


	// createjs.Matrix2D = Matrix2D;
	return Matrix2D;
}());
/*
 * File:   ui-circle.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic circle for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIBody
 * @extends UIElement
 * 物理引擎中的刚体。它是方块刚体，圆形刚体和多边形刚体的父类，它本身是一个抽象类，不能直接创建对象。
 * 
 * 可以设置它的物理引擎参数，如摩擦力，弹力和密度等。密度为0表示是静态刚体，大于0表示是动态刚体。
 * 静态刚体不会有速度等动态行为，通常用来表示大地等不动的物体，但可以通过程序来移动它的位置。
 *
 * 可以向刚体中添加图片和动画来装饰刚体。
 *
 * 注意：刚体只能放到场景中，如果设计时把刚体放在其它控件中，它不会继承父控件的位置属性，移动父控件刚体不会跟随移动。
 */

/**
 * @event onBeginContact
 * 两个刚体碰撞到一起时，会触发onBeginContact事件。一般事件调用顺序是：onBeginContact ->  onPreSolve -> onPostSolve ->onPreSolve -> onPostSolve -> ………… -> onPreSolve -> onPostSolve -> onEndContact。
 *
 *
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/](//www.box2dflash.org/docs/2.1a/reference/)
 *
 *     @example small frame
 *     if(body.element.name === "ui-coin") {
 *          body.element.remove(true);
 *     }
 */

/**
 * @event onEndContact
 * 碰撞结束事件。两个刚体碰撞在一起，然后分离开的事件。
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 *
 */

/**
 * @event onPreSolve
 * PreSolve
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 * @param {Object} oldManifold [b2Manifold](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Collision/b2Manifold.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html](//www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html)
 */

/**
 * @event onPostSolve
 * Post Solve 
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 * @param {Object} impulse [b2ContactImpulse](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactImpulse.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html](//www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html)
 */

/**
 * @event onMoved
 * 当刚体移动时触发本事件。
 *
 */

/**
 * @property {Boolean} cameraFollowMe
 * 是否启用镜头跟随。
 * 注意：需要设置当前场景的虚拟宽度大于场景宽度，或虚拟高度大于场景高度，否则镜头跟随不生效。
 */

function UIBody() {
	return;
}

UIBody.prototype = new UIElement();
UIBody.prototype.isUIBody = true;
UIBody.prototype.isUIPhysicsShape = true;

UIBody.prototype.saveProps = ["density", "friction", "restitution", "isSensor", "allowSleep", "isBullet", "autoDestroyWhenOutside",
	"fixedRotation", "groupIndex", "noStroke", "cameraFollowMe", "xInitVelocity", "yInitVelocity",
	"linearDamping", "angularDamping"];

UIBody.prototype.initUIBody = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setCanRectSelectable(false, false);

	this.density = 0;
	this.friction = 0;
	this.restitution = 0;
	this.allowSleep = true;

	this.addEventNames(["onBeginContact", "onEndContact", "onMoved", "onPreSolve", "onPostSolve"]);

	return this;
}

UIBody.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

//////////////////////////////////////////////////////////////

/**
 * @method setGravityScale
 * 设置刚体的重力系数，动态修改单个刚体的重力。
 * @param {Point} gravityScale 重力系数。
 * @return {UIElement} 返回控件本身。
 *
 *
 * 去掉重力影响：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:0});
 *
 * Y方向的重力取反：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:-1});
 
 * Y方向的重力减半：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:0.5});
 *
 */
UIBody.prototype.setGravityScale = function(gravityScale) {
	this.gravity = {};
	this.gravityScale = gravityScale;

	if(this.body) {
		this.body.modifyGravity  = this.modifyGravity.bind(this);
	}

	return this;
}

UIBody.prototype.modifyGravity = function(gravity) {
	var g = this.gravity;
	var gs = this.gravityScale;

	g.x = gravity.x * gs.x;
	g.y = gravity.y * gs.y;

	return g;
}

UIBody.prototype.onBodyCreated = function() {
	if(this.gravity && this.gravityScale) {
		this.body.modifyGravity  = this.modifyGravity.bind(this);
	}
}

/**
 * @method setSensor
 * 设置刚体为感应器。感应器可以产生碰撞的事件，但不会有碰撞的效果(直接穿越过对方)。
 * @param {Boolean} isSensor 是否为感应器。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setSensor = function(isSensor) {
	this.isSensor = isSensor;

	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetSensor(isSensor);
		}
	}

	return this;
}

/**
 * @method getDensity
 * 获取刚体的密度。
 * @return {Number} 返回刚体的密度。
 *
 */
UIBody.prototype.getDensity = function() {
	if(this.body) {
		return this.body.GetFixtureList().GetDensity();
	}
	else {
		return this.density;
	}
}

/**
 * @method setRestitution
 * 设置刚体的弹力系数。
 * @param {Number} restitution 刚体的弹力系数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setRestitution = function(restitution) {
    if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetRestitution(restitution);
		}
    }

    return this;
}

/**
 * @method getRestitution
 * 获取刚体的弹力系数。
 * @return {Number} 返回刚体的弹力系数。
 *
 */
UIBody.prototype.getRestitution = function() {
    if(this.body) {
        return this.body.GetFixtureList().GetRestitution();
    } else {
        return this.restitution;
    }
}

/**
 * @method setFriction
 * 设置刚体的摩擦系数。
 * @param {Number} friction 刚体的摩擦系数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setFriction = function(friction) {
    if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetFriction(friction);
		}
    }

    return this;
}

/**
 * @method getFriction
 * 获取刚体的摩擦系数。
 * @return {Number} 返回刚体的摩擦系数。
 *
 */
UIBody.prototype.getFriction = function() {
    if(this.body) {
        return this.body.GetFixtureList().GetFriction();
    } else {
        return this.friction;
    }
}

/**
 * @method setDensity
 * 设置刚体的密度。
 * @param {Number} density 刚体的密度。 
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setDensity = function(density) {
	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetDensity(density);
		}

		if(density > 0) {
			this.body.SetType(b2Body.b2_dynamicBody);
		}
		else if(density === 0) {
			this.body.SetType(b2Body.b2_staticBody);
		}
		else {
			this.body.SetType(b2Body.b2_kinematicBody);
		}
		this.body.ResetMassData();
	}

	return this;
}


/**
 * @method setV
 * 设置刚体的线性速度，x，y的取值为null/undefined时，保留原来的值。
 * @param {Number} x 水平方向上的速度，向右为正，向左为负。
 * @param {Number} y 垂直方向上的速度，向下为正，向上为负。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setV = function(x, y) {
	var body = this.body;
	if(body) {
		this.setVisible(true);

		if(!body.IsActive()) {
			body.SetActive(true);
		}

		if(!body.IsAwake()) {
			body.SetAwake(true);
		}

		var v = body.GetLinearVelocity();
		if(x !== null && x !== undefined) {
			v.x = x;
		}

		if(y !== null && y !== undefined) {
			v.y = y;
		}

		body.SetLinearVelocity(v);
	}
	else {
		this.xInitVelocity = x;
		this.yInitVelocity = y;
	}

	return this;
}

/**
 * @method getV
 * 获取刚体的线性速度。
 * @return {Point} 返回刚体的线性速度。
 *
 */
UIBody.prototype.getV = function() {
	return this.body ? this.body.GetLinearVelocity() : {x:0, y:0};
}

/**
 * @method addV
 * 增加刚体的线性速度。
 * @param {Number} dx 水平方向上的速度增量。
 * @param {Number} dy 垂直方向上的速度增量。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.addV = function(dx, dy) {
	var v = this.getV();

	if(dx !== null && dx !== undefined) {
		v.x += dx;
	}
	
	if(dy !== null && dy !== undefined) {
		v.y += dy;
	}

	return this.setV(v.x, v.y);
}

/**
 * @method getMass
 * 获取刚体的质量。
 * @return {Number} 返回刚体的质量。
 *
 */
UIBody.prototype.getMass = function() {
	return this.body ? this.body.GetMass() : 0;
}

/**
 * @method applyTorque
 * 作用一个力矩到刚体上。
 * @param {Number} torque
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.applyTorque = function(torque) {
	if(this.body) {
		this.body.ApplyTorque(torque);
	}

	return this;
}

/**
 * @method applyForce
 * 作用一个力到刚体上。
 * @param {Number} forceX X方向上的力。
 * @param {Number} forceY Y方向上的力。
 * @param {Number} x 作用点X。
 * @param {Number} y 作用点Y。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.applyForce = function(forceX, forceY, x, y) {
	if(this.body) {
		var force = {};
		var position = {};
		x = (x === undefined || x === null) ? (this.left + (this.w >> 1)) : x;
		y = (y === undefined || y === null) ? (this.top + (this.h >> 1)) : y;

		force.x = forceX;
		force.y = forceY;
		position.x = Physics.toMeter(x);
		position.y = Physics.toMeter(y);

		this.body.ApplyForce(force, position);
	}

	return this;
}

UIBody.prototype.setEnable = function(enable) {
	this.enable = enable;
	if(this.body) {
		this.body.SetActive(enable);
	}

	return this;
}

/**
 * @method setGroupIndex
 * 设置刚体的分组。
 * @param {Number} groupIndex 相同负数分组的刚体之间不会碰撞。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setGroupIndex = function(groupIndex) {
	this.groupIndex = groupIndex;
	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.m_filter.groupIndex = groupIndex;
		}
	}

	return this;
}

/**
 * @method getGroupIndex
 * 获取刚体的分组。
 * @return {Number} 返回控件的分组。
 *
 */
UIBody.prototype.getGroupIndex = function() {
	return this.groupIndex;
}

/**
 * @method getBody
 * 获取box2d的刚体对象。在特殊情况下，需要直接操作box2d，请使用本函数。
 * @return {Object} 返回box2d的刚体对象。
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/](http://www.box2dflash.org/docs/2.1a/reference/)
 */
UIBody.prototype.getBody = function() {
	return this.body;
}

UIBody.prototype.setRotation = function(rotation) {
	this.rotation = rotation;

	if(this.body) {
		this.body.SetAngle(rotation);
	}

	return this;
}

/**
 * @method boom
 * 通过这个方法向刚体周围放射作用力，达到爆炸效果。
 * @param {Number} range 爆炸的作用半径范围。
 * @param {Number} force 爆炸产成的作用力大小。
 * @param {Boolean} removeSelf 是否删除空间本身。
 */
UIBody.prototype.boom = function(range, force, removeSelf) {
    var position = this.getPosition();
    position = new b2Vec2(Physics.toMeter(position.x), Physics.toMeter(position.y));
    var win = this.getWindow();
    var world = win.world;
    range = Physics.toMeter(range);

    for (var i = 0; i <= 100; i++) {
        var angle = 360 / 100 * i;

        var input = new b2RayCastInput();
        input.p1 = position;
        input.p2.Set(position.x + range * Math.cos(angle), position.y + range * Math.sin(angle));
        input.maxFraction = 1;
        var output = new b2RayCastOutput();

        for (var currentBody = world.GetBodyList(); currentBody; currentBody = currentBody.GetNext()) {
            if (currentBody.element == this) {
                continue;
            }
            var fix = currentBody.GetFixtureList();
            if (!fix) {
                continue;
            }

            var isHit = fix.RayCast(output, input);
            if (isHit) {
                var p1 = input.p1.Copy();
                var p2 = input.p2.Copy();
                p2.Subtract(p1);
                p2.Multiply(output.fraction);
                p1.Add(p2);
  
                var hitPoint = p1.Copy();
                hitPoint.Subtract(position);
                currentBody.ApplyForce(new b2Vec2(hitPoint.x * (1 - output.fraction) * force, hitPoint.y * (1 - output.fraction) * force), hitPoint);
            }
        }
    }

    removeSelf && this.remove();
}



UIBody.prototype.needStroke = function() {
	return (!this.noStroke && !this.isStrokeColorTransparent()) || this.mode === Shape.MODE_EDITING;
}

UIBody.prototype.setSize = function(w, h) {
	RShape.prototype.setSize.call(this, w, h);

	var win = this.getWindow();
	this.updateLayoutParams();

	if(this.body && win && win.isUIScene) {
		this.resizeBody();
	}

	return this;
}

UIBody.prototype.onPositionChanged = function() {
	var x = this.left;
	var y = this.top;

	var win = this.getWindow();
	if(this.body && win && win.isUIScene) {
		var p = {};
		var pos = this.getParent().getPositionInWindow();

		x += pos.x;
		y += pos.y;

		p.x = win.toMeter(x + (this.w >> 1)); 
		p.y = win.toMeter(y + (this.h >> 1)); 
		this.body.SetPosition(p);
	}
	
	return this;
}

UIBody.prototype.paintSelfOnly = function(canvas) {
	var needStroke = this.needStroke();
	var needFill = !this.isFillColorTransparent();

	if(!needFill && !needStroke) {
		return;
	}

	canvas.beginPath();
	this.drawShape(canvas);

	if(needFill) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(needStroke) {
		if(this.noStroke) {
			canvas.setLineDash([5, 5]);	
		}

		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}
/*
 * File:   ui-path.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic path for game. 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPath
 * @extends UIElement
 * UIPath 控制物体按照指定的路径运动。目前路径支持直线，抛物线，二次和三次贝塞尔曲线，sin/cos函数和圆弧曲线。可以指定运动的速度(由duration控制)和加速度(由interpolator决定)。
 *
 * 使用时先放一个UIPath对象到场景中，然后在onInit事件里增加路径，在任何时间都可以向UIPath增加对象或删除对象。
 *
 * 注意：
 *
 * 1.文档中时长的单位为毫秒，速度单位为像素/秒，加速单位为像素/秒^2，角度单位为幅度。
 *
 * 2.插值算法实现加速/加速/匀速等效果，请参考插值算法。
 *
 */
function UIPath() {
	return;
}

UIPath.prototype = new UIElement();
UIPath.prototype.isUIPath = true;
UIPath.prototype.saveProps = ["showPath"];
UIPath.prototype.initUIPath = function(type, w, h) {
	this.initUIElement(type);	
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onInit"]);

	return this;
}

UIPath.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPath.prototype.onInit = function() {
	this.shapesInfo = [];
	this.elapsedTime = 0;
	this.pathAnimation = new PathAnimation();
	this.animationState = UIElement.STATE_RUNNING;

	this.callOnInitHandler();

	return;
}

/**
 * @method restart
 * 重新开始。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.restart = function() {
	this.elapsedTime = 0;
	this.animationState = UIElement.STATE_RUNNING;
	
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		iter.done = false;
		iter.startTime = iter.delayTime;
	}

	return this;
}

/**
 * @method pause
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.pause = function() {
	this.animationState = UIElement.STATE_PAUSED;

	return this;
}

/**
 * @method resume 
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.resume = function() {
	this.animationState = UIElement.STATE_RUNNING;

	return this;
}

UIPath.prototype.hasObj = function(shape) {
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		if(iter.shape === shape) {
			return true;
		}
	}

	return false;
}

/**
 * @method addObj
 * 增加一个对象，让它沿路径运动。
 * @param {UIElement} shape 对象。
 * @param {Function} onStep 每一步的回调函数（可选）。
 * @param {Function} onDone 完成时的回调函数（可选）。
 * @param {Number} delayTime 延迟启动时间（可选）。
 * @param {Number} noRotation 是否禁止旋转（可选）。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addObj = function(shape, onStep, onDone, delayTime, noRotation) {
	if(this.hasObj(shape)) {
		console.log("obj exist in path.");
		return this;
	}

	var info = {
		shape : shape, 
		onStep : onStep,
		onDone : onDone,
		noRotation:noRotation,
		delayTime : delayTime ? delayTime : 0, 
		startTime: Date.now()
	};

	info.startTime = info.delayTime + this.elapsedTime;
	this.shapesInfo.push(info);

	return this;
}

/**
 * @method removeObj
 * 从路径中移除一个对象。
 * @param {UIElement} shape 对象。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.removeObj = function(shape) {
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		if(iter.shape === shape) {
			a.splice(i, 1);
			break;
		}
	}

	return this;
}

/**
 * @method resetObjs
 * 清除全部对象。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.resetObjs = function() {
	this.shapesInfo = [];

	return this;
}

/**
 * @method resetPath
 * 重置路径。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.resetPath = function() {
	this.pathAnimation.reset();

	return this;
}

UIPath.prototype.getStartPoint = function() {
	return this.pathAnimation.startPoint;
}

UIPath.prototype.getEndPoint = function() {
	return this.endPoint;
}

UIPath.prototype.addPath = function(path) {
	this.pathAnimation.addPath(path);

	return this;
}

/**
 * @method addLine
 * 增加一条直线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addLine = function(duration, interpolator, p1, p2) {
	return this.addPath(LinePath.create(duration, interpolator, p1.x, p1.y, p2.x, p2.y));
}

/**
 * @method addArc
 * 增加一条弧线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} origin 原点
 * @param {Number} r 半径。
 * @param {Number} sAngle 初始角度。
 * @param {Number} eAngle 结束角度。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addArc = function(duration, interpolator, origin, r, sAngle, eAngle) {
	return this.addPath(ArcPath.create(duration, interpolator, origin.x, origin.y, r, sAngle, eAngle));
}

/**
 * @method addPara
 * 增加一条抛物线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p 初始位置。 
 * @param {Point} a 加速度。
 * @param {Point} v 初速度。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addPara = function(duration, interpolator, p, a, v) {
	return this.addPath(ParaPath.create(duration, interpolator, p.x, p.y, a.x, a.y, v.x, v.y));
}

/**
 * @method addSin
 * 增加一条sin/cos曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Number} p 初始位置。
 * @param {Number} waveLenth 波长。
 * @param {Number} v 波速(X方向上的速度)。
 * @param {Number} amplitude 振幅。
 * @param {Number} phaseOffset 角度偏移。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addSin = function(duration, interpolator, p, waveLenth, v, amplitude, phaseOffset) {
	return this.addPath(SinPath.create(duration, interpolator, p.x, p.y, waveLenth, v, amplitude, phaseOffset));
}

/**
 * @method addBezier
 * 增加一条三次贝塞尔曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 控制点1。
 * @param {Point} p3 控制点2。
 * @param {Point} p4 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addBezier = function(duration, interpolator, p1, p2, p3, p4) {
	return this.addPath(Bezier3Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y, p4.x,p4.y));
}

/**
 * @method addQuad
 * 增加一条二次贝塞尔曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 控制点。
 * @param {Point} p3 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addQuad = function(duration, interpolator, p1, p2, p3) {
	return this.addPath(Bezier2Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y));
}

UIPath.prototype.getDuration = function() {
	return this.pathAnimation.duration;
}

UIPath.prototype.getPosition = function(elapsedTime) {
	return this.pathAnimation.getPosition(elapsedTime);
}

UIPath.prototype.getDirection = function(elapsedTime) {
	return this.pathAnimation.getDirection(elapsedTime);
}

UIPath.prototype.updateObjs = function(canvas) {
	this.elapsedTime += canvas.timeStep;
	var elapsedTime = this.elapsedTime;
	
	var a = this.shapesInfo.slice();
	var n = this.shapesInfo.length;
	var pathAnimation = this.pathAnimation;
	var duration = pathAnimation.getDuration();

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		var shape = iter.shape;
		if(!shape || !shape.parentShape) continue;

		var t = elapsedTime - iter.startTime;
		if(t > 0 && !iter.done) {
			var angle = pathAnimation.getDirection(t);
			var position = pathAnimation.getPosition(t);

			if(!shape.visible) {
				shape.setVisible(true);
			}

			if(shape.anchor) {
				shape.setPosition(position.x, position.y);
			}
			else {
				shape.setPosition(position.x-(shape.w>>1), position.y-(shape.h>>1));
			}
			if(!iter.noRotation) {
				shape.setRotation(angle);
			}

			if(iter.onStep) {
				var onStep = iter.onStep;
				onStep(shape, t, position, angle);
			}
			
			if(t > duration) {
				iter.done = true;
				if(iter.onDone) {
					var onDone = iter.onDone;
					onDone(shape);
				}
			}
		}
	}
}

UIPath.prototype.paintSelf = function(canvas) {
	if(this.isIcon || this.mode === Shape.MODE_EDITING) {
		UIElement.prototype.paintSelf.call(this, canvas);
		return;
	}

	if(this.showPath && !this.isStrokeColorTransparent()) {
		canvas.strokeStyle = this.style.lineColor;
		canvas.lineWidth = this.style.lineWidth;
		this.pathAnimation.draw(canvas);
	}

	if(this.animationState === UIElement.STATE_RUNNING) {
		this.updateObjs(canvas);
		canvas.needRedraw++;
	}
	
	return;
}

function UIPathCreator() {
	var args = ["ui-path", "ui-path", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPath();
		return g.initUIPath(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPathCreator());
/*
 * File:   ui-sprite.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sprite for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISprite() {
	return;
}

UISprite.prototype = new UIImage();
UISprite.prototype.isUISprite = true;

UISprite.prototype.initUISprite = function(type, w, h, bg) {
	this.initUIImage(type, w ,h, bg);	

	return this;
}

function UISpriteCreator() {
	var args = ["ui-sprite", "ui-sprite", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISprite();
		return g.initUISprite(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISpriteCreator());

/*
 * File:   ui-point.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPoint() {
	return;
}

UIPoint.prototype = new UIElement();
UIPoint.prototype.isUIPoint = true;

UIPoint.prototype.initUIPoint = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);

	return this;
}

UIPoint.prototype.paintSelfOnly = function(canvas) {
	var fillIt = !this.isFillColorTransparent();
	var strokeIt = !this.isStrokeColorTransparent();

	if(fillIt || strokeIt) {
		var x = this.w >> 1;
		var y = this.h >> 1;
		canvas.beginPath();
		canvas.arc(x, y, 10, 0, 2 * Math.PI);
		
		if(fillIt) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fill();
		}

		if(strokeIt) {
			canvas.strokeStyle = this.style.lineColor;
			canvas.lineWidth = this.style.lineWidth;
			canvas.stroke();
		}

		if(this.showIndex) {
			canvas.font = "12px";
			canvas.textAlign = "center";
			canvas.textBaseline = "middle";
			canvas.fillStyle = this.style.textColor || "Black";
			canvas.fillText(this.getIndex(), x, y);
		}
	}

	return;
}

UIPoint.prototype.setShowIndex = function(showIndex) {
	this.showIndex = showIndex;

	return this;
}

UIPoint.prototype.isUserResizable = function() {
	return false;
}

UIPoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIPointCreator() {
	var args = ["ui-point", "ui-point", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPoint();
		return g.initUIPoint(this.type, 20, 20, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPointCreator());

/*
 * File:   ui-two-points.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  two anchor points 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UITwoPoints
 * @extends UIElement
 * 两个点组成的控件。用来实现边(Edge)刚体和距离关节等。
 */
function UITwoPoints() {
	return;
}

UITwoPoints.prototype = new UIElement();

UITwoPoints.prototype.initUITwoPoints = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_POINT1, null);
	this.setImage(UIElement.IMAGE_POINT2, null);
	
	this.points = [{x:0, y:0}, {x:80, y:80}];
	this.savedPoints = [{x:0, y:0}, {x:80, y:80}];

	return this;
}

UITwoPoints.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.points = [{x:0, y:0}, {x:80, y:80}];
	o.points[0].x = this.points[0].x;
	o.points[0].y = this.points[0].y;
	o.points[1].x = this.points[1].x;
	o.points[1].y = this.points[1].y;

	o.x0Param = this.x0Param;
	o.x1Param = this.x1Param;
	o.y0Param = this.y0Param;
	o.y1Param = this.y1Param;

	return o;
}

UITwoPoints.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.points[0].x = js.points[0].x;
	this.points[0].y = js.points[0].y;
	this.points[1].x = js.points[1].x;
	this.points[1].y = js.points[1].y;
	this.x0Param = js.x0Param;
	this.x1Param = js.x1Param;
	this.y0Param = js.y0Param;
	this.y1Param = js.y1Param;


	return this;
}

UITwoPoints.prototype.relayout = function() {
	if(this.disableRelayout || this.mode === Shape.MODE_EDITING) {
		return;
	}

	var p = getParentShapeOfShape(this);
	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);

	if(this.xAttr === UIElement.X_SCALE) {
		this.points[0].x = wParent * this.x0Param;
		this.points[1].x = wParent * this.x1Param;
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.points[0].y = hParent * this.y0Param;
		this.points[1].y = hParent * this.y1Param;
	}

	return;
}

UITwoPoints.prototype.updateLayoutParams = function() {
	this.xParam = 1;
	this.yParam = 1;

	var p = this.parentShape;
	if(!p) {
		return;
	}

	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.x0Param = this.points[0].x / wParent;
		this.x1Param = this.points[1].x / wParent;
	}

	if(this.yAttr === UIElement.Y_SCALE) {
		this.y0Param = this.points[0].y / hParent;
		this.y1Param = this.points[1].y / hParent;
	}

    this.w = Math.abs(this.points[0].x - this.points[1].x);
    this.h = Math.abs(this.points[0].y - this.points[1].y);

	return;
}

UITwoPoints.prototype.drawSelectMarks = function(canvas) {
}

UITwoPoints.prototype.setPositionByBody = function(x, y) {
    if(this.isUIEdge) {
        var dx = x - this.left;
        var dy = y - this.top;
        this.points[0].x += dx;
        this.points[0].y += dy;
        this.points[1].x += dx;
        this.points[1].y += dy;
    }
    UIElement.prototype.setPositionByBody.call(this, x, y);
}

UITwoPoints.prototype.paintSelf = function(canvas) {
	canvas.save();
	canvas.globalAlpha *=  this.opacity;
	var p1 = this.points[0];
	var p2 = this.points[1];
	if(this.isIcon) {
		this.translate(canvas);
		p1 = {x:p1.x+30, y:p1.y+30}
		p2 = {x:p2.x-10, y:p2.y-10}
	}

	var image = null;
	var srcRect = null;
	var bg = this.getImageByType(UIElement.IMAGE_DEFAULT);
	var p1Img = this.getImageByType(UIElement.IMAGE_POINT1);
	var p2Img = this.getImageByType(UIElement.IMAGE_POINT2);
	var r = this.anchorSize ? this.anchorSize : 5;

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;

	if(bg && bg.getImage()) {
		image = bg.getImage();
		srcRect = bg.getImageRect();
		UIElement.drawImageLine(canvas, image, this.images.display, p1, p2, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.moveTo(p1.x, p1.y);
		canvas.lineTo(p2.x, p2.y);
		canvas.stroke();
	}

	if(p1Img && p1Img.getImage()) {
		image = p1Img.getImage();
		srcRect = p1Img.getImageRect();
		this.drawImageAt(canvas, image, WImage.DISPLAY_CENTER , p1.x-r, p1.y-r, r+r, r+r, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.arc(p1.x, p1.y, r, 0, Math.PI * 2);
		canvas.fill();
	}

	if(p2Img && p2Img.getImage()) {
		image = p2Img.getImage();
		srcRect = p2Img.getImageRect();
		this.drawImageAt(canvas, image, WImage.DISPLAY_CENTER , p2.x-r, p2.y-r, r+r, r+r, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.arc(p2.x, p2.y, r, 0, Math.PI * 2);
		canvas.fill();
	}

	canvas.restore();
	
	this.drawSelectMarks(canvas);

	return;
}

UITwoPoints.prototype.shapeCanBeChild = function(shape) {
	return false;
}

/**
 * @method getPoint
 * 获取点的坐标。 
 * @param {Number} index 索引。
 * @return {Point} 返回点的坐标。
 *
 */
UITwoPoints.prototype.getPoint = function(index) {
	return this.points[index ? 1 : 0];
}

UITwoPoints.prototype.getCenterX = function() {
	return (this.points[0].x + this.points[1].x)>>1;
}

UITwoPoints.prototype.getCenterY = function() {
	return (this.points[0].y + this.points[1].y)>>1;
}

/**
 * @method setPoint
 * 设置点的坐标。 
 * @param {Number} index 索引。
 * @param {Number} x
 * @param {Number} y
 * @return {UIElement} 返回控件本身。
 *
 */
UITwoPoints.prototype.setPoint = function(index, x, y) {
	var p = this.points[index ? 1 : 0];
	p.x = x;
	p.y = y;
	this.updateLayoutParams();

	return this;
}

/**
 * @method getDistance
 * 获取两点的距离。
 * @return {Number} 返回两点的距离。
 *
 */
UITwoPoints.prototype.getDistance = function() {
	return Math.round(Math.distanceBetween(this.points[0], this.points[1]));
}

/**
 * @method getAngle
 * 获取两点的的角度。
 * @return {Number} 返回两点的的角度。
 *
 */
UITwoPoints.prototype.getAngle = function() {
	return Math.lineAngle(this.points[0], this.points[1]);
}

/*
 * File:   ui-image-line.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief: image line 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageLine() {
	return;
}

UIImageLine.prototype = new UITwoPoints();
UIImageLine.prototype.isUIImageLine = true;

UIImageLine.prototype.initUIImageLine = function(type, w, h) {
	this.initUITwoPoints(type);	
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

UIImageLine.prototype.paintSelf = function(canvas) {
	var image = this.getBgImage();
	if(image && image.getImage()){
		canvas.save();
		if(this.isIcon) {
			this.translate(canvas);
		}

		var p0 = this.points[0];
		var p1 = this.points[1];
		var srcRect = image.getImageRect();
		UIElement.drawImageLine(canvas, image.getImage(), this.images.display, p0, p1, srcRect);
		this.drawSelectMarks(canvas);
		canvas.restore();
	}
	else {
		UITwoPoints.prototype.paintSelf.call(this, canvas);
	}

	return;
}

function UIImageLineCreator() {
	var args = ["ui-image-line", "ui-image-line", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageLine();
		return g.initUIImageLine(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageLineCreator());

/*
 * File:   ui-polygon.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic polygon for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPolygon
 * @extends UIBody
 * 多边形刚体。是物理引擎中的多边形刚体。多边形可以是三角形，四边形，五边形和组合多边形，多边形必须是按顺时针形成的凸多边形。组合多边形每5个点组成一个多边形。
 */
function UIPolygon() {
	return;
}

UIPolygon.prototype = new UIBody();
UIPolygon.prototype.isUIPolygon = true;

UIPolygon.prototype.initUIPolygon = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UIPolygon.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	if(shape.isUIPoint) {
		return true;
	}

	return !shape.isUIPhysicsShape;
}

UIPolygon.prototype.drawShape = function(canvas) {
	var x0 = 0;
	var y0 = 0;
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(!iter.isUIPoint) {
			continue;
		}

		var x = iter.left + (iter.w >> 1);
		var y = iter.top + (iter.h >> 1);

		if(i%5 === 0) {
			x0 = x;
			y0 = y;
			if(i > 0) {
				canvas.closePath();
			}
			canvas.moveTo(x, y);
		}
		else {
			canvas.lineTo(x, y);
		}
	}
	canvas.lineTo(x0, y0);
}

UIPolygon.prototype.afterChildAppended = function(shape) {
	if(shape.isUIPoint) {
		shape.z = shape.getIndex();
		shape.setShowIndex(true).setSize(20, 20);
	}

	return;
}

UIPolygon.prototype.resizeBody = function(xScale, yScale) {
	var arr = [];
	var cx = this.w >> 1;
	var cy = this.h >> 1
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];

		if(!iter.isUIPoint) {
			continue;
		}

		var hw = iter.w >> 1;
		var hh = iter.h >> 1;
		var icx = (iter.left + (hw >> 1)) * xScale;
		var icy = (iter.top + (hh >> 1)) * yScale;
		var left = icx - hw;
		var top = icy - hh;
		iter.setLeftTop(left, top);

		arr.push({x:Physics.toMeter(icx-cx), y:Physics.toMeter(icy-cy)});
	}

	var x = Physics.toMeter(this.left + (this.w >> 1));
	var y = Physics.toMeter(this.top + (this.h>>1));
	
	var shape = this.body.GetFixtureList().GetShape();
	shape.SetAsArray(arr, arr.length);
	
	this.body.SetAwake(true);
	this.body.SynchronizeFixtures();
    this.body.SetPositionAndAngle({x:x, y:y}, this.rotation);

	return;
}

UIPolygon.prototype.setSize = function(w, h) {
	if(w === this.w && h === this.h) {
		console.log("UIPolygon.prototype.setSize: Size not changed.");
		return;
	}

	var xScale = w/this.w;
	var yScale = h/this.h;
	RShape.prototype.setSize.call(this, w, h);

	var win = this.getWindow();
	this.updateLayoutParams();

	if(this.body && win && win.isUIScene) {
		this.resizeBody(xScale, yScale);
	}

	return this;
}

UIPolygon.prototype.onFromJsonDone = function(js) {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(iter.isUIPoint) {
			iter.z = iter.getIndex();
			iter.setShowIndex(true).setSize(20, 20);
		}
	}

	return;
}

function UIPolygonCreator() {
	var args = ["ui-polygon", "ui-polygon", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPolygon();
		return g.initUIPolygon(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPolygonCreator());

/*
 * File:   ui-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic box for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIBox
 * @extends UIBody
 * 方形刚体。
 */
function UIBox() {
	return;
}

UIBox.prototype = new UIBody();
UIBox.prototype.isUIBox = true;

UIBox.prototype.initUIBox = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UIBox.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

UIBox.prototype.resizeBody = function() {
	var x = this.left;
	var y = this.top;
	var hw = this.getWidth(true) >> 1;
	var hh = this.getHeight(true) >> 1;
	var shape = this.body.GetFixtureList().GetShape();

	shape.SetAsBox(Physics.toMeter(hw), Physics.toMeter(hh));
	this.body.SynchronizeFixtures();
	this.setLeftTop(x, y);
}

UIBox.prototype.drawShape = function(canvas) {
	var x = this.getHMargin();
	var y = this.getVMargin();
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	
	canvas.rect(x, y, w, h);

	return;
}

function UIBoxCreator() {
	var args = ["ui-box", "ui-box", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBox();
		return g.initUIBox(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBoxCreator());

/*
 * File:   ui-one-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  one anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIOneJoint() {
	return;
}

UIOneJoint.prototype = new UIElement();
UIOneJoint.prototype.isUIJoint = true;
UIOneJoint.prototype.isUIOneJoint = true;

UIOneJoint.prototype.initUIOneJoint = function(type) {
	this.initUIElement(type);	

	this.setDefSize(20, 20);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_POINT, null);

	return this;
}

UIOneJoint.prototype.isUserResizable = function() {
	return false;
}

UIOneJoint.prototype.setSize = function(w, h) {
	this.w = 20;
	this.h = 20;

	return this;
}

UIOneJoint.prototype.paintSelfOnly = function(canvas) {
	var pImage = this.getImageByType(UIElement.IMAGE_POINT);
	if(pImage && pImage.getImage()) {
		var image = pImage.getImage();
		var srcRect = pImage.getImageRect();
		this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, srcRect);
	}
	else {
		var fillIt = !this.isFillColorTransparent();
		var strokeIt = !this.isStrokeColorTransparent();

		if(fillIt || strokeIt) {
			var x = this.w >> 1;
			var y = this.h >> 1;
			canvas.beginPath();
			canvas.arc(x, y, 10, 0, 2 * Math.PI);
			
			if(fillIt) {
				canvas.fillStyle = this.style.fillColor;
				canvas.fill();
			}

			if(strokeIt) {
				canvas.strokeStyle = this.style.lineColor;
				canvas.lineWidth = this.style.lineWidth;
				canvas.stroke();
			}
		}
	}

	return;
}

UIOneJoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIOneJointCreator() {
	var args = ["ui-one-joint", "ui-one-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIOneJoint();
		return g.initUIOneJoint(this.type);
	}
	
	return;
}
/*!
 * Proton v1.0.1
 * https://github.com/a-jie/Proton
 *
 * Copyright 2011-2015, A-JIE
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license
 *
 */

(function(window, undefined) {
	//the max particle number in pool
	Proton.POOL_MAX = 1000;
	Proton.TIME_STEP = 60;
	//1:100
	Proton.MEASURE = 100;
	Proton.EULER = 'euler';
	Proton.RK2 = 'runge-kutta2';
	Proton.RK4 = 'runge-kutta4';
	Proton.VERLET = 'verlet';

	Proton.PARTICLE_CREATED = 'partilcleCreated';
	Proton.PARTICLE_UPDATE = 'partilcleUpdate';
	Proton.PARTICLE_SLEEP = 'particleSleep';
	Proton.PARTICLE_DEAD = 'partilcleDead';
	Proton.PROTON_UPDATE = 'protonUpdate';
	Proton.PROTON_UPDATE_AFTER = 'protonUpdateAfter';
	Proton.EMITTER_ADDED = 'emitterAdded';
	Proton.EMITTER_REMOVED = 'emitterRemoved';

	Proton.amendChangeTabsBug = true;
	Proton.TextureBuffer = {};
	Proton.TextureCanvasBuffer = {};

	/**
	 * Proton is a html5 particle engine
	 *
	 * @class Proton
	 * @constructor
	 */
	function Proton(proParticleCount, integrationType) {
		this.proParticleCount = Proton.Util.initValue(proParticleCount, Proton.POOL_MAX);
		this.integrationType = Proton.Util.initValue(integrationType, Proton.EULER);
		this.emitters = [];
		this.renderers = [];
		this.time = 0;
		this.oldTime = 0;

		Proton.pool = new Proton.ParticlePool(this.proParticleCount);
		Proton.integrator = new Proton.NumericalIntegration(this.integrationType);
	}


	Proton.prototype = {
		/**
		 * add a type of Renderer
		 *
		 * @method addRender
		 * @param {Renderer} render
		 */
		addRender : function(render) {
			render.proton = this;
			this.renderers.push(render.proton);
		},
		/**
		 * add the Emitter
		 *
		 * @method addEmitter
		 * @param {Emitter} emitter
		 */
		addEmitter : function(emitter) {
			this.emitters.push(emitter);
			emitter.parent = this;

			this.dispatchEvent(new Proton.Event({
				type : Proton.EMITTER_ADDED,
				emitter : emitter
			}));
		},

		removeEmitter : function(emitter) {
			var index = this.emitters.indexOf(emitter);
			this.emitters.splice(index, 1);
			emitter.parent = null;

			this.dispatchEvent(new Proton.Event({
				type : Proton.EMITTER_REMOVED,
				emitter : emitter
			}));
		},

		update : function() {
			this.dispatchEvent(new Proton.Event({
				type : Proton.PROTON_UPDATE
			}));

			if (!this.oldTime)
				this.oldTime = new Date().getTime();

			var time = new Date().getTime();
			this.elapsed = (time - this.oldTime) / 1000;
			if (Proton.amendChangeTabsBug)
				this.amendChangeTabsBug();
			this.oldTime = time;
			if (this.elapsed > 0) {
				for (var i = 0; i < this.emitters.length; i++) {
					this.emitters[i].update(this.elapsed);
				}
			}

			this.dispatchEvent(new Proton.Event({
				type : Proton.PROTON_UPDATE_AFTER
			}));
		},

		amendChangeTabsBug : function() {
			if (this.elapsed > .5) {
				this.oldTime = new Date().getTime();
				this.elapsed = 0;
			}
		},

		getCount : function() {
			var total = 0;
			var length = this.emitters.length;
			for (var i = 0; i < length; i++) {
				total += this.emitters[i].particles.length;
			}
			return total;
		},

		destory : function() {
			var length = this.emitters.length;
			for (var i = 0; i < length; i++) {
				this.emitters[i].destory();
				delete this.emitters[i];
			}

			this.emitters = [];
			this.time = 0;
			this.oldTime = 0;
			Proton.pool.release();
		}
	};

	window.Proton = Proton;


/*
 * EventDispatcher
 * Visit http://createjs.com/ for documentation, updates and examples.
 *
 **/

	function EventDispatcher() {
		this.initialize();
	};

	var p = EventDispatcher.prototype;

	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.removeEventListener = p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
	};

	p._listeners = null;

	p.initialize = function() {
	};

	p.addEventListener = function(type, listener) {
		var listeners = this._listeners;
		if (!listeners) {
			listeners = this._listeners = {};
		} else {
			this.removeEventListener(type, listener);
		}
		var arr = listeners[type];
		if (!arr) {
			arr = listeners[type] = [];
		}
		arr.push(listener);
		return listener;
	};

	p.removeEventListener = function(type, listener) {
		var listeners = this._listeners;
		if (!listeners) {
			return;
		}
		var arr = listeners[type];
		if (!arr) {
			return;
		}
		for (var i = 0, l = arr.length; i < l; i++) {
			if (arr[i] == listener) {
				if (l == 1) {
					delete (listeners[type]);
				}// allows for faster checks.
				else {
					arr.splice(i, 1);
				}
				break;
			}
		}
	};

	p.removeAllEventListeners = function(type) {
		if (!type) {
			this._listeners = null;
		} else if (this._listeners) {
			delete (this._listeners[type]);
		}
	};

	p.dispatchEvent = function(eventObj) {
		var ret = false, listeners = this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr)
				return ret;
				
			arr = arr.slice();
			// to avoid issues with items being removed or added during the dispatch
			for (var i = 0, l = arr.length; i < l; i++) {
				var o = arr[i];
				ret = ret || o(eventObj);
			}
		}
		return !!ret;
	};

	p.hasEventListener = function(type) {
		var listeners = this._listeners;
		return !!(listeners && listeners[type]);
	};

	Proton.EventDispatcher = EventDispatcher;
	Proton.EventDispatcher.initialize(Proton.prototype);



	function Event(pObj) {
		this.type = pObj['type'];
		this.particle = pObj['particle'];
		this.emitter = pObj['emitter'];
	}


	Event.PARTICLE_CREATED = Proton.PARTICLE_CREATED;
	Event.PARTICLE_UPDATA = Proton.PARTICLE_UPDATA;
	Event.PARTICLE_SLEEP = Proton.PARTICLE_SLEEP;
	Event.PARTICLE_DEAD = Proton.PARTICLE_DEAD;

	Proton.Event = Event;



	var Util = Util || {
		initValue : function(value, defaults) {
			var value = (value != null && value != undefined) ? value : defaults;
			return value;
		},

		isArray : function(value) {
			return typeof value === 'object' && value.hasOwnProperty('length');
		},

		destroyArray : function(array) {
			array.length = 0;
		},

		destroyObject : function(obj) {
			for (var o in obj)
			delete obj[o];
		},

		getVector2D : function(postionOrX, y) {
			if ( typeof (postionOrX) == 'object') {
				return postionOrX;
			} else {
				var vector2d = new Proton.Vector2D(postionOrX, y);
				return vector2d;
			}
		},

		judgeVector2D : function(pOBJ) {
			var result = '';
			if (pOBJ.hasOwnProperty('x') || pOBJ.hasOwnProperty('y') || pOBJ.hasOwnProperty('p') || pOBJ.hasOwnProperty('position'))
				result += 'p';
			if (pOBJ.hasOwnProperty('vx') || pOBJ.hasOwnProperty('vx') || pOBJ.hasOwnProperty('v') || pOBJ.hasOwnProperty('velocity'))
				result += 'v';
			if (pOBJ.hasOwnProperty('ax') || pOBJ.hasOwnProperty('ax') || pOBJ.hasOwnProperty('a') || pOBJ.hasOwnProperty('accelerate'))
				result += 'a';

			return result;
		},

		setVector2DByObject : function(target, pOBJ) {
			if (pOBJ.hasOwnProperty('x'))
				target.p.x = pOBJ['x'];

			if (pOBJ.hasOwnProperty('y'))
				target.p.y = pOBJ['y'];

			if (pOBJ.hasOwnProperty('vx'))
				target.v.x = pOBJ['vx'];

			if (pOBJ.hasOwnProperty('vy'))
				target.v.y = pOBJ['vy'];

			if (pOBJ.hasOwnProperty('ax'))
				target.a.x = pOBJ['ax'];

			if (pOBJ.hasOwnProperty('ay'))
				target.a.y = pOBJ['ay'];

			if (pOBJ.hasOwnProperty('p'))
				particle.p.copy(pOBJ['p']);

			if (pOBJ.hasOwnProperty('v'))
				particle.v.copy(pOBJ['v']);

			if (pOBJ.hasOwnProperty('a'))
				particle.a.copy(pOBJ['a']);

			if (pOBJ.hasOwnProperty('position'))
				particle.p.copy(pOBJ['position']);

			if (pOBJ.hasOwnProperty('velocity'))
				particle.v.copy(pOBJ['velocity']);

			if (pOBJ.hasOwnProperty('accelerate'))
				particle.a.copy(pOBJ['accelerate']);
		},
		//强行添加属性
		addPrototypeByObject : function(target, prototypeObject, filters) {
			for (var singlePrototype in prototypeObject ) {
				if (filters) {
					if (filters.indexOf(singlePrototype) < 0)
						target[singlePrototype] = Proton.Util.getSpanValue(prototypeObject[singlePrototype]);
				} else {
					target[singlePrototype] = Proton.Util.getSpanValue(prototypeObject[singlePrototype]);
				}
			}

			return target;
		},
		//set prototype
		setPrototypeByObject : function(target, prototypeObject, filters) {
			for (var singlePrototype in prototypeObject ) {
				if (target.hasOwnProperty(singlePrototype)) {
					if (filters) {
						if (filters.indexOf(singlePrototype) < 0)
							target[singlePrototype] = Proton.Util.getSpanValue(prototypeObject[singlePrototype]);
					} else {
						target[singlePrototype] = Proton.Util.getSpanValue(prototypeObject[singlePrototype]);
					}
				}
			}

			return target;
		},

		setSpanValue : function(a, b, c) {
			if ( a instanceof Proton.Span) {
				return a;
			} else {
				if (!b) {
					return new Proton.Span(a);
				} else {
					if (!c)
						return new Proton.Span(a, b);
					else
						return new Proton.Span(a, b, c);
				}
			}
		},

		getSpanValue : function(pan) {
			if ( pan instanceof Proton.Span)
				return pan.getValue();
			else
				return pan;
		},

		inherits : function(subClass, superClass) {
			subClass._super_ = superClass;
			if (Object['create']) {
				//console.log(subClass,superClass);
				subClass.prototype = Object.create(superClass.prototype, {
					constructor : {
						value : subClass
					}
				});
			} else {
				var F = function() {
				};
				F.prototype = superClass.prototype;
				subClass.prototype = new F();
				subClass.prototype.constructor = subClass;
			}
		},

		getImageData : function(context, image, rect) {
			context.drawImage(image, rect.x, rect.y);
			var imagedata = context.getImageData(rect.x, rect.y, rect.width, rect.height);
			context.clearRect(rect.x, rect.y, rect.width, rect.height);
			return imagedata;
		},

		getImage : function(img, particle, drawCanvas, fun) {
			if ( typeof (img) == 'string') {
				this.loadAndSetImage(img, particle, drawCanvas, fun);
			} else if ( typeof (img) == 'object') {
				this.loadAndSetImage(img.src, particle, drawCanvas, fun);
			} else if ( img instanceof Image) {
				this.loadedImage(img.src, particle, drawCanvas, fun, img);
			}
		},

		loadedImage : function(src, particle, drawCanvas, fun, target) {
			particle.target = target;
			particle.transform.src = src;
			if (!Proton.TextureBuffer[src])
				Proton.TextureBuffer[src] = particle.target;
			if (drawCanvas) {
				if (Proton.TextureCanvasBuffer[src]) {
					particle.transform.canvas = Proton.TextureCanvasBuffer[src];
				} else {
					var _width = Proton.WebGLUtil.nhpot(particle.target.width);
					var _height = Proton.WebGLUtil.nhpot(particle.target.height);
					particle.transform.canvas = Proton.DomUtil.createCanvas('canvas' + src, _width, _height);
					var context = particle.transform.canvas.getContext('2d');
					context.drawImage(particle.target, 0, 0, particle.target.width, particle.target.height);
					Proton.TextureCanvasBuffer[src] = particle.transform.canvas;
				}
			}
			if (fun)
				fun(particle);
		},

		loadAndSetImage : function(src, particle, drawCanvas, fun) {
			if (Proton.TextureBuffer[src]) {
				this.loadedImage(src, particle, drawCanvas, fun, Proton.TextureBuffer[src]);
			} else {
				var self = this;
				var myImage = new Image();
				myImage.onload = function(e) {
					self.loadedImage(src, particle, drawCanvas, fun, e.target);
				}
				myImage.src = src;
			}
		},

		hexToRGB : function(h) {
			var hex16 = (h.charAt(0) == "#") ? h.substring(1, 7) : h;
			var r = parseInt(hex16.substring(0, 2), 16);
			var g = parseInt(hex16.substring(2, 4), 16);
			var b = parseInt(hex16.substring(4, 6), 16);

			return {
				r : r,
				g : g,
				b : b
			}
		},

		rgbToHex : function(rbg) {
			return 'rgb(' + rbg.r + ', ' + rbg.g + ', ' + rbg.b + ')';
		}
	};

	Proton.Util = Util;



	var WebGLUtil = WebGLUtil || {
		ipot : function(length) {
			return (length & (length - 1)) == 0;
		},

		nhpot : function(length) {--length;
			for (var i = 1; i < 32; i <<= 1) {
				length = length | length >> i;
			}
			return length + 1;
		},

		makeTranslation : function(tx, ty) {
			return [1, 0, 0, 0, 1, 0, tx, ty, 1];
		},

		makeRotation : function(angleInRadians) {
			var c = Math.cos(angleInRadians);
			var s = Math.sin(angleInRadians);
			return [c, -s, 0, s, c, 0, 0, 0, 1];
		},

		makeScale : function(sx, sy) {
			return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
		},

		matrixMultiply : function(a, b) {
			var a00 = a[0 * 3 + 0];
			var a01 = a[0 * 3 + 1];
			var a02 = a[0 * 3 + 2];
			var a10 = a[1 * 3 + 0];
			var a11 = a[1 * 3 + 1];
			var a12 = a[1 * 3 + 2];
			var a20 = a[2 * 3 + 0];
			var a21 = a[2 * 3 + 1];
			var a22 = a[2 * 3 + 2];
			var b00 = b[0 * 3 + 0];
			var b01 = b[0 * 3 + 1];
			var b02 = b[0 * 3 + 2];
			var b10 = b[1 * 3 + 0];
			var b11 = b[1 * 3 + 1];
			var b12 = b[1 * 3 + 2];
			var b20 = b[2 * 3 + 0];
			var b21 = b[2 * 3 + 1];
			var b22 = b[2 * 3 + 2];
			return [a00 * b00 + a01 * b10 + a02 * b20, a00 * b01 + a01 * b11 + a02 * b21, a00 * b02 + a01 * b12 + a02 * b22, a10 * b00 + a11 * b10 + a12 * b20, a10 * b01 + a11 * b11 + a12 * b21, a10 * b02 + a11 * b12 + a12 * b22, a20 * b00 + a21 * b10 + a22 * b20, a20 * b01 + a21 * b11 + a22 * b21, a20 * b02 + a21 * b12 + a22 * b22];
		}
	}

	Proton.WebGLUtil = WebGLUtil;



	var DomUtil = DomUtil || {
		createCanvas : function($id, $width, $height, $position) {
			var element = document.createElement("canvas");
			var position = $position ? $position : 'absolute';
			element.id = $id;
			element.width = $width;
			element.height = $height;
			element.style.position = position;
			element.style.opacity = 0;
			this.transformDom(element, -500, -500, 0, 0);
			return element;
		},

		transformDom : function($div, $x, $y, $scale, $rotate) {
			$div.style.WebkitTransform = 'translate(' + $x + 'px, ' + $y + 'px) ' + 'scale(' + $scale + ') ' + 'rotate(' + $rotate + 'deg)';
			$div.style.MozTransform = 'translate(' + $x + 'px, ' + $y + 'px) ' + 'scale(' + $scale + ') ' + 'rotate(' + $rotate + 'deg)';
			$div.style.OTransform = 'translate(' + $x + 'px, ' + $y + 'px) ' + 'scale(' + $scale + ') ' + 'rotate(' + $rotate + 'deg)';
			$div.style.msTransform = 'translate(' + $x + 'px, ' + $y + 'px) ' + 'scale(' + $scale + ') ' + 'rotate(' + $rotate + 'deg)';
			$div.style.transform = 'translate(' + $x + 'px, ' + $y + 'px) ' + 'scale(' + $scale + ') ' + 'rotate(' + $rotate + 'deg)';
		}
	}

	Proton.DomUtil = DomUtil;



	function MStack() {
		this.mats = [];
		this.size = 0;
		for (var i = 0; i < 20; i++)
			this.mats.push(Proton.Mat3.create([0, 0, 0, 0, 0, 0, 0, 0, 0]));
	}


	MStack.prototype.set = function(m, i) {
		if (i == 0)
			Proton.Mat3.set(m, this.mats[0]);
		else
			Proton.Mat3.multiply(this.mats[i - 1], m, this.mats[i]);
		this.size = Math.max(this.size, i + 1);
	}

	MStack.prototype.push = function(m) {
		if (this.size == 0)
			Proton.Mat3.set(m, this.mats[0]);
		else
			Proton.Mat3.multiply(this.mats[this.size - 1], m, this.mats[this.size]);
		this.size++;
	}

	MStack.prototype.pop = function() {
		if (this.size > 0)
			this.size--;
	}

	MStack.prototype.top = function() {
		return (this.mats[this.size - 1]);
	}

	Proton.MStack = MStack;




	Particle.ID = 0;
	/**
	 * the Particle class
	 *
	 * @class Proton.Particle
	 * @constructor
	 * @param {Object} pObj the parameters object;
	 * for example {life:3,dead:false}
	 */
	function Particle(pOBJ) {
		/**
		 * The particle's id;
		 * @property id
		 * @type {String} id
		 */
		this.id = 'particle_' + Particle.ID++;
		this.reset(true);
		Proton.Util.setPrototypeByObject(this, pOBJ);
	}


	Particle.prototype = {
		getDirection : function() {
			return Math.atan2(this.v.x, -this.v.y) * (180 / Math.PI);
		},

		reset : function(init) {
			this.life = Infinity;
			this.age = 0;
			//能量损失
			this.energy = 1;
			this.dead = false;
			this.sleep = false;
			this.target = null;
			this.sprite = null;
			this.parent = null;
			this.mass = 1;
			this.radius = 10;
			this.alpha = 1;
			this.scale = 1;
			this.rotation = 0;
			this.color = null;
			this.easing = Proton.ease.setEasingByName(Proton.easeLinear);
			if (init) {
				this.transform = {}
				this.p = new Proton.Vector2D();
				this.v = new Proton.Vector2D();
				this.a = new Proton.Vector2D();
				this.old = {
					p : new Proton.Vector2D(),
					v : new Proton.Vector2D(),
					a : new Proton.Vector2D()
				};
				this.behaviours = [];
			} else {
				Proton.Util.destroyObject(this.transform);
				this.p.set(0, 0);
				this.v.set(0, 0);
				this.a.set(0, 0);
				this.old.p.set(0, 0);
				this.old.v.set(0, 0);
				this.old.a.set(0, 0);
				this.removeAllBehaviours();
			}

			this.transform.rgb = {
				r : 255,
				g : 255,
				b : 255
			}
			return this;
		},

		update : function(time, index) {
			if (!this.sleep) {
				this.age += time;
				var length = this.behaviours.length, i;
				for ( i = 0; i < length; i++) {
					if (this.behaviours[i])
						this.behaviours[i].applyBehaviour(this, time, index)
				}
			} else {

			}

			if (this.age >= this.life) {
				this.destory();
			} else {
				var scale = this.easing(this.age / this.life);
				this.energy = Math.max(1 - scale, 0);
			}

		},

		addBehaviour : function(behaviour) {
			this.behaviours.push(behaviour);
			if (behaviour.hasOwnProperty('parents'))
				behaviour.parents.push(this);
			behaviour.initialize(this);
		},

		addBehaviours : function(behaviours) {
			var length = behaviours.length, i;
			for ( i = 0; i < length; i++) {
				this.addBehaviour(behaviours[i]);
			}
		},

		removeBehaviour : function(behaviour) {
			var index = this.behaviours.indexOf(behaviour);
			if (index > -1) {
				var behaviour = this.behaviours.splice(index, 1);
				behaviour.parents = null;
			}
		},

		removeAllBehaviours : function() {
			Proton.Util.destroyArray(this.behaviours);
		},
		/**
		 * Destory this particle
		 * @method destory
		 */
		destory : function() {
			this.removeAllBehaviours();
			this.energy = 0;
			this.dead = true;
			this.parent = null;
		}
	};

	Proton.Particle = Particle;




	function ParticlePool(num, releaseTime) {
		this.proParticleCount = Proton.Util.initValue(num, 0);
		this.releaseTime = Proton.Util.initValue(releaseTime, -1);
		this.poolList = [];
		this.timeoutID = 0;
		for (var i = 0; i < this.proParticleCount; i++) {
			this.add();
		}
		//////////////////////////////
		if (this.releaseTime > 0)
			this.timeoutID = setTimeout(this.release, this.releaseTime / 1000);
	}


	ParticlePool.prototype = {
		create : function(newTypeParticleClass) {
			if (newTypeParticleClass)
				return new newTypeParticle;
			else
				return new Proton.Particle;
		},
		getCount : function() {
			return this.poolList.length;
		},
		add : function() {
			return this.poolList.push(this.create());
		},
		get : function() {
			if (this.poolList.length === 0) {
				return this.create();
			} else {
				return this.poolList.pop().reset();
			}

		},
		set : function(particle) {
			if (this.poolList.length < Proton.POOL_MAX)
				return this.poolList.push(particle);
		},
		release : function() {
			for (var i = 0; i < this.poolList.length; i++) {
				if (this.poolList[i]['destory'])
					this.poolList[i].destory();
				delete this.poolList[i];
			}
			this.poolList = [];
		}
	}

	Proton.ParticlePool = ParticlePool;




	var MathUtils = {
		randomAToB : function(a, b, INT) {
			if (!INT)
				return a + Math.random() * (b - a );
			else
				return Math.floor(Math.random() * (b - a)) + a;
		},
		randomFloating : function(center, f, INT) {
			return MathUtils.randomAToB(center - f, center + f, INT);
		},
		randomZone : function(display) {

		},

		degreeTransform : function(a) {
			return a * Math.PI / 180;
		},

		toColor16 : function getRGB(num) {
			return "#" + num.toString(16);
		},
		
		randomColor : function() {
			return '#' + ('00000' + (Math.random() * 0x1000000 << 0).toString(16)).slice(-6);
		}
	}

	Proton.MathUtils = MathUtils;


//数值积分

	var NumericalIntegration = function(type) {
		this.type = Proton.Util.initValue(type, Proton.EULER);
	}

	NumericalIntegration.prototype = {
		integrate : function(particles, time, damping) {
			this.eulerIntegrate(particles, time, damping);
		},

		eulerIntegrate : function(particle, time, damping) {
			if (!particle.sleep) {
				particle.old.p.copy(particle.p);
				particle.old.v.copy(particle.v);
				particle.a.multiplyScalar(1 / particle.mass);
				particle.v.add(particle.a.multiplyScalar(time));
				particle.p.add(particle.old.v.multiplyScalar(time));
				if (damping)
					particle.v.multiplyScalar(damping);
				particle.a.clear();
			}
		}
	}

	Proton.NumericalIntegration = NumericalIntegration;


//@author mrdoob / http://mrdoob.com/

	var Vector2D = function(x, y) {
		this.x = x || 0;
		this.y = y || 0;
	}

	Vector2D.prototype = {
		set : function(x, y) {

			this.x = x;
			this.y = y;
			return this;

		},

		setX : function(x) {

			this.x = x;
			return this;

		},

		setY : function(y) {

			this.y = y;

			return this;

		},

		setComponent : function(index, value) {

			switch ( index ) {

				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				default:
					throw new Error("index is out of range: " + index);

			}

		},

		getGradient : function() {
			if (this.x != 0)
				return Math.atan2(this.y, this.x);
			else if (this.y > 0)
				return Math.PI / 2;
			else if (this.y < 0)
				return -Math.PI / 2;
		},

		getComponent : function(index) {

			switch ( index ) {

				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw new Error("index is out of range: " + index);

			}

		},

		copy : function(v) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add : function(v, w) {

			if (w !== undefined) {
				return this.addVectors(v, w);

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addXY : function(a, b) {

			this.x += a;
			this.y += b;

			return this;

		},

		addVectors : function(a, b) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScalar : function(s) {

			this.x += s;
			this.y += s;

			return this;

		},

		sub : function(v, w) {

			if (w !== undefined) {
				return this.subVectors(v, w);

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subVectors : function(a, b) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiplyScalar : function(s) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divideScalar : function(s) {

			if (s !== 0) {

				this.x /= s;
				this.y /= s;

			} else {

				this.set(0, 0);

			}

			return this;

		},

		min : function(v) {

			if (this.x > v.x) {

				this.x = v.x;

			}

			if (this.y > v.y) {

				this.y = v.y;

			}

			return this;

		},

		max : function(v) {

			if (this.x < v.x) {

				this.x = v.x;

			}

			if (this.y < v.y) {

				this.y = v.y;

			}

			return this;

		},

		clamp : function(min, max) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if (this.x < min.x) {

				this.x = min.x;

			} else if (this.x > max.x) {

				this.x = max.x;

			}

			if (this.y < min.y) {

				this.y = min.y;

			} else if (this.y > max.y) {

				this.y = max.y;

			}

			return this;

		},

		negate : function() {

			return this.multiplyScalar(-1);

		},

		dot : function(v) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq : function() {

			return this.x * this.x + this.y * this.y;

		},

		length : function() {

			return Math.sqrt(this.x * this.x + this.y * this.y);

		},

		normalize : function() {

			return this.divideScalar(this.length());

		},

		distanceTo : function(v) {

			return Math.sqrt(this.distanceToSquared(v));

		},

		rotate : function(tha) {
			var x = this.x;
			var y = this.y;
			this.x = x * Math.cos(tha) + y * Math.sin(tha);
			this.y = -x * Math.sin(tha) + y * Math.cos(tha);
			return this;
		},

		distanceToSquared : function(v) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength : function(l) {

			var oldLength = this.length();

			if (oldLength !== 0 && l !== oldLength) {

				this.multiplyScalar(l / oldLength);
			}

			return this;

		},

		lerp : function(v, alpha) {

			this.x += (v.x - this.x ) * alpha;
			this.y += (v.y - this.y ) * alpha;

			return this;

		},

		equals : function(v) {

			return ((v.x === this.x ) && (v.y === this.y ) );

		},

		toArray : function() {

			return [this.x, this.y];

		},

		clear : function() {
			this.x = 0.0;
			this.y = 0.0;
			return this;
		},

		clone : function() {

			return new Proton.Vector2D(this.x, this.y);

		}
	};

	Proton.Vector2D = Vector2D;



	var Polar2D = function(r, tha) {
		this.r = Math.abs(r) || 0;
		this.tha = tha || 0;
	}

	Polar2D.prototype = {
		set : function(r, tha) {

			this.r = r;
			this.tha = tha;
			return this;

		},

		setR : function(r) {

			this.r = r;
			return this;

		},

		setTha : function(tha) {

			this.tha = tha;

			return this;

		},

		copy : function(p) {

			this.r = p.r;
			this.tha = p.tha;

			return this;

		},

		toVector : function() {
			return new Proton.Vector2D(this.getX(), this.getY());
		},

		getX : function() {
			return this.r * Math.sin(this.tha);
		},

		getY : function() {
			return -this.r * Math.cos(this.tha);
		},

		normalize : function() {

			this.r = 1;
			return this;
		},

		equals : function(v) {

			return ((v.r === this.r ) && (v.tha === this.tha ) );

		},

		toArray : function() {

			return [this.r, this.tha];

		},

		clear : function() {
			this.r = 0.0;
			this.tha = 0.0;
			return this;
		},

		clone : function() {

			return new Proton.Polar2D(this.r, this.tha);

		}
	};

	Proton.Polar2D = Polar2D;



	function Span(a, b, center) {
		this.isArray = false;

		if (Proton.Util.isArray(a)) {
			this.isArray = true;
			this.a = a;
		} else {
			this.a = Proton.Util.initValue(a, 1);
			this.b = Proton.Util.initValue(b, this.a);
			this.center = Proton.Util.initValue(center, false);
		}
	}


	Span.prototype = {
		getValue : function(INT) {
			if (this.isArray) {
				return this.a[Math.floor(this.a.length * Math.random())];
			} else {
				if (!this.center)
					return Proton.MathUtils.randomAToB(this.a, this.b, INT);
				else
					return Proton.MathUtils.randomFloating(this.a, this.b, INT);
			}
		}
	}

	Proton.Span = Span;
	Proton.getSpan = function(a, b, center) {
		return new Proton.Span(a, b, center);
	}



	function ColorSpan(color) {
		if (Proton.Util.isArray(color)) {
			this.colorArr = color;
		} else {
			this.colorArr = [color];
		}
	}


	Proton.Util.inherits(ColorSpan, Proton.Span);
	ColorSpan.prototype.getValue = function() {
		var color = this.colorArr[Math.floor(this.colorArr.length * Math.random())];
		if (color == 'random' || color == 'Random')
			return Proton.MathUtils.randomColor();
		else
			return color;
	}

	Proton.ColorSpan = ColorSpan;



	function Rectangle(x, y, w, h) {
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.bottom = this.y + this.height;
		this.right = this.x + this.width;
	}


	Rectangle.prototype = {
		contains : function(x, y) {
			if (x <= this.right && x >= this.x && y <= this.bottom && y >= this.y)
				return true
			else
				return false
		}
	}

	Proton.Rectangle = Rectangle;



	var Mat3 = Mat3 || {
		create : function(mat3) {
			var mat = new Float32Array(9);
			if (mat3)
				this.set(mat3, mat);
			return mat;
		},
		set : function(mat1, mat2) {
			for (var i = 0; i < 9; i++)
				mat2[i] = mat1[i];
			return mat2;
		},
		multiply : function(mat, mat2, mat3) {
			var a00 = mat[0], a01 = mat[1], a02 = mat[2], a10 = mat[3], a11 = mat[4], a20 = mat[6], a21 = mat[7], b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b10 = mat2[3], b11 = mat2[4], b20 = mat2[6], b21 = mat2[7];

			mat3[0] = b00 * a00 + b01 * a10;
			mat3[1] = b00 * a01 + b01 * a11;
			mat3[2] = a02 * b02;
			mat3[3] = b10 * a00 + b11 * a10;
			mat3[4] = b10 * a01 + b11 * a11;
			mat3[6] = b20 * a00 + b21 * a10 + a20;
			mat3[7] = b20 * a01 + b21 * a11 + a21;
			return mat3;
		},
		inverse : function(mat, mat3) {
			var a00 = mat[0], a01 = mat[1], a10 = mat[3], a11 = mat[4], a20 = mat[6], a21 = mat[7], b01 = a11, b11 = -a10, b21 = a21 * a10 - a11 * a20, d = a00 * b01 + a01 * b11, id;
			id = 1 / d;
			mat3[0] = b01 * id;
			mat3[1] = (-a01 ) * id;
			mat3[3] = b11 * id;
			mat3[4] = a00 * id;
			mat3[6] = b21 * id;
			mat3[7] = (-a21 * a00 + a01 * a20) * id;
			return mat3;
		},
		multiplyVec2 : function(m, vec, mat3) {
			var x = vec[0], y = vec[1];
			mat3[0] = x * m[0] + y * m[3] + m[6];
			mat3[1] = x * m[1] + y * m[4] + m[7];
			return mat3;
		}
	}

	Proton.Mat3 = Mat3;



	Behaviour.id = 0;
	/**
	 * The Behaviour class is the base for the other Behaviour
	 *
	 * @class Behaviour
	 * @constructor
	 */
	function Behaviour(life, easing) {
		/**
		 * The behaviour's id;
		 * @property id
		 * @type {String} id
		 */
		this.id = 'Behaviour_' + Behaviour.id++;
		this.life = Proton.Util.initValue(life, Infinity);
		/**
		 * The behaviour's decaying trend, for example Proton.easeOutQuart;
		 * @property easing
		 * @type {String}
		 * @default Proton.easeLinear
		 */
		this.easing = Proton.ease.setEasingByName(easing);
		this.age = 0;
		this.energy = 1;
		/**
		 * The behaviour is Dead;
		 * @property dead
		 * @type {Boolean}
		 */
		this.dead = false;
		/**
		 * The behaviour's parents array;
		 * @property parents
		 * @type {Array}
		 */
		this.parents = [];
		/**
		 * The behaviour name;
		 * @property name
		 * @type {string}
		 */
		this.name = 'Behaviour';
	}


	Behaviour.prototype = {
		/**
		 * Reset this behaviour's parameters
		 *
		 * @method reset
		 * @param {Number} this behaviour's life
		 * @param {String} this behaviour's easing
		 */
		reset : function(life, easing) {
			this.life = Proton.Util.initValue(life, Infinity);
			this.easing = Proton.Util.initValue(easing, Proton.ease.setEasingByName(Proton.easeLinear));
		},
		/**
		 * Normalize a force by 1:100;
		 *
		 * @method normalizeForce
		 * @param {Proton.Vector2D} force 
		 */
		normalizeForce : function(force) {
			return force.multiplyScalar(Proton.MEASURE);
		},

		/**
		 * Normalize a value by 1:100;
		 *
		 * @method normalizeValue
		 * @param {Number} value
		 */
		normalizeValue : function(value) {
			return value * Proton.MEASURE;
		},

		/**
		 * Initialize the behaviour's parameters for all particles
		 *
		 * @method initialize
		 * @param {Proton.Particle} particle
		 */
		initialize : function(particle) {
		},
		
		/**
		 * Apply this behaviour for all particles every time
		 *
		 * @method applyBehaviour
		 * @param {Proton.Particle} particle
		 * @param {Number} the integrate time 1/ms
		 * @param {Int} the particle index
		 */
		applyBehaviour : function(particle, time, index) {
			this.age += time;
			if (this.age >= this.life || this.dead) {
				this.energy = 0;
				this.dead = true;
				this.destory();
			} else {
				var scale = this.easing(particle.age / particle.life);
				this.energy = Math.max(1 - scale, 0);
			}
		},
		
		/**
		 * Destory this behaviour
		 * @method destory
		 */
		destory : function() {
			var index;
			var length = this.parents.length, i;
			for ( i = 0; i < length; i++) {
				this.parents[i].removeBehaviour(this);
			}

			this.parents = [];
		}
	};

	Proton.Behaviour = Behaviour;



	/**
	 * The number of particles per second emission (a [particle]/b [s]);
	 * @class Proton.Rate
	 * @constructor
	 * @param {Array or Number or Proton.Span} numpan the number of each emission;
	 * @param {Array or Number or Proton.Span} timepan the time of each emission;
	 * for example: new Proton.Rate(new Proton.Span(10, 20), new Proton.Span(.1, .25));
	 */
	function Rate(numpan, timepan) {
		this.numPan = Proton.Util.initValue(numpan, 1);
		this.timePan = Proton.Util.initValue(timepan, 1);
		this.numPan = Proton.Util.setSpanValue(this.numPan);
		this.timePan = Proton.Util.setSpanValue(this.timePan);
		this.startTime = 0;
		this.nextTime = 0;
		this.init();
	}


	Rate.prototype = {
		init : function() {
			this.startTime = 0;
			this.nextTime = this.timePan.getValue();
		},

		getValue : function(time) {
			this.startTime += time;
			if (this.startTime >= this.nextTime) {
				this.startTime = 0;
				this.nextTime = this.timePan.getValue();
				if (this.numPan.b == 1) {
					if (this.numPan.getValue(false) > 0.5)
						return 1;
					else
						return 0;
				} else {
					return this.numPan.getValue(true);
				}
			}
			return 0;
		}
	}

	Proton.Rate = Rate;



	function Initialize() {

	}


	Initialize.prototype.reset = function() {

	}

	Initialize.prototype.init = function(emitter, particle) {
		if (particle) {
			this.initialize(particle);
		} else {
			this.initialize(emitter);
		}
	};

	///sub class init
	Initialize.prototype.initialize = function(target) {
	};

	Proton.Initialize = Initialize;



	var InitializeUtil = {

		initialize : function(emitter, particle, initializes) {
			var length = initializes.length, i;
			for ( i = 0; i < length; i++) {
				if (initializes[i] instanceof Proton.Initialize)
					initializes[i].init(emitter, particle);
				else
					Proton.InitializeUtil.init(emitter, particle, initializes[i]);
			}

			Proton.InitializeUtil.bindEmitter(emitter, particle);
		},
		
		//////////////////////init//////////////////////
		init : function(emitter, particle, initialize) {
			Proton.Util.setPrototypeByObject(particle, initialize);
			Proton.Util.setVector2DByObject(particle, initialize);
		},

		bindEmitter : function(emitter, particle) {
			if (emitter.bindEmitter) {
				particle.p.add(emitter.p);
				particle.v.add(emitter.v);
				particle.a.add(emitter.a);
				particle.v.rotate(Proton.MathUtils.degreeTransform(emitter.rotation));
			}
		}
		//////////////////////init//////////////////////
	}

	Proton.InitializeUtil = InitializeUtil;



	function Life(a, b, c) {
		Life._super_.call(this);
		this.lifePan = Proton.Util.setSpanValue(a, b, c);
	}


	Proton.Util.inherits(Life, Proton.Initialize);
	Life.prototype.initialize = function(target) {
		if (this.lifePan.a == Infinity)
			target.life = Infinity;
		else
			target.life = this.lifePan.getValue();
	};

	Proton.Life = Life;



	function Position(zone) {
		Position._super_.call(this);
		this.zone = Proton.Util.initValue(zone, new Proton.PointZone());
	}


	Proton.Util.inherits(Position, Proton.Initialize);
	Position.prototype.reset = function(zone) {
		this.zone = Proton.Util.initValue(zone, new Proton.PointZone());
	};

	Position.prototype.initialize = function(target) {
		this.zone.getPosition();
		target.p.x = this.zone.vector.x;
		target.p.y = this.zone.vector.y;
	};

	Proton.Position = Position;
	Proton.P = Position;



	//radius and tha
	function Velocity(rpan, thapan, type) {
		Velocity._super_.call(this);
		this.rPan = Proton.Util.setSpanValue(rpan);
		this.thaPan = Proton.Util.setSpanValue(thapan);
		this.type = Proton.Util.initValue(type, 'vector');
	}


	Proton.Util.inherits(Velocity, Proton.Initialize);

	Velocity.prototype.reset = function(rpan, thapan, type) {
		this.rPan = Proton.Util.setSpanValue(rpan);
		this.thaPan = Proton.Util.setSpanValue(thapan);
		this.type = Proton.Util.initValue(type, 'vector');
	};

	Velocity.prototype.normalizeVelocity = function(vr) {
		return vr * Proton.MEASURE;
	}

	Velocity.prototype.initialize = function(target) {
		if (this.type == 'p' || this.type == 'P' || this.type == 'polar') {
			var polar2d = new Proton.Polar2D(this.normalizeVelocity(this.rPan.getValue()), this.thaPan.getValue() * Math.PI / 180);
			target.v.x = polar2d.getX();
			target.v.y = polar2d.getY();
		} else {
			target.v.x = this.normalizeVelocity(this.rPan.getValue());
			target.v.y = this.normalizeVelocity(this.thaPan.getValue());
		}
	};

	Proton.Velocity = Velocity;
	Proton.V = Velocity;



	function Mass(a, b, c) {
		Mass._super_.call(this);
		this.massPan = Proton.Util.setSpanValue(a, b, c);
	}


	Proton.Util.inherits(Mass, Proton.Initialize);
	Mass.prototype.initialize = function(target) {
		target.mass = this.massPan.getValue();
	};

	Proton.Mass = Mass;



	function Radius(a, b, c) {
		Radius._super_.call(this);
		this.radius = Proton.Util.setSpanValue(a, b, c);
	}


	Proton.Util.inherits(Radius, Proton.Initialize);
	Radius.prototype.reset = function(a, b, c) {
		this.radius = Proton.Util.setSpanValue(a, b, c);
	};

	Radius.prototype.initialize = function(particle) {
		particle.radius = this.radius.getValue();
		particle.transform.oldRadius = particle.radius;
	};

	Proton.Radius = Radius;



	function ImageTarget(image, w, h) {
		ImageTarget._super_.call(this);
		this.image = this.setSpanValue(image);
		this.w = Proton.Util.initValue(w, 20);
		this.h = Proton.Util.initValue(h, this.w);
	}


	Proton.Util.inherits(ImageTarget, Proton.Initialize);
	ImageTarget.prototype.initialize = function(particle) {
		var imagetarget = this.image.getValue();
		if ( typeof (imagetarget) == 'string') {
			particle.target = {
				width : this.w,
				height : this.h,
				src : imagetarget
			}
		} else {
			particle.target = imagetarget;
		}
	};

	ImageTarget.prototype.setSpanValue = function(color) {
		if ( color instanceof Proton.ColorSpan) {
			return color;
		} else {
			return new Proton.ColorSpan(color);
		}
	}

	Proton.ImageTarget = ImageTarget;



	function Force(fx, fy, life, easing) {
		Force._super_.call(this, life, easing);
		this.force = this.normalizeForce(new Proton.Vector2D(fx, fy));
		this.name = "Force";
	}


	Proton.Util.inherits(Force, Proton.Behaviour);
	Force.prototype.reset = function(fx, fy, life, easing) {
		this.force = this.normalizeForce(new Proton.Vector2D(fx, fy));
		if (life)
			Force._super_.prototype.reset.call(this, life, easing);
	}

	Force.prototype.applyBehaviour = function(particle, time, index) {
		Force._super_.prototype.applyBehaviour.call(this, particle, time, index);
		particle.a.add(this.force);
	};

	Proton.Force = Force;
	Proton.F = Force;



	function Attraction(targetPosition, force, radius, life, easing) {
		Attraction._super_.call(this, life, easing);
		this.targetPosition = Proton.Util.initValue(targetPosition, new Proton.Vector2D);
		this.radius = Proton.Util.initValue(radius, 1000);
		this.force = Proton.Util.initValue(this.normalizeValue(force), 100);
		this.radiusSq = this.radius * this.radius
		this.attractionForce = new Proton.Vector2D();
		this.lengthSq = 0;
		this.name = "Attraction";
	}


	Proton.Util.inherits(Attraction, Proton.Behaviour);
	Attraction.prototype.reset = function(targetPosition, force, radius, life, easing) {
		this.targetPosition = Proton.Util.initValue(targetPosition, new Proton.Vector2D);
		this.radius = Proton.Util.initValue(radius, 1000);
		this.force = Proton.Util.initValue(this.normalizeValue(force), 100);
		this.radiusSq = this.radius * this.radius
		this.attractionForce = new Proton.Vector2D();
		this.lengthSq = 0;
		if (life)
			Attraction._super_.prototype.reset.call(this, life, easing);
	}

	Attraction.prototype.applyBehaviour = function(particle, time, index) {
		Attraction._super_.prototype.applyBehaviour.call(this, particle, time, index);
		this.attractionForce.copy(this.targetPosition);
		this.attractionForce.sub(particle.p);
		this.lengthSq = this.attractionForce.lengthSq();
		if (this.lengthSq > 0.000004 && this.lengthSq < this.radiusSq) {
			this.attractionForce.normalize();
			this.attractionForce.multiplyScalar(1 - this.lengthSq / this.radiusSq);
			this.attractionForce.multiplyScalar(this.force);
			particle.a.add(this.attractionForce);
		}
	};

	Proton.Attraction = Attraction;




	function RandomDrift(driftX, driftY, delay, life, easing) {
		RandomDrift._super_.call(this, life, easing);
		this.reset(driftX, driftY, delay);
		this.time = 0;
		this.name = "RandomDrift";
	}


	Proton.Util.inherits(RandomDrift, Proton.Behaviour);
	RandomDrift.prototype.reset = function(driftX, driftY, delay, life, easing) {
		this.panFoce = new Proton.Vector2D(driftX, driftY);
		this.panFoce = this.normalizeForce(this.panFoce);
		this.delay = delay;
		if (life)
			RandomDrift._super_.prototype.reset.call(this, life, easing);
	}

	RandomDrift.prototype.applyBehaviour = function(particle, time, index) {
		RandomDrift._super_.prototype.applyBehaviour.call(this, particle, time, index);
		this.time += time;
		if (this.time >= this.delay) {
			
			particle.a.addXY(Proton.MathUtils.randomAToB(-this.panFoce.x, this.panFoce.x), Proton.MathUtils.randomAToB(-this.panFoce.y, this.panFoce.y));
			this.time = 0;
		};
	};

	Proton.RandomDrift = RandomDrift;



	function Repulsion(targetPosition, force, radius, life, easing) {
		Repulsion._super_.call(this, targetPosition, force, radius, life, easing);
		this.force *= -1;
		this.name = "Repulsion";
	}


	Proton.Util.inherits(Repulsion, Proton.Attraction);
	Repulsion.prototype.reset = function(targetPosition, force, radius, life, easing) {
		Repulsion._super_.prototype.reset.call(this, targetPosition, force, radius, life, easing);
		this.force *= -1;
	}
	Proton.Repulsion = Repulsion;




	function Gravity(g, life, easing) {
		Gravity._super_.call(this, 0, g, life, easing);
		this.name = "Gravity";
	}


	Proton.Util.inherits(Gravity, Proton.Force);
	Gravity.prototype.reset = function(g, life, easing) {
		Gravity._super_.prototype.reset.call(this, 0, g, life, easing);
	}
	Proton.Gravity = Gravity;
	Proton.G = Gravity;



	//can use Collision(emitter,true,function(){}) or Collision();
	function Collision(emitter, mass, callback, life, easing) {
		Collision._super_.call(this, life, easing);
		this.reset(emitter, mass, callback);
		this.name = "Collision";
	}


	Proton.Util.inherits(Collision, Proton.Behaviour);
	Collision.prototype.reset = function(emitter, mass, callback, life, easing) {
		this.emitter = Proton.Util.initValue(emitter, null);
		this.mass = Proton.Util.initValue(mass, true);
		this.callback = Proton.Util.initValue(callback, null);
		this.collisionPool = [];
		this.delta = new Proton.Vector2D();
		if (life)
			Collision._super_.prototype.reset.call(this, life, easing);
	}

	Collision.prototype.applyBehaviour = function(particle, time, index) {
		var newPool = this.emitter ? this.emitter.particles.slice(index) : this.pool.slice(index);
		var otherParticle;
		var lengthSq;
		var overlap;
		var averageMass1, averageMass2;
		var length = newPool.length;
		for (var i = 0; i < length; i++) {
			otherParticle = newPool[i];
			if (otherParticle !== particle) {
				this.delta.copy(otherParticle.p);
				this.delta.sub(particle.p);
				lengthSq = this.delta.lengthSq();
				distance = particle.radius + otherParticle.radius;

				if (lengthSq <= distance * distance) {
					overlap = distance - Math.sqrt(lengthSq);
					overlap += 0.5;
					totalMass = particle.mass + otherParticle.mass;
					averageMass1 = this.mass ? otherParticle.mass / totalMass : 0.5;
					averageMass2 = this.mass ? particle.mass / totalMass : 0.5;
					particle.p.add(this.delta.clone().normalize().multiplyScalar(overlap * -averageMass1));
					otherParticle.p.add(this.delta.normalize().multiplyScalar(overlap * averageMass2));
					if (this.callback)
						this.callback(particle, otherParticle);
				}
			}
		}
	};

	Proton.Collision = Collision;




	function CrossZone(zone, crossType, life, easing) {
		CrossZone._super_.call(this, life, easing);
		this.reset(zone, crossType);
		///dead /bound /cross
		this.name = "CrossZone";
	}


	Proton.Util.inherits(CrossZone, Proton.Behaviour);
	CrossZone.prototype.reset = function(zone, crossType, life, easing) {
		this.zone = zone;
		this.zone.crossType = Proton.Util.initValue(crossType, "dead");
		if (life)
			CrossZone._super_.prototype.reset.call(this, life, easing);
	}

	CrossZone.prototype.applyBehaviour = function(particle, time, index) {
		CrossZone._super_.prototype.applyBehaviour.call(this, particle, time, index);
		this.zone.crossing(particle);
	};

	Proton.CrossZone = CrossZone;



	function Alpha(a, b, life, easing) {
		Alpha._super_.call(this, life, easing);
		this.reset(a, b);
		/**
		 * The Behaviour name;
		 * @property name
		 * @type {string}
		 */
		this.name = "Alpha";
	}


	Proton.Util.inherits(Alpha, Proton.Behaviour);
	Alpha.prototype.reset = function(a, b, life, easing) {
		if (b == null || b == undefined)
			this.same = true;
		else
			this.same = false;
		this.a = Proton.Util.setSpanValue(Proton.Util.initValue(a, 1));
		this.b = Proton.Util.setSpanValue(b);
		if (life)
			Alpha._super_.prototype.reset.call(this, life, easing);
	}

	Alpha.prototype.initialize = function(particle) {
		particle.transform.alphaA = this.a.getValue();
		if (this.same)
			particle.transform.alphaB = particle.transform.alphaA;
		else
			particle.transform.alphaB = this.b.getValue();
	};

	Alpha.prototype.applyBehaviour = function(particle, time, index) {
		Alpha._super_.prototype.applyBehaviour.call(this, particle, time, index);
		particle.alpha = particle.transform.alphaB + (particle.transform.alphaA - particle.transform.alphaB) * this.energy;
		if (particle.alpha < 0.001)
			particle.alpha = 0;
	};

	Proton.Alpha = Alpha;



	function Scale(a, b, life, easing) {
		Scale._super_.call(this, life, easing);
		this.reset(a, b);
		this.name = "Scale";
	}


	Proton.Util.inherits(Scale, Proton.Behaviour);
	Scale.prototype.reset = function(a, b, life, easing) {
		if (b == null || b == undefined)
			this.same = true;
		else
			this.same = false;
		this.a = Proton.Util.setSpanValue(Proton.Util.initValue(a, 1));
		this.b = Proton.Util.setSpanValue(b);
		if (life)
			Scale._super_.prototype.reset.call(this, life, easing);
	}

	Scale.prototype.initialize = function(particle) {
		particle.transform.scaleA = this.a.getValue();
		particle.transform.oldRadius = particle.radius;
		if (this.same)
			particle.transform.scaleB = particle.transform.scaleA;
		else
			particle.transform.scaleB = this.b.getValue();

	};

	Scale.prototype.applyBehaviour = function(particle, time, index) {
		Scale._super_.prototype.applyBehaviour.call(this, particle, time, index);
		particle.scale = particle.transform.scaleB + (particle.transform.scaleA - particle.transform.scaleB) * this.energy;
		if (particle.scale < 0.0001)
			particle.scale = 0;
		particle.radius = particle.transform.oldRadius * particle.scale;
	};

	Proton.Scale = Scale;



	function Rotate(a, b, style, life, easing) {
		Rotate._super_.call(this, life, easing);
		this.reset(a, b, style);
		this.name = "Rotate";
	}


	Proton.Util.inherits(Rotate, Proton.Behaviour);
	Rotate.prototype.reset = function(a, b, style, life, easing) {
		if (b == null || b == undefined)
			this.same = true;
		else
			this.same = false;
		this.a = Proton.Util.setSpanValue(Proton.Util.initValue(a, "Velocity"));
		this.b = Proton.Util.setSpanValue(Proton.Util.initValue(b, 0));
		this.style = Proton.Util.initValue(style, 'to');
		if (life)
			Rotate._super_.prototype.reset.call(this, life, easing);
	}

	Rotate.prototype.initialize = function(particle) {
		particle.rotation = this.a.getValue();
		particle.transform.rotationA = this.a.getValue();
		if (!this.same)
			particle.transform.rotationB = this.b.getValue();
	};

	Rotate.prototype.applyBehaviour = function(particle, time, index) {
		Rotate._super_.prototype.applyBehaviour.call(this, particle, time, index);
		if (!this.same) {
			if (this.style == 'to' || this.style == 'TO' || this.style == '_') {
				particle.rotation += particle.transform.rotationB + (particle.transform.rotationA - particle.transform.rotationB) * this.energy
			} else {
				particle.rotation += particle.transform.rotationB;
			}
		} else if (this.a.a == "V" || this.a.a == "Velocity" || this.a.a == "v") {
			//beta...
			particle.rotation = particle.getDirection();
		}
	};

	Proton.Rotate = Rotate;



	function Color(color1, color2, life, easing) {
		Color._super_.call(this, life, easing);
		this.reset(color1, color2);
		this.name = "Color";
	}


	Proton.Util.inherits(Color, Proton.Behaviour);
	Color.prototype.reset = function(color1, color2, life, easing) {
		this.color1 = this.setSpanValue(color1);
		this.color2 = this.setSpanValue(color2);
		if (life)
			Color._super_.prototype.reset.call(this, life, easing);
	}

	Color.prototype.initialize = function(particle) {
		particle.color = this.color1.getValue();
		particle.transform.beginRGB = Proton.Util.hexToRGB(particle.color);

		if (this.color2)
			particle.transform.endRGB = Proton.Util.hexToRGB(this.color2.getValue());
	};

	Color.prototype.applyBehaviour = function(particle, time, index) {
		if (this.color2) {
			Color._super_.prototype.applyBehaviour.call(this, particle, time, index);
			particle.transform.rgb.r = particle.transform.endRGB.r + (particle.transform.beginRGB.r - particle.transform.endRGB.r) * this.energy;
			particle.transform.rgb.g = particle.transform.endRGB.g + (particle.transform.beginRGB.g - particle.transform.endRGB.g) * this.energy;
			particle.transform.rgb.b = particle.transform.endRGB.b + (particle.transform.beginRGB.b - particle.transform.endRGB.b) * this.energy;
			particle.transform.rgb.r = parseInt(particle.transform.rgb.r, 10);
			particle.transform.rgb.g = parseInt(particle.transform.rgb.g, 10);
			particle.transform.rgb.b = parseInt(particle.transform.rgb.b, 10);
		} else {
			particle.transform.rgb.r = particle.transform.beginRGB.r;
			particle.transform.rgb.g = particle.transform.beginRGB.g;
			particle.transform.rgb.b = particle.transform.beginRGB.b;

		}
	};

	Color.prototype.setSpanValue = function(color) {
		if (color) {
			if ( color instanceof Proton.ColorSpan) {
				return color;
			} else {
				return new Proton.ColorSpan(color);
			}
		} else {
			return null;
		}
	}

	Proton.Color = Color;



	function GravityWell(centerPoint, force, life, easing) {
		GravityWell._super_.call(this, life, easing);
		this.distanceVec = new Proton.Vector2D();
		this.centerPoint = Proton.Util.initValue(centerPoint, new Proton.Vector2D);
		this.force = Proton.Util.initValue(this.normalizeValue(force), 100);
		this.name = "GravityWell";
	}


	Proton.Util.inherits(GravityWell, Proton.Behaviour);
	GravityWell.prototype.reset = function(centerPoint, force, life, easing) {
		this.distanceVec = new Proton.Vector2D();
		this.centerPoint = Proton.Util.initValue(centerPoint, new Proton.Vector2D);
		this.force = Proton.Util.initValue(this.normalizeValue(force), 100);
		if (life)
			GravityWell._super_.prototype.reset.call(this, life, easing);
	};
	GravityWell.prototype.initialize = function(particle) {

	};

	GravityWell.prototype.applyBehaviour = function(particle, time, index) {
		this.distanceVec.set(this.centerPoint.x - particle.p.x, this.centerPoint.y - particle.p.y);
		var distanceSq = this.distanceVec.lengthSq();
		if (distanceSq != 0) {
			var distance = this.distanceVec.length();
			var factor = (this.force * time ) / (distanceSq * distance );
			particle.v.x += factor * this.distanceVec.x;
			particle.v.y += factor * this.distanceVec.y;
		}
	}

	Proton.GravityWell = GravityWell;



	Emitter.ID = 0;
	/**
	 * You can use this emit particles.
	 *
	 * It will dispatch follow events:
	 * Proton.PARTICLE_CREATED
	 * Proton.PARTICLE_UPDATA
	 * Proton.PARTICLE_DEAD
	 *
	 * @class Proton.Emitter
	 * @constructor
	 * @param {Object} pObj the parameters object;
	 * for example {damping:0.01,bindEmitter:false}
	 */
	function Emitter(pObj) {
		this.initializes = [];
		this.particles = [];
		this.behaviours = [];
		this.emitTime = 0;
		this.emitTotalTimes = -1;
		/**
		 * The friction coefficient for all particle emit by This;
		 * @property damping
		 * @type {Number}
		 * @default 0.006
		 */
		this.damping = .006;
		/**
		 * If bindEmitter the particles can bind this emitter's property;
		 * @property bindEmitter
		 * @type {Boolean}
		 * @default true
		 */
		this.bindEmitter = true;
		/**
		 * The number of particles per second emit (a [particle]/b [s]);
		 * @property rate
		 * @type {Proton.Rate}
		 * @default Proton.Rate(1, .1)
		 */
		this.rate = new Proton.Rate(1, .1);
		Emitter._super_.call(this, pObj);
		/**
		 * The emitter's id;
		 * @property id
		 * @type {String} id
		 */
		this.id = 'emitter_' + Emitter.ID++;
	};

	Proton.Util.inherits(Emitter, Proton.Particle);
	Proton.EventDispatcher.initialize(Emitter.prototype);
	/**
	 * start emit particle
	 * @method emit
	 * @param {Number} emitTime begin emit time;
	 * @param {String} life the life of this emitter
	 */
	Emitter.prototype.emit = function(emitTime, life) {
		this.emitTime = 0;
		this.emitTotalTimes = Proton.Util.initValue(emitTime, Infinity);

		if (life == true || life == 'life' || life == 'destroy') {
			if (emitTime == 'once')
				this.life = 1;
			else
				this.life = this.emitTotalTimes;
		} 
		
		if (life && !isNaN(life)) {
			this.life = life;
		}

		this.rate.init();
	};

	/**
	 * stop emiting
	 * @method stopEmit
	 */
	Emitter.prototype.stopEmit = function() {
		this.emitTotalTimes = -1;
		this.emitTime = 0;
	};

	/**
	 * remove current all particles
	 * @method removeAllParticles
	 */
	Emitter.prototype.removeAllParticles = function() {
		for (var i = 0; i < this.particles.length; i++)
			this.particles[i].dead = true;
	};
	/**
	 * create single particle;
	 * 
	 * can use emit({x:10},new Gravity(10),{'particleUpdate',fun}) or emit([{x:10},new Initialize],new Gravity(10),{'particleUpdate',fun})
	 * @method removeAllParticles
	 */
	Emitter.prototype.createParticle = function(initialize, behaviour) {
		var particle = Proton.pool.get();
		this.setupParticle(particle, initialize, behaviour);
		this.dispatchEvent(new Proton.Event({
			type : Proton.PARTICLE_CREATED,
			particle : particle
		}));
		return particle;
	};
	/**
	 * add initialize to this emitter
	 * @method addSelfInitialize
	 */
	Emitter.prototype.addSelfInitialize = function(pObj) {
		if (pObj['init']) {
			pObj.init(this);
		} else {
			this.initAll();
		}
	};
	/**
	 * add the Initialize to particles;
	 * 
	 * you can use initializes array:for example emitter.addInitialize(initialize1,initialize2,initialize3);
	 * @method addInitialize
	 * @param {Proton.Initialize} initialize like this new Proton.Radius(1, 12)
	 */
	Emitter.prototype.addInitialize = function() {
		var length = arguments.length, i;
		for ( i = 0; i < length; i++) {
			this.initializes.push(arguments[i]);
		}
	};
	/**
	 * remove the Initialize
	 * @method removeInitialize
	 * @param {Proton.Initialize} initialize a initialize
	 */
	Emitter.prototype.removeInitialize = function(initializer) {
		var index = this.initializes.indexOf(initializer);
		if (index > -1) {
			this.initializes.splice(index, 1);
		}
	};

	/**
	 * remove all Initializes
	 * @method removeInitializers
	 */
	Emitter.prototype.removeInitializers = function() {
		Proton.Util.destroyArray(this.initializes);
	};
	/**
	 * add the Behaviour to particles;
	 * 
	 * you can use Behaviours array:emitter.addBehaviour(Behaviour1,Behaviour2,Behaviour3);
	 * @method addBehaviour
	 * @param {Proton.Behaviour} behaviour like this new Proton.Color('random')
	 */
	Emitter.prototype.addBehaviour = function() {
		var length = arguments.length, i;
		for ( i = 0; i < length; i++) {
			this.behaviours.push(arguments[i]);
			if (arguments[i].hasOwnProperty("parents"))
				arguments[i].parents.push(this);
		}
	};
	/**
	 * remove the Behaviour
	 * @method removeBehaviour
	 * @param {Proton.Behaviour} behaviour a behaviour
	 */
	Emitter.prototype.removeBehaviour = function(behaviour) {
		var index = this.behaviours.indexOf(behaviour);
		if (index > -1)
			this.behaviours.splice(index, 1);
	};
	/**
	 * remove all behaviours
	 * @method removeAllBehaviours
	 */
	Emitter.prototype.removeAllBehaviours = function() {
		Proton.Util.destroyArray(this.behaviours);
	};

	Emitter.prototype.integrate = function(time) {
		var damping = 1 - this.damping;
		Proton.integrator.integrate(this, time, damping);
		var length = this.particles.length, i;
		for ( i = 0; i < length; i++) {
			var particle = this.particles[i];
			particle.update(time, i);
			Proton.integrator.integrate(particle, time, damping);

			this.dispatchEvent(new Proton.Event({
				type : Proton.PARTICLE_UPDATE,
				particle : particle
			}));
		}
	};

	Emitter.prototype.emitting = function(time) {
		if (this.emitTotalTimes == 'once') {
			var length = this.rate.getValue(99999), i;
			for ( i = 0; i < length; i++) {
				this.createParticle();
			}

			this.emitTotalTimes = 'none';
		} else if (!isNaN(this.emitTotalTimes)) {
			this.emitTime += time;
			if (this.emitTime < this.emitTotalTimes) {
				var length = this.rate.getValue(time), i;
				for ( i = 0; i < length; i++) {
					this.createParticle();
				}
			}
		}
	}

	Emitter.prototype.update = function(time) {
		this.age += time;
		if (this.age >= this.life || this.dead) {
			this.destroy();
		}

		this.emitting(time);
		this.integrate(time);
		var particle;
		var length = this.particles.length, k;
		for ( k = length - 1; k >= 0; k--) {
			particle = this.particles[k];
			if (particle.dead) {
				Proton.pool.set(particle);
				this.particles.splice(k, 1);
				this.dispatchEvent(new Proton.Event({
					type : Proton.PARTICLE_DEAD,
					particle : particle
				}));
			}
		}
	};

	Emitter.prototype.setupParticle = function(particle, initialize, behaviour) {
		var initializes = this.initializes;
		var behaviours = this.behaviours;

		if (initialize) {
			if ( initialize instanceof Array)
				initializes = initialize;
			else
				initializes = [initialize];
		}

		if (behaviour) {
			if ( behaviour instanceof Array)
				behaviours = behaviour;
			else
				behaviours = [behaviour];
		}

		Proton.InitializeUtil.initialize(this, particle, initializes);
		particle.addBehaviours(behaviours);
		particle.parent = this;
		this.particles.push(particle);
	};

	/**
	 * Destory this Emitter
	 * @method destory
	 */
	Emitter.prototype.destroy = function() {
		this.dead = true;
		this.emitTotalTimes = -1;
		if (this.particles.length == 0) {
			this.removeInitializers();
			this.removeAllBehaviours();

			if (this.parent)
				this.parent.removeEmitter(this);
		}
	}

	Proton.Emitter = Emitter;



	/**
	 * The BehaviourEmitter class inherits from Proton.Emitter
	 *
	 * use the BehaviourEmitter you can add behaviours to self;
	 * @class Proton.BehaviourEmitter
	 * @constructor
	 * @param {Object} pObj the parameters object;
	 */
	function BehaviourEmitter(pObj) {
		this.selfBehaviours = [];
		BehaviourEmitter._super_.call(this, pObj);
	};

	Proton.Util.inherits(BehaviourEmitter, Proton.Emitter);
	/**
	 * add the Behaviour to emitter;
	 *
	 * you can use Behaviours array:emitter.addSelfBehaviour(Behaviour1,Behaviour2,Behaviour3);
	 * @method addSelfBehaviour
	 * @param {Proton.Behaviour} behaviour like this new Proton.Color('random')
	 */
	BehaviourEmitter.prototype.addSelfBehaviour = function() {
		var length = arguments.length, i;
		for ( i = 0; i < length; i++) {
			this.selfBehaviours.push(arguments[i]);
		}
	};
	/**
	 * remove the Behaviour for self
	 * @method removeSelfBehaviour
	 * @param {Proton.Behaviour} behaviour a behaviour
	 */
	BehaviourEmitter.prototype.removeSelfBehaviour = function(behaviour) {
		var index = this.selfBehaviours.indexOf(behaviour);
		if (index > -1)
			this.selfBehaviours.splice(index, 1);
	};

	BehaviourEmitter.prototype.update = function(time) {
		BehaviourEmitter._super_.prototype.update.call(this, time);

		if (!this.sleep) {
			var length = this.selfBehaviours.length, i;
			for ( i = 0; i < length; i++) {
				this.selfBehaviours[i].applyBehaviour(this, time, i)
			}
		}
	}

	Proton.BehaviourEmitter = BehaviourEmitter;



	/**
	 * The FollowEmitter class inherits from Proton.Emitter
	 *
	 * use the FollowEmitter will emit particle when mousemoving
	 *
	 * @class Proton.FollowEmitter
	 * @constructor
	 * @param {Element} mouseTarget mouseevent's target;
	 * @param {Number} ease the easing of following speed;
	 * @default 0.7
	 * @param {Object} pObj the parameters object;
	 */
	function FollowEmitter(mouseTarget, ease, pObj) {
		this.mouseTarget = Proton.Util.initValue(mouseTarget, window);
		this.ease = Proton.Util.initValue(ease, .7);
		this._allowEmitting = false;
		this.initEventHandler();
		FollowEmitter._super_.call(this, pObj);
	};

	Proton.Util.inherits(FollowEmitter, Proton.Emitter);
	FollowEmitter.prototype.initEventHandler = function() {
		var self = this;
		this.mousemoveHandler = function(e) {
			self.mousemove.call(self, e);
		};

		this.mousedownHandler = function(e) {
			self.mousedown.call(self, e);
		};

		this.mouseupHandler = function(e) {
			self.mouseup.call(self, e);
		};
		this.mouseTarget.addEventListener('mousemove', this.mousemoveHandler, false);
	}
	/**
	 * start emit particle
	 * @method emit
	 */
	FollowEmitter.prototype.emit = function() {
		this._allowEmitting = true;
	}
	/**
	 * stop emiting
	 * @method stopEmit
	 */
	FollowEmitter.prototype.stopEmit = function() {
		this._allowEmitting = false;
	}

	FollowEmitter.prototype.mousemove = function(e) {
		if (e.layerX || e.layerX == 0) {
			this.p.x += (e.layerX - this.p.x) * this.ease;
			this.p.y += (e.layerY - this.p.y) * this.ease;
		} else if (e.offsetX || e.offsetX == 0) {
			this.p.x += (e.offsetX - this.p.x) * this.ease;
			this.p.y += (e.offsetY - this.p.y) * this.ease;
		}
		if (this._allowEmitting)
			FollowEmitter._super_.prototype.emit.call(this, 'once');
	};
	/**
	 * Destory this Emitter
	 * @method destory
	 */
	FollowEmitter.prototype.destroy = function() {
		FollowEmitter._super_.prototype.destroy.call(this);
		this.mouseTarget.removeEventListener('mousemove', this.mousemoveHandler, false);
	}

	Proton.FollowEmitter = FollowEmitter;



	var ease = ease || {
		easeLinear : function(value) {
			return value;
		},

		easeInQuad : function(value) {
			return Math.pow(value, 2);
		},

		easeOutQuad : function(value) {
			return -(Math.pow((value - 1), 2) - 1);
		},

		easeInOutQuad : function(value) {
			if ((value /= 0.5) < 1)
				return 0.5 * Math.pow(value, 2);
			return -0.5 * ((value -= 2) * value - 2);
		},

		easeInCubic : function(value) {
			return Math.pow(value, 3);
		},

		easeOutCubic : function(value) {
			return (Math.pow((value - 1), 3) + 1);
		},

		easeInOutCubic : function(value) {
			if ((value /= 0.5) < 1)
				return 0.5 * Math.pow(value, 3);
			return 0.5 * (Math.pow((value - 2), 3) + 2);
		},

		easeInQuart : function(value) {
			return Math.pow(value, 4);
		},

		easeOutQuart : function(value) {
			return -(Math.pow((value - 1), 4) - 1);
		},

		easeInOutQuart : function(value) {
			if ((value /= 0.5) < 1)
				return 0.5 * Math.pow(value, 4);
			return -0.5 * ((value -= 2) * Math.pow(value, 3) - 2);
		},
	
		easeInSine : function(value) {
			return -Math.cos(value * (Math.PI / 2)) + 1;
		},

		easeOutSine : function(value) {
			return Math.sin(value * (Math.PI / 2));
		},

		easeInOutSine : function(value) {
			return (-0.5 * (Math.cos(Math.PI * value) - 1));
		},

		easeInExpo : function(value) {
			return (value === 0) ? 0 : Math.pow(2, 10 * (value - 1));
		},

		easeOutExpo : function(value) {
			return (value === 1) ? 1 : -Math.pow(2, -10 * value) + 1;
		},

		easeInOutExpo : function(value) {
			if (value === 0)
				return 0;
			if (value === 1)
				return 1;
			if ((value /= 0.5) < 1)
				return 0.5 * Math.pow(2, 10 * (value - 1));
			return 0.5 * (-Math.pow(2, -10 * --value) + 2);
		},

		easeInCirc : function(value) {
			return -(Math.sqrt(1 - (value * value)) - 1);
		},

		easeOutCirc : function(value) {
			return Math.sqrt(1 - Math.pow((value - 1), 2));
		},

		easeInOutCirc : function(value) {
			if ((value /= 0.5) < 1)
				return -0.5 * (Math.sqrt(1 - value * value) - 1);
			return 0.5 * (Math.sqrt(1 - (value -= 2) * value) + 1);
		},
		
		easeInBack : function(value) {
			var s = 1.70158;
			return (value) * value * ((s + 1) * value - s);
		},

		easeOutBack : function(value) {
			var s = 1.70158;
			return ( value = value - 1) * value * ((s + 1) * value + s) + 1;
		},

		easeInOutBack : function(value) {
			var s = 1.70158;
			if ((value /= 0.5) < 1)
				return 0.5 * (value * value * (((s *= (1.525)) + 1) * value - s));
			return 0.5 * ((value -= 2) * value * (((s *= (1.525)) + 1) * value + s) + 2);
		},

		setEasingByName : function(name) {
			switch (name) {
				case 'easeLinear':
					return Proton.ease.easeLinear;
					break;

				case 'easeInQuad':
					return Proton.ease.easeInQuad;
					break;

				case 'easeOutQuad':
					return Proton.ease.easeOutQuad;
					break;

				case 'easeInOutQuad':
					return Proton.ease.easeInOutQuad;
					break;

				case 'easeInCubic':
					return Proton.ease.easeInCubic;
					break;

				case 'easeOutCubic':
					return Proton.ease.easeOutCubic;
					break;

				case 'easeInOutCubic':
					return Proton.ease.easeInOutCubic;
					break;

				case 'easeInQuart':
					return Proton.ease.easeInQuart;
					break;

				case 'easeOutQuart':
					return Proton.ease.easeOutQuart;
					break;

				case 'easeInOutQuart':
					return Proton.ease.easeInOutQuart;
					break;

				case 'easeInSine':
					return Proton.ease.easeInSine;
					break;

				case 'easeOutSine':
					return Proton.ease.easeOutSine;
					break;

				case 'easeInOutSine':
					return Proton.ease.easeInOutSine;
					break;

				case 'easeInExpo':
					return Proton.ease.easeInExpo;
					break;

				case 'easeOutExpo':
					return Proton.ease.easeOutExpo;
					break;

				case 'easeInOutExpo':
					return Proton.ease.easeInOutExpo;
					break;

				case 'easeInCirc':
					return Proton.ease.easeInCirc;
					break;

				case 'easeOutCirc':
					return Proton.ease.easeOutCirc;
					break;

				case 'easeInOutCirc':
					return Proton.ease.easeInOutCirc;
					break;

				case 'easeInBack':
					return Proton.ease.easeInBack;
					break;

				case 'easeOutBack':
					return Proton.ease.easeOutBack;
					break;

				case 'easeInOutBack':
					return Proton.ease.easeInOutBack;
					break;
				
				default:
					return Proton.ease.easeLinear;
					break;
			}
		}
	}

	Proton.ease = ease;
	Proton.easeLinear = 'easeLinear';

	Proton.easeInQuad = 'easeInQuad';
	Proton.easeOutQuad = 'easeOutQuad';
	Proton.easeInOutQuad = 'easeInOutQuad';

	Proton.easeInCubic = 'easeInCubic';
	Proton.easeOutCubic = 'easeOutCubic';
	Proton.easeInOutCubic = 'easeInOutCubic';

	Proton.easeInQuart = 'easeInQuart';
	Proton.easeOutQuart = 'easeOutQuart';
	Proton.easeInOutQuart = 'easeInOutQuart';

	Proton.easeInSine = 'easeInSine';
	Proton.easeOutSine = 'easeOutSine';
	Proton.easeInOutSine = 'easeInOutSine';

	Proton.easeInExpo = 'easeInExpo';
	Proton.easeOutExpo = 'easeOutExpo';
	Proton.easeInOutExpo = 'easeInOutExpo';

	Proton.easeInCirc = 'easeInCirc';
	Proton.easeOutCirc = 'easeOutCirc';
	Proton.easeInOutCirc = 'easeInOutCirc';

	Proton.easeInBack = 'easeInBack';
	Proton.easeOutBack = 'easeOutBack';
	Proton.easeInOutBack = 'easeInOutBack';
	


//the own renderer

	function Renderer(type, proton, element) {
		///element dom/div canvas/canvas easeljs/cantainer(or stage)
		this.element = element;
		this.type = Proton.Util.initValue(type, 'canvas');
		this.proton = proton;
		this.renderer = this.getRenderer();
	}


	Renderer.prototype = {
		start : function() {
			this.addEventHandler();
			this.renderer.start();
		},
		stop : function() {
			this.renderer.stop();
		},

		resize : function(width, height) {
			this.renderer.resize(width, height);
		},
		setStroke : function(color, thinkness) {
			if (this.renderer.hasOwnProperty('stroke'))
				this.renderer.setStroke(color, thinkness);
			else
				alert('Sorry this renderer do not suppest stroke method!');
		},
		createImageData : function(data) {
			if (this.renderer instanceof Proton.PixelRender)
				this.renderer.createImageData(data);
		},
		setMaxRadius : function(radius) {
			if (this.renderer instanceof Proton.WebGLRender)
				this.renderer.setMaxRadius(radius);
		},
		blendEquation : function(A) {
			if (this.renderer instanceof Proton.WebGLRender)
				this.renderer.blendEquation(A);
		},
		blendFunc : function(A, B) {
			if (this.renderer instanceof Proton.WebGLRender)
				this.renderer.blendFunc(A, B);
		},
		setType : function(type) {
			this.type = type;
			this.renderer = this.getRenderer();
		},
		getRenderer : function() {
			switch(this.type) {
				case 'dom':
					return new Proton.DomRender(this.proton, this.element);
					break;

				case 'canvas':
					return new Proton.CanvasRender(this.proton, this.element);
					break;

				case 'webgl':
					return new Proton.WebGLRender(this.proton, this.element);
					break;

				case 'easel':
					return new Proton.EaselRender(this.proton, this.element);
					break;

				case 'easeljs':
					return new Proton.EaselRender(this.proton, this.element);
					break;

				case 'pixel':
					return new Proton.PixelRender(this.proton, this.element);
					break;

				default:
					return new Proton.BaseRender(this.proton, this.element);
			}
		},
		render : function(callback) {
			this.renderer.render(callback);
		},
		addEventHandler : function() {
			if (this.onProtonUpdate)
				this.renderer.onProtonUpdate = this.onProtonUpdate;

			if (this.onParticleCreated)
				this.renderer.onParticleCreated = this.onParticleCreated;

			if (this.onParticleUpdate)
				this.renderer.onParticleUpdate = this.onParticleUpdate;

			if (this.onParticleDead)
				this.renderer.onParticleDead = this.onParticleDead;
		}
	}

	Proton.Renderer = Renderer;



	function BaseRender(proton, element, stroke) {
		this.proton = proton;
		this.element = element;
		this.stroke = stroke;
	}


	BaseRender.prototype = {
		start : function() {
			var self = this;
			this.proton.addEventListener(Proton.PROTON_UPDATE, function(e) {
				self.onProtonUpdate.call(self);
			});

			this.proton.addEventListener(Proton.PROTON_UPDATE_AFTER, function(e) {
				self.onProtonUpdateAfter.call(self);
			});

			this.proton.addEventListener(Proton.EMITTER_ADDED, function(e) {
				self.onEmitterAdded.call(self, e.emitter);
			});

			this.proton.addEventListener(Proton.EMITTER_REMOVED, function(e) {
				self.onEmitterRemoved.call(self, e.emitter);
			});

			var length = this.proton.emitters.length, i;
			for ( i = 0; i < length; i++) {
				var emitter = this.proton.emitters[i];
				this.addEmitterListener(emitter);
			}
		},

		resize : function(width, height) {
		},

		addEmitterListener : function(emitter) {
			var self = this;
			emitter.addEventListener(Proton.PARTICLE_CREATED, function(e) {
				self.onParticleCreated.call(self, e.particle);
			});
			emitter.addEventListener(Proton.PARTICLE_UPDATE, function(e) {
				self.onParticleUpdate.call(self, e.particle);
			});
			emitter.addEventListener(Proton.PARTICLE_DEAD, function(e) {
				self.onParticleDead.call(self, e.particle);
			});
		},

		stop : function() {
			var length = this.proton.emitters.length, i;
			this.proton.removeAllEventListeners();
			for ( i = 0; i < length; i++) {
				var emitter = this.proton.emitters[i];
				emitter.removeAllEventListeners();
			}
		},

		onEmitterAdded : function(emitter) {
			this.addEmitterListener(emitter);
		},

		onEmitterRemoved : function(emitter) {
			emitter.removeAllEventListeners();
		},

		onProtonUpdate : function() {

		},

		onProtonUpdateAfter : function() {

		},

		onParticleCreated : function(particle) {

		},

		onParticleUpdate : function(particle) {

		},

		onParticleDead : function(particle) {

		}
	}

	Proton.BaseRender = BaseRender;



	function DomRender(proton, element) {
		DomRender._super_.call(this, proton, element);
		this.stroke = null;
	}


	Proton.Util.inherits(DomRender, Proton.BaseRender);

	DomRender.prototype.start = function() {
		DomRender._super_.prototype.start.call(this);
	}

	DomRender.prototype.setStroke = function(color, thinkness) {
		color = Proton.Util.initValue(color, '#000000');
		thinkness = Proton.Util.initValue(thinkness, 1);
		this.stroke = {
			color : color,
			thinkness : thinkness
		};
	}

	DomRender.prototype.onProtonUpdate = function() {
	}

	DomRender.prototype.onParticleCreated = function(particle) {
		if (particle.target) {
			var self = this;
			Proton.Util.getImage(particle.target, particle, false, function(particle) {
				self.setImgInDIV.call(self, particle);
			});
		} else {
			particle.transform.canvas = Proton.DomUtil.createCanvas(particle.id + '_canvas', particle.radius + 1, particle.radius + 1, 'absolute');
			particle.transform.bakOldRadius = particle.radius;

			if (this.stroke) {
				particle.transform.canvas.width = 2 * particle.radius + this.stroke.thinkness * 2;
				particle.transform.canvas.height = 2 * particle.radius + this.stroke.thinkness * 2;
			} else {
				particle.transform.canvas.width = 2 * particle.radius + 1;
				particle.transform.canvas.height = 2 * particle.radius + 1;
			}

			particle.transform.context = particle.transform.canvas.getContext('2d');
			particle.transform.context.fillStyle = particle.color;
			particle.transform.context.beginPath();
			particle.transform.context.arc(particle.radius, particle.radius, particle.radius, 0, Math.PI * 2, true);

			if (this.stroke) {
				particle.transform.context.strokeStyle = this.stroke.color;
				particle.transform.context.lineWidth = this.stroke.thinkness;
				particle.transform.context.stroke();
			}

			particle.transform.context.closePath();
			particle.transform.context.fill();
			this.element.appendChild(particle.transform.canvas);
		}

	}

	DomRender.prototype.onParticleUpdate = function(particle) {
		if (particle.target) {
			if (particle.target instanceof Image) {
				particle.transform.canvas.style.opacity = particle.alpha;
				Proton.DomUtil.transformDom(particle.transform.canvas, particle.p.x - particle.target.width / 2, particle.p.y - particle.target.height / 2, particle.scale, particle.rotation);
			}
		} else {
			particle.transform.canvas.style.opacity = particle.alpha;
			if (particle.transform['oldRadius'])
				Proton.DomUtil.transformDom(particle.transform.canvas, particle.p.x - particle.transform.oldRadius, particle.p.y - particle.transform.oldRadius, particle.scale, particle.rotation);
			else
				Proton.DomUtil.transformDom(particle.transform.canvas, particle.p.x - particle.transform.bakOldRadius, particle.p.y - particle.transform.bakOldRadius, particle.scale, particle.rotation);
		}
	}

	DomRender.prototype.onParticleDead = function(particle) {
		if (particle.transform.canvas)
			this.element.removeChild(particle.transform.canvas);
	}

	DomRender.prototype.setImgInDIV = function(particle) {
		particle.transform.canvas = Proton.DomUtil.createCanvas(particle.id + '_canvas', particle.target.width + 1, particle.target.height + 1, 'absolute', particle.p.x - particle.radius, particle.p.y - particle.radius);
		particle.transform.context = particle.transform.canvas.getContext('2d');
		particle.transform.context.drawImage(particle.target, 0, 0, particle.target.width, particle.target.height);
		this.element.appendChild(particle.transform.canvas);
	}

	Proton.DomRender = DomRender;



	function EaselRender(proton, element, stroke) {
		EaselRender._super_.call(this, proton, element);
		this.stroke = stroke;
	}


	Proton.Util.inherits(EaselRender, Proton.BaseRender);
	EaselRender.prototype.resize = function(width, height) {

	}
	EaselRender.prototype.start = function() {
		EaselRender._super_.prototype.start.call(this);
	};

	EaselRender.prototype.onProtonUpdate = function() {

	}

	EaselRender.prototype.onParticleCreated = function(particle) {
		if (particle.target) {
			particle.target = particle.target.clone();
			if (!particle.target.parent) {
				if (!!particle.target['image']) {
					particle.target.regX = particle.target.image.width / 2;
					particle.target.regY = particle.target.image.height / 2;
				}
				this.element.addChild(particle.target);
			}
		} else {
			var graphics = new createjs.Graphics();
			if (this.stroke) {
				if (this.stroke == true) {
					graphics.beginStroke('#000000');
				} else if (this.stroke instanceof String) {
					graphics.beginStroke(this.stroke);
				}
			}

			graphics.beginFill(particle.color).drawCircle(0, 0, particle.radius);
			var shape = new createjs.Shape(graphics);
			particle.target = shape;
			this.element.addChild(particle.target);
		}
	}

	EaselRender.prototype.onParticleUpdate = function(particle) {
		if (particle.target) {
			particle.target.x = particle.p.x;
			particle.target.y = particle.p.y;
			particle.target.alpha = particle.alpha;
			particle.target.scaleX = particle.target.scaleY = particle.scale;
			particle.target.rotation = particle.rotation;
		}
	}

	EaselRender.prototype.onParticleDead = function(particle) {
		if (particle.target) {
			if (particle.target.parent)
				particle.target.parent.removeChild(particle.target);
		}
	}

	Proton.EaselRender = EaselRender;



	function CanvasRender(proton, element) {
		CanvasRender._super_.call(this, proton, element);
		this.stroke = null;
		this.context = this.element.getContext("2d");
		this.bufferCache = {};
	}


	Proton.Util.inherits(CanvasRender, Proton.BaseRender);
	CanvasRender.prototype.resize = function(width, height) {
		this.element.width = width;
		this.element.height = height;
	}
	CanvasRender.prototype.start = function() {
		CanvasRender._super_.prototype.start.call(this);
	}

	CanvasRender.prototype.setStroke = function(color, thinkness) {
		color = Proton.Util.initValue(color, '#000000');
		thinkness = Proton.Util.initValue(thinkness, 1);
		this.stroke = {
			color : color,
			thinkness : thinkness
		};
	}

	CanvasRender.prototype.onProtonUpdate = function() {
		this.context.clearRect(0, 0, this.element.width, this.element.height);
	}

	CanvasRender.prototype.onParticleCreated = function(particle) {
		if (particle.target)
			Proton.Util.getImage(particle.target, particle, false);
		else
			particle.color = particle.color ? particle.color : '#ff0000';
	}

	CanvasRender.prototype.onParticleUpdate = function(particle) {
		if (particle.target) {
			if (particle.target instanceof Image) {
				var w = particle.target.width * particle.scale | 0;
				var h = particle.target.height * particle.scale | 0;
				var x = particle.p.x - w / 2;
				var y = particle.p.y - h / 2;

				if (!!particle.color) {
					if (!particle.transform["buffer"])
						particle.transform.buffer = this.getBuffer(particle.target);
					var bufferContext = particle.transform.buffer.getContext('2d');
					bufferContext.clearRect(0, 0, particle.transform.buffer.width, particle.transform.buffer.height);
					bufferContext.globalAlpha = particle.alpha;
					bufferContext.drawImage(particle.target, 0, 0);
					bufferContext.globalCompositeOperation = "source-atop";
					bufferContext.fillStyle = Proton.Util.rgbToHex(particle.transform.rgb);
					bufferContext.fillRect(0, 0, particle.transform.buffer.width, particle.transform.buffer.height);
					bufferContext.globalCompositeOperation = "source-over";
					bufferContext.globalAlpha = 1;
					this.context.drawImage(particle.transform.buffer, 0, 0, particle.transform.buffer.width, particle.transform.buffer.height, x, y, w, h);
				} else {
					this.context.save();
					this.context.globalAlpha = particle.alpha;
					this.context.translate(particle.p.x, particle.p.y);
					this.context.rotate(Proton.MathUtils.degreeTransform(particle.rotation));
					this.context.translate(-particle.p.x, -particle.p.y);
					this.context.drawImage(particle.target, 0, 0, particle.target.width, particle.target.height, x, y, w, h);
					this.context.globalAlpha = 1;
					this.context.restore();
				}
			}
		} else {
			if (particle.transform["rgb"])
				this.context.fillStyle = 'rgba(' + particle.transform.rgb.r + ',' + particle.transform.rgb.g + ',' + particle.transform.rgb.b + ',' + particle.alpha + ')';
			else
				this.context.fillStyle = particle.color;
			this.context.beginPath();
			this.context.arc(particle.p.x, particle.p.y, particle.radius, 0, Math.PI * 2, true);
			if (this.stroke) {
				this.context.strokeStyle = this.stroke.color;
				this.context.lineWidth = this.stroke.thinkness;
				this.context.stroke();
			}

			this.context.closePath();
			this.context.fill();
		}
	}

	CanvasRender.prototype.onParticleDead = function(particle) {

	}

	CanvasRender.prototype.getBuffer = function(image) {
		if ( image instanceof Image) {
			var size = image.width + '_' + image.height;
			var canvas = this.bufferCache[size];
			if (!canvas) {
				canvas = document.createElement('canvas');
				canvas.width = image.width;
				canvas.height = image.height;
				this.bufferCache[size] = canvas;
			}
			return canvas;
		}
	}

	Proton.CanvasRender = CanvasRender;



	function PixelRender(proton, element, rectangle) {
		PixelRender._super_.call(this, proton, element);
		this.context = this.element.getContext('2d');
		this.imageData = null;
		this.rectangle = null;
		this.rectangle = rectangle;
		this.createImageData(rectangle);
	}


	Proton.Util.inherits(PixelRender, Proton.BaseRender);
	PixelRender.prototype.resize = function(width, height) {
		this.element.width = width;
		this.element.height = height;
	}
	PixelRender.prototype.createImageData = function(rectangle) {
		if (!rectangle)
			this.rectangle = new Proton.Rectangle(0, 0, this.element.width, this.element.height);
		else
			this.rectangle = rectangle;
		this.imageData = this.context.createImageData(this.rectangle.width, this.rectangle.height);
		this.context.putImageData(this.imageData, this.rectangle.x, this.rectangle.y);
	}

	PixelRender.prototype.start = function() {
		PixelRender._super_.prototype.start.call(this);
	};

	PixelRender.prototype.onProtonUpdate = function() {
		this.context.clearRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
		this.imageData = this.context.getImageData(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
	}

	PixelRender.prototype.onProtonUpdateAfter = function() {
		this.context.putImageData(this.imageData, this.rectangle.x, this.rectangle.y);
	}

	PixelRender.prototype.onParticleCreated = function(particle) {

	}

	PixelRender.prototype.onParticleUpdate = function(particle) {
		if (this.imageData) {
			this.setPixel(this.imageData, Math.floor(particle.p.x - this.rectangle.x), Math.floor(particle.p.y - this.rectangle.y), particle);
		}
	}

	PixelRender.prototype.setPixel = function(imagedata, x, y, particle) {
		var rgb = particle.transform.rgb;
		if ((x < 0) || (x > this.element.width) || (y < 0) || (y > this.elementwidth))
			return;

		var i = ((y >> 0) * imagedata.width + (x >> 0)) * 4;

		imagedata.data[i] = rgb.r;
		imagedata.data[i + 1] = rgb.g;
		imagedata.data[i + 2] = rgb.b;
		imagedata.data[i + 3] = particle.alpha * 255;
	}

	PixelRender.prototype.onParticleDead = function(particle) {

	}

	Proton.PixelRender = PixelRender;



	function WebGLRender(proton, element) {
		WebGLRender._super_.call(this, proton, element);
		this.gl = this.element.getContext('experimental-webgl', {
			antialias : true,
			stencil : false,
			depth : false
		});
		if (!this.gl)
			alert("Sorry your browser do not suppest WebGL!");
		this.initVar();
		this.setMaxRadius();
		this.initShaders();
		this.initBuffers();
		this.gl.blendEquation(this.gl.FUNC_ADD);
		this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
		this.gl.enable(this.gl.BLEND);
	}


	Proton.Util.inherits(WebGLRender, Proton.BaseRender);
	WebGLRender.prototype.resize = function(width, height) {
		this.umat[4] = -2;
		this.umat[7] = 1;
		this.smat[0] = 1 / width;
		this.smat[4] = 1 / height;
		this.mstack.set(this.umat, 0);
		this.mstack.set(this.smat, 1);
		this.gl.viewport(0, 0, width, height);
		this.element.width = width;
		this.element.height = height;
	}

	WebGLRender.prototype.setMaxRadius = function(radius) {
		this.circleCanvasURL = this.createCircle(radius);
	}

	WebGLRender.prototype.getVertexShader = function() {
		var vsSource = ["uniform vec2 viewport;", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 tMat;", "varying vec2 vTextureCoord;", "varying float alpha;", "void main() {", "vec3 v = tMat * vec3(aVertexPosition, 1.0);", "gl_Position = vec4(v.x, v.y, 0, 1);", "vTextureCoord = aTextureCoord;", "alpha = tMat[0][2];", "}"].join("\n");
		return vsSource;
	}

	WebGLRender.prototype.getFragmentShader = function() {
		var fsSource = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float alpha;", "uniform sampler2D uSampler;", "uniform vec4 color;", "uniform bool useTexture;", "uniform vec3 uColor;", "void main() {", "vec4 textureColor = texture2D(uSampler, vTextureCoord);", "gl_FragColor = textureColor * vec4(uColor, 1.0);", "gl_FragColor.w *= alpha;", "}"].join("\n");
		return fsSource;
	}

	WebGLRender.prototype.initVar = function() {
		this.mstack = new Proton.MStack();
		this.umat = Proton.Mat3.create([2, 0, 1, 0, -2, 0, -1, 1, 1]);
		this.smat = Proton.Mat3.create([1 / 100, 0, 1, 0, 1 / 100, 0, 0, 0, 1]);
		this.texturebuffers = {};
	}

	WebGLRender.prototype.start = function() {
		WebGLRender._super_.prototype.start.call(this);
		this.resize(this.element.width, this.element.height);
	}

	WebGLRender.prototype.blendEquation = function(A) {
		this.gl.blendEquation(this.gl[A]);
	}

	WebGLRender.prototype.blendFunc = function(A, B) {
		this.gl.blendFunc(this.gl[A], this.gl[B]);
	}

	WebGLRender.prototype.getShader = function(gl, str, fs) {
		var shader;
		if (fs)
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		else
			shader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(shader, str);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	}

	WebGLRender.prototype.initShaders = function() {
		var fragmentShader = this.getShader(this.gl, this.getFragmentShader(), true);
		var vertexShader = this.getShader(this.gl, this.getVertexShader(), false);

		this.sprogram = this.gl.createProgram();
		this.gl.attachShader(this.sprogram, vertexShader);
		this.gl.attachShader(this.sprogram, fragmentShader);
		this.gl.linkProgram(this.sprogram);
		if (!this.gl.getProgramParameter(this.sprogram, this.gl.LINK_STATUS))
			alert("Could not initialise shaders");

		this.gl.useProgram(this.sprogram);
		this.sprogram.vpa = this.gl.getAttribLocation(this.sprogram, "aVertexPosition");
		this.sprogram.tca = this.gl.getAttribLocation(this.sprogram, "aTextureCoord");
		this.gl.enableVertexAttribArray(this.sprogram.tca);
		this.gl.enableVertexAttribArray(this.sprogram.vpa);

		this.sprogram.tMatUniform = this.gl.getUniformLocation(this.sprogram, "tMat");
		this.sprogram.samplerUniform = this.gl.getUniformLocation(this.sprogram, "uSampler");
		this.sprogram.useTex = this.gl.getUniformLocation(this.sprogram, "useTexture");
		this.sprogram.color = this.gl.getUniformLocation(this.sprogram, "uColor");
		this.gl.uniform1i(this.sprogram.useTex, 1);
	};

	WebGLRender.prototype.initBuffers = function() {
		this.unitIBuffer = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.unitIBuffer);
		var vs = [0, 3, 1, 0, 2, 3];
		this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vs), this.gl.STATIC_DRAW);

		var ids = [];
		for (var i = 0; i < 100; i++)
			ids.push(i);

		idx = new Uint16Array(ids);
		this.unitI33 = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.unitI33);
		this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, idx, this.gl.STATIC_DRAW);

		ids = [];
		for ( i = 0; i < 100; i++)
			ids.push(i, i + 1, i + 2);

		idx = new Uint16Array(ids);
		this.stripBuffer = this.gl.createBuffer();
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.stripBuffer);
		this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, idx, this.gl.STATIC_DRAW);
	};

	WebGLRender.prototype.createCircle = function(raidus) {
		this.circleCanvasRadius = Proton.WebGLUtil.nhpot(Proton.Util.initValue(raidus, 32));
		var canvas = Proton.DomUtil.createCanvas('circle_canvas', this.circleCanvasRadius * 2, this.circleCanvasRadius * 2);
		var context = canvas.getContext('2d');
		context.beginPath();
		context.arc(this.circleCanvasRadius, this.circleCanvasRadius, this.circleCanvasRadius, 0, Math.PI * 2, true);
		context.closePath();
		context.fillStyle = '#FFF';
		context.fill();
		return canvas.toDataURL();
	};

	WebGLRender.prototype.setImgInCanvas = function(particle) {
		var _w = particle.target.width;
		var _h = particle.target.height;
		var _width = Proton.WebGLUtil.nhpot(particle.target.width);
		var _height = Proton.WebGLUtil.nhpot(particle.target.height);
		var _scaleX = particle.target.width / _width;
		var _scaleY = particle.target.height / _height;

		if (!this.texturebuffers[particle.transform.src])
			this.texturebuffers[particle.transform.src] = [this.gl.createTexture(), this.gl.createBuffer(), this.gl.createBuffer()];
		particle.transform.texture = this.texturebuffers[particle.transform.src][0];
		particle.transform.vcBuffer = this.texturebuffers[particle.transform.src][1];
		particle.transform.tcBuffer = this.texturebuffers[particle.transform.src][2];
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, particle.transform.tcBuffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, _scaleX, 0.0, 0.0, _scaleY, _scaleY, _scaleY]), this.gl.STATIC_DRAW);
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, particle.transform.vcBuffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, _w, 0.0, 0.0, _h, _w, _h]), this.gl.STATIC_DRAW);

		var context = particle.transform.canvas.getContext('2d');
		var data = context.getImageData(0, 0, _width, _height);

		this.gl.bindTexture(this.gl.TEXTURE_2D, particle.transform.texture);
		this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
		this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
		this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
		this.gl.generateMipmap(this.gl.TEXTURE_2D);
		particle.transform.textureLoaded = true;
		particle.transform.textureWidth = _w;
		particle.transform.textureHeight = _h;
	}

	WebGLRender.prototype.setStroke = function(color, thinkness) {

	}

	WebGLRender.prototype.onProtonUpdate = function() {
		//this.gl.clearColor(0, 0, 0, 1);
		//this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
	}

	WebGLRender.prototype.onParticleCreated = function(particle) {
		var self = this;
		particle.transform.textureLoaded = false;
		particle.transform.tmat = Proton.Mat3.create();
		particle.transform.tmat[8] = 1;
		particle.transform.imat = Proton.Mat3.create();
		particle.transform.imat[8] = 1;
		if (particle.target) {
			Proton.Util.getImage(particle.target, particle, true, function(particle) {
				self.setImgInCanvas.call(self, particle);
				particle.transform.oldScale = 1;
			});
		} else {
			Proton.Util.getImage(this.circleCanvasURL, particle, true, function(particle) {
				self.setImgInCanvas.call(self, particle);
				particle.transform.oldScale = particle.radius / self.circleCanvasRadius;
			});
		}
	}

	WebGLRender.prototype.onParticleUpdate = function(particle) {
		if (particle.transform.textureLoaded) {
			this.updateMatrix(particle);
			this.gl.uniform3f(this.sprogram.color, particle.transform.rgb.r / 255, particle.transform.rgb.g / 255, particle.transform.rgb.b / 255);
			this.gl.uniformMatrix3fv(this.sprogram.tMatUniform, false, this.mstack.top());
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, particle.transform.vcBuffer);
			this.gl.vertexAttribPointer(this.sprogram.vpa, 2, this.gl.FLOAT, false, 0, 0);
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, particle.transform.tcBuffer);
			this.gl.vertexAttribPointer(this.sprogram.tca, 2, this.gl.FLOAT, false, 0, 0);
			this.gl.bindTexture(this.gl.TEXTURE_2D, particle.transform.texture);
			this.gl.uniform1i(this.sprogram.samplerUniform, 0);
			this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.unitIBuffer);
			this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
			this.mstack.pop();
		}
	}

	WebGLRender.prototype.onParticleDead = function(particle) {
		
	}

	WebGLRender.prototype.updateMatrix = function(particle) {
		var moveOriginMatrix = Proton.WebGLUtil.makeTranslation(-particle.transform.textureWidth / 2, -particle.transform.textureHeight / 2);
		var translationMatrix = Proton.WebGLUtil.makeTranslation(particle.p.x, particle.p.y);
		var angel = particle.rotation * (Math.PI / 180);
		var rotationMatrix = Proton.WebGLUtil.makeRotation(angel);
		var scale = particle.scale * particle.transform.oldScale;
		var scaleMatrix = Proton.WebGLUtil.makeScale(scale, scale);

		var matrix = Proton.WebGLUtil.matrixMultiply(moveOriginMatrix, scaleMatrix);
		matrix = Proton.WebGLUtil.matrixMultiply(matrix, rotationMatrix);
		matrix = Proton.WebGLUtil.matrixMultiply(matrix, translationMatrix);

		Proton.Mat3.inverse(matrix, particle.transform.imat);
		matrix[2] = particle.alpha;
		this.mstack.push(matrix);
	}

	Proton.WebGLRender = WebGLRender;



	function Zone() {
		this.vector = new Proton.Vector2D(0, 0);
		this.random = 0;
		this.crossType = "dead";
		this.alert = true;
	}


	Zone.prototype = {
		getPosition : function() {

		},

		crossing : function(particle) {

		}
	};

	Proton.Zone = Zone;



	function LineZone(x1, y1, x2, y2, direction) {
		LineZone._super_.call(this);
		if (x2 - x1 >= 0) {
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
		} else {
			this.x1 = x2;
			this.y1 = y2;
			this.x2 = x1;
			this.y2 = y1;
		}
		this.dx = this.x2 - this.x1;
		this.dy = this.y2 - this.y1;
		this.minx = Math.min(this.x1, this.x2);
		this.miny = Math.min(this.y1, this.y2);
		this.maxx = Math.max(this.x1, this.x2);
		this.maxy = Math.max(this.y1, this.y2);
		this.dot = this.x2 * this.y1 - this.x1 * this.y2;
		this.xxyy = this.dx * this.dx + this.dy * this.dy;
		this.gradient = this.getGradient();
		this.length = this.getLength();
		this.direction = Proton.Util.initValue(direction, '>');
	}


	Proton.Util.inherits(LineZone, Proton.Zone);
	LineZone.prototype.getPosition = function() {
		this.random = Math.random();
		this.vector.x = this.x1 + this.random * this.length * Math.cos(this.gradient);
		this.vector.y = this.y1 + this.random * this.length * Math.sin(this.gradient);
		return this.vector;
	}

	LineZone.prototype.getDirection = function(x, y) {
		var A = this.dy;
		var B = -this.dx;
		var C = this.dot;
		var D = B == 0 ? 1 : B;
		if ((A * x + B * y + C) * D > 0)
			return true
		else
			return false;
	}

	LineZone.prototype.getDistance = function(x, y) {
		var A = this.dy;
		var B = -this.dx;
		var C = this.dot;
		var D = (A * x + B * y + C);
		return D / Math.sqrt(this.xxyy);
	}

	LineZone.prototype.getSymmetric = function(v) {
		var tha2 = v.getGradient();
		var tha1 = this.getGradient();
		var tha = 2 * (tha1 - tha2);
		var oldx = v.x;
		var oldy = v.y;
		v.x = oldx * Math.cos(tha) - oldy * Math.sin(tha);
		v.y = oldx * Math.sin(tha) + oldy * Math.cos(tha);
		return v;
	}

	LineZone.prototype.getGradient = function() {
		return Math.atan2(this.dy, this.dx);
	}

	LineZone.prototype.getRange = function(particle, fun) {
		var angle = Math.abs(this.getGradient());
		if (angle <= Math.PI / 4) {
			if (particle.p.x < this.maxx && particle.p.x > this.minx) {
				fun();
			}
		} else {
			if (particle.p.y < this.maxy && particle.p.y > this.miny) {
				fun();
			}
		}
	}

	LineZone.prototype.getLength = function() {
		return Math.sqrt(this.dx * this.dx + this.dy * this.dy)
	}

	LineZone.prototype.crossing = function(particle) {
		var self = this;
		if (this.crossType == "dead") {
			if (this.direction == ">" || this.direction == "R" || this.direction == "right" || this.direction == "down") {
				this.getRange(particle, function() {
					if (self.getDirection(particle.p.x, particle.p.y))
						particle.dead = true;
				})
			} else {
				this.getRange(particle, function() {
					if (!self.getDirection(particle.p.x, particle.p.y))
						particle.dead = true;
				})
			}
		} else if (this.crossType == "bound") {
			this.getRange(particle, function() {
				if (self.getDistance(particle.p.x, particle.p.y) <= particle.radius) {
					if (self.dx == 0) {
						particle.v.x *= -1;
					} else if (self.dy == 0) {
						particle.v.y *= -1;
					} else {
						self.getSymmetric(particle.v);
					}
				}
			});
		} else if (this.crossType == "cross") {
			if (this.alert) {
				alert('Sorry lineZone does not support cross method');
				this.alert = false;
			}
		}
	}

	Proton.LineZone = LineZone;



	function CircleZone(x, y, radius) {
		CircleZone._super_.call(this);
		this.x = x;
		this.y = y;
		this.radius = radius;
		this.angle = 0;
		this.center = {
			x : this.x,
			y : this.y
		};
	}


	Proton.Util.inherits(CircleZone, Proton.Zone);
	CircleZone.prototype.getPosition = function() {
		this.random = Math.random();
		this.angle = Math.PI * 2 * Math.random();
		this.vector.x = this.x + this.random * this.radius * Math.cos(this.angle);
		this.vector.y = this.y + this.random * this.radius * Math.sin(this.angle);
		return this.vector;
	}

	CircleZone.prototype.setCenter = function(x, y) {
		this.center.x = x;
		this.center.y = y;
	}

	CircleZone.prototype.crossing = function(particle) {
		var d = particle.p.distanceTo(this.center);
		if (this.crossType == "dead") {
			if (d - particle.radius > this.radius)
				particle.dead = true;
		} else if (this.crossType == "bound") {
			if (d + particle.radius >= this.radius)
				this.getSymmetric(particle);
		} else if (this.crossType == "cross") {
			if (this.alert) {
				alert('Sorry CircleZone does not support cross method');
				this.alert = false;
			}
		}
	}

	CircleZone.prototype.getSymmetric = function(particle) {
		var tha2 = particle.v.getGradient();
		var tha1 = this.getGradient(particle);
		var tha = 2 * (tha1 - tha2);
		var oldx = particle.v.x;
		var oldy = particle.v.y;
		particle.v.x = oldx * Math.cos(tha) - oldy * Math.sin(tha);
		particle.v.y = oldx * Math.sin(tha) + oldy * Math.cos(tha);
	}

	CircleZone.prototype.getGradient = function(particle) {
		return -Math.PI / 2 + Math.atan2(particle.p.y - this.center.y, particle.p.x - this.center.x);
	}

	Proton.CircleZone = CircleZone;



	function PointZone(x, y) {
		PointZone._super_.call(this);
		this.x = x;
		this.y = y;
	}


	Proton.Util.inherits(PointZone, Proton.Zone);
	PointZone.prototype.getPosition = function() {
		this.vector.x = this.x;
		this.vector.y = this.y;
		return this.vector;
	}

	PointZone.prototype.crossing = function(particle) {
		if (this.alert) {
			alert('Sorry PointZone does not support crossing method');
			this.alert = false;
		}
	}

	Proton.PointZone = PointZone;



	function RectZone(x, y, width, height) {
		RectZone._super_.call(this);
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}


	Proton.Util.inherits(RectZone, Proton.Zone);
	RectZone.prototype.getPosition = function() {
		this.vector.x = this.x + Math.random() * this.width;
		this.vector.y = this.y + Math.random() * this.height;
		return this.vector;
	}

	RectZone.prototype.crossing = function(particle) {
		if (this.crossType == "dead") {
			if (particle.p.x + particle.radius < this.x)
				particle.dead = true;
			else if (particle.p.x - particle.radius > this.x + this.width)
				particle.dead = true;

			if (particle.p.y + particle.radius < this.y)
				particle.dead = true;
			else if (particle.p.y - particle.radius > this.y + this.height)
				particle.dead = true;
		} else if (this.crossType == "bound") {
			if (particle.p.x - particle.radius < this.x) {
				particle.p.x = this.x + particle.radius;
				particle.v.x *= -1;
			} else if (particle.p.x + particle.radius > this.x + this.width) {
				particle.p.x = this.x + this.width - particle.radius;
				particle.v.x *= -1;
			}
			
			if (particle.p.y - particle.radius < this.y) {
				particle.p.y = this.y + particle.radius;
				particle.v.y *= -1;
			} else if (particle.p.y + particle.radius > this.y + this.height) {
				particle.p.y = this.y + this.height - particle.radius;
				particle.v.y *= -1;
			}
		} else if (this.crossType == "cross") {
			if (particle.p.x + particle.radius < this.x && particle.v.x <= 0)
				particle.p.x = this.x + this.width + particle.radius;
			else if (particle.p.x - particle.radius > this.x + this.width && particle.v.x >= 0)
				particle.p.x = this.x - particle.radius;

			if (particle.p.y + particle.radius < this.y && particle.v.y <= 0)
				particle.p.y = this.y + this.height + particle.radius;
			else if (particle.p.y - particle.radius > this.y + this.height && particle.v.y >= 0)
				particle.p.y = this.y - particle.radius;
		}
	}

	Proton.RectZone = RectZone;



	function ImageZone(imageData, x, y, d) {
		ImageZone._super_.call(this);
		this.reset(imageData, x, y, d);
	}


	Proton.Util.inherits(ImageZone, Proton.Zone);
	ImageZone.prototype.reset = function(imageData, x, y, d) {
		this.imageData = imageData;
		this.x = Proton.Util.initValue(x, 0);
		this.y = Proton.Util.initValue(y, 0);
		this.d = Proton.Util.initValue(d, 2);
		this.vectors = [];
		this.setVectors();
	}

	ImageZone.prototype.setVectors = function() {
		var i, j;
		var length1 = this.imageData.width;
		var length2 = this.imageData.height;
		for ( i = 0; i < length1; i += this.d) {
			for ( j = 0; j < length2; j += this.d) {
				var index = ((j >> 0) * length1 + (i >> 0)) * 4;
				if (this.imageData.data[index + 3] > 0) {
					this.vectors.push({
						x : i + this.x,
						y : j + this.y
					});
				}
			}
		}
		return this.vector;
	}

	ImageZone.prototype.getBound = function(x, y) {
		var index = ((y >> 0) * this.imageData.width + (x >> 0)) * 4;
		if (this.imageData.data[index + 3] > 0)
			return true;
		else
			return false;
	}

	ImageZone.prototype.getPosition = function() {
		return this.vector.copy(this.vectors[Math.floor(Math.random() * this.vectors.length)]);
	}

	ImageZone.prototype.getColor = function(x, y) {
		x -= this.x;
		y -= this.y;
		var i = ((y >> 0) * this.imageData.width + (x >> 0)) * 4;
		return {
			r : this.imageData.data[i],
			g : this.imageData.data[i + 1],
			b : this.imageData.data[i + 2],
			a : this.imageData.data[i + 3]
		};
	}

	ImageZone.prototype.crossing = function(particle) {
		if (this.crossType == "dead") {
			if (this.getBound(particle.p.x - this.x, particle.p.y - this.y))
				particle.dead = true;
			else
				particle.dead = false;
		} else if (this.crossType == "bound") {
			if (!this.getBound(particle.p.x - this.x, particle.p.y - this.y))
				particle.v.negate();
		}
	}

	Proton.ImageZone = ImageZone;


/**
 * You can use this emit particles.
 *
 * This method will console.log the fixed number of your info  in updata or requestAnimationFrame
 * 
 * use like this Proton.log('+12',mc); log 12 times
 *
 * @class Proton.log
 * @constructor
 * @param {*} logInfo;
 */

	var log = function() {
		if (window.console && window.console.log) {
			var arg = arguments;
			if ( typeof arguments[0] == 'string') {
				if (arguments[0].indexOf('+') == 0) {
					var n = parseInt(arguments[0]);
					if (log.once < n) {
						delete arg[0];
						console.log(arg);
						log.once++;
					}
				} else {
					console.log(arg);
				}
			} else {
				console.log(arg);
			}
		}
	}

	log.once = 0;
	Proton.log = log;



	var Debug = Debug || {
		addEventListener : function(proton, fun) {
			proton.addEventListener(Proton.PROTON_UPDATE, function(e) {
				fun();
			});
		},

		setStyle : function(c) {
			var color = c || '#ff0000';
			var rgb = Proton.Util.hexToRGB(color);
			var style = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + 0.5 + ')';
			return style;
		},

		drawZone : function(proton, canvas, zone, clear) {
			var context = canvas.getContext('2d');
			var style = this.setStyle();
			this.addEventListener(proton, function() {
				if (clear)
					context.clearRect(0, 0, canvas.width, canvas.height);

				if ( zone instanceof Proton.PointZone) {
					context.beginPath();
					context.fillStyle = style;
					context.arc(zone.x, zone.y, 10, 0, Math.PI * 2, true);
					context.fill();
					context.closePath();
				} else if ( zone instanceof Proton.LineZone) {
					context.beginPath();
					context.strokeStyle = style;
					context.moveTo(zone.x1, zone.y1);
					context.lineTo(zone.x2, zone.y2);
					context.stroke();
					context.closePath();
				} else if ( zone instanceof Proton.RectZone) {
					context.beginPath();
					context.strokeStyle = style;
					context.drawRect(zone.x, zone.y, zone.width, zone.height);
					context.stroke();
					context.closePath();
				} else if ( zone instanceof Proton.CircleZone) {
					context.beginPath();
					context.strokeStyle = style;
					context.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2, true);
					context.stroke();
					context.closePath();
				}
			});
		},

		drawEmitter : function(proton, canvas, emitter, clear) {
			var context = canvas.getContext('2d');
			var style = this.setStyle();
			this.addEventListener(proton, function() {
				if (clear)
					context.clearRect(0, 0, canvas.width, canvas.height);

				context.beginPath();
				context.fillStyle = style;
				context.arc(emitter.p.x, emitter.p.y, 10, 0, Math.PI * 2, true);
				context.fill();
				context.closePath();
			});
		},

		test : {},

		setTest : function(id, value) {
			this.test[id] = value;
		},

		getTest : function(id) {
			if (this.test.hasOwnProperty(id))
				return this.test[id];
			else
				return false;
		}
	}

	Proton.Debug = Debug;


})(window);
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller
// fixes from Paul Irish and Tino Zijdel
( function() {
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];
		for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
		}

		if (!window.requestAnimationFrame)
			window.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime();
				var timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function() {
					callback(currTime + timeToCall);
				}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};

		if (!window.cancelAnimationFrame)
			window.cancelAnimationFrame = function(id) {
				clearTimeout(id);
			};
	}()); 
/*
 * File:   ui-four-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  four anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIFourJoint() {
	return;
}

UIFourJoint.prototype = new UIElement();
UIFourJoint.prototype.isUIJoint = true;
UIFourJoint.prototype.isUIFourJoint = true;

UIFourJoint.prototype.initUIFourJoint = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.points = [{x:0, y:80}, {x:0, y:0}, {x:80, y:0},{x:80, y:80}];

	return this;
}

UIFourJoint.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.points = [{}, {},{},{}];
	o.points[0].x = this.points[0].x;
	o.points[0].y = this.points[0].y;
	o.points[1].x = this.points[1].x;
	o.points[1].y = this.points[1].y;
	o.points[2].x = this.points[2].x;
	o.points[2].y = this.points[2].y;
	o.points[3].x = this.points[3].x;
	o.points[3].y = this.points[3].y;

	return;
}

UIFourJoint.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	if(js.points) {
		this.points = js.points;
	}

	return;
}

UIFourJoint.prototype.asIcon = function() {
	if(!this.isIcon) {
		this.isIcon = true;
		this.points = [{x:0, y:80}, {x:20, y:0}, {x:60, y:0},{x:80, y:80}];
	}

	return;
}

UIFourJoint.prototype.relayout = function() {
	if(this.disableRelayout || this.mode === Shape.MODE_EDITING) {
		return;
	}

	var p = getParentShapeOfShape(this);
	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);

	if(this.xAttr === UIElement.X_SCALE) {
		this.points[0].x = wParent * this.x0Param;
		this.points[1].x = wParent * this.x1Param;
		this.points[2].x = wParent * this.x2Param;
		this.points[3].x = wParent * this.x3Param;
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.points[0].y = hParent * this.y0Param;
		this.points[1].y = hParent * this.y1Param;
		this.points[2].y = hParent * this.y2Param;
		this.points[3].y = hParent * this.y3Param;
	}

	return;
}

UIFourJoint.prototype.updateLayoutParams = function() {
	this.xParam = 1;
	this.yParam = 1;

	var p = this.parentShape;
	if(!p) {
		return;
	}

	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.x0Param = this.points[0].x / wParent;
		this.x1Param = this.points[1].x / wParent;
		this.x2Param = this.points[2].x / wParent;
		this.x3Param = this.points[3].x / wParent;
	}

	if(this.yAttr === UIElement.Y_SCALE) {
		this.y0Param = this.points[0].y / hParent;
		this.y1Param = this.points[1].y / hParent;
		this.y2Param = this.points[2].y / hParent;
		this.y3Param = this.points[3].y / hParent;
	}

	return;
}

UIFourJoint.prototype.hitTest = function(point) {
	if(Math.distanceBetween(point, this.points[0]) < 20) {
		return 1;
	}

	if(Math.distanceBetween(point, this.points[1]) < 20) {
		return 2;
	}

	if(Math.distanceBetween(point, this.points[2]) < 20) {
		return 3;
	}
	
	if(Math.distanceBetween(point, this.points[3]) < 20) {
		return 4;
	}

	return Shape.HIT_TEST_NONE;
}

UIFourJoint.prototype.getSelectMark = function(type, point) {
	var n =  this.points.length;
	if(type <= n) {
		point.x = this.points[type-1].x;
		point.y = this.points[type-1].y;

		return true;
	}

	return false;
}

UIFourJoint.prototype.onAppendedInParent = function() {
	if(this.isCreatingElement()) {
		var parentShape = this.getParent();
		var p = parentShape.getPositionInView();

		this.points[0].x -= p.x;
		this.points[0].y -= p.y;
		
		this.points[1].x -= p.x;
		this.points[1].y -= p.y;
		
		this.points[2].x -= p.x;
		this.points[2].y -= p.y;
		
		this.points[3].x -= p.x;
		this.points[3].y -= p.y;
	}

	return;
}

UIFourJoint.prototype.drawSelectMarks = function(canvas) {
	return UITwoJoint.prototype.drawSelectMarks.call(this, canvas);
}

UIFourJoint.prototype.getMinMaxX = function() {
	var max = this.points[0].x;
	var min = max;

	for(var i = 0; i < this.points.length; i++) {
		var p = this.points[i];
		if(p.x > max) {
			max = p.x;
		}
		if(p.x < min) {
			min = p.x;
		}
	}

	return {min:min, max:max};
}

UIFourJoint.prototype.getMinMaxY = function() {
	var max = this.points[0].y;
	var min = max;

	for(var i = 0; i < this.points.length; i++) {
		var p = this.points[i];
		if(p.y > max) {
			max = p.y;
		}
		if(p.y < min) {
			min = p.y;
		}
	}

	return {min:min, max:max};
}

UIFourJoint.prototype.getX = function() {
	return this.getMinMaxX().min;
}

UIFourJoint.prototype.getY = function() {
	return this.getMinMaxY().min;
}

UIFourJoint.prototype.getWidth = function() {
	var range = this.getMinMaxX();

	return range.max - range.min;
}

UIFourJoint.prototype.getHeight = function() {
	var range = this.getMinMaxY();

	return range.max - range.min;
}

UIFourJoint.prototype.paintSelf = function(canvas) {
	canvas.save();
	if(this.isIcon) {
		this.translate(canvas);
	}

	var r = this.anchorSize ? this.anchorSize : 5;
	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;
	
	canvas.beginPath();
	canvas.moveTo(this.points[0].x, this.points[0].y);
	canvas.lineTo(this.points[1].x, this.points[1].y);
	canvas.lineTo(this.points[2].x, this.points[2].y);
	canvas.lineTo(this.points[3].x, this.points[3].y);
	canvas.stroke();
	
	canvas.beginPath();
	canvas.arc(this.points[0].x, this.points[0].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[1].x, this.points[1].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[2].x, this.points[2].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[3].x, this.points[3].y, r, 0, Math.PI * 2);
	canvas.fill();

	canvas.beginPath();

	canvas.restore();
	
	this.drawSelectMarks(canvas);

	return;
}

UIFourJoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIFourJoint.prototype.onPointerDownNormal = function(point) {
	this.hitTestResult = this.hitTest(point);
	this.selected = this.hitTestResult != Shape.HIT_TEST_NONE;

	return this.hitTestResult;
}

UIFourJoint.prototype.onPointerMoveNormal = function(point) {
	 if(this.mode === Shape.MODE_EDITING && this.hitTestResult > 0) {
	 	var index = this.hitTestResult - 1;
	 	this.points[index].x = point.x;
	 	this.points[index].y = point.y;
	 }
}

UIFourJoint.prototype.onPointerUpNormal = function(point) {
	this.hitTestResult = Shape.HIT_TEST_NONE;

	return;
}

UIFourJoint.prototype.onPointerDownCreating = function(point) {
	switch(this.state) {
		case Shape.STAT_CREATING_0: {
			this.state = Shape.STAT_NORMAL;
		}
		default: {
			return false;
		}
	}
}

UIFourJoint.prototype.onPointerMoveCreating = function(point) {
	switch(this.state) {
		case Shape.STAT_CREATING_0: {
			this.points[0].x = point.x;
			this.points[0].y = point.y + 80;
			this.points[1].x = point.x + 20;
			this.points[1].y = point.y;
			this.points[2].x = point.x + 60;
			this.points[2].y = point.y;
			this.points[3].x = point.x + 80;
			this.points[3].y = point.y + 80;
			return true;
		}
		default: {
			return false;
		}
	}
}

function UIFourJointCreator() {
	var args = ["ui-four-joint", "ui-four-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFourJoint();
		return g.initUIFourJoint(this.type, 200, 200);
	}
	
	return;
}

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @class egret.Matrix
 * @classdesc
 * Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。
 * 您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
 * @extends egret.HashObject
 * @includeExample egret/geom/Matrix.ts
 */
var Matrix = (function () {
    /**
     * 创建一个 egret.Matrix 对象
     * @method egret.Matrix#constructor
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值。
     * @param b {number} 旋转或倾斜图像时影响像素沿 y 轴定位的值。
     * @param c {number} 旋转或倾斜图像时影响像素沿 x 轴定位的值。
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值。
     * @param tx {number} 沿 x 轴平移每个点的距离。
     * @param ty {number} 沿 y 轴平移每个点的距离。
     */
    function Matrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    var __egretProto__ = Matrix.prototype;
    /**
     * 前置矩阵
     * @method egret.Matrix#prepend
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param b {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param c {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param tx {number} 沿 x 轴平移每个点的距离
     * @param ty {number} 沿 y 轴平移每个点的距离
     * @returns {egret.Matrix}
     */
    __egretProto__.prepend = function (a, b, c, d, tx, ty) {
        var tx1 = this.tx;
        if (a != 1 || b != 0 || c != 0 || d != 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = a1 * a + this.b * c;
            this.b = a1 * b + this.b * d;
            this.c = c1 * a + this.d * c;
            this.d = c1 * b + this.d * d;
        }
        this.tx = tx1 * a + this.ty * c + tx;
        this.ty = tx1 * b + this.ty * d + ty;
        return this;
    };
    /**
     * 后置矩阵
     * @method egret.Matrix#append
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param b {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param c {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param tx {number} 沿 x 轴平移每个点的距离
     * @param ty {number} 沿 y 轴平移每个点的距离
     * @returns {egret.Matrix}
     */
    __egretProto__.append = function (a, b, c, d, tx, ty) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        if (a != 1 || b != 0 || c != 0 || d != 1) {
            this.a = a * a1 + b * c1;
            this.b = a * b1 + b * d1;
            this.c = c * a1 + d * c1;
            this.d = c * b1 + d * d1;
        }
        this.tx = tx * a1 + ty * c1 + this.tx;
        this.ty = tx * b1 + ty * d1 + this.ty;
        return this;
    };
    /**
     * 前置矩阵
     * @method egret.Matrix#prependTransform
     * @param x {number} x值
     * @param y {number} y值
     * @param scaleX {number} 水平缩放
     * @param scaleY {number} 垂直缩放
     * @param rotation {number} 旋转
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @param regX {number} x值偏移
     * @param regY {number} y值偏移
     * @returns {egret.Matrix}
     */
    __egretProto__.prependTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        if (rotation % 360) {
            var r = rotation; // * Matrix.DEG_TO_RAD;
            var cos = egret.NumberUtils.cos(r);
            var sin = egret.NumberUtils.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (regX || regY) {
            // append the registration offset:
            this.tx -= regX;
            this.ty -= regY;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single prepend operation?
            //                skewX *= Matrix.DEG_TO_RAD;
            //                skewY *= Matrix.DEG_TO_RAD;
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
            this.prepend(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), x, y);
        }
        else {
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        return this;
    };
    /**
     * 后置矩阵
     * @method egret.Matrix#appendTransform
     * @param x {number} x值
     * @param y {number} y值
     * @param scaleX {number} 水平缩放
     * @param scaleY {number} 垂直缩放
     * @param rotation {number} 旋转
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @param regX {number} x值偏移
     * @param regY {number} y值偏移
     * @returns {egret.Matrix}
     */
    __egretProto__.appendTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        if (rotation % 360) {
            var r = rotation; // * Matrix.DEG_TO_RAD;
            var cos = egret.NumberUtils.cos(r);
            var sin = egret.NumberUtils.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single append?
            //                skewX *= Matrix.DEG_TO_RAD;
            //                skewY *= Matrix.DEG_TO_RAD;
            this.append(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), x, y);
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
        }
        else {
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        if (regX || regY) {
            // prepend the registration offset:
            this.tx -= regX * this.a + regY * this.c;
            this.ty -= regX * this.b + regY * this.d;
        }
        return this;
    };
    /**
     * 对 Matrix 对象应用旋转转换。
     * 矩阵旋转，以角度制为单位
     * @method egret.Matrix#rotate
     * @param angle {number} 角度
     * @returns {egret.Matrix}
     */
    __egretProto__.rotate = function (angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
    };
    /**
     * 矩阵斜切，以角度值为单位
     * @method egret.Matrix#skew
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @returns {egret.Matrix}
     */
    __egretProto__.skew = function (skewX, skewY) {
        //            skewX = skewX * Matrix.DEG_TO_RAD;
        //            skewY = skewY * Matrix.DEG_TO_RAD;
        this.append(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), 0, 0);
        return this;
    };
    /**
     * 矩阵缩放
     * @method egret.Matrix#scale
     * @param x {number} 水平缩放
     * @param y {number} 垂直缩放
     * @returns {egret.Matrix}
     */
    __egretProto__.scale = function (x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    };
    /**
     * 沿 x 和 y 轴平移矩阵，由 x 和 y 参数指定。
     * @method egret.Matrix#translate
     * @param x {number} 沿 x 轴向右移动的量（以像素为单位）。
     * @param y {number} 沿 y 轴向下移动的量（以像素为单位）。
     * @returns {egret.Matrix}
     */
    __egretProto__.translate = function (x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    };
    /**
     * 为每个矩阵属性设置一个值，该值将导致 null 转换。
     * 通过应用恒等矩阵转换的对象将与原始对象完全相同。
     * 调用 identity() 方法后，生成的矩阵具有以下属性：a=1、b=0、c=0、d=1、tx=0 和 ty=0。
     * @method egret.Matrix#identity
     * @returns {egret.Matrix}
     */
    __egretProto__.identity = function () {
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
    };
    /**
     * 矩阵重置为目标矩阵
     * @method egret.Matrix#identityMatrix
     * @param matrix {egret.Matrix} 重置的目标矩阵
     * @returns {egret.Matrix}
     * @deprecated
     */
    __egretProto__.identityMatrix = function (matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    };
    /**
     * 执行原始矩阵的逆转换。
     * 您可以将一个逆矩阵应用于对象来撤消在应用原始矩阵时执行的转换。
     * @method egret.Matrix#invert
     * @returns {egret.Matrix}
     */
    __egretProto__.invert = function () {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
    };
    /**
     * 根据一个矩阵，返回某个点在该矩阵上的坐标
     * @method egret.Matrix.transformCoords
     * @param matrix {egret.Matrix}
     * @param x {number}
     * @param y {number}
     * @returns {numberPoint}
     * @stable C 该方法以后可能删除
     * @deprecated
     */
    Matrix.transformCoords = function (matrix, x, y) {
        var resultPoint = egret.Point.identity;
        resultPoint.x = matrix.a * x + matrix.c * y + matrix.tx;
        resultPoint.y = matrix.d * y + matrix.b * x + matrix.ty;
        //        resultPoint.x = matrix.a * x + matrix.c * y - matrix.tx;
        //        resultPoint.y = matrix.d * y + matrix.b * x - matrix.ty;
        return resultPoint;
    };
    /**
     * @private
     */
    __egretProto__.toArray = function (transpose) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        if (transpose) {
            this.array[0] = this.a;
            this.array[1] = this.b;
            this.array[2] = 0;
            this.array[3] = this.c;
            this.array[4] = this.d;
            this.array[5] = 0;
            this.array[6] = this.tx;
            this.array[7] = this.ty;
            this.array[8] = 1;
        }
        else {
            this.array[0] = this.a;
            this.array[1] = this.b;
            this.array[2] = this.tx;
            this.array[3] = this.c;
            this.array[4] = this.d;
            this.array[5] = this.ty;
            this.array[6] = 0;
            this.array[7] = 0;
            this.array[8] = 1;
        }
        return this.array;
    };
    /**
     * 将 Matrix 的成员设置为指定值
     * @method egret.Matrix#setTo
     * @param aa {number} 要将 Matrix 设置为的值
     * @param ba {number} 要将 Matrix 设置为的值
     * @param ca {number} 要将 Matrix 设置为的值
     * @param da {number} 要将 Matrix 设置为的值
     * @param txa {number} 要将 Matrix 设置为的值
     * @param tya {number} 要将 Matrix 设置为的值
     */
    __egretProto__.setTo = function (aa, ba, ca, da, txa, tya) {
        this.a = aa;
        this.b = ba;
        this.c = ca;
        this.d = da;
        this.tx = txa;
        this.ty = tya;
    };
    /**
     * 将源 Matrix 对象中的所有矩阵数据复制到调用方 Matrix 对象中。
     * @method egret.Matrix#copyFrom
     * @param sourceMatrix {egret.Matrix} 要从中复制数据的 Matrix 对象
     */
    __egretProto__.copyFrom = function (sourceMatrix) {
        this.identityMatrix(sourceMatrix);
    };
    /**
     * 返回一个新的 Matrix 对象，它是此矩阵的克隆，带有与所含对象完全相同的副本。
     * @method egret.Matrix#clone
     * @returns {Matrix} 一个 Matrix 对象
     */
    __egretProto__.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    };
    /**
     * 将某个矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
     * @method egret.Matrix#concat
     * @param m {egret.Matrix} 要连接到源矩阵的矩阵
     */
    __egretProto__.concat = function (m) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var ty1 = this.ty;
        var a2 = m.a;
        var b2 = m.b;
        var c2 = m.c;
        var d2 = m.d;
        var tx2 = m.tx;
        var ty2 = m.ty;
        var a = a1 * a2;
        var b = 0;
        var c = 0;
        var d = d1 * d2;
        var tx = tx1 * a2 + tx2;
        var ty = ty1 * d2 + ty2;
        if (b1 != 0 || c1 != 0 || b2 != 0 || c2 != 0) {
            a += b1 * c2;
            d += c1 * b2;
            b += a1 * b2 + b1 * d2;
            c += c1 * a2 + d1 * c2;
            tx += ty1 * c2;
            ty += tx1 * b2;
        }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * 如果给定预转换坐标空间中的点，则此方法返回发生转换后该点的坐标。
     * 与使用 transformPoint() 方法应用的标准转换不同，deltaTransformPoint() 方法的转换不考虑转换参数 tx 和 ty。
     * @method egret.Matrix#deltaTransformPoint
     * @param point {egret.Point} 想要获得其矩阵转换结果的点
     * @returns {egret.Point} 由应用矩阵转换所产生的点
     */
    __egretProto__.deltaTransformPoint = function (point) {
        var self = this;
        var x = self.a * point.x + self.c * point.y;
        var y = self.b * point.x + self.d * point.y;
        return new egret.Point(x, y);
    };
    /**
     * 返回将 Matrix 对象表示的几何转换应用于指定点所产生的结果。
     * @method egret.Matrix#transformPoint
     * @param point {egret.Point} 想要获得其矩阵转换结果的点
     * @returns {egret.Point} 由应用矩阵转换所产生的点
     */
    __egretProto__.transformPoint = function (point) {
        var self = this;
        var x = self.a * point.x + self.c * point.y + self.tx;
        var y = self.b * point.x + self.d * point.y + self.ty;
        return new egret.Point(x, y);
    };
    /**
     * 返回列出该 Matrix 对象属性的文本值。
     * @method egret.Matrix#toString
     * @returns {egret.Point} 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
     */
    __egretProto__.toString = function () {
        return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
    };
    /**
     * 包括用于缩放、旋转和转换的参数。当应用于矩阵时，该方法会基于这些参数设置矩阵的值。
     * @method egret.Matrix#createBox
     * @param scaleX {number} 水平缩放所用的系数
     * @param scaleY {number} 垂直缩放所用的系数
     * @param rotation {number} 旋转量（以弧度为单位）
     * @param tx {number} 沿 x 轴向右平移（移动）的像素数
     * @param ty {number} 沿 y 轴向下平移（移动）的像素数
     */
    __egretProto__.createBox = function (scaleX, scaleY, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        var self = this;
        if (rotation !== 0) {
            rotation = rotation / egret.Matrix.DEG_TO_RAD;
            var u = egret.NumberUtils.cos(rotation);
            var v = egret.NumberUtils.sin(rotation);
            self.a = u * scaleX;
            self.b = v * scaleY;
            self.c = -v * scaleX;
            self.d = u * scaleY;
        }
        else {
            self.a = scaleX;
            self.b = 0;
            self.c = 0;
            self.d = scaleY;
        }
        self.tx = tx;
        self.ty = ty;
    };
    /**
     * 创建 Graphics 类的 beginGradientFill() 和 lineGradientStyle() 方法所需的矩阵的特定样式。
     * 宽度和高度被缩放为 scaleX/scaleY 对，而 tx/ty 值偏移了宽度和高度的一半。
     * @method egret.Matrix#createGradientBox
     * @param width {number} 渐变框的宽度
     * @param height {number} 渐变框的高度
     * @param rotation {number} 旋转量（以弧度为单位）
     * @param tx {number} 沿 x 轴向右平移的距离（以像素为单位）。此值将偏移 width 参数的一半
     * @param ty {number} 沿 y 轴向下平移的距离（以像素为单位）。此值将偏移 height 参数的一半
     */
    __egretProto__.createGradientBox = function (width, height, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
    };
    /**
     * 引擎内部用于函数传递返回值的全局 Matrix 对象，开发者请勿随意修改此对象
     * @member {egret.Matrix} egret.Matrix.identity
     */
    Matrix.identity = new Matrix();
    /**
     * @private
     */
    Matrix.DEG_TO_RAD = Math.PI / 180;
    return Matrix;
})();
var NumberUtils = (function () {
    function NumberUtils() {
    }
    var __egretProto__ = NumberUtils.prototype;
    /**
     * @private
     */
    NumberUtils.isNumber = function (value) {
        return typeof (value) === "number" && !isNaN(value);
    };
    /**
     * 得到对应角度值的sin近似值
     * @param value {number} 角度值
     * @returns {number} sin值
     */
    NumberUtils.sin = function (value) {
        var valueFloor = Math.floor(value);
        var valueCeil = valueFloor + 1;
        var resultFloor = NumberUtils.sinInt(valueFloor);
        var resultCeil = NumberUtils.sinInt(valueCeil);
        return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
    };
    NumberUtils.sinInt = function (value) {
        value = value % 360;
        if (value < 0) {
            value += 360;
        }
        if (value < 90) {
            return egret_sin_map[value];
        }
        if (value < 180) {
            return egret_cos_map[value - 90];
        }
        if (value < 270) {
            return -egret_sin_map[value - 180];
        }
        return -egret_cos_map[value - 270];
    };
    /**
     * 得到对应角度值的cos近似值
     * @param value {number} 角度值
     * @returns {number} cos值
     */
    NumberUtils.cos = function (value) {
        var valueFloor = Math.floor(value);
        var valueCeil = valueFloor + 1;
        var resultFloor = NumberUtils.cosInt(valueFloor);
        var resultCeil = NumberUtils.cosInt(valueCeil);
        return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
    };
    NumberUtils.cosInt = function (value) {
        value = value % 360;
        if (value < 0) {
            value += 360;
        }
        if (value < 90) {
            return egret_cos_map[value];
        }
        if (value < 180) {
            return -egret_sin_map[value - 90];
        }
        if (value < 270) {
            return -egret_cos_map[value - 180];
        }
        return egret_sin_map[value - 270];
    };
    return NumberUtils;
})();
var egret_sin_map = {};
var egret_cos_map = {};
for (var NumberUtils_i = 0; NumberUtils_i <= 90; NumberUtils_i++) {
    egret_sin_map[NumberUtils_i] = Math.sin(NumberUtils_i * Matrix.DEG_TO_RAD);
    egret_cos_map[NumberUtils_i] = Math.cos(NumberUtils_i * Matrix.DEG_TO_RAD);
}
/**
 * @class egret.Rectangle
 * @classdesc 矩形类
 * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
 * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
 * 但是，right 和 bottom 属性与这四个属性是整体相关的。例如，如果更改 right 属性的值，则 width 属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化。
 * @extends egret.HashObject
 * @includeExample egret/geom/Rectangle.ts
 */
var Rectangle = (function () {
    /**
     * 创建一个 egret.Rectangle 对象。
     * 其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。如果调用此函数时不使用任何参数，将创建一个 x、y、width 和 height 属性均设置为 0 的矩形。
     * @method egret.Rectangle#constructor
     * @param x {number} 矩形左上角的 x 坐标。
     * @param y {number} 矩形左上角的 y 坐标。
     * @param width {number} 矩形的宽度（以像素为单位）。
     * @param height {number} 矩形的高度（以像素为单位）。
     */
    function Rectangle(x, y, width, height) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    var __egretProto__ = Rectangle.prototype;
    Object.defineProperty(__egretProto__, "left", {
        /**
         * 矩形左上角的 x 坐标。
         * @member {number} egret.Rectangle#left
         */
        get: function () {
            return this.x;
        },
        set: function (value) {
            this.width += this.x - value;
            this.x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "right", {
        /**
         * x 和 width 属性的和。
         * @member {number} egret.Rectangle#right
         */
        get: function () {
            return this.x + this.width;
        },
        set: function (value) {
            this.width = value - this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "top", {
        /**
         * 矩形左上角的 y 坐标。
         * @member {number} egret.Rectangle#top
         */
        get: function () {
            return this.y;
        },
        set: function (value) {
            this.height += this.y - value;
            this.y = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "bottom", {
        /**
         * y 和 height 属性的和。
         * @member {number} egret.Rectangle#bottom
         */
        get: function () {
            return this.y + this.height;
        },
        set: function (value) {
            this.height = value - this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "topLeft", {
        /**
         * 由该点的 x 和 y 坐标确定的 Rectangle 对象左上角的位置。
         * @member {number} egret.Rectangle#topLeft
         */
        get: function () {
            return new egret.Point(this.left, this.top);
        },
        set: function (value) {
            this.top = value.y;
            this.left = value.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "bottomRight", {
        /**
         * 由 right 和 bottom 属性的值确定的 Rectangle 对象的右下角的位置。
         * @member {number} egret.Rectangle#bottomRight
         */
        get: function () {
            return new egret.Point(this.right, this.bottom);
        },
        set: function (value) {
            this.bottom = value.y;
            this.right = value.x;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 举行类初始化赋值，开发者尽量调用此方法复用Rectangle对象，而不是每次需要的时候都重新创建
     * @method egret.Rectangle#initialize
     * @param x {number} 矩形的x轴
     * @param y {number} 矩形的y轴
     * @param width {number} 矩形的宽度
     * @param height {number} 矩形的高度
     * @returns {egret.Rectangle}
     * @deprecated
     */
    __egretProto__.initialize = function (x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
    };
    /**
     * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
     * @method egret.Rectangle#contains
     * @param x {number} 检测点的x轴
     * @param y {number} 检测点的y轴
     * @returns {boolean} 如果检测点位于矩形内，返回true，否则，返回false
     */
    __egretProto__.contains = function (x, y) {
        return this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y;
    };
    /**
     * 确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
     * @method egret.Rectangle#intersects
     * @param toIntersect {egret.Rectangle} 要与此 Rectangle 对象比较的 Rectangle 对象。
     * @returns {boolean} 如果两个矩形相交，返回true，否则返回false
     */
    __egretProto__.intersects = function (toIntersect) {
        return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right) && Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
    };
    /**
     * 将 Rectangle 对象的所有属性设置为 0。
     * @method egret.Rectangle#setEmpty
     */
    __egretProto__.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    };
    /**
     * 克隆矩形对象
     * @method egret.Rectangle#clone
     * @returns {egret.Rectangle} 返回克隆后的矩形
     */
    __egretProto__.clone = function () {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };
    /**
     * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
     * 此方法与 Rectangle.contains() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#containsPoint
     * @param point {egret.Point} 包含点对象
     * @returns {boolean} 如果包含，返回true，否则返回false
     */
    __egretProto__.containsPoint = function (point) {
        if (this.x < point.x && this.x + this.width > point.x && this.y < point.y && this.y + this.height > point.y) {
            return true;
        }
        return false;
    };
    /**
     * 将 Rectangle 的成员设置为指定值
     * @method egret.Rectangle#setTo
     * @param xa {number} 要将 Rectangle 设置为的值
     * @param ya {number} 要将 Rectangle 设置为的值
     * @param widtha {number} 要将 Rectangle 设置为的值
     * @param heighta {number} 要将 Rectangle 设置为的值
     */
    __egretProto__.setTo = function (xa, ya, widtha, heighta) {
        this.initialize(xa, ya, widtha, heighta);
    };
    /**
     * 将源 Rectangle 对象中的所有矩形数据复制到调用方 Rectangle 对象中
     * @method egret.Rectangle#copyFrom
     * @param sourceRect {egret.Rectangle} 要从中复制数据的 Rectangle 对象
     */
    __egretProto__.copyFrom = function (sourceRect) {
        this.x = sourceRect.x;
        this.y = sourceRect.y;
        this.width = sourceRect.width;
        this.height = sourceRect.height;
    };
    /**
     * 按指定量增加 Rectangle 对象的大小（以像素为单位）
     * 保持 Rectangle 对象的中心点不变，使用 dx 值横向增加它的大小，使用 dy 值纵向增加它的大小。
     * @method egret.Rectangle#inflate
     * @param dx {number} Rectangle 对象横向增加的值。
     * @param dy {number} Rectangle 对象纵向增加的值。
     */
    __egretProto__.inflate = function (dx, dy) {
        this.x -= dx;
        this.width += 2 * dx;
        this.y -= dy;
        this.height += 2 * dy;
    };
    /**
     * 确定此 Rectangle 对象是否为空
     * @method egret.Rectangle#isEmpty
     * @returns {boolean} 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false
     */
    __egretProto__.isEmpty = function () {
        return this.width == 0 || this.height == 0;
    };
    /**
     * 确定此 Rectangle 对象内是否包含由 rect 参数指定的 Rectangle 对象。
     * 如果一个 Rectangle 对象完全在另一个 Rectangle 的边界内，我们说第二个 Rectangle 包含第一个 Rectangle。
     * @method egret.Rectangle#containsRect
     * @param rect {egret.Rectangle} 所检查的 Rectangle 对象
     * @returns {boolean} 如果此 Rectangle 对象包含您指定的 Rectangle 对象，则返回 true 值，否则返回 false。
     */
    __egretProto__.containsRect = function (rect) {
        var r1 = rect.x + rect.width;
        var b1 = rect.y + rect.height;
        var r2 = this.x + this.width;
        var b2 = this.y + this.height;
        return (rect.x >= this.x) && (rect.x < r2) && (rect.y >= this.y) && (rect.y < b2) && (r1 > this.x) && (r1 <= r2) && (b1 > this.y) && (b1 <= b2);
    };
    /**
     * 确定在 toCompare 参数中指定的对象是否等于此 Rectangle 对象。
     * 此方法将某个对象的 x、y、width 和 height 属性与此 Rectangle 对象所对应的相同属性进行比较。
     * @method egret.Rectangle#equals
     * @param toCompare {egret.Rectangle} 要与此 Rectangle 对象进行比较的矩形
     * @returns {boolean} 如果对象具有与此 Rectangle 对象完全相同的 x、y、width 和 height 属性值，则返回 true 值，否则返回 false。
     */
    __egretProto__.equals = function (toCompare) {
        if (this === toCompare) {
            return true;
        }
        return this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height;
    };
    /**
     * 增加 Rectangle 对象的大小。此方法与 Rectangle.inflate() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#inflatePoint
     * @param point {egret.Point} 此 Point 对象的 x 属性用于增加 Rectangle 对象的水平尺寸。y 属性用于增加 Rectangle 对象的垂直尺寸。
     */
    __egretProto__.inflatePoint = function (point) {
        this.inflate(point.x, point.y);
    };
    /**
     * 如果在 toIntersect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。
     * 如果矩形不相交，则此方法返回一个空的 Rectangle 对象，其属性设置为 0。
     * @method egret.Rectangle#intersection
     * @param toIntersect {egret.Rectangle} 要与此 Rectangle 对象比较的 Rectangle 对象。
     * @returns {egret.Rectangle} 等于交集区域的 Rectangle 对象。如果该矩形不相交，则此方法返回一个空的 Rectangle 对象；即，其 x、y、width 和 height 属性均设置为 0 的矩形。
     */
    __egretProto__.intersection = function (toIntersect) {
        var result = this.clone();
        var x0 = result.x;
        var y0 = result.y;
        var x1 = toIntersect.x;
        var y1 = toIntersect.y;
        var l = Math.max(x0, x1);
        var r = Math.min(x0 + result.width, x1 + toIntersect.width);
        if (l <= r) {
            var t = Math.max(y0, y1);
            var b = Math.min(y0 + result.height, y1 + toIntersect.height);
            if (t <= b) {
                result.setTo(l, t, r - l, b - t);
                return result;
            }
        }
        result.setEmpty();
        return result;
    };
    /**
     * 按指定量调整 Rectangle 对象的位置（由其左上角确定）。
     * @method egret.Rectangle#offset
     * @param dx {number} 将 Rectangle 对象的 x 值移动此数量。
     * @param dy {number} 将 Rectangle 对象的 t 值移动此数量。
     */
    __egretProto__.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    /**
     * 将 Point 对象用作参数来调整 Rectangle 对象的位置。此方法与 Rectangle.offset() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#offsetPoint
     * @param point {egret.Point} 要用于偏移此 Rectangle 对象的 Point 对象。
     */
    __egretProto__.offsetPoint = function (point) {
        this.offset(point.x, point.y);
    };
    /**
     * 生成并返回一个字符串，该字符串列出 Rectangle 对象的水平位置和垂直位置以及高度和宽度。
     * @method egret.Rectangle#toString
     * @returns {string} 一个字符串，它列出了 Rectangle 对象的下列各个属性的值：x、y、width 和 height。
     */
    __egretProto__.toString = function () {
        return "(x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
    };
    /**
     * 通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
     * @method egret.Rectangle#union
     * @param toUnion {egret.Rectangle} 要添加到此 Rectangle 对象的 Rectangle 对象。
     * @returns {egret.Rectangle} 充当两个矩形的联合的新 Rectangle 对象。
     */
    __egretProto__.union = function (toUnion) {
        var result = this.clone();
        if (toUnion.isEmpty()) {
            return result;
        }
        if (result.isEmpty()) {
            result.copyFrom(toUnion);
            return result;
        }
        var l = Math.min(result.x, toUnion.x);
        var t = Math.min(result.y, toUnion.y);
        result.setTo(l, t, Math.max(result.right, toUnion.right) - l, Math.max(result.bottom, toUnion.bottom) - t);
        return result;
    };
    /**
     * 引擎内部用于函数传递返回值的全局 Rectangle 对象，开发者请勿随意修改此对象
     * @member {egret.Rectangle} egret.Rectangle.identity
     */
    Rectangle.identity = new Rectangle(0, 0, 0, 0);
    return Rectangle;
})();
/**
* @private
*/
var DisplayObjectProperties = (function () {
    function DisplayObjectProperties() {
        this._name = null;
        this._explicitWidth = NaN;
        this._explicitHeight = NaN;
        this._x = 0;
        this._y = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._anchorOffsetX = 0;
        this._anchorOffsetY = 0;
        this._anchorX = 0;
        this._anchorY = 0;
        this._rotation = 0;
        this._alpha = 1;
        this._skewX = 0;
        this._skewY = 0;
        this._blendMode = null;
        this._touchEnabled = DisplayObjectProperties.defaultTouchEnabled;
        this._visible = true;
        this._worldAlpha = 1;
        this._scrollRect = null;
        this._cacheAsBitmap = false;
        this._parent = null;
        this._stage = null;
        this._needDraw = false;
        /**
         * beta功能，请勿调用此方法
         */
        this._filters = null;
        this._hasWidthSet = false;
        this._hasHeightSet = false;
        this._normalDirty = true;
        //对宽高有影响
        this._sizeDirty = true;
        this._isContainer = false;
    }
    var __egretProto__ = DisplayObjectProperties.prototype;
    /**
     * 每个显示对象初始化时默认的 touchEnabled 属性值
     * @default false
     */
    DisplayObjectProperties.defaultTouchEnabled = false;
    return DisplayObjectProperties;
})();
    /**
     * @private
     */
    var DisplayObjectPrivateProperties = (function () {
        function DisplayObjectPrivateProperties() {
            this._hitTestPointTexture = null;
            this._rectW = 0;
            this._rectH = 0;
            this._cacheDirty = false;
        }
        var __egretProto__ = DisplayObjectPrivateProperties.prototype;
        return DisplayObjectPrivateProperties;
    })();
var DisplayObject = (function () {
    /**
     * 创建一个 egret.DisplayObject 对象
     */
    function DisplayObject() {
        this._texture_to_render = null;
        this._worldBounds = null;
        this.__hack_local_matrix = null;
        //尺寸发生改变的回调函数。若此对象被添加到UIAsset里，此函数将被赋值，在尺寸发生改变时通知UIAsset重新测量。
        this._sizeChangeCallBack = null;
        this._sizeChangeCallTarget = null;
        /**
         * 调用显示对象被指定的 mask 对象遮罩。
         * 要确保当舞台缩放时蒙版仍然有效，mask 显示对象必须处于显示列表的活动部分。但不绘制 mask 对象本身。
         * 将 mask 设置为 null 可删除蒙版。
         */
        this.mask = null;
        /**
         * @private
         */
        this.renderTexture = null;
        this._DO_Props_ = new DisplayObjectProperties();
        this._DO_Privs_ = new DisplayObjectPrivateProperties();
        this._worldTransform = new Matrix();
        this._worldBounds = new Rectangle(0, 0, 0, 0);
        this._DO_Privs_._cacheBounds = new Rectangle(0, 0, 0, 0);
    }
    var __egretProto__ = DisplayObject.prototype;
    __egretProto__._setDirty = function () {
        this._DO_Props_._normalDirty = true;
    };
    /**
     * @private
     */
    __egretProto__.getDirty = function () {
        return this._DO_Props_._normalDirty || this._DO_Props_._sizeDirty;
    };
    __egretProto__._setParentSizeDirty = function () {
        var parent = this._DO_Props_._parent;
        if (parent) {
            if (!(parent._DO_Props_._hasWidthSet || parent._DO_Props_._hasHeightSet)) {
                parent._setSizeDirty();
            }
            else {
                parent._setCacheDirty();
            }
        }
    };
    __egretProto__._setSizeDirty = function () {
        var self = this;
        var do_props = self._DO_Props_;
        if (do_props._sizeDirty) {
            return;
        }
        do_props._sizeDirty = true;
        this._setDirty();
        this._setCacheDirty();
        this._setParentSizeDirty();
        if (self._sizeChangeCallBack != null) {
            if (self._sizeChangeCallTarget == do_props._parent) {
                self._sizeChangeCallBack.call(self._sizeChangeCallTarget);
            }
            else {
                self._sizeChangeCallBack = null;
                self._sizeChangeCallTarget = null;
            }
        }
    };
    __egretProto__._clearDirty = function () {
        //todo 这个除了文本的，其他都没有clear过
        this._DO_Props_._normalDirty = false;
    };
    __egretProto__._clearSizeDirty = function () {
        //todo 最好在enterFrame都重新算一遍
        this._DO_Props_._sizeDirty = false;
    };
    Object.defineProperty(__egretProto__, "name", {
        get: function () {
            return this._DO_Props_._name;
        },
        /**
         * 表示 DisplayObject 的实例名称。
         * 通过调用父显示对象容器的 getChildByName() 方法，可以在父显示对象容器的子列表中标识该对象。
         * @member {string} egret.DisplayObject#name
         */
        set: function (value) {
            this._DO_Props_._name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "parent", {
        /**
         * 表示包含此显示对象的 DisplayObjectContainer 对象。
         * 使用 parent 属性可以指定高于显示列表层次结构中当前显示对象的显示对象的相对路径。
         * @member {egret.DisplayObjectContainer} egret.DisplayObject#parent
         */
        get: function () {
            return this._DO_Props_._parent;
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._parentChanged = function (parent) {
        this._DO_Props_._parent = parent;
    };
    Object.defineProperty(__egretProto__, "x", {
        /**
         * 表示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 x 坐标。
         * 如果该对象位于具有变形的 DisplayObjectContainer 内，则它也位于包含 DisplayObjectContainer 的本地坐标系中。因此，对于逆时针旋转 90 度的 DisplayObjectContainer，该 DisplayObjectContainer 的子级将继承逆时针旋转 90 度的坐标系。
         * @member {number} egret.DisplayObject#x
         */
        get: function () {
            return this._DO_Props_._x;
        },
        set: function (value) {
            this._setX(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setX = function (value) {
        if (NumberUtils.isNumber(value) && this._DO_Props_._x != value) {
            this._DO_Props_._x = value;
            this._setDirty();
            this._setParentSizeDirty();
        }
    };
    Object.defineProperty(__egretProto__, "y", {
        /**
         * 表示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 y 坐标。
         * 如果该对象位于具有变形的 DisplayObjectContainer 内，则它也位于包含 DisplayObjectContainer 的本地坐标系中。因此，对于逆时针旋转 90 度的 DisplayObjectContainer，该 DisplayObjectContainer 的子级将继承逆时针旋转 90 度的坐标系。
         * @member {number} egret.DisplayObject#y
         */
        get: function () {
            return this._DO_Props_._y;
        },
        set: function (value) {
            this._setY(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setY = function (value) {
        if (NumberUtils.isNumber(value) && this._DO_Props_._y != value) {
            this._DO_Props_._y = value;
            this._setDirty();
            this._setParentSizeDirty();
        }
    };
    Object.defineProperty(__egretProto__, "scaleX", {
        /**
         * 表示从注册点开始应用的对象的水平缩放比例（百分比）。
         * 缩放本地坐标系统将更改 x 和 y 属性值，这些属性值是以整像素定义的。
         * 默认值为 1，即不缩放。
         * @member {number} egret.DisplayObject#scaleX
         * @default 1
         */
        get: function () {
            return this._DO_Props_._scaleX;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._scaleX != value) {
                this._DO_Props_._scaleX = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "scaleY", {
        /**
         * 表示从对象注册点开始应用的对象的垂直缩放比例（百分比）。
         * 缩放本地坐标系统将更改 x 和 y 属性值，这些属性值是以整像素定义的。
         * 默认值为 1，即不缩放。
         * @member {number} egret.DisplayObject#scaleY
         * @default 1
         */
        get: function () {
            return this._DO_Props_._scaleY;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._scaleY != value) {
                this._DO_Props_._scaleY = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "anchorOffsetX", {
        /**
         * 表示从对象绝对锚点X。
         * @member {number} egret.DisplayObject#anchorOffsetX
         * @default 0
         */
        get: function () {
            return this._DO_Props_._anchorOffsetX;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._anchorOffsetX != value) {
                this._DO_Props_._anchorOffsetX = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "anchorOffsetY", {
        /**
         * 表示从对象绝对锚点Y。
         * @member {number} egret.DisplayObject#anchorOffsetY
         * @default 0
         */
        get: function () {
            return this._DO_Props_._anchorOffsetY;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._anchorOffsetY != value) {
                this._DO_Props_._anchorOffsetY = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "anchorX", {
        /**
         * 表示从对象相对锚点X。
         * @member {number} egret.DisplayObject#anchorX
         * @default 0
         * @deprecated
         */
        get: function () {
            return this._DO_Props_._anchorX;
        },
        set: function (value) {
            this._setAnchorX(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setAnchorX = function (value) {
        if (NumberUtils.isNumber(value) && this._DO_Props_._anchorX != value) {
            this._DO_Props_._anchorX = value;
            this._setDirty();
            this._setParentSizeDirty();
        }
    };
    Object.defineProperty(__egretProto__, "anchorY", {
        /**
         * 表示从对象相对锚点Y。
         * @member {number} egret.DisplayObject#anchorY
         * @default 0
         * @deprecated
         */
        get: function () {
            return this._DO_Props_._anchorY;
        },
        set: function (value) {
            this._setAnchorY(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setAnchorY = function (value) {
        if (NumberUtils.isNumber(value) && this._DO_Props_._anchorY != value) {
            this._DO_Props_._anchorY = value;
            this._setDirty();
            this._setParentSizeDirty();
        }
    };
    Object.defineProperty(__egretProto__, "visible", {
        /**
         * 显示对象是否可见。
         * 不可见的显示对象已被禁用。例如，如果实例的 visible=false，则无法单击该对象。
         * 默认值为 true 可见
         * @member {boolean} egret.DisplayObject#visible
         */
        get: function () {
            return this._DO_Props_._visible;
        },
        set: function (value) {
            this._setVisible(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setVisible = function (value) {
        if (this._DO_Props_._visible != value) {
            this._DO_Props_._visible = value;
            this._setSizeDirty();
        }
    };
    Object.defineProperty(__egretProto__, "rotation", {
        /**
         * 表示 DisplayObject 实例距其原始方向的旋转程度，以度为单位。
         * 从 0 到 180 的值表示顺时针方向旋转；从 0 到 -180 的值表示逆时针方向旋转。对于此范围之外的值，可以通过加上或减去 360 获得该范围内的值。例如，my_video.rotation = 450语句与 my_video.rotation = 90 是相同的。
         * @member {number} egret.DisplayObject#rotation
         * @default 0 默认值为 0 不旋转。
         */
        get: function () {
            return this._DO_Props_._rotation;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._rotation != value) {
                this._DO_Props_._rotation = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "alpha", {
        /**
         * 表示指定对象的 Alpha 透明度值。
         * 有效值为 0（完全透明）到 1（完全不透明）。alpha 设置为 0 的显示对象是活动的，即使它们不可见。
         * @member {number} egret.DisplayObject#alpha
         * @default 1
         */
        get: function () {
            return this._DO_Props_._alpha;
        },
        set: function (value) {
            this._setAlpha(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setAlpha = function (value) {
        if (NumberUtils.isNumber(value) && this._DO_Props_._alpha != value) {
            this._DO_Props_._alpha = value;
            this._setDirty();
            this._setCacheDirty();
        }
    };
    Object.defineProperty(__egretProto__, "skewX", {
        /**
         * 表示DisplayObject的x方向斜切
         * @member {number} egret.DisplayObject#skewX
         * @default 0
         */
        get: function () {
            return this._DO_Props_._skewX;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._skewX != value) {
                this._DO_Props_._skewX = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "skewY", {
        /**
         * 表示DisplayObject的y方向斜切
         * @member {number} egret.DisplayObject#skewY
         * @default 0
         */
        get: function () {
            return this._DO_Props_._skewY;
        },
        set: function (value) {
            if (NumberUtils.isNumber(value) && this._DO_Props_._skewY != value) {
                this._DO_Props_._skewY = value;
                this._setDirty();
                this._setParentSizeDirty();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "touchEnabled", {
        /**
         * 指定此对象是否接收鼠标/触摸事件
         * @member {boolean} egret.DisplayObject#touchEnabled
         * @default false 默认为 false 即不可以接收。
         */
        get: function () {
            return this._DO_Props_._touchEnabled;
        },
        set: function (value) {
            this._setTouchEnabled(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setTouchEnabled = function (value) {
        this._DO_Props_._touchEnabled = value;
    };
    Object.defineProperty(__egretProto__, "blendMode", {
        /**
         * BlendMode 类中的一个值，用于指定要使用的混合模式。
         * 内部绘制位图的方法有两种。 如果启用了混合模式或外部剪辑遮罩，则将通过向矢量渲染器添加有位图填充的正方形来绘制位图。 如果尝试将此属性设置为无效值，则运行时会将此值设置为 BlendMode.NORMAL。
         * @member {string} egret.DisplayObject#blendMode
         */
        get: function () {
            return this._DO_Props_._blendMode;
        },
        set: function (value) {
            this._DO_Props_._blendMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "scrollRect", {
        /**
         * 显示对象的滚动矩形范围。显示对象被裁切为矩形定义的大小，当您更改 scrollRect 对象的 x 和 y 属性时，它会在矩形内滚动。
         *  @member {egret.Rectangle} egret.DisplayObject#scrollRect
         */
        get: function () {
            return this._DO_Props_._scrollRect;
        },
        set: function (value) {
            this._setScrollRect(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._setScrollRect = function (value) {
        this._DO_Props_._scrollRect = value;
        this._setSizeDirty();
    };
    Object.defineProperty(__egretProto__, "measuredWidth", {
        /**
         * 测量宽度
         * @returns {number}
         * @member {egret.Rectangle} egret.DisplayObject#measuredWidth
         */
        get: function () {
            return this._measureBounds().width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "measuredHeight", {
        /**
         * 测量高度
         * @returns {number}
         * @member {egret.Rectangle} egret.DisplayObject#measuredWidth
         */
        get: function () {
            return this._measureBounds().height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "explicitWidth", {
        /**
         * 显式设置宽度
         * @returns {number}
         */
        get: function () {
            return this._DO_Props_._explicitWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "explicitHeight", {
        /**
         * 显式设置高度
         * @returns {number}
         */
        get: function () {
            return this._DO_Props_._explicitHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "width", {
        /**
         * 表示显示对象的宽度，以像素为单位。
         * 宽度是根据显示对象内容的范围来计算的。优先顺序为 显式设置宽度 > 测量宽度。
         * @member {number} egret.DisplayObject#width
         * @returns {number}
         */
        get: function () {
            return this._getWidth();
        },
        set: function (value) {
            this._setWidth(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._getWidth = function () {
        return this._getSize(Rectangle.identity).width;
    };
    Object.defineProperty(__egretProto__, "height", {
        /**
         * 表示显示对象的高度，以像素为单位。
         * 高度是根据显示对象内容的范围来计算的。优先顺序为 显式设置高度 > 测量高度。
         * @member {number} egret.DisplayObject#height
         * @returns {number}
         */
        get: function () {
            return this._getHeight();
        },
        set: function (value) {
            this._setHeight(value);
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._getHeight = function () {
        return this._getSize(Rectangle.identity).height;
    };
    /**
     * @inheritDoc
     */
    __egretProto__._setWidth = function (value) {
        this._setSizeDirty();
        this._setCacheDirty();
        this._DO_Props_._explicitWidth = value;
        this._DO_Props_._hasWidthSet = NumberUtils.isNumber(value);
    };
    /**
     * @inheritDoc
     */
    __egretProto__._setHeight = function (value) {
        this._setSizeDirty();
        this._setCacheDirty();
        this._DO_Props_._explicitHeight = value;
        this._DO_Props_._hasHeightSet = NumberUtils.isNumber(value);
    };
    Object.defineProperty(__egretProto__, "worldAlpha", {
        get: function () {
            return this._DO_Props_._worldAlpha;
        },
        /**
         * @private
         */
        set: function (value) {
            this._DO_Props_._worldAlpha = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param renderContext
     */
    __egretProto__._draw = function (renderContext) {
        var o = this;
        if (!o._DO_Props_._visible) {
            o.destroyCacheBounds();
            return;
        }
        var hasDrawCache = o.drawCacheTexture(renderContext);
        if (hasDrawCache) {
            o.destroyCacheBounds();
            return;
        }
        var isCommandPush = MainContext.__use_new_draw && o._DO_Props_._isContainer;
        if (o._hasFilters() && !isCommandPush) {
            this._setGlobalFilters(renderContext);
        }
        renderContext.setAlpha(o.worldAlpha, o.blendMode);
        renderContext.setTransform(o._worldTransform);
        var mask = o.mask || o._DO_Props_._scrollRect;
        if (mask && !isCommandPush) {
            renderContext.pushMask(mask);
        }
        o._render(renderContext);
        if (mask && !isCommandPush) {
            renderContext.popMask();
        }
        if (o._hasFilters() && !isCommandPush) {
            this._removeGlobalFilters(renderContext);
        }
        o.destroyCacheBounds();
    };
    __egretProto__._setGlobalFilters = function (renderContext) {
        var o = this;
        var arr;
        if (o._DO_Props_._filters) {
            arr = o._DO_Props_._filters.concat();
        }
        else {
            arr = [];
        }
        if (this._transform) {
            var colorTransform = this._transform._colorTransform;
            var color = DisplayObject.color;
            color[0] = colorTransform._redMultiplier;
            color[4] = colorTransform._redOffset;
            color[6] = colorTransform._greenMultiplier;
            color[9] = colorTransform._greenOffset;
            color[12] = colorTransform._blueMultiplier;
            color[14] = colorTransform._blueOffset;
            color[18] = colorTransform._alphaMultiplier;
            color[19] = colorTransform._alphaOffset;
            DisplayObject.colorMatrixFilter._matrix = color;
            arr.push(DisplayObject.colorMatrixFilter);
        }
        renderContext.setGlobalFilters(arr);
    };
    __egretProto__._removeGlobalFilters = function (renderContext) {
        renderContext.setGlobalFilters(null);
    };
    __egretProto__._hasFilters = function () {
        var result = this._DO_Props_._filters && this._DO_Props_._filters.length > 0;
        if (this._transform) {
            var colorTransform = this._transform._colorTransform;
            if (colorTransform._redMultiplier != 1 || colorTransform._redOffset != 0 || colorTransform._greenMultiplier != 1 || colorTransform._greenOffset != 0 || colorTransform._blueMultiplier != 1 || colorTransform._blueOffset != 0 || colorTransform._alphaMultiplier != 1 || colorTransform._alphaOffset != 0) {
                result = true;
            }
        }
        return result;
    };
    __egretProto__._pushMask = function (renderContext) {
        var o = this;
        renderContext.setTransform(o._worldTransform);
        var mask = o.mask || o._DO_Props_._scrollRect;
        if (mask) {
            renderContext.pushMask(mask);
        }
    };
    __egretProto__._popMask = function (renderContext) {
        renderContext.popMask();
    };
    /**
     * @private
     */
    __egretProto__.drawCacheTexture = function (renderContext) {
        var display = this;
        if (display._DO_Props_._cacheAsBitmap == false) {
            return false;
        }
        var bounds = display.getBounds(Rectangle.identity);
        if (display._DO_Privs_._cacheDirty || display._texture_to_render == null || Math.round(bounds.width) - display._texture_to_render._textureWidth >= 1 || Math.round(bounds.height) - display._texture_to_render._textureHeight >= 1) {
            var cached = display._makeBitmapCache();
            display._DO_Privs_._cacheDirty = !cached;
        }
        //没有成功生成cache的情形
        if (display._texture_to_render == null)
            return false;
        var renderTexture = display._texture_to_render;
        var offsetX = renderTexture._offsetX;
        var offsetY = renderTexture._offsetY;
        var width = renderTexture._textureWidth;
        var height = renderTexture._textureHeight;
        display._updateTransform();
        renderContext.setAlpha(display.worldAlpha, display.blendMode);
        renderContext.setTransform(display._worldTransform);
        var renderFilter = RenderFilter.getInstance();
        renderFilter.drawImage(renderContext, display, 0, 0, width, height, offsetX, offsetY, width, height);
        return true;
    };
    Object.defineProperty(__egretProto__, "needDraw", {
        get: function () {
            return this._DO_Props_._needDraw;
        },
        /**
         * 强制每帧执行_draw函数
         * @public
         * @member {string} egret.DisplayObject#blendMode
         */
        set: function (value) {
            this._DO_Props_._needDraw = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param renderContext
     */
    __egretProto__._updateTransform = function () {
        var o = this;
        var do_props = o._DO_Props_;
        if (!do_props._visible) {
            return;
        }
        o._calculateWorldTransform();
        if (MainContext._renderLoopPhase == "updateTransform") {
            if (o.needDraw || o._texture_to_render || do_props._cacheAsBitmap) {
                MainContext.instance.addDraw(o._draw, o);
//                RenderCommand.push(o._draw, o);
            }
        }
    };
    /**
     * 计算全局数据
     * @private
     */
    __egretProto__._calculateWorldTransform = function () {
        var o = this;
        var do_props = o._DO_Props_;
        var worldTransform = o._worldTransform;
        var parent = do_props._parent;
        if(parent) {
        	worldTransform.identityMatrix(parent._worldTransform);
        }
        else {
        	worldTransform.identityMatrix(new Matrix);
        }
        this._getMatrix(worldTransform);
        var scrollRect = do_props._scrollRect;
        if (scrollRect) {
            worldTransform.append(1, 0, 0, 1, -scrollRect.x, -scrollRect.y);
        }
        if(parent) {
            o.worldAlpha = parent.worldAlpha * do_props._alpha;
        }
        else {
        	o.worldAlpha = do_props._alpha;
        }
    };
    /**
     * @private
     * @param renderContext
     */
    __egretProto__._render = function (renderContext) {
    };
    /**
     * 获取显示对象的测量边界
     * @method egret.DisplayObject#getBounds
     * @param resultRect {Rectangle} 可选参数，传入用于保存结果的Rectangle对象，避免重复创建对象。
     * @param calculateAnchor {boolean} 可选参数，是否会计算锚点。
     * @returns {Rectangle}
     */
    __egretProto__.getBounds = function (resultRect, calculateAnchor) {
        if (calculateAnchor === void 0) { calculateAnchor = true; }
        var do_props = this._DO_Props_;
        var do_privs = this._DO_Privs_;
        //            if (do_props._cacheBounds.x == 0 && do_props._cacheBounds.y == 0 && do_props._cacheBounds.width == 0 && do_props._cacheBounds.height == 0) {
        var rect = this._measureBounds();
        var w = do_props._hasWidthSet ? do_props._explicitWidth : rect.width;
        var h = do_props._hasHeightSet ? do_props._explicitHeight : rect.height;
        //记录测量宽高
        do_privs._rectW = rect.width;
        do_privs._rectH = rect.height;
        this._clearSizeDirty();
        var x = rect.x;
        var y = rect.y;
        var anchorX = 0, anchorY = 0;
        if (calculateAnchor) {
            if (do_props._anchorX != 0 || do_props._anchorY != 0) {
                anchorX = w * do_props._anchorX;
                anchorY = h * do_props._anchorY;
            }
            else {
                anchorX = do_props._anchorOffsetX;
                anchorY = do_props._anchorOffsetY;
            }
        }
        do_privs._cacheBounds.initialize(x - anchorX, y - anchorY, w, h);
        //            }
        var result = do_privs._cacheBounds;
        if (!resultRect) {
            resultRect = new Rectangle();
        }
        return resultRect.initialize(result.x, result.y, result.width, result.height);
    };
    __egretProto__.destroyCacheBounds = function () {
        var do_privs = this._DO_Privs_;
        do_privs._cacheBounds.x = 0;
        do_privs._cacheBounds.y = 0;
        do_privs._cacheBounds.width = 0;
        do_privs._cacheBounds.height = 0;
    };
    __egretProto__._getConcatenatedMatrix = function () {
        //todo:采用local_matrix模式下这里的逻辑需要修改
        var matrix = DisplayObject.identityMatrixForGetConcatenated.identity();
        var o = this;
        while (o != null) {
            var do_props = o._DO_Props_;
            if (do_props._anchorX != 0 || do_props._anchorY != 0) {
                var bounds = o._getSize(Rectangle.identity);
                matrix.prependTransform(do_props._x, do_props._y, do_props._scaleX, do_props._scaleY, do_props._rotation, do_props._skewX, do_props._skewY, bounds.width * do_props._anchorX, bounds.height * do_props._anchorY);
            }
            else {
                matrix.prependTransform(do_props._x, do_props._y, do_props._scaleX, do_props._scaleY, do_props._rotation, do_props._skewX, do_props._skewY, do_props._anchorOffsetX, do_props._anchorOffsetY);
            }
            if (do_props._scrollRect) {
                matrix.prepend(1, 0, 0, 1, -do_props._scrollRect.x, -do_props._scrollRect.y);
            }
            o = do_props._parent;
        }
        return matrix;
    };
    /**
     * 将 point 对象从显示对象的（本地）坐标转换为舞台（全局）坐标。
     * 此方法允许您将任何给定的 x 和 y 坐标从相对于特定显示对象原点 (0,0) 的值（本地坐标）转换为相对于舞台原点的值（全局坐标）。
     * @method egret.DisplayObject#localToGlobal
     * @param x {number} 本地x坐标
     * @param y {number} 本地y坐标
     * @param resultPoint {Point} 可选参数，传入用于保存结果的Point对象，避免重复创建对象。
     * @returns {egret.Point} 具有相对于舞台的坐标的 Point 对象。
     */
    __egretProto__.localToGlobal = function (x, y, resultPoint) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        var mtx = this._getConcatenatedMatrix();
        mtx.append(1, 0, 0, 1, x, y);
        if (!resultPoint) {
            resultPoint = new Point();
        }
        resultPoint.x = mtx.tx;
        resultPoint.y = mtx.ty;
        return resultPoint;
    };
    /**
     * 将指定舞台坐标（全局）转换为显示对象（本地）坐标。
     * @method egret.DisplayObject#globalToLocal
     * @param x {number} 全局x坐标
     * @param y {number} 全局y坐标
     * @param resultPoint {Point} 可选参数，传入用于保存结果的Point对象，避免重复创建对象。
     * @returns {egret.Point} 具有相对于显示对象的坐标的 Point 对象。
     */
    __egretProto__.globalToLocal = function (x, y, resultPoint) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        var mtx = this._getConcatenatedMatrix();
        mtx.invert();
        mtx.append(1, 0, 0, 1, x, y);
        if (!resultPoint) {
            resultPoint = new Point();
        }
        resultPoint.x = mtx.tx;
        resultPoint.y = mtx.ty;
        return resultPoint;
    };
    /**
     * 检测指定坐标是否在显示对象内
     * @method egret.DisplayObject#hitTest
     * @param x {number} 检测坐标的x轴
     * @param y {number} 检测坐标的y轴
     * @param ignoreTouchEnabled {boolean} 是否忽略 touchEnabled 属性
     * @returns {*}
     */
    __egretProto__.hitTest = function (x, y, ignoreTouchEnabled) {
        if (ignoreTouchEnabled === void 0) { ignoreTouchEnabled = false; }
        var self = this;
        var do_props = self._DO_Props_;
        if (!do_props._visible || (!ignoreTouchEnabled && !do_props._touchEnabled)) {
            return null;
        }
        var bound = self.getBounds(Rectangle.identity, false);
        x -= bound.x;
        y -= bound.y;
        if (0 <= x && x < bound.width && 0 <= y && y < bound.height) {
            if (self.mask || do_props._scrollRect) {
                if (do_props._scrollRect && x > do_props._scrollRect.x && y > do_props._scrollRect.y && x < do_props._scrollRect.x + do_props._scrollRect.width && y < do_props._scrollRect.y + do_props._scrollRect.height) {
                    return self;
                }
                else if (self.mask && self.mask.x <= x && x < self.mask.x + self.mask.width && self.mask.y <= y && y < self.mask.y + self.mask.height) {
                    return self;
                }
                return null;
            }
            return self;
        }
        else {
            return null;
        }
    };
    /**
     * 计算显示对象，以确定它是否与 x 和 y 参数指定的点重叠或相交。x 和 y 参数指定舞台的坐标空间中的点，而不是包含显示对象的显示对象容器中的点（除非显示对象容器是舞台）。
     * 注意，不要在大量物体中使用精确碰撞像素检测，这会带来巨大的性能开销
     * @method egret.DisplayObject#hitTestPoint
     * @param x {number}  要测试的此对象的 x 坐标。
     * @param y {number}  要测试的此对象的 y 坐标。
     * @param shapeFlag {boolean} 是检查对象 (true) 的实际像素，还是检查边框 (false) 的实际像素。
     * @returns {boolean} 如果显示对象与指定的点重叠或相交，则为 true；否则为 false。
     * @platform Web
     */
    __egretProto__.hitTestPoint = function (x, y, shapeFlag) {
        var self = this;
        var do_privs = self._DO_Privs_;
        var p = self.globalToLocal(x, y);
        if (!shapeFlag) {
            return !!self.hitTest(p.x, p.y, true);
        }
        else {
            if (!do_privs._hitTestPointTexture) {
                do_privs._hitTestPointTexture = new RenderTexture();
            }
            var testTexture = do_privs._hitTestPointTexture;
            var px = p.x - do_privs._hitTestPointTexture._offsetX;
            var py = p.y - do_privs._hitTestPointTexture._offsetY;
            testTexture.drawToTexture(self, new Rectangle(px - 1, py - 1, 3, 3));
            var pixelData = testTexture.getPixel32(1, 1);
            if (pixelData[3] != 0) {
                return true;
            }
            return false;
        }
    };
    __egretProto__._getMatrix = function (parentMatrix) {
        if (!parentMatrix) {
            parentMatrix = Matrix.identity.identity();
        }
        var self = this;
        var do_props = self._DO_Props_;
        var anchorX, anchorY;
        var resultPoint = this._getOffsetPoint();
        anchorX = resultPoint.x;
        anchorY = resultPoint.y;
        var matrix = self.__hack_local_matrix;
        if (matrix) {
            parentMatrix.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            parentMatrix.append(1, 0, 0, 1, -anchorX, -anchorY);
        }
        else {
            parentMatrix.appendTransform(do_props._x, do_props._y, do_props._scaleX, do_props._scaleY, do_props._rotation, do_props._skewX, do_props._skewY, anchorX, anchorY);
        }
        return parentMatrix;
    };
    __egretProto__._getSize = function (resultRect) {
        var self = this;
        var do_props = self._DO_Props_;
        if (do_props._hasHeightSet && do_props._hasWidthSet) {
            this._clearSizeDirty();
            return resultRect.initialize(0, 0, do_props._explicitWidth, do_props._explicitHeight);
        }
        this._measureSize(resultRect);
        if (do_props._hasWidthSet) {
            resultRect.width = do_props._explicitWidth;
        }
        if (do_props._hasHeightSet) {
            resultRect.height = do_props._explicitHeight;
        }
        return resultRect;
    };
    /**
     * 测量显示对象坐标与大小
     */
    __egretProto__._measureSize = function (resultRect) {
        var self = this;
        var do_props = self._DO_Props_;
        var do_privs = self._DO_Privs_;
        if (do_props._sizeDirty) {
            resultRect = this._measureBounds();
            do_privs._rectW = resultRect.width;
            do_privs._rectH = resultRect.height;
            this._clearSizeDirty();
        }
        else {
            resultRect.width = do_privs._rectW;
            resultRect.height = do_privs._rectH;
        }
        resultRect.x = 0;
        resultRect.y = 0;
        return resultRect;
    };
    /**
     * 测量显示对象坐标，这个方法需要子类重写
     * @returns {egret.Rectangle}
     * @private
     */
    __egretProto__._measureBounds = function () {
        return Rectangle.identity.initialize(0, 0, 0, 0);
    };
    __egretProto__._getOffsetPoint = function () {
        var o = this;
        var do_props = o._DO_Props_;
        var regX = do_props._anchorOffsetX;
        var regY = do_props._anchorOffsetY;
        if (do_props._anchorX != 0 || do_props._anchorY != 0) {
            var bounds = o._getSize(Rectangle.identity);
            regX = do_props._anchorX * bounds.width;
            regY = do_props._anchorY * bounds.height;
        }
    //    var result = Point.identity;
        var result = {};
        result.x = regX;
        result.y = regY;
        return result;
    };
    __egretProto__._onAddToStage = function () {
        this._DO_Props_._stage = MainContext.instance.stage;
        DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST.push(this);
    };
    __egretProto__._onRemoveFromStage = function () {
        DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST.push(this);
    };
    Object.defineProperty(__egretProto__, "stage", {
        /**
         * 显示对象的舞台。
         * 例如，您可以创建多个显示对象并加载到显示列表中，每个显示对象的 stage 属性是指相同的 Stage 对象。
         * 如果显示对象未添加到显示列表，则其 stage 属性会设置为 null。
         * @member {number} egret.DisplayObject#stage
         * @returns {egret.Stage}
         */
        get: function () {
            return this._DO_Props_._stage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    __egretProto__.addEventListener = function (type, listener, thisObject, useCapture, priority) {
        if (useCapture === void 0) { useCapture = false; }
        if (priority === void 0) { priority = 0; }
        _super.prototype.addEventListener.call(this, type, listener, thisObject, useCapture, priority);
        var isEnterFrame = (type == egret.Event.ENTER_FRAME);
        if (isEnterFrame || type == egret.Event.RENDER) {
            var list = isEnterFrame ? DisplayObject._enterFrameCallBackList : DisplayObject._renderCallBackList;
            this._insertEventBin(list, listener, thisObject, priority, this);
        }
    };
    /**
     * @inheritDoc
     */
    __egretProto__.removeEventListener = function (type, listener, thisObject, useCapture) {
        if (useCapture === void 0) { useCapture = false; }
        _super.prototype.removeEventListener.call(this, type, listener, thisObject, useCapture);
        var isEnterFrame = (type == egret.Event.ENTER_FRAME);
        if (isEnterFrame || type == egret.Event.RENDER) {
            var list = isEnterFrame ? DisplayObject._enterFrameCallBackList : DisplayObject._renderCallBackList;
            this._removeEventBin(list, listener, thisObject, this);
        }
    };
    /**
     * @inheritDoc
     */
    __egretProto__.dispatchEvent = function (event) {
        if (!event._bubbles) {
            return _super.prototype.dispatchEvent.call(this, event);
        }
        var list = [];
        var target = this;
        while (target) {
            list.push(target);
            target = target._DO_Props_._parent;
        }
        event._reset();
        this._dispatchPropagationEvent(event, list);
        return !event._isDefaultPrevented;
    };
    __egretProto__._dispatchPropagationEvent = function (event, list, targetIndex) {
        var length = list.length;
        var eventPhase = 1;
        for (var i = length - 1; i >= 0; i--) {
            var currentTarget = list[i];
            event._currentTarget = currentTarget;
            event._target = this;
            event._eventPhase = eventPhase;
            currentTarget._notifyListener(event);
            if (event._isPropagationStopped || event._isPropagationImmediateStopped) {
                return;
            }
        }
        var eventPhase = 2;
        var currentTarget = list[0];
        event._currentTarget = currentTarget;
        event._target = this;
        event._eventPhase = eventPhase;
        currentTarget._notifyListener(event);
        if (event._isPropagationStopped || event._isPropagationImmediateStopped) {
            return;
        }
        var eventPhase = 3;
        for (i = 1; i < length; i++) {
            var currentTarget = list[i];
            event._currentTarget = currentTarget;
            event._target = this;
            event._eventPhase = eventPhase;
            currentTarget._notifyListener(event);
            if (event._isPropagationStopped || event._isPropagationImmediateStopped) {
                return;
            }
        }
    };
    /**
     * @inheritDoc
     */
    __egretProto__.willTrigger = function (type) {
        var parent = this;
        while (parent) {
            if (parent.hasEventListener(type))
                return true;
            parent = parent._DO_Props_._parent;
        }
        return false;
    };
    Object.defineProperty(__egretProto__, "cacheAsBitmap", {
        /**
         * 如果设置为 true，则 egret 运行时将缓存显示对象的内部位图表示形式。此缓存可以提高包含复杂矢量内容的显示对象的性能。
         * 具有已缓存位图的显示对象的所有矢量数据都将被绘制到位图而不是主显示。像素按一对一与父对象进行映射。如果位图的边界发生更改，则将重新创建位图而不会拉伸它。
         * 除非将 cacheAsBitmap 属性设置为 true，否则不会创建内部位图。
         * @member {number} egret.DisplayObject#cacheAsBitmap
         */
        get: function () {
            return this._DO_Props_._cacheAsBitmap;
        },
        set: function (bool) {
            this._DO_Props_._cacheAsBitmap = bool;
            if (bool) {
                egret.callLater(this._makeBitmapCache, this);
            }
            else {
                this._texture_to_render = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._makeBitmapCache = function () {
        if (!this.renderTexture) {
            this.renderTexture = new egret.RenderTexture();
        }
        var result = this.renderTexture.drawToTexture(this);
        if (result) {
            this._texture_to_render = this.renderTexture;
        }
        else {
            this._texture_to_render = null;
        }
        return result;
    };
    __egretProto__._setCacheDirty = function (dirty) {
        if (dirty === void 0) { dirty = true; }
        this._DO_Privs_._cacheDirty = dirty;
    };
    /**
     * @private
     */
    DisplayObject.getTransformBounds = function (bounds, mtx) {
        var x = bounds.x, y = bounds.y;
        //            var x, y;
        var width = bounds.width, height = bounds.height;
        if (x || y) {
            mtx.appendTransform(0, 0, 1, 1, 0, 0, 0, -x, -y);
        }
        //        if (matrix) { mtx.prependMatrix(matrix); }
        var x_a = width * mtx.a, x_b = width * mtx.b;
        var y_c = height * mtx.c, y_d = height * mtx.d;
        var tx = mtx.tx, ty = mtx.ty;
        var minX = tx, maxX = tx, minY = ty, maxY = ty;
        if ((x = x_a + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((x = x_a + y_c + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((x = y_c + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((y = x_b + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        if ((y = x_b + y_d + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        if ((y = y_d + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        return bounds.initialize(minX, minY, maxX - minX, maxY - minY);
    };
    Object.defineProperty(__egretProto__, "filters", {
        get: function () {
            return this._DO_Props_._filters;
        },
        /**
         * @private
         */
        set: function (value) {
            this._DO_Props_._filters = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "transform", {
        /**
         * @private
         */
        get: function () {
            if (!this._transform) {
                this._transform = new egret.Transform(this);
            }
            return this._transform;
        },
        enumerable: true,
        configurable: true
    });
    DisplayObject.color = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
    ];
    //DisplayObject.colorMatrixFilter = new ColorMatrixFilter();
    /**
     * @private
     * @returns {Matrix}
     */
    DisplayObject.identityMatrixForGetConcatenated = new Matrix();
    DisplayObject._enterFrameCallBackList = [];
    DisplayObject._renderCallBackList = [];
    return DisplayObject;
})();
/**
 * @extends egret.DisplayObject
 * @class egret.DisplayObjectContainer
 * @classdesc
 * DisplayObjectContainer 类是可用作显示列表中显示对象容器的所有对象的基类。
 * 该显示列表管理运行时中显示的所有对象。使用 DisplayObjectContainer 类排列显示列表中的显示对象。每个 DisplayObjectContainer 对象都有自己的子级列表，用于组织对象的 Z 轴顺序。Z 轴顺序是由前至后的顺序，可确定哪个对象绘制在前，哪个对象绘制在后等。
 * @see http://edn.egret.com/cn/index.php?g=&m=article&a=index&id=108&terms1_id=25&terms2_id=28 显示容器的概念与实现
 * @includeExample egret/display/DisplayObjectContainer.ts
 */
var DisplayObjectContainer = (function (_super) {
    __extends(DisplayObjectContainer, _super);
    /**
     * 创建一个 egret.DisplayObjectContainer 对象
     */
    function DisplayObjectContainer() {
        _super.call(this);
        this._touchChildren = true;
        this._children = [];
        this._DO_Props_._isContainer = true;
    }
    var __egretProto__ = DisplayObjectContainer.prototype;
    Object.defineProperty(__egretProto__, "touchChildren", {
        /**
         * 指定此对象的子项以及子孙项是否接收鼠标/触摸事件
         * 默认值为 true 即可以接收。
         * @member {boolean} egret.DisplayObjectContainer#touchChildren
         */
        get: function () {
            return this._touchChildren;
        },
        set: function (value) {
            this._touchChildren = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "numChildren", {
        /**
         * 返回此对象的子项数目。
         * @member {number} egret.DisplayObjectContainer#numChildren
         */
        get: function () {
            return this._children.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 更改现有子项在显示对象容器中的位置。这会影响子对象的分层。
     * @method egret.DisplayObjectContainer#setChildIndex
     * @param child {egret.DisplayObject} 要为其更改索引编号的 DisplayObject 子实例。
     * @param index {number} 生成的 child 显示对象的索引编号。当新的索引编号小于0或大于已有子元件数量时，新加入的DisplayObject对象将会放置于最上层。
     */
    __egretProto__.setChildIndex = function (child, index) {
        this.doSetChildIndex(child, index);
    };
    __egretProto__.doSetChildIndex = function (child, index) {
        var lastIdx = this._children.indexOf(child);
        if (lastIdx < 0) {
            egret.$error(1006);
        }
        //从原来的位置删除
        this._children.splice(lastIdx, 1);
        //放到新的位置
        if (index < 0 || this._children.length <= index) {
            this._children.push(child);
        }
        else {
            this._children.splice(index, 0, child);
        }
    };
    /**
     * 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。子项将被添加到该 DisplayObjectContainer 实例中其他所有子项的前（上）面。（要将某子项添加到特定索引位置，请使用 addChildAt() 方法。）
     * @method egret.DisplayObjectContainer#addChild
     * @param child {egret.DisplayObject} 要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
     * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
     */
    __egretProto__.addChild = function (child) {
        var index = this._children.length;
        if (child.parent == this)
            index--;
        return this._doAddChild(child, index);
    };
    /**
     * 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 DisplayObjectContainer 对象的显示列表的后（底）部。如果索引值为-1，则表示该DisplayObjectContainer 对象的显示列表的前（上）部。
     * @method egret.DisplayObjectContainer#addChildAt
     * @param child {egret.DisplayObject} 要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
     * @param index {number} 添加该子项的索引位置。 如果指定当前占用的索引位置，则该位置以及所有更高位置上的子对象会在子级列表中上移一个位置。
     * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
     */
    __egretProto__.addChildAt = function (child, index) {
        return this._doAddChild(child, index);
    };
    __egretProto__._doAddChild = function (child, index, notifyListeners) {
        if (notifyListeners === void 0) { notifyListeners = true; }
        if (child == this)
            return child;
        if (index < 0 || index > this._children.length) {
            egret.$error(1007);
            return child;
        }
        var host = child.parent;
        if (host == this) {
            this.doSetChildIndex(child, index);
            return child;
        }
        if (host) {
            var hostIndex = host._children.indexOf(child);
            if (hostIndex >= 0) {
                host._doRemoveChild(hostIndex);
            }
        }
        this._children.splice(index, 0, child);
        child._parentChanged(this);
        if (notifyListeners)
            var i = 0;
            //child.dispatchEventWith(egret.Event.ADDED, true);
        if (this._DO_Props_._stage) {
            child._onAddToStage();
            var list = DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST;
            while (list.length > 0) {
                var childAddToStage = list.shift();
                if (notifyListeners) {
                    //childAddToStage.dispatchEventWith(egret.Event.ADDED_TO_STAGE);
                    var j = 0;
                }
            }
        }
        child._setDirty();
        this._setSizeDirty();
        return child;
    };
    /**
     * 将一个 DisplayObject 子实例从 DisplayObjectContainer 实例中移除。
     * @method egret.DisplayObjectContainer#removeChild
     * @param child {egret.DisplayObject} 要删除的 DisplayObject 实例。
     * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
     */
    __egretProto__.removeChild = function (child) {
        var index = this._children.indexOf(child);
        if (index >= 0) {
            return this._doRemoveChild(index);
        }
        else {
            egret.$error(1008);
            return null;
        }
    };
    /**
     * 从 DisplayObjectContainer 的子列表中指定的 index 位置删除子 DisplayObject。
     * @method egret.DisplayObjectContainer#removeChildAt
     * @param index {number} 要删除的 DisplayObject 的子索引。
     * @returns {egret.DisplayObject} 已删除的 DisplayObject 实例。
     */
    __egretProto__.removeChildAt = function (index) {
        if (index >= 0 && index < this._children.length) {
            return this._doRemoveChild(index);
        }
        else {
            egret.$error(1007);
            return null;
        }
    };
    __egretProto__._doRemoveChild = function (index, notifyListeners) {
        if (notifyListeners === void 0) { notifyListeners = true; }
        var locChildren = this._children;
        var child = locChildren[index];
        if (notifyListeners) {
            var i = 0;
//            child.dispatchEventWith(egret.Event.REMOVED, true);
        }
        if (this._DO_Props_._stage) {
            child._onRemoveFromStage();
            var list = DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST;
            while (list.length > 0) {
                var childAddToStage = list.shift();
                if (notifyListeners) {
                    var j = 0;
                    //childAddToStage.dispatchEventWith(egret.Event.REMOVED_FROM_STAGE);
                }
                childAddToStage._DO_Props_._stage = null;
            }
        }
        child._parentChanged(null);
        locChildren.splice(index, 1);
        this._setSizeDirty();
        return child;
    };
    /**
     * 返回位于指定索引处的子显示对象实例。
     * @method egret.DisplayObjectContainer#getChildAt
     * @param index {number} 子对象的索引位置。
     * @returns {egret.DisplayObject} 位于指定索引位置处的子显示对象。
     */
    __egretProto__.getChildAt = function (index) {
        if (index >= 0 && index < this._children.length) {
            return this._children[index];
        }
        else {
            egret.$error(1007);
            return null;
        }
    };
    /**
     * 确定指定显示对象是 DisplayObjectContainer 实例的子项还是该实例本身。搜索包括整个显示列表（其中包括此 DisplayObjectContainer 实例）。孙项、曾孙项等，每项都返回 true。
     * @method egret.DisplayObjectContainer#contains
     * @param child {egret.DisplayObject} 要测试的子对象。
     * @returns {boolean} 如果指定的显示对象为DisplayObjectContainer该实例本身，则返回true，如果指定的显示对象为当前实例子项，则返回false。
     */
    __egretProto__.contains = function (child) {
        while (child) {
            if (child == this) {
                return true;
            }
            child = child.parent;
        }
        return false;
    };
    /**
     * 在子级列表中两个指定的索引位置，交换子对象的 Z 轴顺序（前后顺序）。显示对象容器中所有其他子对象的索引位置保持不变。
     * @method egret.DisplayObjectContainer#swapChildrenAt
     * @param index1 {number} 第一个子对象的索引位置。
     * @param index2 {number} 第二个子对象的索引位置。
     */
    __egretProto__.swapChildrenAt = function (index1, index2) {
        if (index1 >= 0 && index1 < this._children.length && index2 >= 0 && index2 < this._children.length) {
            this._swapChildrenAt(index1, index2);
        }
        else {
            egret.$error(1007);
        }
    };
    /**
     * 交换两个指定子对象的 Z 轴顺序（从前到后顺序）。显示对象容器中所有其他子对象的索引位置保持不变。
     * @method egret.DisplayObjectContainer#swapChildren
     * @param child1 {egret.DisplayObject} 第一个子对象。
     * @param child2 {egret.DisplayObject} 第二个子对象。
     */
    __egretProto__.swapChildren = function (child1, child2) {
        var index1 = this._children.indexOf(child1);
        var index2 = this._children.indexOf(child2);
        if (index1 == -1 || index2 == -1) {
            egret.$error(1008);
        }
        else {
            this._swapChildrenAt(index1, index2);
        }
    };
    __egretProto__._swapChildrenAt = function (index1, index2) {
        if (index1 == index2) {
            return;
        }
        var list = this._children;
        var child = list[index1];
        list[index1] = list[index2];
        list[index2] = child;
    };
    /**
     * 返回 DisplayObject 的 child 实例的索引位置。
     * @method egret.DisplayObjectContainer#getChildIndex
     * @param child {egret.DisplayObject} 要标识的 DisplayObject 实例。
     * @returns {number} 要标识的子显示对象的索引位置。
     */
    __egretProto__.getChildIndex = function (child) {
        return this._children.indexOf(child);
    };
    /**
     * 从 DisplayObjectContainer 实例的子级列表中删除所有 child DisplayObject 实例。
     * @method egret.DisplayObjectContainer#removeChildren
     */
    __egretProto__.removeChildren = function () {
        var locChildren = this._children;
        for (var i = locChildren.length - 1; i >= 0; i--) {
            this._doRemoveChild(i);
        }
    };
    __egretProto__._updateTransform = function () {
        var o = this;
        if (!o._DO_Props_._visible) {
            return;
        }
        if (o._hasFilters()) {
            egret.RenderCommand.push(o._setGlobalFilters, o);
        }
        var mask = o.mask || o._DO_Props_._scrollRect;
        if (mask) {
            egret.RenderCommand.push(o._pushMask, o);
        }
        _super.prototype._updateTransform.call(this);
        if (!o._DO_Props_._cacheAsBitmap || !o._texture_to_render) {
            for (var i = 0, children = o._children, length = children.length; i < length; i++) {
                var child = children[i];
                child._updateTransform();
            }
        }
        if (mask) {
            egret.RenderCommand.push(o._popMask, o);
        }
        if (o._hasFilters()) {
            egret.RenderCommand.push(o._removeGlobalFilters, o);
        }
    };
    __egretProto__._render = function (renderContext) {
        if (!egret.MainContext.__use_new_draw) {
            var o = this;
            for (var i = 0, children = o._children, length = children.length; i < length; i++) {
                var child = children[i];
                child._draw(renderContext);
            }
        }
    };
    /**
     * @see egret.DisplayObject._measureBounds
     * @returns {null}
     * @private
     */
    __egretProto__._measureBounds = function () {
        var o = this;
        var minX = 0, maxX = 0, minY = 0, maxY = 0;
        var children = o._children;
        var l = children.length;
        for (var i = 0; i < l; i++) {
            var child = children[i];
            if (!child.visible) {
                continue;
            }
            var childBounds = child.getBounds(egret.Rectangle.identity, false);
            var childBoundsX = childBounds.x;
            var childBoundsY = childBounds.y;
            var childBoundsW = childBounds.width;
            var childBoundsH = childBounds.height;
            var childMatrix = child._getMatrix();
            var bounds = egret.DisplayObject.getTransformBounds(egret.Rectangle.identity.initialize(childBoundsX, childBoundsY, childBoundsW, childBoundsH), childMatrix);
            var x1 = bounds.x, y1 = bounds.y, x2 = bounds.width + bounds.x, y2 = bounds.height + bounds.y;
            if (x1 < minX || i == 0) {
                minX = x1;
            }
            if (x2 > maxX || i == 0) {
                maxX = x2;
            }
            if (y1 < minY || i == 0) {
                minY = y1;
            }
            if (y2 > maxY || i == 0) {
                maxY = y2;
            }
        }
        return egret.Rectangle.identity.initialize(minX, minY, maxX - minX, maxY - minY);
    };
    /**
     * 检测指定坐标是否在显示对象内
     * @method egret.DisplayObjectContainer#hitTest
     * @see egret.DisplayObject.hitTest
     * @param x {number} 检测坐标的x轴
     * @param y {number} 检测坐标的y轴
     * @param ignoreTouchEnabled {boolean} 是否忽略TouchEnabled
     * @returns {egret.DisplayObject} 返回所发生碰撞的DisplayObject对象
     */
    __egretProto__.hitTest = function (x, y, ignoreTouchEnabled) {
        if (ignoreTouchEnabled === void 0) { ignoreTouchEnabled = false; }
        var o = this;
        var result;
        if (!o._DO_Props_._visible) {
            return null;
        }
        if (o._DO_Props_._scrollRect) {
            if (x < o._DO_Props_._scrollRect.x || y < o._DO_Props_._scrollRect.y || x > o._DO_Props_._scrollRect.x + o._DO_Props_._scrollRect.width || y > o._DO_Props_._scrollRect.y + o._DO_Props_._scrollRect.height) {
                return null;
            }
        }
        else if (o.mask) {
            if (o.mask.x > x || x > o.mask.x + o.mask.width || o.mask.y > y || y > o.mask.y + o.mask.height) {
                return null;
            }
        }
        var children = o._children;
        var l = children.length;
        var touchChildren = o._touchChildren; //这里不用考虑父级的touchChildren，从父级调用下来过程中已经判断过了。
        for (var i = l - 1; i >= 0; i--) {
            var child = children[i];
            var mtx = child._getMatrix();
            //todo
            var scrollRect = child.scrollRect;
            if (scrollRect) {
                mtx.append(1, 0, 0, 1, -scrollRect.x, -scrollRect.y);
            }
            mtx.invert();
            var point = egret.Matrix.transformCoords(mtx, x, y);
            var childHitTestResult = child.hitTest(point.x, point.y, true);
            if (childHitTestResult) {
                if (!touchChildren) {
                    return o;
                }
                if (childHitTestResult._DO_Props_._touchEnabled && touchChildren) {
                    return childHitTestResult;
                }
                result = o;
            }
        }
        if (result) {
            return result;
        }
        else if (o._texture_to_render) {
            return _super.prototype.hitTest.call(this, x, y, ignoreTouchEnabled);
        }
        return null;
    };
    __egretProto__._onAddToStage = function () {
        var o = this;
        _super.prototype._onAddToStage.call(this);
        var children = o._children;
        var length = children.length;
        for (var i = 0; i < length; i++) {
            var child = this._children[i];
            child._onAddToStage();
        }
    };
    __egretProto__._onRemoveFromStage = function () {
        var o = this;
        _super.prototype._onRemoveFromStage.call(this);
        var children = o._children;
        var length = children.length;
        for (var i = 0; i < length; i++) {
            var child = children[i];
            child._onRemoveFromStage();
        }
    };
    /**
     * 返回具有指定名称的子显示对象。
     * @method egret.DisplayObjectContainer#getChildByName
     * @param name {string} 要返回的子项的名称。
     * @returns {egret.DisplayObject} 具有指定名称的子显示对象。
     */
    __egretProto__.getChildByName = function (name) {
        var locChildren = this._children;
        var length = locChildren.length;
        var displayObject;
        for (var i = 0; i < length; i++) {
            displayObject = locChildren[i];
            if (displayObject.name == name) {
                return displayObject;
            }
        }
        return null;
    };
    DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST = [];
    DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST = [];
    return DisplayObjectContainer;
})(DisplayObject);
/**
* @classdesc
* @extends egret.HashObject
* @private
*/
var RenderFilter = (function () {
    function RenderFilter() {
        this._originalData = {};
        this._drawAreaList = [];
    }
    var __egretProto__ = RenderFilter.prototype;
    /**
     * @method egret.egret.getInstance
     * @returns {RenderFilter}
     */
    RenderFilter.getInstance = function () {
        if (RenderFilter.instance == null) {
            RenderFilter.instance = new RenderFilter();
        }
        return RenderFilter.instance;
    };
    /**
     * @method egret.egret#addDrawArea
     * @param area {egret.Rectangle}
     */
    __egretProto__.addDrawArea = function (area) {
        this._drawAreaList.push(area);
    };
    /**
     * @method egret.egret#clearDrawArea
     */
    __egretProto__.clearDrawArea = function () {
        this._drawAreaList = [];
    };
    /**
     * 先检查有没有不需要绘制的区域，再把需要绘制的区域绘制出来
     * @method egret.egret#drawImage
     * @param renderContext {any}
     * @param data {RenderData}
     * @param sourceX {number}
     * @param sourceY {number}
     * @param sourceWidth {number}
     * @param sourceHeight {number}
     * @param destX {number}
     * @param destY {number}
     * @param destWidth {number}
     * @param destHeight {number}
     */
    __egretProto__.drawImage = function (renderContext, data, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, repeat) {
        if (repeat === void 0) { repeat = undefined; }
        destX = destX || 0;
        destY = destY || 0;
        var locTexture = data._texture_to_render;
        if (locTexture == null || sourceHeight == 0 || sourceWidth == 0 || destWidth == 0 || destHeight == 0) {
            return;
        }
        var texture_scale_factor = MainContext.instance.rendererContext._texture_scale_factor;
        sourceWidth = sourceWidth / texture_scale_factor;
        sourceHeight = sourceHeight / texture_scale_factor;
        if (this._drawAreaList.length == 0 || !egret.MainContext.instance.rendererContext["_cacheCanvasContext"]) {
            renderContext.drawImage(locTexture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, repeat);
            return;
        }
        //计算worldBounds
        var bounds = DisplayObject.getTransformBounds(data._getSize(RenderFilter.identityRectangle), data._worldTransform);
        data._worldBounds.initialize(bounds.x, bounds.y, bounds.width, bounds.height);
        var originalData = this._originalData;
        originalData.sourceX = sourceX;
        originalData.sourceY = sourceY;
        originalData.sourceWidth = sourceWidth;
        originalData.sourceHeight = sourceHeight;
        originalData.destX = destX;
        originalData.destY = destY;
        originalData.destWidth = destWidth;
        originalData.destHeight = destHeight;
        var locDrawAreaList = this.getDrawAreaList();
        for (var j = 0; j < locDrawAreaList.length; j++) {
            var drawArea = locDrawAreaList[j];
            if (this.ignoreRender(data, drawArea, originalData.destX, originalData.destY)) {
                continue;
            }
            renderContext.drawImage(locTexture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, repeat);
            break;
        }
    };
    __egretProto__.ignoreRender = function (data, rect, destX, destY) {
        var bounds = data._worldBounds;
        var destX = destX * data._worldTransform.a;
        var destY = destY * data._worldTransform.d;
        if (bounds.x + bounds.width + destX <= rect.x || bounds.x + destX >= rect.x + rect.width || bounds.y + bounds.height + destY <= rect.y || bounds.y + destY >= rect.y + rect.height) {
            return true;
        }
        return false;
    };
    /**
     * @method egret.egret#getDrawAreaList
     * @returns {Rectangle}
     */
    __egretProto__.getDrawAreaList = function () {
        var locDrawAreaList;
        //默认整个舞台都是重绘区域
        if (this._drawAreaList.length == 0) {
            if (!this._defaultDrawAreaList) {
                this._defaultDrawAreaList = [new Rectangle(0, 0, MainContext.instance.stage.stageWidth, egret.MainContext.instance.stage.stageHeight)];
                egret.MainContext.instance.stage.addEventListener(egret.Event.RESIZE, this.onResize, this);
            }
            locDrawAreaList = this._defaultDrawAreaList;
        }
        else {
            locDrawAreaList = this._drawAreaList;
        }
        return locDrawAreaList;
    };
    /**
     * 改变尺寸时使用
     */
    __egretProto__.onResize = function () {
        egret.MainContext.instance.stage.removeEventListener(egret.Event.RESIZE, this.onResize, this);
        this._defaultDrawAreaList = null;
    };
    RenderFilter.identityRectangle = new Rectangle();
    return RenderFilter;
})();
var MainContext = (function () {
    function MainContext() {
        this.timeScale = 1;
    	this.drawList = [];
        this.container = null;
        this.rendererContext = null;
        this.texture_scale_factor = 1;
    }

    MainContext.PHASE_DRAW = 'draw';
    MainContext.PHASE_TRANSFORM = 'updateTransform';

    MainContext.prototype.setRenderContext = function(context) {
    	this.rendererContext = context; 
    }

    MainContext.prototype.setObjectContainer = function(container) {
    	this.container = container;	
    }

    MainContext.prototype.addDraw = function(callback, thisObject) {
    	this.drawList.push({callback: callback, thisObject: thisObject});
    }

    MainContext.prototype.run = function() {
		var me = this; 
		var oldTime = Date.now();

		function doEnter() {
			var currentTime = Date.now();
			var advanceTime = currentTime - oldTime;

			me.renderLoop(advanceTime);
        	dragonBones.WorldClock.clock.advanceTime(advanceTime / 1000);

			window.requestAnimationFrame(doEnter);
			oldTime = currentTime;
		}

		window.requestAnimationFrame(doEnter);
	}

	MainContext.prototype.setScale = function(scaleX, scaleY) {
		this.container.scaleX = scaleX;
		this.container.scaleY = scaleY;
	}

	MainContext.prototype.setPosition = function(x, y) {
		this.container.x = x;
		this.container.y = y;
	}

    MainContext.prototype.renderLoop = function (canvas) {
    	this.init(canvas);
        this.startRender();
        MainContext._renderLoopPhase = MainContext.PHASE_TRANSFORM;
        this.container._updateTransform();
        MainContext._renderLoopPhase = MainContext.PHASE_DRAW;
        MainContext.instance.draw(this);
        this.endRender();
    }

    MainContext.prototype.draw = function (context) {
        var length = this.drawList.length;
        for (var i = 0; i < length; i++) {
            var cmd = this.drawList[i];
            context.canvasContext.save();
            cmd.callback.call(cmd.thisObject, context);
            context.canvasContext.restore();
        }
        this.drawList.length = 0;

        return;
    }

    return MainContext;
})();

MainContext.instance = new MainContext;
var CanvasRenderer = (function () {
	var BlendMode = {
		NORMAL: "normal",
		ADD: "add",
		ERASE: "erase",
        ERASE_REVERSE: "eraseReverse"
	};

    function CanvasRenderer(canvas) {
        this.texture_scale_factor = 1;
        this._texture_scale_factor = 1;
    }

    var defaultCanvasId = 'x-canvas';
    var defaultCanvasWidth = 1280;
    var defaultCanvasHeight= 800;

	CanvasRenderer.prototype.setScale = function(scaleX, scaleY) {
		this.container.scaleX = scaleX;
		this.container.scaleY = scaleY;
	}

	CanvasRenderer.prototype.setPosition = function(x, y) {
		this.container.x = x;
		this.container.y = y;
	}

	CanvasRenderer.prototype.uninit = function() {
		this.container = null;
		this.canvasContext = null;
	}

    CanvasRenderer.prototype.init = function(canvas) {
//    	if(this.canvasContext) return;
        this.canvasContext = canvas;
        var f = this.canvasContext.setTransform;
        this.bkTransform = f;
        var that = this;

        this.canvasContext.setTransform = function (a, b, c, d, tx, ty) {
            that._matrixA = a;
            that._matrixB = b;
            that._matrixC = c;
            that._matrixD = d;
            that._matrixTx = tx;
            that._matrixTy = ty;
            this.transform(a, b, c ,d, tx, ty);
//            f.call(that.canvasContext, a, b, c, d, tx, ty);
        };
        this._matrixA = 1;
        this._matrixB = 0;
        this._matrixC = 0;
        this._matrixD = 1;
        this._matrixTx = 0;
        this._matrixTy = 0;
        this._transformTx = 0;
        this._transformTy = 0;
        this.initBlendMode();
    }

    CanvasRenderer.prototype.clearScreen = function () {
        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    CanvasRenderer.prototype.startRender = function () {
        this.canvasContext.save();
    }

    CanvasRenderer.prototype.endRender = function () {
        this.canvasContext.restore();
        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        this.canvasContext.setTransform = this.bkTransform;
        this.bkTransform = null;
    }

    CanvasRenderer.prototype.drawImage = function (texture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, renderType) {
        if (renderType === void 0) { renderType = undefined; }
        destX += this._transformTx;
        destY += this._transformTy;
        this.canvasContext.drawImage(texture._bitmapData, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    }

    CanvasRenderer.prototype.setTransform = function (matrix) {
        //在没有旋转缩放斜切的情况下，先不进行矩阵偏移，等下次绘制的时候偏移
        if (matrix.a == 1 && matrix.b == 0 && matrix.c == 0 && matrix.d == 1 && this._matrixA == 1 && this._matrixB == 0 && this._matrixC == 0 && this._matrixD == 1) {
            this._transformTx = matrix.tx - this._matrixTx;
            this._transformTy = matrix.ty - this._matrixTy;
            return;
        }
        this._transformTx = this._transformTy = 0;
        if (this._matrixA != matrix.a || this._matrixB != matrix.b || this._matrixC != matrix.c || this._matrixD != matrix.d || this._matrixTx != matrix.tx || this._matrixTy != matrix.ty) {
            this.canvasContext.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        }
    }

    CanvasRenderer.prototype.setAlpha = function (alpha, blendMode) {
        this.canvasContext.globalAlpha = alpha;
        if (blendMode) {
            this.blendValue = this.blendModes[blendMode];
            this.canvasContext.globalCompositeOperation = this.blendValue;
        }
        else if (this.blendValue != BlendMode.NORMAL) {
            this.blendValue = this.blendModes[BlendMode.NORMAL];
            this.canvasContext.globalCompositeOperation = this.blendValue;
        }
    }

    CanvasRenderer.prototype.initBlendMode = function () {
        this.blendModes = {};
        this.blendModes[BlendMode.NORMAL] = "source-over";
        this.blendModes[BlendMode.ADD] = "lighter";
        this.blendModes[BlendMode.ERASE] = "destination-out";
        this.blendModes[BlendMode.ERASE_REVERSE] = "destination-in";
    }

    return CanvasRenderer;
})();
var Bitmap = (function (_super) {
    __extends(Bitmap, _super);
    /**
     * 创建一个 egret.Bitmap 对象以引用指定的 Texture 对象
     * @param texture {Texture} 纹理
     */
    function Bitmap(texture) {
        _super.call(this);
        this._texture = null;
        /**
         * 矩形区域，它定义位图对象的九个缩放区域。此属性仅当fillMode为BitmapFillMode.SCALE时有效。
         * scale9Grid的x、y、width、height分别代表九宫图中中间那块的左上点的x、y以及中间方块的宽高。
         * @member {egret.Rectangle} egret.Bitmap#scale9Grid
         */
        this.scale9Grid = null;
        /**
         * 确定位图填充尺寸的方式。
         * 设置为 BitmapFillMode.REPEAT时，位图将重复以填充区域；BitmapFillMode.SCALE时，位图将拉伸以填充区域。
         * 默认值：BitmapFillMode.SCALE。
         * @member {string} egret.Bitmap#fillMode
         */
        this.fillMode = "scale";
        if (texture) {
            this._texture = texture;
            this._setSizeDirty();
        }
        this.needDraw = true;
    }
    var __egretProto__ = Bitmap.prototype;
    Object.defineProperty(__egretProto__, "texture", {
        /**
         * 渲染纹理
         * @member {egret.Texture} egret.Bitmap#texture
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (value == this._texture) {
                return;
            }
            this._setSizeDirty();
            this._texture = value;
        },
        enumerable: true,
        configurable: true
    });
    __egretProto__._render = function (renderContext) {
        var texture = this._texture;
        if (!texture) {
            this._texture_to_render = null;
            return;
        }
        this._texture_to_render = texture;
        var destW = this._DO_Props_._hasWidthSet ? this._DO_Props_._explicitWidth : texture._textureWidth;
        var destH = this._DO_Props_._hasHeightSet ? this._DO_Props_._explicitHeight : texture._textureHeight;
        Bitmap._drawBitmap(renderContext, destW, destH, this);
    };
    Bitmap._drawBitmap = function (renderContext, destW, destH, thisObject) {
        var texture = thisObject._texture_to_render;
        if (!texture) {
            return;
        }
        var textureWidth = texture._textureWidth;
        var textureHeight = texture._textureHeight;
        if (thisObject.fillMode == "scale") {
            var s9g = thisObject.scale9Grid || texture["scale9Grid"];
            if (s9g && textureWidth - s9g.width < destW && textureHeight - s9g.height < destH) {
                Bitmap.drawScale9GridImage(renderContext, thisObject, s9g, destW, destH);
            }
            else {
                var offsetX = texture._offsetX;
                var offsetY = texture._offsetY;
                var bitmapWidth = texture._bitmapWidth || textureWidth;
                var bitmapHeight = texture._bitmapHeight || textureHeight;
                var scaleX = destW / textureWidth;
                offsetX = Math.round(offsetX * scaleX);
                destW = Math.round(bitmapWidth * scaleX);
                var scaleY = destH / textureHeight;
                offsetY = Math.round(offsetY * scaleY);
                destH = Math.round(bitmapHeight * scaleY);
                Bitmap.renderFilter.drawImage(renderContext, thisObject, texture._bitmapX, texture._bitmapY, bitmapWidth, bitmapHeight, offsetX, offsetY, destW, destH);
            }
        }
        else {
            Bitmap.drawRepeatImage(renderContext, thisObject, destW, destH, thisObject.fillMode);
        }
    };
    /**
     * 绘制平铺位图
     */
    Bitmap.drawRepeatImage = function (renderContext, data, destWidth, destHeight, repeat) {
        var texture = data._texture_to_render;
        if (!texture) {
            return;
        }
        var textureWidth = texture._textureWidth;
        var textureHeight = texture._textureHeight;
        var sourceX = texture._bitmapX;
        var sourceY = texture._bitmapY;
        var sourceWidth = texture._bitmapWidth || textureWidth;
        var sourceHeight = texture._bitmapHeight || textureHeight;
        var destX = texture._offsetX;
        var destY = texture._offsetY;
        var renderFilter = egret.RenderFilter.getInstance();
        renderFilter.drawImage(renderContext, data, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, repeat);
    };
    /**
     * 绘制九宫格位图
     */
    Bitmap.drawScale9GridImage = function (renderContext, data, scale9Grid, destWidth, destHeight) {
        var texture_scale_factor = egret.MainContext.instance.rendererContext._texture_scale_factor;
        var texture = data._texture_to_render;
        if (!texture || !scale9Grid) {
            return;
        }
        var textureWidth = texture._textureWidth;
        var textureHeight = texture._textureHeight;
        var sourceX = texture._bitmapX;
        var sourceY = texture._bitmapY;
        var sourceWidth = texture._bitmapWidth || textureWidth;
        var sourceHeight = texture._bitmapHeight || textureHeight;
        destWidth -= textureWidth - sourceWidth;
        destHeight -= textureHeight - sourceHeight;
        if (renderContext.drawImageScale9(texture, sourceX, sourceY, sourceWidth, sourceHeight, texture._offsetX, texture._offsetY, destWidth, destHeight, scale9Grid)) {
            return;
        }
        var destX = texture._offsetX / texture_scale_factor;
        var destY = texture._offsetY / texture_scale_factor;
        var renderFilter = egret.RenderFilter.getInstance();
        var s9g = egret.Rectangle.identity.initialize(scale9Grid.x - Math.round(destX), scale9Grid.y - Math.round(destX), scale9Grid.width, scale9Grid.height);
        var roundedDrawX = Math.round(destX);
        var roundedDrawY = Math.round(destY);
        //防止空心的情况出现。
        if (s9g.y == s9g.bottom) {
            if (s9g.bottom < sourceHeight)
                s9g.bottom++;
            else
                s9g.y--;
        }
        if (s9g.x == s9g.right) {
            if (s9g.right < sourceWidth)
                s9g.right++;
            else
                s9g.x--;
        }
        var sourceX2 = sourceX + s9g.x / texture_scale_factor;
        var sourceX3 = sourceX + s9g.right / texture_scale_factor;
        var sourceRightW = sourceWidth - s9g.right;
        var sourceY2 = sourceY + s9g.y / texture_scale_factor;
        var sourceY3 = sourceY + s9g.bottom / texture_scale_factor;
        var sourceBottomH = sourceHeight - s9g.bottom;
        var destX1 = roundedDrawX + s9g.x;
        var destY1 = roundedDrawY + s9g.y;
        var destScaleGridBottom = destHeight - (sourceHeight - s9g.bottom);
        var destScaleGridRight = destWidth - (sourceWidth - s9g.right);
        renderFilter.drawImage(renderContext, data, sourceX, sourceY, s9g.x, s9g.y, roundedDrawX, roundedDrawY, s9g.x, s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX2, sourceY, s9g.width, s9g.y, destX1, roundedDrawY, destScaleGridRight - s9g.x, s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX3, sourceY, sourceRightW, s9g.y, roundedDrawX + destScaleGridRight, roundedDrawY, destWidth - destScaleGridRight, s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX, sourceY2, s9g.x, s9g.height, roundedDrawX, destY1, s9g.x, destScaleGridBottom - s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX2, sourceY2, s9g.width, s9g.height, destX1, destY1, destScaleGridRight - s9g.x, destScaleGridBottom - s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX3, sourceY2, sourceRightW, s9g.height, roundedDrawX + destScaleGridRight, destY1, destWidth - destScaleGridRight, destScaleGridBottom - s9g.y);
        renderFilter.drawImage(renderContext, data, sourceX, sourceY3, s9g.x, sourceBottomH, roundedDrawX, roundedDrawY + destScaleGridBottom, s9g.x, destHeight - destScaleGridBottom);
        renderFilter.drawImage(renderContext, data, sourceX2, sourceY3, s9g.width, sourceBottomH, destX1, roundedDrawY + destScaleGridBottom, destScaleGridRight - s9g.x, destHeight - destScaleGridBottom);
        renderFilter.drawImage(renderContext, data, sourceX3, sourceY3, sourceRightW, sourceBottomH, roundedDrawX + destScaleGridRight, roundedDrawY + destScaleGridBottom, destWidth - destScaleGridRight, destHeight - destScaleGridBottom);
    };
    /**
     * @see egret.DisplayObject.measureBounds
     * @returns {egret.Rectangle}
     * @private
     */
    __egretProto__._measureBounds = function () {
        var texture = this._texture;
        if (!texture) {
            return _super.prototype._measureBounds.call(this);
        }
        //点击区域要包含原图中得透明区域，所以xy均返回0
        var x = 0; //texture._offsetX;
        var y = 0; //texture._offsetY;
        var w = texture._textureWidth;
        var h = texture._textureHeight;
        return Rectangle.identity.initialize(x, y, w, h);
    };
    Bitmap.renderFilter = RenderFilter.getInstance();
    return Bitmap;
})(DisplayObject);
/**
 * @class egret.SpriteSheet
 * @classdesc SpriteSheet 是一张由多个子位图拼接而成的集合位图，它包含多个 Texture 对象。
 * 每一个 Texture 都共享 SpriteSheet 的集合位图，但是指向它的不同的区域。
 * 在WebGL / OpenGL上，这种做法可以显著提升性能
 * 同时，SpriteSheet可以很方便的进行素材整合，降低HTTP请求数量
 * SpriteSheet 格式的具体规范可以参见此文档  https://github.com/egret-labs/egret-core/wiki/Egret-SpriteSheet-Specification
 * @see http://edn.egret.com/cn/index.php?g=&m=article&a=index&id=135&terms1_id=25&terms2_id=31 纹理集的使用
 * @includeExample egret/display/SpriteSheet.ts
 */
var SpriteSheet = (function () {
    /**
     * 创建一个 egret.SpriteSheet 对象
     * @param texture {Texture} 纹理
     */
    function SpriteSheet(texture) {
        /**
         * 表示bitmapData.width
         */
        this._sourceWidth = 0;
        /**
         * 表示bitmapData.height
         */
        this._sourceHeight = 0;
        /**
         * 表示这个SpriteSheet的位图区域在bitmapData上的起始位置x。
         */
        this._bitmapX = 0;
        /**
         * 表示这个SpriteSheet的位图区域在bitmapData上的起始位置y。
         */
        this._bitmapY = 0;
        /**
         * 纹理缓存字典
         */
        this._textureMap = {};
        this.texture = texture;
        this._sourceWidth = texture.width;
        this._sourceHeight = texture.height;
        this._bitmapX = 0;//texture._bitmapX - texture._offsetX;
        this._bitmapY = 0;//texture._bitmapY - texture._offsetY;
    }
    var __egretProto__ = SpriteSheet.prototype;
    /**
     * 根据指定纹理名称获取一个缓存的 Texture 对象
     * @method egret.SpriteSheet#getTexture
     * @param name {string} 缓存这个 Texture 对象所使用的名称
     * @returns {egret.Texture} Texture 对象
     */
    __egretProto__.getTexture = function (name) {
        return this._textureMap[name];
    };
    /**
     * 为 SpriteSheet 上的指定区域创建一个新的 Texture 对象并缓存它
     * @method egret.SpriteSheet#createTexture
     * @param name {string} 缓存这个 Texture 对象所使用的名称，如果名称已存在，将会覆盖之前的 Texture 对象
     * @param bitmapX {number} 纹理区域在 bitmapData 上的起始坐标x
     * @param bitmapY {number} 纹理区域在 bitmapData 上的起始坐标y
     * @param bitmapWidth {number} 纹理区域在 bitmapData 上的宽度
     * @param bitmapHeight {number} 纹理区域在 bitmapData 上的高度
     * @param offsetX {number} 原始位图的非透明区域 x 起始点
     * @param offsetY {number} 原始位图的非透明区域 y 起始点
     * @param textureWidth {number} 原始位图的高度，若不传入，则使用 bitmapWidth 的值。
     * @param textureHeight {number} 原始位图的宽度，若不传入，则使用 bitmapHeight 的值。
     * @returns {egret.Texture} 创建的 Texture 对象
     */
    __egretProto__.createTexture = function (name, bitmapX, bitmapY, bitmapWidth, bitmapHeight, offsetX, offsetY, textureWidth, textureHeight) {
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (typeof textureWidth === "undefined") {
            textureWidth = offsetX + bitmapWidth;
        }
        if (typeof textureHeight === "undefined") {
            textureHeight = offsetY + bitmapHeight;
        }

        var texture = new Object();
        texture._bitmapData = this.texture;
        var scale = MainContext.instance.rendererContext.texture_scale_factor;
        texture._bitmapX = this._bitmapX + bitmapX;
        texture._bitmapY = this._bitmapY + bitmapY;
        texture._bitmapWidth = bitmapWidth * scale;
        texture._bitmapHeight = bitmapHeight * scale;
        texture._offsetX = offsetX;
        texture._offsetY = offsetY;
        texture._textureWidth = textureWidth * scale;
        texture._textureHeight = textureHeight * scale;
        texture._sourceWidth = this._sourceWidth;
        texture._sourceHeight = this._sourceHeight;
        this._textureMap[name] = texture;
        return texture;
    };
    /**
     * 销毁 SpriteSheet 对象所持有的纹理对象
     * @method egret.SpriteSheet#dispose
     */
    __egretProto__.dispose = function () {
        if (this.texture) {
            this.texture.dispose();
        }
    };
    return SpriteSheet;
})();
var __define = this.__define || function (o, p, g, s) {   Object.defineProperty(o, p, { configurable:true, enumerable:true, get:g,set:s }) };
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DragonBones
     * @classdesc
     * DragonBones
     */
    var DragonBones = (function () {
        function DragonBones() {
        }
        var d = __define,c=DragonBones,p=c.prototype;
        /**
         * DragonBones当前数据格式版本
         */
        DragonBones.DATA_VERSION = "4.0";
        DragonBones.DATA_VERSION_4_5 = "4.5";
        /**
         *
         */
        DragonBones.PARENT_COORDINATE_DATA_VERSION = "3.0";
        DragonBones.VERSION = "4.5.8";
        return DragonBones;
    }());
    dragonBones.DragonBones = DragonBones;
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Animation
     * @classdesc
     * Animation实例隶属于Armature,用于控制Armature的动画播放。
     * @see dragonBones.Bone
     * @see dragonBones.Armature
     * @see dragonBones.AnimationState
     * @see dragonBones.AnimationData
     *
     * @example
       <pre>
       //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        armatureDisplay.x = 200;
        armatureDisplay.y = 500;
        //把它添加到舞台上
        this.addChild(armatureDisplay);


        
        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName:string = armature.animation.animationList[0];

        var animation:dragonBones.Animation = armature.animation;

        //gotoAndPlay的用法：动画播放，播放一遍
        animation.gotoAndPlay(curAnimationName,0,-1,1);

        //gotoAndStop的用法：
        //curAnimationName = armature.animation.animationList[1];
        //动画停在第二个动画的第0.2秒的位置
        //animation.gotoAndStop(curAnimationName,0.2);
        //动画停在第二个动画的一半的位置，如果第三个参数大于0，会忽略第二个参数
        //animation.gotoAndStop(curAnimationName,0, 0.5);
        //继续播放
        //animation.play();
        //暂停播放
        //animation.stop();

        //动画融合
        //animation.gotoAndPlay(curAnimationName,0,-1,0,0,"group1");

        //var animationState:dragonBones.AnimationState = armature.animation.getState(curAnimationName);
        //animationState.addBoneMask("neck",true);
        //播放第二个动画， 放到group "Squat"里
        //curAnimationName = armature.animation.animationList[1];
        //armature.animation.gotoAndPlay(curAnimationName,0,-1,0,0,"group2",dragonBones.Animation.SAME_GROUP);
        //animationState = armature.animation.getState(curAnimationName);
        //animationState.addBoneMask("hip",true);//“hip”是骨架的根骨骼的名字
        //animationState.removeBoneMask("neck",true);
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Animation = (function () {
        /**
         * 创建一个新的Animation实例并赋给传入的Armature实例
         * @param armature {Armature} 骨架实例
         */
        function Animation(armature) {
            /** @private */
            this._animationStateCount = 0;
            this._armature = armature;
            this._animationList = [];
            this._animationStateList = [];
            this._timeScale = 1;
            this._isPlaying = false;
            this.tweenEnabled = true;
        }
        var d = __define,c=Animation,p=c.prototype;
        /**
         * 回收Animation实例用到的所有资源
         */
        p.dispose = function () {
            if (!this._armature) {
                return;
            }
            this._resetAnimationStateList();
            this._animationList.length = 0;
            this._armature = null;
            this._animationDataList = null;
            this._animationList = null;
            this._animationStateList = null;
        };
        p._resetAnimationStateList = function () {
            var i = this._animationStateList.length;
            var animationState;
            while (i--) {
                animationState = this._animationStateList[i];
                animationState._resetTimelineStateList();
                dragonBones.AnimationState._returnObject(animationState);
            }
            this._animationStateList.length = 0;
        };
        /**
         * 开始播放指定名称的动画。
         * 要播放的动画将经过指定时间的淡入过程，然后开始播放，同时之前播放的动画会经过相同时间的淡出过程。
         * @param animationName {string} 指定播放动画的名称.
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param playTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         * @param layer {number} 动画所处的层
         * @param group {string} 动画所处的组
         * @param fadeOutMode {string} 动画淡出模式 (none, sameLayer, sameGroup, sameLayerAndGroup, all).默认值：sameLayerAndGroup
         * @param pauseFadeOut {boolean} 动画淡出时暂停播放
         * @param pauseFadeIn {boolean} 动画淡入时暂停播放
         * @returns {AnimationState} 动画播放状态实例
         * @see dragonBones.AnimationState.
         */
        p.gotoAndPlay = function (animationName, fadeInTime, duration, playTimes, layer, group, fadeOutMode, pauseFadeOut, pauseFadeIn) {
            if (fadeInTime === void 0) { fadeInTime = -1; }
            if (duration === void 0) { duration = -1; }
            if (playTimes === void 0) { playTimes = NaN; }
            if (layer === void 0) { layer = 0; }
            if (group === void 0) { group = null; }
            if (fadeOutMode === void 0) { fadeOutMode = Animation.SAME_LAYER_AND_GROUP; }
            if (pauseFadeOut === void 0) { pauseFadeOut = true; }
            if (pauseFadeIn === void 0) { pauseFadeIn = true; }
            if (!this._animationDataList) {
                return null;
            }
            var i = this._animationDataList.length;
            var animationData;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    animationData = this._animationDataList[i];
                    break;
                }
            }
            if (!animationData) {
                return null;
            }
            var needUpdate = this._isPlaying == false;
            this._isPlaying = true;
            this._isFading = true;
            //
            fadeInTime = fadeInTime < 0 ? (animationData.fadeTime < 0 ? 0.3 : animationData.fadeTime) : fadeInTime;
            var durationScale;
            if (duration < 0) {
                durationScale = animationData.scale < 0 ? 1 : animationData.scale;
            }
            else {
                durationScale = duration * 1000 / animationData.duration;
            }
            playTimes = isNaN(playTimes) ? animationData.playTimes : playTimes;
            //根据fadeOutMode,选择正确的animationState执行fadeOut
            var animationState;
            switch (fadeOutMode) {
                case Animation.NONE:
                    break;
                case Animation.SAME_LAYER:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.layer == layer) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
                case Animation.SAME_GROUP:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.group == group) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
                case Animation.ALL:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        animationState.fadeOut(fadeInTime, pauseFadeOut);
                    }
                    break;
                case Animation.SAME_LAYER_AND_GROUP:
                default:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.layer == layer && animationState.group == group) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
            }
            this._lastAnimationState = dragonBones.AnimationState._borrowObject();
            this._lastAnimationState._layer = layer;
            this._lastAnimationState._group = group;
            this._lastAnimationState.autoTween = this.tweenEnabled;
            this._lastAnimationState._fadeIn(this._armature, animationData, fadeInTime, 1 / durationScale, playTimes, pauseFadeIn);
            this.addState(this._lastAnimationState);
            //控制子骨架播放同名动画
            var slotList = this._armature.getSlots(false);
            i = slotList.length;
            while (i--) {
                var slot = slotList[i];
                if (slot.childArmature) {
                    slot.childArmature.animation.gotoAndPlay(animationName, fadeInTime);
                }
            }
            if (needUpdate) {
                this._armature.advanceTime(0);
            }
            return this._lastAnimationState;
        };
        /**
         * 播放指定名称的动画并停止于某个时间点
         * @param animationName {string} 指定播放的动画名称.
         * @param time {number} 动画停止的绝对时间
         * @param normalizedTime {number} 动画停止的相对动画总时间的系数，这个参数和time参数是互斥的（例如 0.2：动画停止总时间的20%位置） 默认值：-1 意味着使用绝对时间。
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：0
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param layer {string} 动画所处的层
         * @param group {string} 动画所处的组
         * @param fadeOutMode {string} 动画淡出模式 (none, sameLayer, sameGroup, sameLayerAndGroup, all).默认值：sameLayerAndGroup
         * @returns {AnimationState} 动画播放状态实例
         * @see dragonBones.AnimationState.
         */
        p.gotoAndStop = function (animationName, time, normalizedTime, fadeInTime, duration, layer, group, fadeOutMode) {
            if (normalizedTime === void 0) { normalizedTime = -1; }
            if (fadeInTime === void 0) { fadeInTime = 0; }
            if (duration === void 0) { duration = -1; }
            if (layer === void 0) { layer = 0; }
            if (group === void 0) { group = null; }
            if (fadeOutMode === void 0) { fadeOutMode = Animation.ALL; }
            var animationState = this.getState(animationName, layer);
            if (!animationState) {
                animationState = this.gotoAndPlay(animationName, fadeInTime, duration, NaN, layer, group, fadeOutMode);
            }
            if (normalizedTime >= 0) {
                animationState.setCurrentTime(animationState.totalTime * normalizedTime);
            }
            else {
                animationState.setCurrentTime(time);
            }
            animationState.stop();
            return animationState;
        };
        /**
         * 从当前位置继续播放动画
         */
        p.play = function () {
            if (!this._animationDataList || this._animationDataList.length == 0) {
                return;
            }
            if (!this._lastAnimationState) {
                this.gotoAndPlay(this._animationDataList[0].name);
            }
            else if (!this._isPlaying) {
                this._isPlaying = true;
            }
            else {
                this.gotoAndPlay(this._lastAnimationState.name);
            }
        };
        /**
         * 暂停动画播放
         */
        p.stop = function () {
            this._isPlaying = false;
        };
        /**
         * 获得指定名称的 AnimationState 实例.
         * @returns {AnimationState} AnimationState 实例.
         * @see dragonBones..AnimationState.
         */
        p.getState = function (name, layer) {
            if (layer === void 0) { layer = 0; }
            var i = this._animationStateList.length;
            while (i--) {
                var animationState = this._animationStateList[i];
                if (animationState.name == name && animationState.layer == layer) {
                    return animationState;
                }
            }
            return null;
        };
        /**
         * 检查是否包含指定名称的动画.
         * @returns {boolean}.
         */
        p.hasAnimation = function (animationName) {
            var i = this._animationDataList.length;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    return true;
                }
            }
            return false;
        };
        /** @private */
        p._advanceTime = function (passedTime) {
            if (!this._isPlaying) {
                return;
            }
            var isFading = false;
            passedTime *= this._timeScale;
            var i = this._animationStateList.length;
            while (i--) {
                var animationState = this._animationStateList[i];
                if (animationState._advanceTime(passedTime)) {
                    this.removeState(animationState);
                }
                else if (animationState.fadeState != 1) {
                    isFading = true;
                }
            }
            this._isFading = isFading;
        };
        /** @private */
        //当动画播放过程中Bonelist改变时触发
        p._updateAnimationStates = function () {
            var i = this._animationStateList.length;
            while (i--) {
                this._animationStateList[i]._updateTimelineStates();
            }
        };
        p.addState = function (animationState) {
            if (this._animationStateList.indexOf(animationState) < 0) {
                this._animationStateList.unshift(animationState);
                this._animationStateCount = this._animationStateList.length;
            }
        };
        p.removeState = function (animationState) {
            var index = this._animationStateList.indexOf(animationState);
            if (index >= 0) {
                this._animationStateList.splice(index, 1);
                dragonBones.AnimationState._returnObject(animationState);
                if (this._lastAnimationState == animationState) {
                    if (this._animationStateList.length > 0) {
                        this._lastAnimationState = this._animationStateList[0];
                    }
                    else {
                        this._lastAnimationState = null;
                    }
                }
                this._animationStateCount = this._animationStateList.length;
            }
        };
        d(p, "movementList"
            /**
            * 不推荐的API.推荐使用 animationList.
            */
            ,function () {
                return this._animationList;
            }
        );
        d(p, "movementID"
            /**
            * 不推荐的API.推荐使用 lastAnimationName.
            */
            ,function () {
                return this.lastAnimationName;
            }
        );
        d(p, "lastAnimationState"
            /**
             * 最近播放的 AnimationState 实例。
             * @member {AnimationState} dragonBones.Animation#lastAnimationState
             * @see dragonBones.AnimationState
             */
            ,function () {
                return this._lastAnimationState;
            }
        );
        d(p, "lastAnimationName"
            /**
             * 最近播放的动画名称.
             * @member {string} dragonBones.Animation#lastAnimationName
             */
            ,function () {
                return this._lastAnimationState ? this._lastAnimationState.name : null;
            }
        );
        d(p, "animationList"
            /**
             * 所有动画名称列表.
             * @member {string[]} dragonBones.Animation#animationList
             */
            ,function () {
                return this._animationList;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.Animation#isPlaying
             */
            ,function () {
                return this._isPlaying && !this.isComplete;
            }
        );
        d(p, "isComplete"
            /**
             * 最近播放的动画是否播放完成.
             * @member {boolean} dragonBones.Animation#isComplete
             */
            ,function () {
                if (this._lastAnimationState) {
                    if (!this._lastAnimationState.isComplete) {
                        return false;
                    }
                    var i = this._animationStateList.length;
                    while (i--) {
                        if (!this._animationStateList[i].isComplete) {
                            return false;
                        }
                    }
                    return true;
                }
                return true;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放倍数
             * @member {number} dragonBones.Animation#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        d(p, "animationDataList"
            /**
             * 包含的所有动画数据列表
             * @member {AnimationData[]} dragonBones.Animation#animationDataList
             * @see dragonBones.AnimationData.
             */
            ,function () {
                return this._animationDataList;
            }
            ,function (value) {
                this._animationDataList = value;
                this._animationList.length = 0;
                for (var i = 0, len = this._animationDataList.length; i < len; i++) {
                    var animationData = this._animationDataList[i];
                    this._animationList[this._animationList.length] = animationData.name;
                }
            }
        );
        Animation.NONE = "none";
        Animation.SAME_LAYER = "sameLayer";
        Animation.SAME_GROUP = "sameGroup";
        Animation.SAME_LAYER_AND_GROUP = "sameLayerAndGroup";
        Animation.ALL = "all";
        return Animation;
    }());
    dragonBones.Animation = Animation;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationState
     * @classdesc
     * AnimationState 实例由 Animation 实例播放动画时产生， 可以对单个动画的播放进行最细致的调节。
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        armatureDisplay.x = 200;
        armatureDisplay.y = 500;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
      
        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName:string = armature.animation.animationList[0];
        //播放这个动画
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //获取animationState可以对动画进行更多控制；
        var animationState:dragonBones.AnimationState = armature.animation.getState(curAnimationName);
      
        //下面的代码实现人物的脖子和头动，但是其他部位不动
        animationState.addBoneMask("neck",true);
        //下面的代码实现人物的身体动，但是脖子和头不动
        //animationState.addBoneMask("hip",true);//“hip”是骨架的根骨骼的名字
        //animationState.removeBoneMask("neck",true);
        //下面的代码实现动画幅度减小的效果
        //animationState.weight = 0.5;
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
           dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var AnimationState = (function () {
        function AnimationState() {
            /** @private */
            this._layer = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._currentPlayTimes = 0;
            this._totalTime = 0;
            this._currentTime = 0;
            this._lastTime = 0;
            //-1 beforeFade, 0 fading, 1 fadeComplete
            this._fadeState = 0;
            this._playTimes = 0;
            this._timelineStateList = [];
            this._slotTimelineStateList = [];
            this._boneMasks = [];
        }
        var d = __define,c=AnimationState,p=c.prototype;
        /** @private */
        AnimationState._borrowObject = function () {
            if (AnimationState._pool.length == 0) {
                return new AnimationState();
            }
            return AnimationState._pool.pop();
        };
        /** @private */
        AnimationState._returnObject = function (animationState) {
            animationState.clear();
            if (AnimationState._pool.indexOf(animationState) < 0) {
                AnimationState._pool[AnimationState._pool.length] = animationState;
            }
        };
        /** @private */
        AnimationState._clear = function () {
            var i = AnimationState._pool.length;
            while (i--) {
                AnimationState._pool[i].clear();
            }
            AnimationState._pool.length = 0;
            dragonBones.TimelineState._clear();
        };
        p.clear = function () {
            this._resetTimelineStateList();
            this._boneMasks.length = 0;
            this._armature = null;
            this._clip = null;
        };
        p._resetTimelineStateList = function () {
            var i = this._timelineStateList.length;
            while (i--) {
                dragonBones.TimelineState._returnObject(this._timelineStateList[i]);
            }
            this._timelineStateList.length = 0;
            i = this._slotTimelineStateList.length;
            while (i--) {
                dragonBones.SlotTimelineState._returnObject(this._slotTimelineStateList[i]);
            }
            this._slotTimelineStateList.length = 0;
        };
        //骨架装配
        /**
         * 检查指定名称的骨头是否在遮罩中。只有在遮罩中的骨头动画才会被播放
         * @param boneName {string} dragonBones.AnimationState#containsBoneMask
         * @returns {boolean}
         */
        p.containsBoneMask = function (boneName) {
            return this._boneMasks.length == 0 || this._boneMasks.indexOf(boneName) >= 0;
        };
        /**
         * 将一个骨头加入遮罩。只有加入遮罩的骨头的动画才会被播放，如果没有骨头加入遮罩，则所有骨头的动画都会播放。通过这个API可以实现只播放角色的一部分.
         * @param boneName {string} 骨头名称.
         * @param ifInvolveChildBones {boolean} 是否影响子骨头。默认值：true.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.addBoneMask = function (boneName, ifInvolveChildBones) {
            if (ifInvolveChildBones === void 0) { ifInvolveChildBones = true; }
            this.addBoneToBoneMask(boneName);
            if (ifInvolveChildBones) {
                var currentBone = this._armature.getBone(boneName);
                if (currentBone) {
                    var boneList = this._armature.getBones(false);
                    var i = boneList.length;
                    while (i--) {
                        var tempBone = boneList[i];
                        if (currentBone.contains(tempBone)) {
                            this.addBoneToBoneMask(tempBone.name);
                        }
                    }
                }
            }
            this._updateTimelineStates();
            return this;
        };
        /**
         * 将一个指定名称的骨头从遮罩中移除.
         * @param boneName {string} 骨头名称.
         * @param ifInvolveChildBones {boolean} 是否影响子骨头。默认值：true.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.removeBoneMask = function (boneName, ifInvolveChildBones) {
            if (ifInvolveChildBones === void 0) { ifInvolveChildBones = true; }
            this.removeBoneFromBoneMask(boneName);
            if (ifInvolveChildBones) {
                var currentBone = this._armature.getBone(boneName);
                if (currentBone) {
                    var boneList = this._armature.getBones(false);
                    var i = boneList.length;
                    while (i--) {
                        var tempBone = boneList[i];
                        if (currentBone.contains(tempBone)) {
                            this.removeBoneFromBoneMask(tempBone.name);
                        }
                    }
                }
            }
            this._updateTimelineStates();
            return this;
        };
        /**
         * 清空骨头遮罩.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.removeAllMixingTransform = function () {
            this._boneMasks.length = 0;
            this._updateTimelineStates();
            return this;
        };
        p.addBoneToBoneMask = function (boneName) {
            if (this._clip.getTimeline(boneName) && this._boneMasks.indexOf(boneName) < 0) {
                this._boneMasks.push(boneName);
            }
        };
        p.removeBoneFromBoneMask = function (boneName) {
            var index = this._boneMasks.indexOf(boneName);
            if (index >= 0) {
                this._boneMasks.splice(index, 1);
            }
        };
        /**
         * @private
         * Update timeline state based on mixing transforms and clip.
         */
        p._updateTimelineStates = function () {
            var timelineState;
            var slotTimelineState;
            var i = this._timelineStateList.length;
            var len;
            while (i--) {
                timelineState = this._timelineStateList[i];
                if (!this._armature.getBone(timelineState.name)) {
                    this.removeTimelineState(timelineState);
                }
            }
            i = this._slotTimelineStateList.length;
            while (i--) {
                slotTimelineState = this._slotTimelineStateList[i];
                if (!this._armature.getSlot(slotTimelineState.name)) {
                    this.removeSlotTimelineState(slotTimelineState);
                }
            }
            if (this._boneMasks.length > 0) {
                i = this._timelineStateList.length;
                while (i--) {
                    timelineState = this._timelineStateList[i];
                    if (this._boneMasks.indexOf(timelineState.name) < 0) {
                        this.removeTimelineState(timelineState);
                    }
                }
                for (i = 0, len = this._boneMasks.length; i < len; i++) {
                    var timelineName = this._boneMasks[i];
                    this.addTimelineState(timelineName);
                }
            }
            else {
                for (i = 0, len = this._clip.timelineList.length; i < len; i++) {
                    var timeline = this._clip.timelineList[i];
                    this.addTimelineState(timeline.name);
                }
            }
            for (i = 0, len = this._clip.slotTimelineList.length; i < len; i++) {
                var slotTimeline = this._clip.slotTimelineList[i];
                this.addSlotTimelineState(slotTimeline.name);
            }
        };
        p.addTimelineState = function (timelineName) {
            var bone = this._armature.getBone(timelineName);
            if (bone) {
                for (var i = 0, len = this._timelineStateList.length; i < len; i++) {
                    var eachState = this._timelineStateList[i];
                    if (eachState.name == timelineName) {
                        return;
                    }
                }
                var timelineState = dragonBones.TimelineState._borrowObject();
                timelineState._fadeIn(bone, this, this._clip.getTimeline(timelineName));
                this._timelineStateList.push(timelineState);
            }
        };
        p.removeTimelineState = function (timelineState) {
            var index = this._timelineStateList.indexOf(timelineState);
            this._timelineStateList.splice(index, 1);
            dragonBones.TimelineState._returnObject(timelineState);
        };
        p.addSlotTimelineState = function (timelineName) {
            var slot = this._armature.getSlot(timelineName);
            if (slot) {
                for (var i = 0, len = this._slotTimelineStateList.length; i < len; i++) {
                    var eachState = this._slotTimelineStateList[i];
                    if (eachState.name == timelineName) {
                        return;
                    }
                }
                var timelineState = dragonBones.SlotTimelineState._borrowObject();
                timelineState._fadeIn(slot, this, this._clip.getSlotTimeline(timelineName));
                this._slotTimelineStateList.push(timelineState);
            }
        };
        p.removeSlotTimelineState = function (timelineState) {
            var index = this._slotTimelineStateList.indexOf(timelineState);
            this._slotTimelineStateList.splice(index, 1);
            dragonBones.SlotTimelineState._returnObject(timelineState);
        };
        //动画
        /**
         * 播放当前动画。如果动画已经播放完毕, 将不会继续播放.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.play = function () {
            this._isPlaying = true;
            return this;
        };
        /**
         * 暂停当前动画的播放。
         * @returns {AnimationState} 动画播放状态实例
         */
        p.stop = function () {
            this._isPlaying = false;
            return this;
        };
        /** @private */
        p._fadeIn = function (armature, clip, fadeTotalTime, timeScale, playTimes, pausePlayhead) {
            this._armature = armature;
            this._clip = clip;
            this._pausePlayheadInFade = pausePlayhead;
            this._name = this._clip.name;
            this._totalTime = this._clip.duration;
            this.autoTween = this._clip.autoTween;
            this.setTimeScale(timeScale);
            this.setPlayTimes(playTimes);
            //reset
            this._isComplete = false;
            this._currentFrameIndex = -1;
            this._currentPlayTimes = -1;
            if (Math.round(this._totalTime * this._clip.frameRate * 0.001) < 2 || timeScale == Infinity) {
                this._currentTime = this._totalTime;
            }
            else {
                this._currentTime = -1;
            }
            this._time = 0;
            this._boneMasks.length = 0;
            //fade start
            this._isFadeOut = false;
            this._fadeWeight = 0;
            this._fadeTotalWeight = 1;
            this._fadeState = -1;
            this._fadeCurrentTime = 0;
            this._fadeBeginTime = this._fadeCurrentTime;
            this._fadeTotalTime = fadeTotalTime * this._timeScale;
            //default
            this._isPlaying = true;
            this.displayControl = true;
            this.lastFrameAutoTween = true;
            this.additiveBlending = false;
            this.weight = 1;
            this.fadeOutTime = fadeTotalTime;
            this._updateTimelineStates();
            return this;
        };
        /**
         * 淡出当前动画
         * @param fadeTotalTime {number} 淡出时间
         * @param pausePlayhead {boolean} 淡出时动画是否暂停。
         */
        p.fadeOut = function (fadeTotalTime, pausePlayhead) {
            if (!this._armature) {
                return null;
            }
            if (isNaN(fadeTotalTime) || fadeTotalTime < 0) {
                fadeTotalTime = 0;
            }
            this._pausePlayheadInFade = pausePlayhead;
            if (this._isFadeOut) {
                if (fadeTotalTime > this._fadeTotalTime / this._timeScale - (this._fadeCurrentTime - this._fadeBeginTime)) {
                    //如果已经在淡出中，新的淡出需要更长的淡出时间，则忽略
                    //If the animation is already in fade out, the new fade out will be ignored.
                    return this;
                }
            }
            else {
                //第一次淡出
                //The first time to fade out.
                for (var i = 0, len = this._timelineStateList.length; i < len; i++) {
                    var timelineState = this._timelineStateList[i];
                    timelineState._fadeOut();
                }
            }
            //fade start
            this._isFadeOut = true;
            this._fadeTotalWeight = this._fadeWeight;
            this._fadeState = -1;
            this._fadeBeginTime = this._fadeCurrentTime;
            this._fadeTotalTime = this._fadeTotalWeight >= 0 ? fadeTotalTime * this._timeScale : 0;
            //default
            this.displayControl = false;
            return this;
        };
        /** @private */
        p._advanceTime = function (passedTime) {
            passedTime *= this._timeScale;
            this.advanceFadeTime(passedTime);
            if (this._fadeWeight) {
                this.advanceTimelinesTime(passedTime);
            }
            return this._isFadeOut && this._fadeState == 1;
        };
        p.advanceFadeTime = function (passedTime) {
            var fadeStartFlg = false;
            var fadeCompleteFlg = false;
            if (this._fadeBeginTime >= 0) {
                var fadeState = this._fadeState;
                this._fadeCurrentTime += passedTime < 0 ? -passedTime : passedTime;
                if (this._fadeCurrentTime >= this._fadeBeginTime + this._fadeTotalTime) {
                    //fade完全结束之后触发
                    //TODO 研究明白为什么要下次再触发
                    if (this._fadeWeight == 1 ||
                        this._fadeWeight == 0) {
                        fadeState = 1;
                        if (this._pausePlayheadInFade) {
                            this._pausePlayheadInFade = false;
                            this._currentTime = -1;
                        }
                    }
                    this._fadeWeight = this._isFadeOut ? 0 : 1;
                }
                else if (this._fadeCurrentTime >= this._fadeBeginTime) {
                    //fading
                    fadeState = 0;
                    //暂时只支持线性淡入淡出
                    //Currently only support Linear fadein and fadeout
                    this._fadeWeight = (this._fadeCurrentTime - this._fadeBeginTime) / this._fadeTotalTime * this._fadeTotalWeight;
                    if (this._isFadeOut) {
                        this._fadeWeight = this._fadeTotalWeight - this._fadeWeight;
                    }
                }
                else {
                    //before fade
                    fadeState = -1;
                    this._fadeWeight = this._isFadeOut ? 1 : 0;
                }
                if (this._fadeState != fadeState) {
                    //_fadeState == -1 && (fadeState == 0 || fadeState == 1)
                    if (this._fadeState == -1) {
                        fadeStartFlg = true;
                    }
                    //(_fadeState == -1 || _fadeState == 0) && fadeState == 1
                    if (fadeState == 1) {
                        fadeCompleteFlg = true;
                    }
                    this._fadeState = fadeState;
                }
            }
            var event;
            if (fadeStartFlg) {
                if (this._isFadeOut) {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_OUT)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_OUT);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
                else {
                    //动画开始，先隐藏不需要的骨头
                    this.hideBones();
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_IN)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_IN);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
            }
            if (fadeCompleteFlg) {
                if (this._isFadeOut) {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_OUT_COMPLETE)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_OUT_COMPLETE);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
                else {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_IN_COMPLETE)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_IN_COMPLETE);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
            }
        };
        p.advanceTimelinesTime = function (passedTime) {
            if (this._isPlaying && !this._pausePlayheadInFade) {
                this._time += passedTime;
            }
            var startFlg = false;
            var completeFlg = false;
            var loopCompleteFlg = false;
            var isThisComplete = false;
            var currentPlayTimes = 0;
            var currentTime = this._time * 1000;
            if (this._playTimes == 0) {
                isThisComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = this._playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    isThisComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    isThisComplete = true;
                }
                else {
                    isThisComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (isThisComplete) {
                    currentTime = this._totalTime;
                }
            }
            //update timeline
            this._isComplete = isThisComplete;
            var progress = this._time * 1000 / this._totalTime;
            var i = 0;
            var len = 0;
            for (i = 0, len = this._timelineStateList.length; i < len; i++) {
                var timeline = this._timelineStateList[i];
                timeline._update(progress);
                this._isComplete = timeline._isComplete && this._isComplete;
            }
            for (i = 0, len = this._slotTimelineStateList.length; i < len; i++) {
                var slotTimeline = this._slotTimelineStateList[i];
                slotTimeline._update(progress);
                this._isComplete = timeline._isComplete && this._isComplete;
            }
            //update main timeline
            if (this._currentTime != currentTime) {
                if (this._currentPlayTimes != currentPlayTimes) {
                    if (this._currentPlayTimes > 0 && currentPlayTimes > 1) {
                        loopCompleteFlg = true;
                    }
                    this._currentPlayTimes = currentPlayTimes;
                }
                if (this._currentTime < 0) {
                    startFlg = true;
                }
                if (this._isComplete) {
                    completeFlg = true;
                }
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                /*
                if(isThisComplete)
                {
                currentTime = _totalTime * 0.999999;
                }
                //[0, _totalTime)
                */
                this.updateMainTimeline(isThisComplete);
            }
            var event;
            if (startFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.START)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.START);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
            }
            if (completeFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.COMPLETE);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
                if (this.autoFadeOut) {
                    this.fadeOut(this.fadeOutTime, true);
                }
            }
            else if (loopCompleteFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.LOOP_COMPLETE);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
            }
        };
        p.updateMainTimeline = function (isThisComplete) {
            var frameList = this._clip.frameList;
            if (frameList.length > 0) {
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._clip.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (isThisComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = frameList[this._currentFrameIndex];
                    if (prevFrame) {
                        this._armature._arriveAtFrame(prevFrame, null, this, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._armature._arriveAtFrame(currentFrame, null, this, false);
                }
            }
        };
        p.hideBones = function () {
            for (var i = 0, len = this._clip.hideTimelineNameMap.length; i < len; i++) {
                var timelineName = this._clip.hideTimelineNameMap[i];
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    bone._hideSlots();
                }
            }
            var slotTimelineName;
            for (i = 0, len = this._clip.hideSlotTimelineNameMap.length; i < len; i++) {
                slotTimelineName = this._clip.hideSlotTimelineNameMap[i];
                var slot = this._armature.getSlot(slotTimelineName);
                if (slot) {
                    slot._resetToOrigin();
                }
            }
        };
        //属性访问
        p.setAdditiveBlending = function (value) {
            this.additiveBlending = value;
            return this;
        };
        p.setAutoFadeOut = function (value, fadeOutTime) {
            if (fadeOutTime === void 0) { fadeOutTime = -1; }
            this.autoFadeOut = value;
            if (fadeOutTime >= 0) {
                this.fadeOutTime = fadeOutTime * this._timeScale;
            }
            return this;
        };
        p.setWeight = function (value) {
            if (isNaN(value) || value < 0) {
                value = 1;
            }
            this.weight = value;
            return this;
        };
        p.setFrameTween = function (autoTween, lastFrameAutoTween) {
            this.autoTween = autoTween;
            this.lastFrameAutoTween = lastFrameAutoTween;
            return this;
        };
        p.setCurrentTime = function (value) {
            if (value < 0 || isNaN(value)) {
                value = 0;
            }
            this._time = value;
            this._currentTime = this._time * 1000;
            return this;
        };
        p.setTimeScale = function (value) {
            if (isNaN(value) || value == Infinity) {
                value = 1;
            }
            this._timeScale = value;
            return this;
        };
        p.setPlayTimes = function (value) {
            if (value === void 0) { value = 0; }
            //如果动画只有一帧  播放一次就可以
            if (Math.round(this._totalTime * 0.001 * this._clip.frameRate) < 2) {
                this._playTimes = value < 0 ? -1 : 1;
            }
            else {
                this._playTimes = value < 0 ? -value : value;
            }
            this.autoFadeOut = value < 0 ? true : false;
            return this;
        };
        d(p, "name"
            /**
             * 动画的名字
             * @member {string} dragonBones.AnimationState#name
             */
            ,function () {
                return this._name;
            }
        );
        d(p, "layer"
            /**
             * 动画所在的层
             * @member {number} dragonBones.AnimationState#layer
             */
            ,function () {
                return this._layer;
            }
        );
        d(p, "group"
            /**
             * 动画所在的组
             * @member {string} dragonBones.AnimationState#group
             */
            ,function () {
                return this._group;
            }
        );
        d(p, "clip"
            /**
             * 动画包含的动画数据
             * @member {AnimationData} dragonBones.AnimationState#clip
             */
            ,function () {
                return this._clip;
            }
        );
        d(p, "isComplete"
            /**
             * 是否播放完成
             * @member {boolean} dragonBones.AnimationState#isComplete
             */
            ,function () {
                return this._isComplete;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.AnimationState#isPlaying
             */
            ,function () {
                return (this._isPlaying && !this._isComplete);
            }
        );
        d(p, "currentPlayTimes"
            /**
             * 当前播放次数
             * @member {number} dragonBones.AnimationState#currentPlayTimes
             */
            ,function () {
                return this._currentPlayTimes < 0 ? 0 : this._currentPlayTimes;
            }
        );
        d(p, "totalTime"
            /**
             * 动画总时长（单位：秒）
             * @member {number} dragonBones.AnimationState#totalTime
             */
            ,function () {
                return this._totalTime * 0.001;
            }
        );
        d(p, "currentTime"
            /**
             * 动画当前播放时间（单位：秒）
             * @member {number} dragonBones.AnimationState#currentTime
             */
            ,function () {
                return this._currentTime < 0 ? 0 : this._currentTime * 0.001;
            }
        );
        d(p, "fadeWeight"
            ,function () {
                return this._fadeWeight;
            }
        );
        d(p, "fadeState"
            ,function () {
                return this._fadeState;
            }
        );
        d(p, "fadeTotalTime"
            ,function () {
                return this._fadeTotalTime;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放系数。用于调节动画播放速度
             * @member {number} dragonBones.AnimationState#timeScale
             */
            ,function () {
                return this._timeScale;
            }
        );
        d(p, "playTimes"
            /**
             * 播放次数 (0:循环播放， >0:播放次数)
             * @member {number} dragonBones.AnimationState#playTimes
             */
            ,function () {
                return this._playTimes;
            }
        );
        AnimationState._pool = [];
        return AnimationState;
    }());
    dragonBones.AnimationState = AnimationState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimelineState
     * @classdesc
     * SlotTimelineState 负责计算 Slot 的时间轴动画。
     * SlotTimelineState 实例隶属于 AnimationState. AnimationState在创建时会为每个包含动作的 Slot生成一个 SlotTimelineState 实例.
     * @see dragonBones.Animation
     * @see dragonBones.AnimationState
     * @see dragonBones.Slot
     */
    var SlotTimelineState = (function () {
        function SlotTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=SlotTimelineState,p=c.prototype;
        /** @private */
        SlotTimelineState._borrowObject = function () {
            if (SlotTimelineState._pool.length == 0) {
                return new SlotTimelineState();
            }
            return SlotTimelineState._pool.pop();
        };
        /** @private */
        SlotTimelineState._returnObject = function (timeline) {
            if (SlotTimelineState._pool.indexOf(timeline) < 0) {
                SlotTimelineState._pool[SlotTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        SlotTimelineState._clear = function () {
            var i = SlotTimelineState._pool.length;
            while (i--) {
                SlotTimelineState._pool[i].clear();
            }
            SlotTimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._slot) {
                this._slot._removeState(this);
                this._slot = null;
            }
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
        };
        //动画开始结束
        /** @private */
        p._fadeIn = function (slot, animationState, timelineData) {
            this._slot = slot;
            this._armature = this._slot.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._rawAnimationScale = this._animationState.clip.scale;
            this._isComplete = false;
            this._blendEnabled = false;
            this._tweenColor = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
            this._slot._addState(this);
        };
        /** @private */
        p._fadeOut = function () {
        };
        //动画进行中
        /** @private */
        p._update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    if (currentTime >= 0) {
                        currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                    }
                    else {
                        currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                    }
                }
            }
            if (this._currentTime != currentTime) {
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration) {
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._slot._arriveAtFrame(prevFrame, this, this._animationState, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._slot._arriveAtFrame(currentFrame, this, this._animationState, false);
                    this._blendEnabled = currentFrame.displayIndex >= 0;
                    if (this._blendEnabled) {
                        this.updateToNextFrame(currentPlayTimes);
                    }
                    else {
                        this._tweenEasing = NaN;
                        this._tweenColor = false;
                    }
                }
                if (this._blendEnabled) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (!this._animationState.lastFrameAutoTween ||
                    (this._animationState.playTimes &&
                        this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                        ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999))) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.clip.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //color
                if (currentFrame.color && nextFrame.color) {
                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset - currentFrame.color.alphaOffset;
                    this._durationColor.redOffset = nextFrame.color.redOffset - currentFrame.color.redOffset;
                    this._durationColor.greenOffset = nextFrame.color.greenOffset - currentFrame.color.greenOffset;
                    this._durationColor.blueOffset = nextFrame.color.blueOffset - currentFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - currentFrame.color.alphaMultiplier;
                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - currentFrame.color.redMultiplier;
                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - currentFrame.color.greenMultiplier;
                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - currentFrame.color.blueMultiplier;
                    if (this._durationColor.alphaOffset ||
                        this._durationColor.redOffset ||
                        this._durationColor.greenOffset ||
                        this._durationColor.blueOffset ||
                        this._durationColor.alphaMultiplier ||
                        this._durationColor.redMultiplier ||
                        this._durationColor.greenMultiplier ||
                        this._durationColor.blueMultiplier) {
                        this._tweenColor = true;
                    }
                    else {
                        this._tweenColor = false;
                    }
                }
                else if (currentFrame.color) {
                    this._tweenColor = true;
                    this._durationColor.alphaOffset = -currentFrame.color.alphaOffset;
                    this._durationColor.redOffset = -currentFrame.color.redOffset;
                    this._durationColor.greenOffset = -currentFrame.color.greenOffset;
                    this._durationColor.blueOffset = -currentFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = 1 - currentFrame.color.alphaMultiplier;
                    this._durationColor.redMultiplier = 1 - currentFrame.color.redMultiplier;
                    this._durationColor.greenMultiplier = 1 - currentFrame.color.greenMultiplier;
                    this._durationColor.blueMultiplier = 1 - currentFrame.color.blueMultiplier;
                }
                else if (nextFrame.color) {
                    this._tweenColor = true;
                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset;
                    this._durationColor.redOffset = nextFrame.color.redOffset;
                    this._durationColor.greenOffset = nextFrame.color.greenOffset;
                    this._durationColor.blueOffset = nextFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - 1;
                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - 1;
                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - 1;
                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - 1;
                }
                else {
                    this._tweenColor = false;
                }
            }
            else {
                this._tweenColor = false;
            }
            if (!this._tweenColor && this._animationState.displayControl) {
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset, currentFrame.color.redOffset, currentFrame.color.greenOffset, currentFrame.color.blueOffset, currentFrame.color.alphaMultiplier, currentFrame.color.redMultiplier, currentFrame.color.greenMultiplier, currentFrame.color.blueMultiplier, true);
                }
                else if (this._slot._isColorChanged) {
                    this._slot._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenColor && this._animationState.displayControl) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, currentFrame.color.redOffset + this._durationColor.redOffset * progress, currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true);
                }
                else {
                    this._slot._updateDisplayColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, 1 + this._durationColor.alphaMultiplier * progress, 1 + this._durationColor.redMultiplier * progress, 1 + this._durationColor.greenMultiplier * progress, 1 + this._durationColor.blueMultiplier * progress, true);
                }
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._slot._arriveAtFrame(currentFrame, this, this._animationState, false);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenColor = false;
            this._blendEnabled = currentFrame.displayIndex >= 0;
            if (this._blendEnabled) {
                /**
                 * <使用绝对数据>
                 * 单帧的timeline，第一个关键帧的transform为0
                 * timeline.originTransform = firstFrame.transform;
                 * eachFrame.transform = eachFrame.transform - timeline.originTransform;
                 * firstFrame.transform == 0;
                 *
                 * <使用相对数据>
                 * 使用相对数据时，timeline.originTransform = 0，第一个关键帧的transform有可能不为 0
                 */
                if (this._animationState.displayControl) {
                    if (currentFrame.color) {
                        this._slot._updateDisplayColor(currentFrame.color.alphaOffset, currentFrame.color.redOffset, currentFrame.color.greenOffset, currentFrame.color.blueOffset, currentFrame.color.alphaMultiplier, currentFrame.color.redMultiplier, currentFrame.color.greenMultiplier, currentFrame.color.blueMultiplier, true);
                    }
                    else if (this._slot._isColorChanged) {
                        this._slot._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                    }
                }
            }
        };
        SlotTimelineState.HALF_PI = Math.PI * 0.5;
        SlotTimelineState.DOUBLE_PI = Math.PI * 2;
        SlotTimelineState._pool = [];
        return SlotTimelineState;
    }());
    dragonBones.SlotTimelineState = SlotTimelineState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TimelineState
     * @classdesc
     * TimelineState 负责计算 Bone 的时间轴动画。
     * TimelineState 实例隶属于 AnimationState. AnimationState在创建时会为每个包含动作的 Bone生成一个 TimelineState 实例.
     * @see dragonBones.Animation
     * @see dragonBones.AnimationState
     * @see dragonBones.Bone
     */
    var TimelineState = (function () {
        function TimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._lastTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._transform = new dragonBones.DBTransform();
            this._pivot = new dragonBones.Point();
            this._durationTransform = new dragonBones.DBTransform();
            this._durationPivot = new dragonBones.Point();
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=TimelineState,p=c.prototype;
        /** @private */
        TimelineState._borrowObject = function () {
            if (TimelineState._pool.length == 0) {
                return new TimelineState();
            }
            return TimelineState._pool.pop();
        };
        /** @private */
        TimelineState._returnObject = function (timeline) {
            if (TimelineState._pool.indexOf(timeline) < 0) {
                TimelineState._pool[TimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        TimelineState._clear = function () {
            var i = TimelineState._pool.length;
            while (i--) {
                TimelineState._pool[i].clear();
            }
            TimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._bone) {
                this._bone._removeState(this);
                this._bone = null;
            }
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
            this._originTransform = null;
            this._originPivot = null;
        };
        //动画开始结束
        /** @private */
        p._fadeIn = function (bone, animationState, timelineData) {
            this._bone = bone;
            this._armature = this._bone.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this._originTransform = this._timelineData.originTransform;
            this._originPivot = this._timelineData.originPivot;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._rawAnimationScale = this._animationState.clip.scale;
            this._isComplete = false;
            this._tweenTransform = false;
            this._tweenScale = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            this._transform.x = 0;
            this._transform.y = 0;
            this._transform.scaleX = 1;
            this._transform.scaleY = 1;
            this._transform.skewX = 0;
            this._transform.skewY = 0;
            this._pivot.x = 0;
            this._pivot.y = 0;
            this._durationTransform.x = 0;
            this._durationTransform.y = 0;
            this._durationTransform.scaleX = 1;
            this._durationTransform.scaleY = 1;
            this._durationTransform.skewX = 0;
            this._durationTransform.skewY = 0;
            this._durationPivot.x = 0;
            this._durationPivot.y = 0;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
            this._bone._addState(this);
        };
        /** @private */
        p._fadeOut = function () {
            this._transform.skewX = dragonBones.TransformUtil.formatRadian(this._transform.skewX);
            this._transform.skewY = dragonBones.TransformUtil.formatRadian(this._transform.skewY);
        };
        //动画进行中
        /** @private */
        p._update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    if (currentTime >= 0) {
                        currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                    }
                    else {
                        currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                    }
                }
            }
            if (this._currentTime != currentTime) {
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._bone._arriveAtFrame(prevFrame, this, this._animationState, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._bone._arriveAtFrame(currentFrame, this, this._animationState, false);
                    this.updateToNextFrame(currentPlayTimes);
                }
                this.updateTween();
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (!this._animationState.lastFrameAutoTween ||
                    (this._animationState.playTimes &&
                        this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                        ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999))) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.clip.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //transform
                this._durationTransform.x = nextFrame.transform.x - currentFrame.transform.x;
                this._durationTransform.y = nextFrame.transform.y - currentFrame.transform.y;
                this._durationTransform.skewX = nextFrame.transform.skewX - currentFrame.transform.skewX;
                this._durationTransform.skewY = nextFrame.transform.skewY - currentFrame.transform.skewY;
                this._durationTransform.scaleX = nextFrame.transform.scaleX - currentFrame.transform.scaleX + nextFrame.scaleOffset.x;
                this._durationTransform.scaleY = nextFrame.transform.scaleY - currentFrame.transform.scaleY + nextFrame.scaleOffset.y;
                this._durationTransform.normalizeRotation();
                if (nextFrameIndex == 0) {
                    this._durationTransform.skewX = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewX);
                    this._durationTransform.skewY = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewY);
                }
                this._durationPivot.x = nextFrame.pivot.x - currentFrame.pivot.x;
                this._durationPivot.y = nextFrame.pivot.y - currentFrame.pivot.y;
                if (this._durationTransform.x ||
                    this._durationTransform.y ||
                    this._durationTransform.skewX ||
                    this._durationTransform.skewY ||
                    this._durationTransform.scaleX ||
                    this._durationTransform.scaleY ||
                    this._durationPivot.x ||
                    this._durationPivot.y) {
                    this._tweenTransform = true;
                    this._tweenScale = currentFrame.tweenScale;
                }
                else {
                    this._tweenTransform = false;
                    this._tweenScale = false;
                }
            }
            else {
                this._tweenTransform = false;
                this._tweenScale = false;
            }
            if (!this._tweenTransform) {
                if (this._animationState.additiveBlending) {
                    this._transform.x = currentFrame.transform.x;
                    this._transform.y = currentFrame.transform.y;
                    this._transform.skewX = currentFrame.transform.skewX;
                    this._transform.skewY = currentFrame.transform.skewY;
                    this._transform.scaleX = currentFrame.transform.scaleX;
                    this._transform.scaleY = currentFrame.transform.scaleY;
                    this._pivot.x = currentFrame.pivot.x;
                    this._pivot.y = currentFrame.pivot.y;
                }
                else {
                    this._transform.x = this._originTransform.x + currentFrame.transform.x;
                    this._transform.y = this._originTransform.y + currentFrame.transform.y;
                    this._transform.skewX = this._originTransform.skewX + currentFrame.transform.skewX;
                    this._transform.skewY = this._originTransform.skewY + currentFrame.transform.skewY;
                    this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                    this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                    this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                    this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
                }
                this._bone.invalidUpdate();
            }
            else if (!this._tweenScale) {
                if (this._animationState.additiveBlending) {
                    this._transform.scaleX = currentFrame.transform.scaleX;
                    this._transform.scaleY = currentFrame.transform.scaleY;
                }
                else {
                    this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                    this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenTransform) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                var currentTransform = currentFrame.transform;
                var currentPivot = currentFrame.pivot;
                if (this._animationState.additiveBlending) {
                    //additive blending
                    this._transform.x = currentTransform.x + this._durationTransform.x * progress;
                    this._transform.y = currentTransform.y + this._durationTransform.y * progress;
                    this._transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress;
                    this._transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress;
                    if (this._tweenScale) {
                        this._transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress;
                        this._transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress;
                    }
                    this._pivot.x = currentPivot.x + this._durationPivot.x * progress;
                    this._pivot.y = currentPivot.y + this._durationPivot.y * progress;
                }
                else {
                    //normal blending
                    this._transform.x = this._originTransform.x + currentTransform.x + this._durationTransform.x * progress;
                    this._transform.y = this._originTransform.y + currentTransform.y + this._durationTransform.y * progress;
                    this._transform.skewX = this._originTransform.skewX + currentTransform.skewX + this._durationTransform.skewX * progress;
                    this._transform.skewY = this._originTransform.skewY + currentTransform.skewY + this._durationTransform.skewY * progress;
                    if (this._tweenScale) {
                        this._transform.scaleX = this._originTransform.scaleX * currentTransform.scaleX + this._durationTransform.scaleX * progress;
                        this._transform.scaleY = this._originTransform.scaleY * currentTransform.scaleY + this._durationTransform.scaleY * progress;
                    }
                    this._pivot.x = this._originPivot.x + currentPivot.x + this._durationPivot.x * progress;
                    this._pivot.y = this._originPivot.y + currentPivot.y + this._durationPivot.y * progress;
                }
                this._bone.invalidUpdate();
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._bone._arriveAtFrame(currentFrame, this, this._animationState, false);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenTransform = false;
            this._tweenScale = false;
            this._tweenColor = false;
            /**
             * <使用绝对数据>
             * 单帧的timeline，第一个关键帧的transform为0
             * timeline.originTransform = firstFrame.transform;
             * eachFrame.transform = eachFrame.transform - timeline.originTransform;
             * firstFrame.transform == 0;
             *
             * <使用相对数据>
             * 使用相对数据时，timeline.originTransform = 0，第一个关键帧的transform有可能不为 0
             */
            if (this._animationState.additiveBlending) {
                this._transform.x = currentFrame.transform.x;
                this._transform.y = currentFrame.transform.y;
                this._transform.skewX = currentFrame.transform.skewX;
                this._transform.skewY = currentFrame.transform.skewY;
                this._transform.scaleX = currentFrame.transform.scaleX;
                this._transform.scaleY = currentFrame.transform.scaleY;
                this._pivot.x = currentFrame.pivot.x;
                this._pivot.y = currentFrame.pivot.y;
            }
            else {
                this._transform.x = this._originTransform.x + currentFrame.transform.x;
                this._transform.y = this._originTransform.y + currentFrame.transform.y;
                this._transform.skewX = this._originTransform.skewX + currentFrame.transform.skewX;
                this._transform.skewY = this._originTransform.skewY + currentFrame.transform.skewY;
                this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
            }
            this._bone.invalidUpdate();
        };
        TimelineState.HALF_PI = Math.PI * 0.5;
        TimelineState.DOUBLE_PI = Math.PI * 2;
        TimelineState._pool = [];
        return TimelineState;
    }());
    dragonBones.TimelineState = TimelineState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.WorldClock
     * @classdesc
     * WorldClock 提供时钟的支持，为控制每个加入时钟的 IAnimatable 对象正确的播放动画。
     * 一般来说，每当 Armature 被创建出来后，只需要将之加入 WorldClock,之后只需要控制 WorldClock 的前进，就可以实现所有 Armature 的动画前进了
     * @see dragonBones.IAnimatable
     * @see dragonBones.Armature
     */
    var WorldClock = (function () {
        /**
         * 创建一个新的 WorldClock 实例。
         * 一般来说，不需要单独创建 WorldClock 的实例，可以直接使用 WorldClock.clock 静态实例就可以了。
         * @param time {number} 开始时间
         * @param timeScale {number} 时间缩放系数
         */
        function WorldClock(time, timeScale) {
            if (time === void 0) { time = -1; }
            if (timeScale === void 0) { timeScale = 1; }
            this._time = time >= 0 ? time : new Date().getTime() * 0.001;
            this._timeScale = isNaN(timeScale) ? 1 : timeScale;
            this._animatableList = [];
        }
        var d = __define,c=WorldClock,p=c.prototype;
        d(p, "time"
            ,function () {
                return this._time;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放系数。用于实现动画的变速播放
             * @member {number} dragonBones.WorldClock#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        /**
         * 检查是否包含指定的 IAnimatable 实例
         * @param animatable {IAnimatable} IAnimatable 实例
         * @returns {boolean}
         */
        p.contains = function (animatable) {
            return this._animatableList.indexOf(animatable) >= 0;
        };
        /**
         * 将一个 IAnimatable 实例加入到时钟
         * @param animatable {IAnimatable} IAnimatable 实例
         */
        p.add = function (animatable) {
            if (animatable && this._animatableList.indexOf(animatable) == -1) {
                this._animatableList.push(animatable);
            }
        };
        /**
         * 将一个 IAnimatable 实例从时钟中移除
         * @param animatable {IAnimatable} IAnimatable 实例
         */
        p.remove = function (animatable) {
            var index = this._animatableList.indexOf(animatable);
            if (index >= 0) {
                this._animatableList[index] = null;
            }
        };
        /**
         * 从时钟中移除所有的 IAnimatable 实例.
         */
        p.clear = function () {
            this._animatableList.length = 0;
        };
        /**
         * 更新所有包含的 IAnimatable 实例，将他们的动画向前播放指定的时间。一般来说，这个方法需要在 ENTERFRAME 事件的响应函数中被调用
         * @param passedTime {number} 前进的时间，默认值为-1，DragonBones会自动为你计算当前帧与上一帧的时间差
         */
        p.advanceTime = function (passedTime) {
            if (passedTime === void 0) { passedTime = -1; }
            if (passedTime < 0) {
                passedTime = new Date().getTime() * 0.001 - this._time;
            }
            passedTime *= this._timeScale;
            this._time += passedTime;
            this._length = this._animatableList.length;
            if (this._length == 0) {
                return;
            }
            this._currentIndex = 0;
            for (this._i = 0; this._i < this._length; this._i++) {
                this._animatable = this._animatableList[this._i];
                if (this._animatable) {
                    if (this._currentIndex != this._i) {
                        this._animatableList[this._currentIndex] = this._animatable;
                        this._animatableList[this._i] = null;
                    }
                    this._animatable.advanceTime(passedTime);
                    this._currentIndex++;
                }
            }
            if (this._currentIndex != this._i) {
                this._length = this._animatableList.length;
                while (this._i < this._length) {
                    this._animatableList[this._currentIndex++] = this._animatableList[this._i++];
                }
                this._animatableList.length = this._currentIndex;
            }
        };
        /**
         * 可以直接使用的全局静态时钟实例.
         * @type dragonBones.WorldClock
         */
        WorldClock.clock = new WorldClock();
        return WorldClock;
    }());
    dragonBones.WorldClock = WorldClock;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EventDispatcher
     * @classdesc
     * 事件派发者
     */
    //var EventDispatcher = (function (_super) {
    //    __extends(EventDispatcher, _super);
    //    function EventDispatcher(target) {
    //        if (target === void 0) { target = null; }
    //        _super.call(this, target);
    //    }
    //    var d = __define,c=EventDispatcher;p=c.prototype;
    //    return EventDispatcher;
    //})(egret.EventDispatcher);
	var EventDispatcher = (function () {
        function EventDispatcher() {
        }
        EventDispatcher.prototype.hasEventListener = function (type) {
            if (this._listenersMap && this._listenersMap[type]) {
                return true;
            }
            return false;
        };

        EventDispatcher.prototype.addEventListener = function (type, listener) {
            if (type && listener) {
                if (!this._listenersMap) {
                    this._listenersMap = {};
                }
                var listeners = this._listenersMap[type];
                if (listeners) {
                    this.removeEventListener(type, listener);
                }
                if (listeners) {
                    listeners.push(listener);
                } else {
                    this._listenersMap[type] = [listener];
                }
            }
        };

        EventDispatcher.prototype.removeEventListener = function (type, listener) {
            if (!this._listenersMap || !type || !listener) {
                return;
            }
            var listeners = this._listenersMap[type];
            if (listeners) {
                var length = listeners.length;
                for (var i = 0; i < length; i++) {
                	//FIX BY LC
                    //if (listeners[i] == listener) {
                    if (listeners[i].toString() === listener.toString()) {
                        if (length == 1) {
                            listeners.length = 0;
                            //FIX BY LC
                            //delete this._listenersMap[type];
                        } else {
                            listeners.splice(i, 1);
                        }
                    }
                }
            }
        };

        EventDispatcher.prototype.removeAllEventListeners = function (type) {
            if (type) {
                delete this._listenersMap[type];
            } else {
                this._listenersMap = null;
            }
        };

        EventDispatcher.prototype.dispatchEvent = function (event) {
            if (event) {
                var listeners = this._listenersMap[event.type];
                if (listeners) {
                    event.target = this;
                    var listenersCopy = listeners.concat();
                    var length = listeners.length;
                    for (var i = 0; i < length; i++) {
                        listenersCopy[i](event);
                    }
                }
            }
        };
        return EventDispatcher;
    })();
    dragonBones.EventDispatcher = EventDispatcher;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var SoundEventManager = (function (_super) {
        __extends(SoundEventManager, _super);
        function SoundEventManager() {
            _super.call(this);
            if (SoundEventManager._instance) {
                throw new Error("Singleton already constructed!");
            }
        }
        var d = __define,c=SoundEventManager,p=c.prototype;
        SoundEventManager.getInstance = function () {
            if (!SoundEventManager._instance) {
                SoundEventManager._instance = new SoundEventManager();
            }
            return SoundEventManager._instance;
        };
        return SoundEventManager;
    }(dragonBones.EventDispatcher));
    dragonBones.SoundEventManager = SoundEventManager;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Armature
     * @classdesc
     * Armature 是 DragonBones 骨骼动画系统的核心。他包含需要加到场景的显示对象，所有的骨骼逻辑和动画系统
     * A Armature instance is the core of the skeleton animation system. It contains the object to display, all sub-bones and the object animation(s).
     * @extends dragonBones.EventDispatcher
     * @see dragonBones.ArmatureData
     * @example
     * <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Armature = (function (_super) {
        __extends(Armature, _super);
        function Armature(display) {
            _super.call(this);
            this._boneIKList = [];
            this._display = display;
            this._animation = new dragonBones.Animation(this);
            this._slotsZOrderChanged = false;
            this._slotList = [];
            this._boneList = [];
            this._eventList = [];
            this._ikList = [];
            this._delayDispose = false;
            this._lockDispose = false;
            this._armatureData = null;
        }
        var d = __define,c=Armature,p=c.prototype;
        d(p, "armatureData"
            /**
             * 骨架数据。
             * @member {ArmatureData} dragonBones.Armature#armatureData
             */
            ,function () {
                return this._armatureData;
            }
        );
        d(p, "display"
            /**
             * 骨架显示对象。骨架创建出来后，需要把该显示对象加到场景中才能显示骨架。
             * 使用根据不同的渲染引擎，显示对象的类型可能不同。
             * @member {any} dragonBones.Armature#display
             */
            ,function () {
                return this._display;
            }
        );
        /**
         * 不推荐的API,使用 display 属性代替。
         */
        p.getDisplay = function () {
            return this._display;
        };
        d(p, "animation"
            /**
             * 骨架的动画实例。
             * @member {Animation} dragonBones.Armature#animation
             */
            ,function () {
                return this._animation;
            }
        );
        /**
         * 清理骨架实例
         */
        p.dispose = function () {
            this._delayDispose = true;
            if (!this._animation || this._lockDispose) {
                return;
            }
            this.userData = null;
            this._animation.dispose();
            var i = this._slotList.length;
            while (i--) {
                this._slotList[i].dispose();
            }
            i = this._boneList.length;
            while (i--) {
                this._boneList[i].dispose();
            }
            i = this._ikList.length;
            while (i--) {
                this._ikList[i].dispose();
            }
            this._armatureData = null;
            this._animation = null;
            this._slotList = null;
            this._boneList = null;
            this._eventList = null;
            this._ikList = null;
            //_display = null;
        };
        /**
         * 在下一帧强制更新指定名称的 Bone 及其包含的所有 Slot 的动画。
         * @param boneName {string} 骨头名。 默认值：null，相当于更新所有骨头。
         */
        p.invalidUpdate = function (boneName) {
            if (boneName === void 0) { boneName = null; }
            if (boneName) {
                var bone = this.getBone(boneName);
                if (bone) {
                    bone.invalidUpdate();
                }
            }
            else {
                var i = this._boneList.length;
                while (i--) {
                    this._boneList[i].invalidUpdate();
                }
            }
        };
        /**
         * 使用这个方法更新动画状态。一般来说，这个方法需要在 ENTERFRAME 事件的响应函数中被调用
         * @param passedTime 动画向前播放的时间（单位：秒）
         */
        p.advanceTime = function (passedTime) {
            this._lockDispose = true;
            this._animation._advanceTime(passedTime);
            passedTime *= this._animation.timeScale; //_animation's time scale will impact childArmature
            this._isFading = this._animation._isFading;
            var len = this._boneIKList.length;
            var bone;
            var j;
            var jLen;
            for (this._i = 0; this._i < len; this._i++) {
                for (j = 0, jLen = this._boneIKList[this._i].length; j < jLen; j++) {
                    bone = this._boneIKList[this._i][j];
                    bone._update(this._isFading);
                    bone.rotationIK = bone.global.rotation;
                    if (this._i != 0 && bone.isIKConstraint) {
                        this._ikList[this._i - 1].compute();
                        bone.adjustGlobalTransformMatrixByIK();
                    }
                }
            }
            this._i = this._slotList.length;
            while (this._i--) {
                this._tmpSlot = this._slotList[this._i];
                this._tmpSlot._update();
                if (this._tmpSlot._isShowDisplay) {
                    var childArmature = this._tmpSlot.childArmature;
                    if (childArmature) {
                        childArmature.advanceTime(passedTime);
                    }
                }
            }
            if (this._slotsZOrderChanged) {
                this.updateSlotsZOrder();
                if (this.hasEventListener(dragonBones.ArmatureEvent.Z_ORDER_UPDATED)) {
                    this.dispatchEvent(new dragonBones.ArmatureEvent(dragonBones.ArmatureEvent.Z_ORDER_UPDATED));
                }
            }
            if (this._eventList.length > 0) {
                for (this._i = 0, this._len = this._eventList.length; this._i < this._len; this._i++) {
                    var event = this._eventList[this._i];
                    this.dispatchEvent(event);
                }
                this._eventList.length = 0;
            }
            this._lockDispose = false;
            if (this._delayDispose) {
                this.dispose();
            }
        };
        p.resetAnimation = function () {
            this.animation.stop();
            this.animation._resetAnimationStateList();
            for (var i = 0, len = this._boneList.length; i < len; i++) {
                this._boneList[i]._removeAllStates();
            }
        };
        /**
         * 获取骨架包含的所有插槽
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Slot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._slotList.concat() : this._slotList;
        };
        /**
         * 获取指定名称的 Slot
         * @param slotName {string} Slot名称
         * @returns {Slot}
         */
        p.getSlot = function (slotName) {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var slot = this._slotList[i];
                if (slot.name == slotName) {
                    return slot;
                }
            }
            return null;
        };
        /**
         * 获取包含指定显示对象的 Slot
         * @param displayObj {any} 显示对象实例
         * @returns {Slot}
         */
        p.getSlotByDisplay = function (displayObj) {
            if (displayObj) {
                var length = this._slotList.length;
                for (var i = 0; i < length; i++) {
                    var slot = this._slotList[i];
                    if (slot.display == displayObj) {
                        return slot;
                    }
                }
            }
            return null;
        };
        /**
         * 为指定名称的 Bone 添加一个子 Slot
         * @param slot {Slot} Slot 实例
         * @param boneName {string}
         * @see dragonBones.Bone
         */
        p.addSlot = function (slot, boneName) {
            var bone = this.getBone(boneName);
            if (bone) {
                bone.addSlot(slot);
            }
            else {
                throw new Error();
            }
        };
        /**
         * 移除指定的Slot
         * @param slot {Slot} Slot 实例
         */
        p.removeSlot = function (slot) {
            if (!slot || slot.armature != this) {
                throw new Error();
            }
            slot.parent.removeSlot(slot);
        };
        /**
         * 移除指定名称的Slot
         * @param slotName {string} Slot 名称
         * @returns {Slot} 被成功移除的 Slot 实例
         */
        p.removeSlotByName = function (slotName) {
            var slot = this.getSlot(slotName);
            if (slot) {
                this.removeSlot(slot);
            }
            return slot;
        };
        /**
         * 获取骨架包含的所有Bone
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Bone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._boneList.concat() : this._boneList;
        };
        /**
         * 获取指定名称的 Bone
         * @param boneName {string} Bone名称
         * @returns {Bone}
         */
        p.getBone = function (boneName) {
            var length = this._boneList.length;
            for (var i = 0; i < length; i++) {
                var bone = this._boneList[i];
                if (bone.name == boneName) {
                    return bone;
                }
            }
            return null;
        };
        /**
         * 获取包含指定显示对象的 Bone
         * @param display {any} 显示对象实例
         * @returns {Bone}
         */
        p.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot ? slot.parent : null;
        };
        /**
         * 在骨架中为指定名称的 Bone 添加一个子 Bone
         * @param bone {Bone} Bone 实例
         * @param parentName {string} 父骨头名称 默认：null
         * @param updateLater {boolean} 是否延迟更新 默认：false，当需要一次添加很多Bone时，开启延迟更新能够提高效率
         */
        p.addBone = function (bone, parentName, updateLater) {
            if (parentName === void 0) { parentName = null; }
            if (updateLater === void 0) { updateLater = false; }
            var parentBone;
            if (parentName) {
                parentBone = this.getBone(parentName);
                if (!parentBone) {
                    throw new Error();
                }
            }
            if (parentBone) {
                parentBone.addChildBone(bone, updateLater);
            }
            else {
                if (bone.parent) {
                    bone.parent.removeChildBone(bone, updateLater);
                }
                bone._setArmature(this);
                if (!updateLater) {
                    this._updateAnimationAfterBoneListChanged();
                }
            }
        };
        /**
         * 移除指定的 Bone
         * @param bone {Bone} Bone 实例
         * @param updateLater {boolean} 是否延迟更新 默认：false，当需要一次移除很多Bone时，开启延迟更新能够提高效率
         */
        p.removeBone = function (bone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!bone || bone.armature != this) {
                throw new Error();
            }
            if (bone.parent) {
                bone.parent.removeChildBone(bone, updateLater);
            }
            else {
                bone._setArmature(null);
                if (!updateLater) {
                    this._updateAnimationAfterBoneListChanged(false);
                }
            }
        };
        /**
         * 移除指定名称的 Bone
         * @param boneName {string} Bone 名称
         * @returns {Bone} 被成功移除的 Bone 实例
         */
        p.removeBoneByName = function (boneName) {
            var bone = this.getBone(boneName);
            if (bone) {
                this.removeBone(bone);
            }
            return bone;
        };
        /** @private */
        p._addBoneToBoneList = function (bone) {
            if (this._boneList.indexOf(bone) < 0) {
                this._boneList[this._boneList.length] = bone;
            }
        };
        /** @private */
        p._removeBoneFromBoneList = function (bone) {
            var index = this._boneList.indexOf(bone);
            if (index >= 0) {
                this._boneList.splice(index, 1);
            }
        };
        /** @private */
        p._addSlotToSlotList = function (slot) {
            if (this._slotList.indexOf(slot) < 0) {
                this._slotList[this._slotList.length] = slot;
            }
        };
        /** @private */
        p._removeSlotFromSlotList = function (slot) {
            var index = this._slotList.indexOf(slot);
            if (index >= 0) {
                this._slotList.splice(index, 1);
            }
        };
        /**
         * 按照显示层级为所有 Slot 排序
         */
        p.updateSlotsZOrder = function () {
            this._slotList.sort(this.sortSlot);
            var i = this._slotList.length;
            while (i--) {
                var slot = this._slotList[i];
                if (slot._isShowDisplay) {
                    //_display 实际上是container, 这个方法就是把原来的显示对象放到container中的第一个
                    slot._addDisplayToContainer(this._display);
                }
            }
            this._slotsZOrderChanged = false;
        };
        p._updateAnimationAfterBoneListChanged = function (ifNeedSortBoneList) {
            if (ifNeedSortBoneList === void 0) { ifNeedSortBoneList = true; }
            if (ifNeedSortBoneList) {
                this.sortBoneList();
            }
            this._animation._updateAnimationStates();
        };
        p.sortBoneList = function () {
            var i = this._boneList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var level = 0;
                var bone = this._boneList[i];
                var boneParent = bone;
                while (boneParent) {
                    level++;
                    boneParent = boneParent.parent;
                }
                helpArray[i] = [level, bone];
            }
            helpArray.sort(dragonBones.ArmatureData.sortBoneDataHelpArrayDescending);
            i = helpArray.length;
            while (i--) {
                this._boneList[i] = helpArray[i][1];
            }
            helpArray.length = 0;
        };
        /** @private When AnimationState enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            if (frame.event && this.hasEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT);
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this._eventList.push(frameEvent);
            }
            if (frame.sound && Armature._soundManager.hasEventListener(dragonBones.SoundEvent.SOUND)) {
                var soundEvent = new dragonBones.SoundEvent(dragonBones.SoundEvent.SOUND);
                soundEvent.armature = this;
                soundEvent.animationState = animationState;
                soundEvent.sound = frame.sound;
                Armature._soundManager.dispatchEvent(soundEvent);
            }
            //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.  
            //后续会扩展更多的action，目前只有gotoAndPlay的含义
            if (frame.action) {
                if (animationState.displayControl) {
                    this.animation.gotoAndPlay(frame.action);
                }
            }
        };
        p.sortSlot = function (slot1, slot2) {
            return slot1.zOrder < slot2.zOrder ? 1 : -1;
        };
        /**
         * 获取Animation实例
         * @returns {any} Animation实例
         */
        p.getAnimation = function () {
            return this._animation;
        };
        p.getIKs = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._ikList.concat() : this._ikList;
        };
        p.buildIK = function () {
            var ikConstraintData;
            this._ikList.length = 0;
            for (var i = 0, len = this._armatureData.ikDataList.length; i < len; i++) {
                ikConstraintData = this._armatureData.ikDataList[i];
                this._ikList.push(new dragonBones.IKConstraint(ikConstraintData, this));
            }
        };
        p.updateBoneCache = function () {
            this._boneList.reverse();
            var temp = {};
            var ikConstraintsCount = this._ikList.length;
            var arrayCount = ikConstraintsCount + 1;
            var i;
            var len;
            var j;
            var jLen;
            var bone;
            var currentBone;
            this._boneIKList = [];
            while (this._boneIKList.length < arrayCount) {
                this._boneIKList[this._boneIKList.length] = [];
            }
            temp[this._boneList[0].name] = 0;
            for (i = 0, len = this._ikList.length; i < len; i++) {
                temp[this._ikList[i].bones[0].name] = i + 1;
            }
            next: for (i = 0, len = this._boneList.length; i < len; i++) {
                bone = this._boneList[i];
                currentBone = bone;
                while (currentBone) {
                    if (currentBone.parent == null) {
                        temp[currentBone.name] = 0;
                    }
                    if (temp.hasOwnProperty(currentBone.name)) {
                        this._boneIKList[temp[currentBone.name]].push(bone);
                        continue next;
                    }
                    currentBone = currentBone.parent;
                }
            }
        };
        p.getIKTargetData = function (bone) {
            var target = [];
            var ik;
            for (var i = 0, len = this._ikList.length; i < len; i++) {
                ik = this._ikList[i];
                if (bone.name == ik.target.name) {
                    target.push(ik);
                }
            }
            return target;
        };
        /**
         * The instance dispatch sound event.
         */
        Armature._soundManager = dragonBones.SoundEventManager.getInstance();
        return Armature;
    }(dragonBones.EventDispatcher));
    dragonBones.Armature = Armature;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Matrix
     * @classdesc
     * Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
     * 这些转换类型统称为仿射转换。仿射转换在转换时保持线条笔直，因此平行线保持平行。
     * 转换矩阵对象为具有如下内容的 3 x 3 的矩阵：
     *  a  c  tx
     *  b  d  ty
     *  u  v  w
     * 在传统的转换矩阵中，u、v 和 w 属性具有其他功能。Matrix 类只能在二维空间中操作，因此始终假定属性值 u 和 v 为 0.0，属性值 w 为 1.0。矩阵的有效值如下：
     *  a  c  tx
     *  b  d  ty
     *  0  0  1
     * 您可以获取和设置 Matrix 对象的全部六个其他属性的值：a、b、c、d、tx 和 ty。
     * Matrix 类支持四种主要类型的转换：平移、缩放、旋转和倾斜。您可以使用特定的方法来设置这些转换的其中三个，如下表中所述：
     * 转换	              矩阵值                      说明
     * 平移（置换）	                            将图像 tx 像素向右移动，将 ty 像素向下移动。
     *                   1  0  tx
     *                   0  1  ty
     *                   0  0  1
     * 缩放                                     将每个像素的位置乘以 x 轴的 sx 和 y 轴的 sy，从而调整图像的大小。
     *                   Sx  0  0
     *                   0  Sy  0
     *                   0  0   1
     * 旋转                                     将图像旋转一个以弧度为单位的角度 q。
     *                   cos(q)  -sin(q)  0
     *                   sin(q)  cos(q)   0
     *                   0         0      1
     * 倾斜或剪切                               以平行于 x 轴或 y 轴的方向逐渐滑动图像。Matrix 对象的 b 属性表示斜角沿 y 轴的正切；Matrix 对象的 c 属性表示斜角沿 x 轴的正切。
     *                  0        tan(skewX) 0
     *                  tan(skewY)  0       0
     *                   0          0       1
     * 每个转换函数都将更改当前矩阵的属性，所以您可以有效地合并多个转换。为此，请先调用多个转换函数，再将矩阵应用于其显示对象目标（通过使用该显示对象的 transform 属性）。
     */
    var Matrix = (function () {
        /**
         *构造函数，实例化一个Matrix，默认为是一个单位矩阵
         */
        function Matrix() {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
        }
        var d = __define,c=Matrix,p=c.prototype;
        /**
         *执行原始矩阵的逆转换。逆矩阵和单位矩阵相乘会得到的单位矩阵
         */
        p.invert = function () {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
        };
        /**
         *将某个矩阵与当前矩阵相乘，从而将这两个矩阵的几何效果有效地结合在一起。
         * 右乘，其几何意义是将两次几何变换变成一次
         * @param m
         */
        p.concat = function (m) {
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var tx1 = this.tx;
            var ty1 = this.ty;
            if (ma != 1 || mb != 0 || mc != 0 || md != 1) {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                this.a = a1 * ma + b1 * mc;
                this.b = a1 * mb + b1 * md;
                this.c = c1 * ma + d1 * mc;
                this.d = c1 * mb + d1 * md;
            }
            this.tx = tx1 * ma + ty1 * mc + m.tx;
            this.ty = tx1 * mb + ty1 * md + m.ty;
        };
        p.copyFrom = function (m) {
            this.tx = m.tx;
            this.ty = m.ty;
            this.a = m.a;
            this.b = m.b;
            this.c = m.c;
            this.d = m.d;
        };
        return Matrix;
    }());
    dragonBones.Matrix = Matrix;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBTransform
     * @classdesc
     * Dragonbones中使用的transform
     * 可以表示位移，旋转，缩放三种属性
     */
    var DBTransform = (function () {
        /**
         * 创建一个 DBTransform 实例.
         */
        function DBTransform() {
            this.x = 0;
            this.y = 0;
            this.skewX = 0;
            this.skewY = 0;
            this.scaleX = 1;
            this.scaleY = 1;
        }
        var d = __define,c=DBTransform,p=c.prototype;
        d(p, "rotation"
            /**
             * 旋转，用弧度表示
             * @member {number} dragonBones.DBTransform#rotation
             */
            ,function () {
                return this.skewX;
            }
            ,function (value) {
                this.skewX = this.skewY = value;
            }
        );
        /**
         * 拷贝传入的transfrom实例的所有属性
         * @param node
         */
        p.copy = function (transform) {
            this.x = transform.x;
            this.y = transform.y;
            this.skewX = transform.skewX;
            this.skewY = transform.skewY;
            this.scaleX = transform.scaleX;
            this.scaleY = transform.scaleY;
        };
        /**
         * transform加法
         * @param node
         */
        p.add = function (transform) {
            this.x += transform.x;
            this.y += transform.y;
            this.skewX += transform.skewX;
            this.skewY += transform.skewY;
            this.scaleX *= transform.scaleX;
            this.scaleY *= transform.scaleY;
        };
        /**
         * transform减法
         * @param node
         */
        p.minus = function (transform) {
            this.x -= transform.x;
            this.y -= transform.y;
            this.skewX -= transform.skewX;
            this.skewY -= transform.skewY;
            this.scaleX /= transform.scaleX;
            this.scaleY /= transform.scaleY;
        };
        p.normalizeRotation = function () {
            this.skewX = dragonBones.TransformUtil.normalizeRotation(this.skewX);
            this.skewY = dragonBones.TransformUtil.normalizeRotation(this.skewY);
        };
        p.clone = function () {
            var output = new DBTransform();
            output.copy(this);
            return output;
        };
        /**
         * 把DBTransform的所有属性转成用String类型表示
         * @return 一个字符串包含有DBTransform的所有属性
         */
        p.toString = function () {
            var string = "x:" + this.x + " y:" + this.y + " skewX:" + this.skewX + " skewY:" + this.skewY + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
            return string;
        };
        return DBTransform;
    }());
    dragonBones.DBTransform = DBTransform;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBObject
     * @classdesc
     * DBObject 是 Bone 和 Slot 的基类
     * @see dragonBones.Bone
     * @see dragonBones.Slot
     */
    var DBObject = (function () {
        function DBObject() {
            this._globalTransformMatrix = new dragonBones.Matrix();
            this._global = new dragonBones.DBTransform();
            this._origin = new dragonBones.DBTransform();
            this._offset = new dragonBones.DBTransform();
            this._offset.scaleX = this._offset.scaleY = 1;
            this._visible = true;
            this._armature = null;
            this._parent = null;
            this.userData = null;
            this.inheritRotation = true;
            this.inheritScale = true;
            this.inheritTranslation = true;
        }
        var d = __define,c=DBObject,p=c.prototype;
        d(p, "global"
            /**
             * 相对世界坐标的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#global
             */
            ,function () {
                return this._global;
            }
        );
        d(p, "origin"
            /**
             * 骨架数据中的原始的相对父亲的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#origin
             */
            ,function () {
                return this._origin;
            }
        );
        d(p, "offset"
            /**
             * 用于运行时动态调整的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#offset
             */
            ,function () {
                return this._offset;
            }
        );
        d(p, "armature"
            /**
             * The armature this DBObject instance belongs to.
             */
            ,function () {
                return this._armature;
            }
        );
        /** @private */
        p._setArmature = function (value) {
            this._armature = value;
        };
        d(p, "parent"
            /**
             * Indicates the Bone instance that directly contains this DBObject instance if any.
             */
            ,function () {
                return this._parent;
            }
        );
        /** @private */
        p._setParent = function (value) {
            this._parent = value;
        };
        /**
         * 清理使用的资源用于垃圾回收
         */
        p.dispose = function () {
            this.userData = null;
            this._globalTransformMatrix = null;
            this._global = null;
            this._origin = null;
            this._offset = null;
            this._armature = null;
            this._parent = null;
        };
        p._calculateRelativeParentTransform = function () {
        };
        p._calculateParentTransform = function () {
            if (this.parent && (this.inheritTranslation || this.inheritRotation || this.inheritScale)) {
                var parentGlobalTransform = this._parent._globalTransformForChild;
                var parentGlobalTransformMatrix = this._parent._globalTransformMatrixForChild;
                /*
                if(!this.inheritTranslation || !this.inheritRotation || !this.inheritScale)
                {
                    parentGlobalTransform = DBObject._tempParentGlobalTransform;
                    parentGlobalTransform.copy(this._parent._globalTransformForChild);
                    if(!this.inheritTranslation)
                    {
                        parentGlobalTransform.x = 0;
                        parentGlobalTransform.y = 0;
                    }
                    if(!this.inheritScale)
                    {
                        parentGlobalTransform.scaleX = 1;
                        parentGlobalTransform.scaleY = 1;
                    }
                    if(!this.inheritRotation)
                    {
                        parentGlobalTransform.skewX = 0;
                        parentGlobalTransform.skewY = 0;
                    }

                    parentGlobalTransformMatrix = DBObject._tempParentGlobalTransformMatrix;
                    TransformUtil.transformToMatrix(parentGlobalTransform, parentGlobalTransformMatrix, true);
                }
                */
                return dragonBones.ParentTransformObject.create().setTo(parentGlobalTransform, parentGlobalTransformMatrix);
            }
            return null;
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                //计算绝对坐标
                var x = this._global.x;
                var y = this._global.y;
                this._global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                this._global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;
                if (this.inheritRotation) {
                    this._global.skewX += parentGlobalTransform.skewX;
                    this._global.skewY += parentGlobalTransform.skewY;
                }
                if (this.inheritScale) {
                    this._global.scaleX *= parentGlobalTransform.scaleX;
                    this._global.scaleY *= parentGlobalTransform.scaleY;
                }
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return output;
        };
        DBObject._tempParentGlobalTransformMatrix = new dragonBones.Matrix();
        DBObject._tempParentGlobalTransform = new dragonBones.DBTransform();
        return DBObject;
    }());
    dragonBones.DBObject = DBObject;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Bone
     * @classdesc
     * Bone 实例代表 Armature 中的一个骨头。一个Armature实例可以由很多 Bone组成。
     * Bone 在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移旋转缩放的实现
     * @extends dragonBones.DBObject
     * @see dragonBones.Armature
     * @see dragonBones.Slot
     * @see dragonBones.BoneData
     *
     * @example
       <pre>
        //获取动画数据 本例使用Knight例子.
        //资源下载地址http://dragonbones.github.io/download_forwarding.html?download_url=downloads/dragonbonesdemos_v2.4.zip
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
        //这个资源需要自己准备
        var horseHat = RES.getRes("horseHat");
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[1].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        armatureDisplay.x = 200;
        armatureDisplay.y = 300;
        this.addChild(armatureDisplay);

        //以下四句代码，实现给骨骼添加slot的功能
        //1.获取马头的骨骼
        var horseHead:dragonBones.Bone = armature.getBone("horseHead");
        //2.创建一个slot
        var horseHatSlot:dragonBones.EgretSlot = new dragonBones.EgretSlot();
        //3.给这个slot赋一个图片
        horseHatSlot.display = new egret.Bitmap(horseHat);
        //4.把这个slot添加到骨骼上
        horseHead.addSlot(horseHatSlot);

        //以下3句代码，实现了子骨骼的获取和播放子骨架的动画
        //1.获取包含子骨架的骨骼
        var weaponBone:dragonBones.Bone = armature.getBone("armOutside");
        //2.获取骨骼上的子骨架
        var childArmature:dragonBones.Armature = weaponBone.childArmature;
        //3.播放子骨架的动画
        childArmature.animation.gotoAndPlay("attack_sword_1",0,-1,0);


        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Bone = (function (_super) {
        __extends(Bone, _super);
        function Bone() {
            _super.call(this);
            /**
             * 标记是否将offset中的平移分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetTranslationToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetTranslationToChild = true;
            /**
             * 标记是否将offset中的旋转分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetRotationToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetRotationToChild = true;
            /**
             * 标记是否将offset中的缩放分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetScaleToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetScaleToChild = false;
            this.isIKConstraint = false;
            this.childrenBones = [];
            /** @private */
            this._needUpdate = 0;
            this._tween = new dragonBones.DBTransform();
            this._tweenPivot = new dragonBones.Point();
            this._tween.scaleX = this._tween.scaleY = 1;
            this._boneList = [];
            this._slotList = [];
            this._timelineStateList = [];
            this._needUpdate = 2;
            this._isColorChanged = false;
        }
        var d = __define,c=Bone,p=c.prototype;
        Bone.initWithBoneData = function (boneData) {
            var outputBone = new Bone();
            outputBone.name = boneData.name;
            outputBone.length = boneData.length;
            outputBone.inheritRotation = boneData.inheritRotation;
            outputBone.inheritScale = boneData.inheritScale;
            outputBone.origin.copy(boneData.transform);
            return outputBone;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._boneList) {
                return;
            }
            _super.prototype.dispose.call(this);
            var i = this._boneList.length;
            while (i--) {
                this._boneList[i].dispose();
            }
            i = this._slotList.length;
            while (i--) {
                this._slotList[i].dispose();
            }
            this._tween = null;
            this._tweenPivot = null;
            this._boneList = null;
            this._slotList = null;
            this._timelineStateList = null;
        };
        //骨架装配
        /**
         * 检查是否包含指定的 Bone 或者 Slot
         * @param child {DBObject} Bone 实例 或者 Slot 实例
         * @returns {boolean}
         */
        p.contains = function (child) {
            if (!child) {
                throw new Error();
            }
            if (child == this) {
                return false;
            }
            var ancestor = child;
            while (!(ancestor == this || ancestor == null)) {
                ancestor = ancestor.parent;
            }
            return ancestor == this;
        };
        /**
         * 添加指定的 Bone 实例做为当前 Bone 实例的子骨头
         * @param childBone {Bone} 需要添加的 Bone 实例
         * @param updateLater {boolean} 是否延迟更新。默认false。当需要一次性添加很多 Bone 时，开启延迟更新能够提高效率
         */
        p.addChildBone = function (childBone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!childBone) {
                throw new Error();
            }
            if (childBone == this || childBone.contains(this)) {
                throw new Error();
            }
            if (childBone.parent == this) {
                return;
            }
            if (childBone.parent) {
                childBone.parent.removeChildBone(childBone, updateLater);
            }
            this._boneList[this._boneList.length] = childBone;
            childBone._setParent(this);
            childBone._setArmature(this._armature);
            var index = this.childrenBones.indexOf(childBone);
            if (index < 0) {
                this.childrenBones.push(childBone);
            }
            if (this._armature && !updateLater) {
                this._armature._updateAnimationAfterBoneListChanged();
            }
        };
        /**
         * 从当前 Bone 实例中移除指定的子骨头
         * @param childBone {Bone} 需要移除的 Bone 实例
         * @param updateLater {boolean} 是否延迟更新。默认false。当需要一次性移除很多 Bone 时，开启延迟更新能够提高效率
         */
        p.removeChildBone = function (childBone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!childBone) {
                throw new Error();
            }
            var index = this._boneList.indexOf(childBone);
            if (index < 0) {
                throw new Error();
            }
            this._boneList.splice(index, 1);
            childBone._setParent(null);
            childBone._setArmature(null);
            var indexs = this.childrenBones.indexOf(childBone);
            if (indexs >= 0) {
                this.childrenBones.splice(indexs, 1);
            }
            if (this._armature && !updateLater) {
                this._armature._updateAnimationAfterBoneListChanged(false);
            }
        };
        /**
         * 向当前 Bone 实例中添加指定的 Slot 实例
         * @param childSlot {Slot} 需要添加的 Slot 实例
         */
        p.addSlot = function (childSlot) {
            if (!childSlot) {
                throw new Error();
            }
            if (childSlot.parent) {
                childSlot.parent.removeSlot(childSlot);
            }
            this._slotList[this._slotList.length] = childSlot;
            childSlot._setParent(this);
            childSlot.setArmature(this._armature);
        };
        /**
         * 从当前 Bone 实例中移除指定的 Slot 实例
         * @param childSlot {Slot} 需要移除的 Slot 实例
         */
        p.removeSlot = function (childSlot) {
            if (!childSlot) {
                throw new Error();
            }
            var index = this._slotList.indexOf(childSlot);
            if (index < 0) {
                throw new Error();
            }
            this._slotList.splice(index, 1);
            childSlot._setParent(null);
            childSlot.setArmature(null);
        };
        /** @private */
        p._setArmature = function (value) {
            if (this._armature == value) {
                return;
            }
            if (this._armature) {
                this._armature._removeBoneFromBoneList(this);
                this._armature._updateAnimationAfterBoneListChanged(false);
            }
            this._armature = value;
            if (this._armature) {
                this._armature._addBoneToBoneList(this);
            }
            var i = this._boneList.length;
            while (i--) {
                this._boneList[i]._setArmature(this._armature);
            }
            i = this._slotList.length;
            while (i--) {
                this._slotList[i].setArmature(this._armature);
            }
        };
        /**
         * 获取当前骨头包含的所有 Bone 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Bone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._boneList.concat() : this._boneList;
        };
        /**
         * 获取当前骨头包含的所有 Slot 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Slot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._slotList.concat() : this._slotList;
        };
        //动画
        /**
         * 在下一帧强制更新当前 Bone 实例及其包含的所有 Slot 的动画。
         */
        p.invalidUpdate = function () {
            this._needUpdate = 2;
            this.operationInvalidUpdate(this);
            var i;
            var len;
            for (i = 0, len = this.childrenBones.length; i < len; i++) {
                if (this.childrenBones[i]._needUpdate != 2) {
                    this.operationInvalidUpdate(this.childrenBones[i]);
                    this.childrenBones[i].invalidUpdate();
                }
            }
        };
        p.operationInvalidUpdate = function (bone) {
            var arr = this.armature.getIKTargetData(bone);
            var i;
            var len;
            var j;
            var jLen;
            var ik;
            var bo;
            for (i = 0, len = arr.length; i < len; i++) {
                ik = arr[i];
                for (j = 0, jLen = ik.bones.length; j < jLen; j++) {
                    bo = ik.bones[j];
                    if (bo._needUpdate != 2) {
                        bo.invalidUpdate();
                    }
                }
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.scaleX = this._origin.scaleX * this._tween.scaleX * this._offset.scaleX;
            this._global.scaleY = this._origin.scaleY * this._tween.scaleY * this._offset.scaleY;
            this._global.skewX = this._origin.skewX + this._tween.skewX + this._offset.skewX;
            this._global.skewY = this._origin.skewY + this._tween.skewY + this._offset.skewY;
            this._global.x = this._origin.x + this._tween.x + this._offset.x;
            this._global.y = this._origin.y + this._tween.y + this._offset.y;
        };
        /** @private */
        p._update = function (needUpdate) {
            if (needUpdate === void 0) { needUpdate = false; }
            this._needUpdate--;
            if (needUpdate || this._needUpdate > 0 || (this._parent && this._parent._needUpdate > 0)) {
                this._needUpdate = 1;
            }
            else {
                return;
            }
            this.blendingTimeline();
            //计算global
            var result = this._updateGlobal();
            var parentGlobalTransform;
            var parentGlobalTransformMatrix;
            if (result) {
                parentGlobalTransform = result.parentGlobalTransform;
                parentGlobalTransformMatrix = result.parentGlobalTransformMatrix;
                result.release();
            }
            //计算globalForChild
            var ifExistOffsetTranslation = this._offset.x != 0 || this._offset.y != 0;
            var ifExistOffsetScale = this._offset.scaleX != 1 || this._offset.scaleY != 1;
            var ifExistOffsetRotation = this._offset.skewX != 0 || this._offset.skewY != 0;
            if ((!ifExistOffsetTranslation || this.applyOffsetTranslationToChild) &&
                (!ifExistOffsetScale || this.applyOffsetScaleToChild) &&
                (!ifExistOffsetRotation || this.applyOffsetRotationToChild)) {
                this._globalTransformForChild = this._global;
                this._globalTransformMatrixForChild = this._globalTransformMatrix;
            }
            else {
                if (!this._tempGlobalTransformForChild) {
                    this._tempGlobalTransformForChild = new dragonBones.DBTransform();
                }
                this._globalTransformForChild = this._tempGlobalTransformForChild;
                if (!this._tempGlobalTransformMatrixForChild) {
                    this._tempGlobalTransformMatrixForChild = new dragonBones.Matrix();
                }
                this._globalTransformMatrixForChild = this._tempGlobalTransformMatrixForChild;
                this._globalTransformForChild.x = this._origin.x + this._tween.x;
                this._globalTransformForChild.y = this._origin.y + this._tween.y;
                this._globalTransformForChild.scaleX = this._origin.scaleX * this._tween.scaleX;
                this._globalTransformForChild.scaleY = this._origin.scaleY * this._tween.scaleY;
                this._globalTransformForChild.skewX = this._origin.skewX + this._tween.skewX;
                this._globalTransformForChild.skewY = this._origin.skewY + this._tween.skewY;
                if (this.applyOffsetTranslationToChild) {
                    this._globalTransformForChild.x += this._offset.x;
                    this._globalTransformForChild.y += this._offset.y;
                }
                if (this.applyOffsetScaleToChild) {
                    this._globalTransformForChild.scaleX *= this._offset.scaleX;
                    this._globalTransformForChild.scaleY *= this._offset.scaleY;
                }
                if (this.applyOffsetRotationToChild) {
                    this._globalTransformForChild.skewX += this._offset.skewX;
                    this._globalTransformForChild.skewY += this._offset.skewY;
                }
                dragonBones.TransformUtil.transformToMatrix(this._globalTransformForChild, this._globalTransformMatrixForChild);
                if (parentGlobalTransformMatrix) {
                    this._globalTransformMatrixForChild.concat(parentGlobalTransformMatrix);
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrixForChild, this._globalTransformForChild, this._globalTransformForChild.scaleX * parentGlobalTransform.scaleX >= 0, this._globalTransformForChild.scaleY * parentGlobalTransform.scaleY >= 0);
                }
            }
        };
        /** @private */
        p._updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this._slotList[i];
                childSlot._updateDisplayColor(aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier);
            }
            this._isColorChanged = colorChanged;
        };
        p.adjustGlobalTransformMatrixByIK = function () {
            if (!this.parent) {
                return;
            }
            this.global.rotation = this.rotationIK;
            dragonBones.TransformUtil.transformToMatrix(this.global, this._globalTransformMatrix);
            this._globalTransformForChild.rotation = this.rotationIK;
            dragonBones.TransformUtil.transformToMatrix(this._globalTransformForChild, this._globalTransformMatrixForChild);
        };
        /** @private */
        p._hideSlots = function () {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this._slotList[i];
                childSlot._changeDisplay(-1);
            }
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            var displayControl = animationState.displayControl &&
                (!this.displayController || this.displayController == animationState.name) &&
                animationState.containsBoneMask(this.name);
            if (displayControl) {
                var tansformFrame = frame;
                var displayIndex = tansformFrame.displayIndex;
                var childSlot;
                if (frame.event && this._armature.hasEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT)) {
                    var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.BONE_FRAME_EVENT);
                    frameEvent.bone = this;
                    frameEvent.animationState = animationState;
                    frameEvent.frameLabel = frame.event;
                    this._armature._eventList.push(frameEvent);
                }
                if (frame.sound && Bone._soundManager.hasEventListener(dragonBones.SoundEvent.SOUND)) {
                    var soundEvent = new dragonBones.SoundEvent(dragonBones.SoundEvent.SOUND);
                    soundEvent.armature = this._armature;
                    soundEvent.animationState = animationState;
                    soundEvent.sound = frame.sound;
                    Bone._soundManager.dispatchEvent(soundEvent);
                }
                //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
                //后续会扩展更多的action，目前只有gotoAndPlay的含义
                if (frame.action) {
                    var length1 = this._slotList.length;
                    for (var i1 = 0; i1 < length1; i1++) {
                        childSlot = this._slotList[i1];
                        var childArmature = childSlot.childArmature;
                        if (childArmature) {
                            childArmature.animation.gotoAndPlay(frame.action);
                        }
                    }
                }
            }
        };
        p._updateGlobal = function () {
            if (!this._armature._skewEnable) {
                return _super.prototype._updateGlobal.call(this);
            }
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null && output.parentGlobalTransformMatrix && output.parentGlobalTransform) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                var scaleXF = this._global.scaleX * parentGlobalTransform.scaleX > 0;
                var scaleYF = this._global.scaleY * parentGlobalTransform.scaleY > 0;
                var relativeRotation = this._global.rotation;
                var relativeScaleX = this._global.scaleX;
                var relativeScaleY = this._global.scaleY;
                var parentRotation = this.parentBoneRotation;
                this._localTransform = this._global;
                if (this.inheritScale && !this.inheritRotation) {
                    if (parentRotation != 0) {
                        this._localTransform = this._localTransform.clone();
                        this._localTransform.rotation -= parentRotation;
                    }
                }
                dragonBones.TransformUtil.transformToMatrix(this._localTransform, this._globalTransformMatrix);
                this._globalTransformMatrix.concat(parentMatrix);
                if (this.inheritScale) {
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, scaleXF, scaleYF);
                }
                else {
                    dragonBones.TransformUtil.matrixToTransformPosition(this._globalTransformMatrix, this._global);
                    this._global.scaleX = this._localTransform.scaleX;
                    this._global.scaleY = this._localTransform.scaleY;
                    this._global.rotation = this._localTransform.rotation + (this.inheritRotation ? parentRotation : 0);
                    dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
                }
            }
            return output;
        };
        /** @private */
        p._addState = function (timelineState) {
            if (this._timelineStateList.indexOf(timelineState) < 0) {
                this._timelineStateList.push(timelineState);
                this._timelineStateList.sort(this.sortState);
            }
        };
        /** @private */
        p._removeState = function (timelineState) {
            var index = this._timelineStateList.indexOf(timelineState);
            if (index >= 0) {
                this._timelineStateList.splice(index, 1);
            }
        };
        /** @private */
        p._removeAllStates = function () {
            this._timelineStateList.length = 0;
        };
        p.blendingTimeline = function () {
            var timelineState;
            var transform;
            var pivot;
            var weight;
            var i = this._timelineStateList.length;
            if (i == 1) {
                timelineState = this._timelineStateList[0];
                weight = timelineState._animationState.weight * timelineState._animationState.fadeWeight;
                timelineState._weight = weight;
                transform = timelineState._transform;
                pivot = timelineState._pivot;
                this._tween.x = transform.x * weight;
                this._tween.y = transform.y * weight;
                this._tween.skewX = transform.skewX * weight;
                this._tween.skewY = transform.skewY * weight;
                this._tween.scaleX = 1 + (transform.scaleX - 1) * weight;
                this._tween.scaleY = 1 + (transform.scaleY - 1) * weight;
                this._tweenPivot.x = pivot.x * weight;
                this._tweenPivot.y = pivot.y * weight;
            }
            else if (i > 1) {
                var x = 0;
                var y = 0;
                var skewX = 0;
                var skewY = 0;
                var scaleX = 1;
                var scaleY = 1;
                var pivotX = 0;
                var pivotY = 0;
                var weigthLeft = 1;
                var layerTotalWeight = 0;
                var prevLayer = this._timelineStateList[i - 1]._animationState.layer;
                var currentLayer = 0;
                //Traversal the layer from up to down
                //layer由高到低依次遍历
                while (i--) {
                    timelineState = this._timelineStateList[i];
                    currentLayer = timelineState._animationState.layer;
                    if (prevLayer != currentLayer) {
                        if (layerTotalWeight >= weigthLeft) {
                            timelineState._weight = 0;
                            break;
                        }
                        else {
                            weigthLeft -= layerTotalWeight;
                        }
                    }
                    prevLayer = currentLayer;
                    weight = timelineState._animationState.weight * timelineState._animationState.fadeWeight * weigthLeft;
                    timelineState._weight = weight;
                    if (weight) {
                        transform = timelineState._transform;
                        pivot = timelineState._pivot;
                        x += transform.x * weight;
                        y += transform.y * weight;
                        skewX += transform.skewX * weight;
                        skewY += transform.skewY * weight;
                        scaleX += (transform.scaleX - 1) * weight;
                        scaleY += (transform.scaleY - 1) * weight;
                        pivotX += pivot.x * weight;
                        pivotY += pivot.y * weight;
                        layerTotalWeight += weight;
                    }
                }
                this._tween.x = x;
                this._tween.y = y;
                this._tween.skewX = skewX;
                this._tween.skewY = skewY;
                this._tween.scaleX = scaleX;
                this._tween.scaleY = scaleY;
                this._tweenPivot.x = pivotX;
                this._tweenPivot.y = pivotY;
            }
        };
        p.sortState = function (state1, state2) {
            return state1._animationState.layer < state2._animationState.layer ? -1 : 1;
        };
        d(p, "childArmature"
            /**
             * 不推荐的API,建议使用 slot.childArmature 替代
             */
            ,function () {
                if (this.slot) {
                    return this.slot.childArmature;
                }
                return null;
            }
        );
        d(p, "display"
            /**
             * 不推荐的API,建议使用 slot.display 替代
             */
            ,function () {
                if (this.slot) {
                    return this.slot.display;
                }
                return null;
            }
            ,function (value) {
                if (this.slot) {
                    this.slot.display = value;
                }
            }
        );
        d(p, "node"
            /**
             * 不推荐的API,建议使用 offset 替代
             */
            ,function () {
                return this._offset;
            }
        );
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    var length = this._slotList.length;
                    for (var i = 0; i < length; i++) {
                        var childSlot = this._slotList[i];
                        childSlot._updateDisplayVisible(this._visible);
                    }
                }
            }
        );
        d(p, "slot"
            /**
             * 返回当前 Bone 实例包含的第一个 Slot 实例
             * @member {Slot} dragonBones.Bone#slot
             */
            ,function () {
                return this._slotList.length > 0 ? this._slotList[0] : null;
            }
        );
        d(p, "parentBoneRotation"
            ,function () {
                return this.parent ? this.parent.rotationIK : 0;
            }
        );
        /**
         * The instance dispatch sound event.
         */
        Bone._soundManager = dragonBones.SoundEventManager.getInstance();
        return Bone;
    }(dragonBones.DBObject));
    dragonBones.Bone = Bone;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var IKConstraint = (function () {
        function IKConstraint(data, armatureData) {
            this.animationCacheBend = 0;
            this.animationCacheWeight = -1;
            this.ikdata = data;
            this.armature = armatureData;
            this.weight = data.weight;
            this.bendDirection = (data.bendPositive ? 1 : -1);
            this.bones = [];
            var bone;
            if (data.chain) {
                bone = armatureData.getBone(data.bones).parent;
                bone.isIKConstraint = true;
                this.bones.push(bone);
            }
            bone = armatureData.getBone(data.bones);
            bone.isIKConstraint = true;
            this.bones.push(bone);
            this.target = armatureData.getBone(data.target);
        }
        var d = __define,c=IKConstraint,p=c.prototype;
        p.dispose = function () {
        };
        p.compute = function () {
            switch (this.bones.length) {
                case 1:
                    var weig1 = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    this.compute1(this.bones[0], this.target, weig1);
                    break;
                case 2:
                    var bend = this.animationCacheBend != 0 ? this.animationCacheBend : this.bendDirection;
                    var weig = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    var tt = this.compute2(this.bones[0], this.bones[1], this.target.global.x, this.target.global.y, bend, weig);
                    this.bones[0].rotationIK = tt.x;
                    this.bones[1].rotationIK = tt.y + tt.x;
                    break;
            }
        };
        p.compute1 = function (bone, target, weightA) {
            var parentRotation = (!bone.inheritRotation || bone.parent == null) ? 0 : bone.parent.global.rotation;
            var rotation = bone.global.rotation;
            var rotationIK = Math.atan2(target.global.y - bone.global.y, target.global.x - bone.global.x);
            bone.rotationIK = rotation + (rotationIK - rotation) * weightA;
        };
        p.compute2 = function (parent, child, targetX, targetY, bendDirection, weightA) {
            //添加斜切后的算法，现在用的
            if (weightA == 0) {
                return new dragonBones.Point(parent.global.rotation, child.global.rotation);
            }
            var tt = new dragonBones.Point();
            /**父的绝对坐标**/
            var p1 = new dragonBones.Point(parent.global.x, parent.global.y);
            /**子的绝对坐标**/
            var p2 = new dragonBones.Point(child.global.x, child.global.y);
            var psx = parent.global.scaleX;
            var psy = parent.global.scaleY;
            var csx = child.global.scaleX;
            var csy = child.global.scaleY;
            var cx = child.origin.x * psx;
            var cy = child.origin.y * psy;
            var initalRotation = Math.atan2(cy, cx); //差值等于子在父落点到父的角度
            var childX = p2.x - p1.x;
            var childY = p2.y - p1.y;
            /**d1的长度**/
            var len1 = Math.sqrt(childX * childX + childY * childY);
            var parentAngle;
            var childAngle;
            outer: if (Math.abs(psx - psy) <= 0.001) {
                var childlength = child.length;
                var len2 = childlength * csx;
                targetX = targetX - p1.x;
                targetY = targetY - p1.y;
                var cosDenom = 2 * len1 * len2;
                if (cosDenom < 0.0001) {
                    var temp = Math.atan2(targetY, targetX);
                    tt.x = temp * weightA - initalRotation;
                    tt.y = temp * weightA + initalRotation; //+ tt.x ;
                    this.normalize(tt.x);
                    this.normalize(tt.y);
                    return tt;
                }
                var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                childAngle = Math.acos(cos) * bendDirection; //o2
                var adjacent = len1 + len2 * cos; //ae
                var opposite = len2 * Math.sin(childAngle); //be
                parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite); //o1
                tt.x = parentAngle * weightA - initalRotation;
                tt.y = childAngle * weightA + initalRotation; //+tt.x;
            }
            else {
                var l1 = len1;
                var tx = targetX - p1.x;
                var ty = targetY - p1.y;
                var l2 = child.length * child.origin.scaleX; //child.currentLocalTransform.scaleX;
                var a = psx * l2;
                var b = psy * l2;
                var ta = Math.atan2(ty, tx);
                var aa = a * a;
                var bb = b * b;
                var ll = l1 * l1;
                var dd = tx * tx + ty * ty;
                var c0 = bb * ll + aa * dd - aa * bb;
                var c1 = -2 * bb * l1;
                var c2 = bb - aa;
                var d = c1 * c1 - 4 * c2 * c0;
                if (d >= 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0) {
                        q = -q;
                    }
                    q = -(c1 + q) / 2;
                    var r0 = q / c2;
                    var r1 = c0 / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        var y1 = Math.sqrt(dd - r * r) * bendDirection;
                        parentAngle = ta - Math.atan2(y1, r);
                        childAngle = Math.atan2(y1 / psy, (r - l1) / psx);
                        tt.x = parentAngle * weightA - initalRotation;
                        tt.y = childAngle * weightA + initalRotation; //+tt.x;
                        break outer;
                    }
                }
                var minAngle = 0;
                var minDist = Number.MAX_VALUE;
                var minX = 0;
                var minY = 0;
                var maxAngle = 0;
                var maxDist = 0;
                var maxX = 0;
                var maxY = 0;
                var x2 = l1 + a;
                var dist = x2 * x2;
                if (dist > maxDist) {
                    maxAngle = 0;
                    maxDist = dist;
                    maxX = x2;
                }
                x2 = l1 - a;
                dist = x2 * x2;
                if (dist < minDist) {
                    minAngle = Math.PI;
                    minDist = dist;
                    minX = x2;
                }
                var angle1 = Math.acos(-a * l1 / (aa - bb));
                x2 = a * Math.cos(angle1) + l1;
                var y2 = b * Math.sin(angle1);
                dist = x2 * x2 + y2 * y2;
                if (dist < minDist) {
                    minAngle = angle1;
                    minDist = dist;
                    minX = x2;
                    minY = y2;
                }
                if (dist > maxDist) {
                    maxAngle = angle1;
                    maxDist = dist;
                    maxX = x2;
                    maxY = y2;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    parentAngle = ta - Math.atan2(minY * bendDirection, minX);
                    childAngle = minAngle * bendDirection;
                }
                else {
                    parentAngle = ta - Math.atan2(maxY * bendDirection, maxX);
                    childAngle = maxAngle * bendDirection;
                }
                tt.x = parentAngle * weightA - initalRotation;
                tt.y = childAngle * weightA + initalRotation; //;
            }
            this.normalize(tt.x);
            this.normalize(tt.y);
            return tt;
        };
        p.normalize = function (rotation) {
            if (rotation > Math.PI) {
                rotation -= Math.PI * 2;
            }
            else if (rotation < -Math.PI) {
                rotation += Math.PI * 2;
            }
        };
        return IKConstraint;
    }());
    dragonBones.IKConstraint = IKConstraint;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Slot
     * @classdesc
     * Slot 实例是骨头上的一个插槽，是显示图片的容器。
     * 一个 Bone 上可以有多个Slot，每个Slot中同一时间都会有一张图片用于显示，不同的Slot中的图片可以同时显示。
     * 每个 Slot 中可以包含多张图片，同一个 Slot 中的不同图片不能同时显示，但是可以在动画进行的过程中切换，用于实现帧动画。
     * @extends dragonBones.DBObject
     * @see dragonBones.Armature
     * @see dragonBones.Bone
     * @see dragonBones.SlotData
     *
     * @example
       <pre>
        //获取动画数据 本例使用Knight例子.
        //资源下载地址http://dragonbones.github.io/download_forwarding.html?download_url=downloads/dragonbonesdemos_v2.4.zip
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
        //这个资源需要自己准备
        var horseHat = RES.getRes("horseHat");
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[1].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        armatureDisplay.x = 200;
        armatureDisplay.y = 300;
        this.addChild(armatureDisplay);

        //以下四句代码，实现给骨骼添加slot的功能
        //1.获取马头的骨骼
        var horseHead:dragonBones.Bone = armature.getBone("horseHead");
        //2.创建一个slot
        var horseHatSlot:dragonBones.EgretSlot = new dragonBones.EgretSlot();
        //3.给这个slot赋一个图片
        horseHatSlot.display = new egret.Bitmap(horseHat);
        //4.把这个slot添加到骨骼上
        horseHead.addSlot(horseHatSlot);

        //以下3句代码，实现了子骨骼的获取和播放子骨架的动画
        //1.获取包含子骨架的骨骼
        var weaponBone:dragonBones.Bone = armature.getBone("armOutside");
        //2.获取骨骼上的子骨架
        var childArmature:dragonBones.Armature = weaponBone.childArmature;
        //3.播放子骨架的动画
        childArmature.animation.gotoAndPlay("attack_sword_1",0,-1,0);


        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Slot = (function (_super) {
        __extends(Slot, _super);
        function Slot() {
            _super.call(this);
            this._currentDisplayIndex = 0;
            this._displayList = [];
            this._timelineStateList = [];
            this._currentDisplayIndex = -1;
            this._originZOrder = 0;
            this._tweenZOrder = 0;
            this._offsetZOrder = 0;
            this._isShowDisplay = false;
            this._colorTransform = new dragonBones.ColorTransform();
            this._displayDataList = null;
            //_childArmature = null;
            this._currentDisplay = null;
            this.inheritRotation = true;
            this.inheritScale = true;
        }
        var d = __define,c=Slot,p=c.prototype;
        /**
         * 通过传入 SlotData 初始化Slot
         * @param slotData
         */
        p.initWithSlotData = function (slotData) {
            this.name = slotData.name;
            this.blendMode = slotData.blendMode;
            this._defaultGotoAndPlay = slotData.gotoAndPlay;
            this._originZOrder = slotData.zOrder;
            this._displayDataList = slotData.displayDataList;
            this._originDisplayIndex = slotData.displayIndex;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._displayList) {
                return;
            }
            _super.prototype.dispose.call(this);
            this._displayList.length = 0;
            this._displayDataList = null;
            this._displayList = null;
            this._currentDisplay = null;
            //_childArmature = null;
        };
        p.sortState = function (state1, state2) {
            return state1._animationState.layer < state2._animationState.layer ? -1 : 1;
        };
        /** @private */
        p._addState = function (timelineState) {
            if (this._timelineStateList.indexOf(timelineState) < 0) {
                this._timelineStateList.push(timelineState);
                this._timelineStateList.sort(this.sortState);
            }
        };
        /** @private */
        p._removeState = function (timelineState) {
            var index = this._timelineStateList.indexOf(timelineState);
            if (index >= 0) {
                this._timelineStateList.splice(index, 1);
            }
        };
        //骨架装配
        /** @private */
        p.setArmature = function (value) {
            if (this._armature == value) {
                return;
            }
            if (this._armature) {
                this._armature._removeSlotFromSlotList(this);
            }
            this._armature = value;
            if (this._armature) {
                this._armature._addSlotToSlotList(this);
                this._armature._slotsZOrderChanged = true;
                this._addDisplayToContainer(this._armature.display);
            }
            else {
                this._removeDisplayFromContainer();
            }
        };
        //动画
        /** @private */
        p._update = function () {
            if (this._parent._needUpdate <= 0 && !this._needUpdate) {
                return;
            }
            var result = this._updateGlobal();
            if (result) {
                result.release();
            }
            this._updateTransform();
            this._needUpdate = false;
        };
        p._calculateRelativeParentTransform = function () {
            this._global.scaleX = this._origin.scaleX * this._offset.scaleX;
            this._global.scaleY = this._origin.scaleY * this._offset.scaleY;
            this._global.skewX = this._origin.skewX + this._offset.skewX;
            this._global.skewY = this._origin.skewY + this._offset.skewY;
            this._global.x = this._origin.x + this._offset.x + this._parent._tweenPivot.x;
            this._global.y = this._origin.y + this._offset.y + this._parent._tweenPivot.y;
        };
        p.updateChildArmatureAnimation = function () {
            if (this.childArmature) {
                if (this._isShowDisplay) {
                    var curAnimation = this._gotoAndPlay;
                    if (curAnimation == null) {
                        curAnimation = this._defaultGotoAndPlay;
                        if (curAnimation == null) {
                            this.childArmature.armatureData.defaultAnimation;
                        }
                    }
                    if (curAnimation == null) {
                        if (this._armature && this._armature.animation.lastAnimationState) {
                            curAnimation = this._armature.animation.lastAnimationState.name;
                        }
                    }
                    if (curAnimation && this.childArmature.animation.hasAnimation(curAnimation)) {
                        this.childArmature.animation.gotoAndPlay(curAnimation);
                    }
                    else {
                        this.childArmature.animation.play();
                    }
                }
                else {
                    this.childArmature.animation.stop();
                    this.childArmature.animation._lastAnimationState = null;
                }
            }
        };
        /** @private */
        p._changeDisplay = function (displayIndex) {
            if (displayIndex === void 0) { displayIndex = 0; }
            if (displayIndex < 0) {
                if (this._isShowDisplay) {
                    this._isShowDisplay = false;
                    this._removeDisplayFromContainer();
                    this.updateChildArmatureAnimation();
                }
            }
            else if (this._displayList.length > 0) {
                var length = this._displayList.length;
                if (displayIndex >= length) {
                    displayIndex = length - 1;
                }
                if (this._currentDisplayIndex != displayIndex) {
                    this._isShowDisplay = true;
                    this._currentDisplayIndex = displayIndex;
                    this._updateSlotDisplay();
                    this.updateChildArmatureAnimation();
                    if (this._displayDataList &&
                        this._displayDataList.length > 0 &&
                        this._currentDisplayIndex < this._displayDataList.length) {
                        this._origin.copy(this._displayDataList[this._currentDisplayIndex].transform);
                    }
                    this._needUpdate = true;
                }
                else if (!this._isShowDisplay) {
                    this._isShowDisplay = true;
                    if (this._armature) {
                        this._armature._slotsZOrderChanged = true;
                        this._addDisplayToContainer(this._armature.display);
                    }
                    this.updateChildArmatureAnimation();
                }
            }
        };
        /** @private
         * Updates the display of the slot.
         */
        p._updateSlotDisplay = function () {
            var currentDisplayIndex = -1;
            if (this._currentDisplay) {
                currentDisplayIndex = this._getDisplayIndex();
                this._removeDisplayFromContainer();
            }
            var displayObj = this._displayList[this._currentDisplayIndex];
            if (displayObj) {
                if (displayObj instanceof dragonBones.Armature) {
                    //_childArmature = display as Armature;
                    this._currentDisplay = displayObj.display;
                }
                else {
                    //_childArmature = null;
                    this._currentDisplay = displayObj;
                }
            }
            else {
                this._currentDisplay = null;
            }
            this._updateDisplay(this._currentDisplay);
            if (this._currentDisplay) {
                if (this._armature && this._isShowDisplay) {
                    if (currentDisplayIndex < 0) {
                        this._armature._slotsZOrderChanged = true;
                        this._addDisplayToContainer(this._armature.display);
                    }
                    else {
                        this._addDisplayToContainer(this._armature.display, currentDisplayIndex);
                    }
                }
                this._updateDisplayBlendMode(this._blendMode);
                this._updateDisplayColor(this._colorTransform.alphaOffset, this._colorTransform.redOffset, this._colorTransform.greenOffset, this._colorTransform.blueOffset, this._colorTransform.alphaMultiplier, this._colorTransform.redMultiplier, this._colorTransform.greenMultiplier, this._colorTransform.blueMultiplier, true);
                this._updateDisplayVisible(this._visible);
                this._updateTransform();
            }
        };
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    this._updateDisplayVisible(this._visible);
                }
            }
        );
        d(p, "displayList"
            /**
             * 显示对象列表(包含 display 或者 子骨架)
             * @member {any[]} dragonBones.Slot#displayList
             */
            ,function () {
                return this._displayList;
            }
            ,function (value) {
                if (!value) {
                    throw new Error();
                }
                //为什么要修改_currentDisplayIndex?
                if (this._currentDisplayIndex < 0) {
                    this._currentDisplayIndex = 0;
                }
                var i = this._displayList.length = value.length;
                while (i--) {
                    this._displayList[i] = value[i];
                }
                //在index不改变的情况下强制刷新 TO DO需要修改
                var displayIndexBackup = this._currentDisplayIndex;
                this._currentDisplayIndex = -1;
                this._changeDisplay(displayIndexBackup);
            }
        );
        d(p, "display"
            /**
             * 当前的显示对象(可能是 display 或者 子骨架)
             * @member {any} dragonBones.Slot#display
             */
            ,function () {
                return this._currentDisplay;
            }
            ,function (value) {
                if (this._currentDisplayIndex < 0) {
                    this._currentDisplayIndex = 0;
                }
                if (this._displayList[this._currentDisplayIndex] == value) {
                    return;
                }
                this._displayList[this._currentDisplayIndex] = value;
                this._updateSlotDisplay();
                this.updateChildArmatureAnimation();
                this._updateTransform(); //是否可以延迟更新？
            }
        );
        /**
         * 不推荐的 API. 使用 display 属性代替
         */
        p.getDisplay = function () {
            return this.display;
        };
        /**
         * Unrecommended API. Please use .display = instead.
         * @returns {any}
         */
        p.setDisplay = function (value) {
            this.display = value;
        };
        d(p, "childArmature"
            /**
             * 当前的子骨架
             * @member {Armature} dragonBones.Slot#childArmature
             */
            ,function () {
                if (this._displayList[this._currentDisplayIndex] instanceof dragonBones.Armature) {
                    return (this._displayList[this._currentDisplayIndex]);
                }
                return null;
            }
            ,function (value) {
                //设计的不好，要修改
                this.display = value;
            }
        );
        d(p, "zOrder"
            /**
             * 显示顺序。(支持小数用于实现动态插入slot)
             * @member {number} dragonBones.Slot#zOrder
             */
            ,function () {
                return this._originZOrder + this._tweenZOrder + this._offsetZOrder;
            }
            ,function (value) {
                if (this.zOrder != value) {
                    this._offsetZOrder = value - this._originZOrder - this._tweenZOrder;
                    if (this._armature) {
                        this._armature._slotsZOrderChanged = true;
                    }
                }
            }
        );
        d(p, "blendMode"
            /**
             * 混合模式
             * @member {string} dragonBones.Slot#blendMode
             */
            ,function () {
                return this._blendMode;
            }
            ,function (value) {
                if (this._blendMode != value) {
                    this._blendMode = value;
                    this._updateDisplayBlendMode(this._blendMode);
                }
            }
        );
        d(p, "gotoAndPlay",undefined
            /**
             * 播放子骨架的动画
             * @member {string} dragonBones.Slot#gotoAndPlay
             */
            ,function (value) {
                if (this._gotoAndPlay != value) {
                    this._gotoAndPlay = value;
                    this.updateChildArmatureAnimation();
                }
            }
        );
        //Abstract method
        /**
         * @private
         */
        p._updateDisplay = function (value) {
            throw new Error("");
        };
        /**
         * @private
         */
        p._getDisplayIndex = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * Adds the original display object to another display object.
         * @param container
         * @param index
         */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * remove the original display object from its parent.
         */
        p._removeDisplayFromContainer = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * Updates the transform of the slot.
         */
        p._updateTransform = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         */
        p._updateDisplayVisible = function (value) {
            /**
             * bone.visible && slot.visible && updateVisible
             * this._parent.visible && this._visible && value;
             */
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * Updates the color of the display object.
         * @param a
         * @param r
         * @param g
         * @param b
         * @param aM
         * @param rM
         * @param gM
         * @param bM
         */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            if (colorChanged === void 0) { colorChanged = false; }
            this._colorTransform.alphaOffset = aOffset;
            this._colorTransform.redOffset = rOffset;
            this._colorTransform.greenOffset = gOffset;
            this._colorTransform.blueOffset = bOffset;
            this._colorTransform.alphaMultiplier = aMultiplier;
            this._colorTransform.redMultiplier = rMultiplier;
            this._colorTransform.greenMultiplier = gMultiplier;
            this._colorTransform.blueMultiplier = bMultiplier;
            this._isColorChanged = colorChanged;
        };
        /**
         * @private
         * Update the blend mode of the display object.
         * @param value The blend mode to use.
         */
        p._updateDisplayBlendMode = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            var displayControl = animationState.displayControl &&
                animationState.containsBoneMask(this.parent.name);
            if (displayControl) {
                var slotFrame = frame;
                var displayIndex = slotFrame.displayIndex;
                var childSlot;
                this._changeDisplay(displayIndex);
                this._updateDisplayVisible(slotFrame.visible);
                if (displayIndex >= 0) {
                    if (!isNaN(slotFrame.zOrder) && slotFrame.zOrder != this._tweenZOrder) {
                        this._tweenZOrder = slotFrame.zOrder;
                        this._armature._slotsZOrderChanged = true;
                    }
                }
                //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
                //后续会扩展更多的action，目前只有gotoAndPlay的含义
                if (frame.action) {
                    if (this.childArmature) {
                        this.childArmature.animation.gotoAndPlay(frame.action);
                    }
                }
                else {
                    this.gotoAndPlay = slotFrame.gotoAndPlay;
                }
            }
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            var output = this._calculateParentTransform();
            if (output) {
                this._globalTransformMatrix.concat(output.parentGlobalTransformMatrix);
                dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, this._global.scaleX * output.parentGlobalTransform.scaleX >= 0, this._global.scaleY * output.parentGlobalTransform.scaleY >= 0);
            }
            return output;
        };
        p._resetToOrigin = function () {
            this._changeDisplay(this._originDisplayIndex);
            this._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, true);
        };
        return Slot;
    }(dragonBones.DBObject));
    dragonBones.Slot = Slot;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationCache
     * @classdesc
     * AnimationCache 实例是动画缓存的实体，包含一个动画的所有缓存数据。
     * 每个Slot的缓存数据存在各个SlotTimelineCache中。
     * 一般来说 AnimationCache 不需要开发者直接操控，而是由AnimationCacheManager代为管理。
     * @see dragonBones.AnimationCacheManager
     * @see dragonBones.TimelineCache
     * @see dragonBones.SlotTimelineCache
     * @see dragonBones.SlotFrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
        </pre>
     */
    var AnimationCache = (function () {
        function AnimationCache() {
            //		public var boneTimelineCacheList:Vector.<BoneTimelineCache> = new Vector.<BoneTimelineCache>();
            this.slotTimelineCacheList = [];
            //		public var boneTimelineCacheDic:Object = {};
            this.slotTimelineCacheDic = {};
            this.frameNum = 0;
        }
        var d = __define,c=AnimationCache,p=c.prototype;
        AnimationCache.initWithAnimationData = function (animationData, armatureData) {
            var output = new AnimationCache();
            output.name = animationData.name;
            var boneTimelineList = animationData.timelineList;
            var boneName;
            var boneData;
            var slotData;
            var slotTimelineCache;
            var slotName;
            for (var i = 0, length = boneTimelineList.length; i < length; i++) {
                boneName = boneTimelineList[i].name;
                for (var j = 0, jlen = armatureData.slotDataList.length; j < jlen; j++) {
                    slotData = armatureData.slotDataList[j];
                    slotName = slotData.name;
                    if (slotData.parent == boneName) {
                        if (output.slotTimelineCacheDic[slotName] == null) {
                            slotTimelineCache = new dragonBones.SlotTimelineCache();
                            slotTimelineCache.name = slotName;
                            output.slotTimelineCacheList.push(slotTimelineCache);
                            output.slotTimelineCacheDic[slotName] = slotTimelineCache;
                        }
                    }
                }
            }
            return output;
        };
        //		public function initBoneTimelineCacheDic(boneCacheGeneratorDic:Object, boneFrameCacheDic:Object):void
        //		{
        //			var name:String;
        //			for each(var boneTimelineCache:BoneTimelineCache in boneTimelineCacheDic)
        //			{
        //				name = boneTimelineCache.name;
        //				boneTimelineCache.cacheGenerator = boneCacheGeneratorDic[name];
        //				boneTimelineCache.currentFrameCache = boneFrameCacheDic[name];
        //			}
        //		}
        p.initSlotTimelineCacheDic = function (slotCacheGeneratorDic, slotFrameCacheDic) {
            var name;
            for (var k in this.slotTimelineCacheDic) {
                var slotTimelineCache = this.slotTimelineCacheDic[k];
                name = slotTimelineCache.name;
                slotTimelineCache.cacheGenerator = slotCacheGeneratorDic[name];
                slotTimelineCache.currentFrameCache = slotFrameCacheDic[name];
            }
        };
        //		public function bindCacheUserBoneDic(boneDic:Object):void
        //		{
        //			for(var name:String in boneDic)
        //			{
        //				(boneTimelineCacheDic[name] as BoneTimelineCache).bindCacheUser(boneDic[name]);
        //			}
        //		}
        p.bindCacheUserSlotDic = function (slotDic) {
            for (var name in slotDic) {
                (this.slotTimelineCacheDic[name]).bindCacheUser(slotDic[name]);
            }
        };
        p.addFrame = function () {
            this.frameNum++;
            //			var boneTimelineCache:BoneTimelineCache;
            //			for(var i:int = 0, length:int = boneTimelineCacheList.length; i < length; i++)
            //			{
            //				boneTimelineCache = boneTimelineCacheList[i];
            //				boneTimelineCache.addFrame();
            //			}
            var slotTimelineCache;
            for (var i = 0, length = this.slotTimelineCacheList.length; i < length; i++) {
                slotTimelineCache = this.slotTimelineCacheList[i];
                slotTimelineCache.addFrame();
            }
        };
        p.update = function (progress) {
            var frameIndex = Math.floor(progress * (this.frameNum - 1));
            //			var boneTimelineCache:BoneTimelineCache;
            //			for(var i:int = 0, length:int = boneTimelineCacheList.length; i < length; i++)
            //			{
            //				boneTimelineCache = boneTimelineCacheList[i];
            //				boneTimelineCache.update(frameIndex);
            //			}
            var slotTimelineCache;
            for (var i = 0, length = this.slotTimelineCacheList.length; i < length; i++) {
                slotTimelineCache = this.slotTimelineCacheList[i];
                slotTimelineCache.update(frameIndex);
            }
        };
        return AnimationCache;
    }());
    dragonBones.AnimationCache = AnimationCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationCacheManager
     * @classdesc
     * AnimationCacheManager 实例是动画缓存管理器，他可以为一个或多个同类型的Armature生成动画缓存数据，从而提高动画运行效率。
     * 目前AnimationCacheManager只支持对FastArmatrue生成缓存，以后会扩展为对任何实现ICacheableArmature接口的Armature生成缓存。
     * @see dragonBones.ICacheableArmature
     * @see dragonBones.FastArmature
     * @see dragonBones.AnimationCache
     * @see dragonBones.FrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var AnimationCacheManager = (function () {
        function AnimationCacheManager() {
            this.animationCacheDic = {};
            //		public var boneFrameCacheDic:Object = {};
            this.slotFrameCacheDic = {};
        }
        var d = __define,c=AnimationCacheManager,p=c.prototype;
        /**
         * 通过ArmatrueData创建并初始化AnimationCacheManager。
         * AnimationCacheManager的创建需要依赖ArmatrueData。
         * @param armatureData {ArmatureData} 骨架数据实例。
         * @param frameRate {number} 帧频。帧频决定生成数据缓存的采样率。
         * @see dragonBones.ArmatureData.
         */
        AnimationCacheManager.initWithArmatureData = function (armatureData, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            var output = new AnimationCacheManager();
            output.armatureData = armatureData;
            if (frameRate <= 0) {
                var animationData = armatureData.animationDataList[0];
                if (animationData) {
                    output.frameRate = animationData.frameRate;
                }
            }
            else {
                output.frameRate = frameRate;
            }
            return output;
        };
        /**
         * 为所有动画初始化AnimationCache实例。在生成动画缓存之前需要调用这个API生成相应的AnimationCache实例
         * @see dragonBones.AnimationCache.
         */
        p.initAllAnimationCache = function () {
            var length = this.armatureData.animationDataList.length;
            for (var i = 0; i < length; i++) {
                var animationData = this.armatureData.animationDataList[i];
                this.animationCacheDic[animationData.name] = dragonBones.AnimationCache.initWithAnimationData(animationData, this.armatureData);
            }
        };
        /**
         * 指定动画名，初始化AnimationCache实例。在生成动画缓存之前需要调用这个API生成相应的AnimationCache实例
         * @param animationName {string} 动画名。
         * @see dragonBones.AnimationCache.
         */
        p.initAnimationCache = function (animationName) {
            this.animationCacheDic[animationName] = dragonBones.AnimationCache.initWithAnimationData(this.armatureData.getAnimationData(animationName), this.armatureData);
        };
        /**
         * 绑定Armature列表做为动画缓存的使用者。
         * 在为Armature生成动画缓存之前，需要将其绑定为动画缓存的使用者
         * @param armatures {Array<any>} 骨架列表。
         * @see dragonBones.ICacheableArmature.
         */
        p.bindCacheUserArmatures = function (armatures) {
            var length = armatures.length;
            for (var i = 0; i < length; i++) {
                var armature = armatures[i];
                this.bindCacheUserArmature(armature);
            }
        };
        /**
         * 绑定制定Armature做为动画缓存的使用者。
         * 在为Armature生成动画缓存之前，需要将其绑定为动画缓存的使用者
         * @param armatures {FastArmature} 要绑定为缓存使用者的骨架对象。
         * @see dragonBones.ICacheableArmature.
         */
        p.bindCacheUserArmature = function (armature) {
            armature.animation.animationCacheManager = this;
            var cacheUser;
            //			for each(cacheUser in armature._boneDic)
            //			{
            //				cacheUser.frameCache = boneFrameCacheDic[cacheUser.name];
            //			}
            for (var k in armature._slotDic) {
                cacheUser = armature._slotDic[k];
                cacheUser.frameCache = this.slotFrameCacheDic[cacheUser.name];
            }
            /*
            var length:number = armature._slotDic.length;
            for(var i:number = 0;i < length;i++){
                cacheUser = armature._slotDic[i];
                cacheUser.frameCache = this.slotFrameCacheDic[cacheUser.name];
            }
            */
        };
        /**
         * 设置指定的Armature做为动画缓存的生成器。（同一个Armature可以既是缓存使用者，也是缓存生成器）
         * 在为Armature生成动画缓存之前，需要设置动画缓存的生成器
         * @param armatures {FastArmature} 要设置为缓存生成器的骨架对象。
         * @see dragonBones.ICacheableArmature.
         */
        p.setCacheGeneratorArmature = function (armature) {
            this.cacheGeneratorArmature = armature;
            var cacheUser;
            //			for each(cacheUser in armature._boneDic)
            //			{
            //				boneFrameCacheDic[cacheUser.name] = new FrameCache();
            //			}
            for (var slot in armature._slotDic) {
                cacheUser = armature._slotDic[slot];
                this.slotFrameCacheDic[cacheUser.name] = new dragonBones.SlotFrameCache();
            }
            /*
            var length:number = armature._slotDic.length;
            for(var i:number = 0;i < length;i++){
                cacheUser = armature._slotDic[i];
                this.slotFrameCacheDic[cacheUser.name] = new SlotFrameCache();
            }
            */
            for (var anim in this.animationCacheDic) {
                var animationCache = this.animationCacheDic[anim];
                animationCache.initSlotTimelineCacheDic(armature._slotDic, this.slotFrameCacheDic);
            }
            /*
            var length1:number = this.animationCacheDic.length;
            for(var i1:number = 0;i1 < length1;i1++){
                var animationCache:AnimationCache = this.animationCacheDic[i1];
//				animationCache.initBoneTimelineCacheDic(armature._boneDic, boneFrameCacheDic);
                animationCache.initSlotTimelineCacheDic(armature._slotDic, this.slotFrameCacheDic);
            }
            */
        };
        /**
         * 生成所有动画缓存数据。生成之后，所有绑定CacheUser的Armature就都能够使用这些缓存了。
         * 在为调用这个API生成动画缓存之前，需要：
         * 1.调用API initAllAnimationCache 初始化AnimationCache实例
         * 2.调用API setCacheGeneratorArmature 设置动画缓存的生成器,
         * 3.调用API bindCacheUserArmatures 绑定动画缓存的使用者
         * @param loop {boolean} 要生成缓存的动画是否需要循环播放。如果该动画在播放时只需要播放一次，则设置为false。如果需要播放大于一次，则设置为true。
         * @see dragonBones.AnimationCache
         */
        p.generateAllAnimationCache = function (loop) {
            /*
            var length:number = this.animationCacheDic.length;
            for(var i:number = 0;i < length;i++){
                var animationCache:AnimationCache = this.animationCacheDic[i];
                this.generateAnimationCache(animationCache.name);
            }
            */
            for (var anim in this.animationCacheDic) {
                var animationCache = this.animationCacheDic[anim];
                this.generateAnimationCache(animationCache.name, loop);
            }
        };
        /**
         * 生成指定动画缓存数据。生成之后，所有绑定CacheUser的Armature就都能够使用这些缓存了。
         * 在为调用这个API生成动画缓存之前，需要：
         * 1.调用API initAnimationCache 初始化AnimationCache实例
         * 2.调用API setCacheGeneratorArmature 设置动画缓存的生成器,
         * 3.调用API bindCacheUserArmatures 绑定动画缓存的使用者
         * @param animationName {string} 要生成缓存的动画名。
         * @param loop {boolean} 要生成缓存的动画是否需要循环播放。如果该动画在播放时只需要播放一次，则设置为false。如果需要播放大于一次，则设置为true。
         * @see dragonBones.AnimationCache
         */
        p.generateAnimationCache = function (animationName, loop) {
            var temp = this.cacheGeneratorArmature.enableCache;
            this.cacheGeneratorArmature.enableCache = false;
            var animationCache = this.animationCacheDic[animationName];
            if (!animationCache) {
                return;
            }
            var animationState = this.cacheGeneratorArmature.getAnimation().animationState;
            var passTime = 1 / this.frameRate;
            if (loop) {
                this.cacheGeneratorArmature.getAnimation().gotoAndPlay(animationName, 0, -1, 0);
            }
            else {
                this.cacheGeneratorArmature.getAnimation().gotoAndPlay(animationName, 0, -1, 1);
            }
            var tempEnableEventDispatch = this.cacheGeneratorArmature.enableEventDispatch;
            this.cacheGeneratorArmature.enableEventDispatch = false;
            var lastProgress;
            do {
                lastProgress = animationState.progress;
                this.cacheGeneratorArmature.advanceTime(passTime);
                animationCache.addFrame();
            } while (animationState.progress >= lastProgress && animationState.progress < 1);
            this.cacheGeneratorArmature.enableEventDispatch = tempEnableEventDispatch;
            this.resetCacheGeneratorArmature();
            this.cacheGeneratorArmature.enableCache = temp;
        };
        /**
         * 将缓存生成器骨架重置，生成动画缓存后调用。
         * @see dragonBones.ICacheableArmature
         */
        p.resetCacheGeneratorArmature = function () {
            this.cacheGeneratorArmature.resetAnimation();
        };
        /**
         * 获取制定名称的AnimationCache实例。
         * @param animationName {string} 动画名。
         * @see dragonBones.AnimationCache
         */
        p.getAnimationCache = function (animationName) {
            return this.animationCacheDic[animationName];
        };
        return AnimationCacheManager;
    }());
    dragonBones.AnimationCacheManager = AnimationCacheManager;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FrameCache = (function () {
        function FrameCache() {
            this.globalTransform = new dragonBones.DBTransform();
            this.globalTransformMatrix = new dragonBones.Matrix();
        }
        var d = __define,c=FrameCache,p=c.prototype;
        //浅拷贝提高效率
        p.copy = function (frameCache) {
            this.globalTransform = frameCache.globalTransform;
            this.globalTransformMatrix = frameCache.globalTransformMatrix;
        };
        p.clear = function () {
            this.globalTransform = FrameCache.ORIGIN_TRAMSFORM;
            this.globalTransformMatrix = FrameCache.ORIGIN_MATRIX;
        };
        FrameCache.ORIGIN_TRAMSFORM = new dragonBones.DBTransform();
        FrameCache.ORIGIN_MATRIX = new dragonBones.Matrix();
        return FrameCache;
    }());
    dragonBones.FrameCache = FrameCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotFrameCache
     * @classdesc
     * SlotFrameCache 存储了Slot的帧缓存数据。
     * @see dragonBones.FastSlot
     * @see dragonBones.ICacheUser
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var SlotFrameCache = (function (_super) {
        __extends(SlotFrameCache, _super);
        function SlotFrameCache() {
            _super.call(this);
            this.displayIndex = -1;
        }
        var d = __define,c=SlotFrameCache,p=c.prototype;
        //浅拷贝提高效率
        p.copy = function (frameCache) {
            _super.prototype.copy.call(this, frameCache);
            this.colorTransform = frameCache.colorTransform;
            this.displayIndex = frameCache.displayIndex;
            this.gotoAndPlay = frameCache.gotoAndPlay;
        };
        p.clear = function () {
            _super.prototype.clear.call(this);
            this.colorTransform = null;
            this.displayIndex = -1;
            this.gotoAndPlay = null;
        };
        return SlotFrameCache;
    }(dragonBones.FrameCache));
    dragonBones.SlotFrameCache = SlotFrameCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TimelineCache
     * @classdesc
     * TimelineCache 是时间轴缓存基类存。
     * @see dragonBones.SlotTimelineCache
     * @see dragonBones.FrameCache
     * @see dragonBones.ICacheUser
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var TimelineCache = (function () {
        function TimelineCache() {
            this.frameCacheList = new Array();
        }
        var d = __define,c=TimelineCache,p=c.prototype;
        p.addFrame = function () {
        };
        p.update = function (frameIndex) {
            if (frameIndex === void 0) { frameIndex = 0; }
            this.currentFrameCache.copy(this.frameCacheList[frameIndex]);
        };
        p.bindCacheUser = function (cacheUser) {
            cacheUser.frameCache = this.currentFrameCache;
        };
        return TimelineCache;
    }());
    dragonBones.TimelineCache = TimelineCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimelineCache
     * @classdesc
     * SlotTimelineCache 存储了Slot的时间轴缓存数据。
     * @see dragonBones.TimelineCache
     * @see dragonBones.SlotFrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var SlotTimelineCache = (function (_super) {
        __extends(SlotTimelineCache, _super);
        function SlotTimelineCache() {
            _super.call(this);
        }
        var d = __define,c=SlotTimelineCache,p=c.prototype;
        p.addFrame = function () {
            var cache = new dragonBones.SlotFrameCache();
            cache.globalTransform.copy(this.cacheGenerator.global);
            cache.globalTransformMatrix.copyFrom(this.cacheGenerator.globalTransformMatrix);
            if (this.cacheGenerator.colorChanged) {
                cache.colorTransform = dragonBones.ColorTransformUtil.cloneColor(this.cacheGenerator.colorTransform);
            }
            cache.displayIndex = this.cacheGenerator.displayIndex;
            cache.gotoAndPlay = this.cacheGenerator.gotoAndPlay;
            this.frameCacheList.push(cache);
        };
        return SlotTimelineCache;
    }(dragonBones.TimelineCache));
    dragonBones.SlotTimelineCache = SlotTimelineCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Event
     * @classdesc
     * 事件
     */
    var Event = (function (_super) {
       // __extends(Event, _super);
        /**
         * 创建一个Event实例
         * @param type 事件的类型
         */
        function Event(type, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
	        this.bubbles = bubbles;
            this.cancelable = cancelable;
            this.type = type;

    //        _super.call(this, type, bubbles, cancelable);
        }
        var d = __define,c=Event;p=c.prototype;
        return Event;
    })();
    dragonBones.Event = Event;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationEvent
     * @extends dragonBones.Event
     * @classdesc
     * 动画事件
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var AnimationEvent = (function (_super) {
        __extends(AnimationEvent, _super);
        /**
         * 创建一个新的 AnimationEvent 的实例
         * @param type 事件的类型
         * @param cancelable
         */
        function AnimationEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=AnimationEvent,p=c.prototype;
        d(AnimationEvent, "MOVEMENT_CHANGE"
            /**
             * 不推荐使用.
             */
            ,function () {
                return AnimationEvent.FADE_IN;
            }
        );
        d(p, "movementID"
            /**
             * 不推荐的API.
             * @member {string} dragonBones.AnimationEvent#movementID
             */
            ,function () {
                return this.animationName;
            }
        );
        d(p, "armature"
            /**
             * 配发出事件的骨架
             * @member {dragonBones.Armature} dragonBones.AnimationEvent#armature
             */
            ,function () {
                return (this.target);
            }
        );
        d(p, "animationName"
            /**
             * 获取动画的名字
             * @returns {string}
             * @member {string} dragonBones.AnimationEvent#animationName
             */
            ,function () {
                return this.animationState.name;
            }
        );
        /**
         * 当动画缓入的时候派发
         */
        AnimationEvent.FADE_IN = "fadeIn";
        /**
         * 当动画缓出的时候派发
         */
        AnimationEvent.FADE_OUT = "fadeOut";
        /**
         * 当动画开始播放时派发
         */
        AnimationEvent.START = "start";
        /**
         * 当动画停止时派发
         */
        AnimationEvent.COMPLETE = "complete";
        /**
         * 当动画播放完一轮后派发
         */
        AnimationEvent.LOOP_COMPLETE = "loopComplete";
        /**
         * 当动画缓入完成时派发
         */
        AnimationEvent.FADE_IN_COMPLETE = "fadeInComplete";
        /**
         * 当动画缓出结束后派发
         */
        AnimationEvent.FADE_OUT_COMPLETE = "fadeOutComplete";
        return AnimationEvent;
    }(dragonBones.Event));
    dragonBones.AnimationEvent = AnimationEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ArmatureEvent
     * @extends dragonBones.Event
     * @classdesc
     * 骨架事件
     */
    var ArmatureEvent = (function (_super) {
        __extends(ArmatureEvent, _super);
        /**
         * 创建一个 ArmatureEvent 的实例
         * @param type 事件类型
         */
        function ArmatureEvent(type) {
            _super.call(this, type);
        }
        var d = __define,c=ArmatureEvent,p=c.prototype;
        /**
         * 当zOrder成功更新后派发
         */
        ArmatureEvent.Z_ORDER_UPDATED = "zOrderUpdated";
        return ArmatureEvent;
    }(dragonBones.Event));
    dragonBones.ArmatureEvent = ArmatureEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FrameEvent
     * @extends dragonBones.Event
     * @classdesc
     * 帧事件
     *
     * @example
     * <pre>
     *  private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

     * </pre>
     */
    var FrameEvent = (function (_super) {
        __extends(FrameEvent, _super);
        /**
         * 创建一个新的 FrameEvent 实例
         * @param type 事件类型
         * @param cancelable
         */
        function FrameEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=FrameEvent,p=c.prototype;
        d(FrameEvent, "MOVEMENT_FRAME_EVENT"
            ,function () {
                return FrameEvent.ANIMATION_FRAME_EVENT;
            }
        );
        d(p, "armature"
            /**
             * 派发这个事件的骨架
             * @member {dragonBones.Armature} dragonBones.FrameEvent#armature
             */
            ,function () {
                return (this.target);
            }
        );
        /**
         * 当动画播放到一个关键帧时派发
         */
        FrameEvent.ANIMATION_FRAME_EVENT = "animationFrameEvent";
        /**
         *
         */
        FrameEvent.BONE_FRAME_EVENT = "boneFrameEvent";
        return FrameEvent;
    }(dragonBones.Event));
    dragonBones.FrameEvent = FrameEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SoundEvent
     * @extends dragonBones.Event
     * @classdesc
     * 声音事件
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var SoundEvent = (function (_super) {
        __extends(SoundEvent, _super);
        /**
         * Creates a new SoundEvent instance.
         * @param type
         * @param cancelable
         */
        function SoundEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=SoundEvent,p=c.prototype;
        /**
         * Dispatched when the animation of the animation enter a frame containing sound labels.
         */
        SoundEvent.SOUND = "sound";
        return SoundEvent;
    }(dragonBones.Event));
    dragonBones.SoundEvent = SoundEvent;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.BaseFactory
     * @classdesc
     * 工厂的基类
     * @extends dragonBones.EventDispatcher
     *
     * @example
       <pre>
         //获取动画数据
         var skeletonData = RES.getRes("skeleton");
         //获取纹理集数据
         var textureData = RES.getRes("textureConfig");
         //获取纹理集图片
         var texture = RES.getRes("texture");
      
         //创建一个工厂，用来创建Armature
         var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
         //把动画数据添加到工厂里
         factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
         //把纹理集数据和图片添加到工厂里
         factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
         //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
         var armatureName:string = skeletonData.armature[0].name;
         //从工厂里创建出Armature
         var armature:dragonBones.Armature = factory.buildArmature(armatureName);
         //获取装载Armature的容器
         var armatureDisplay = armature.display;
         //把它添加到舞台上
         this.addChild(armatureDisplay);
         //取得这个Armature动画列表中的第一个动画的名字
         var curAnimationName = armature.animation.animationList[0];
         //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
         //第一个参数 animationName {string} 指定播放动画的名称.
         //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
         //把Armature添加到心跳时钟里
         dragonBones.WorldClock.clock.add(armature);
         //心跳时钟开启
         egret.Ticker.getInstance().register(function (advancedTime) {
             dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
         }, this);
       </pre>
     */
    var BaseFactory = (function (_super) {
        __extends(BaseFactory, _super);
        function BaseFactory() {
            _super.call(this);
            /** @private */
            this.dragonBonesDataDic = {};
            /** @private */
            this.textureAtlasDic = {};
        }
        var d = __define,c=BaseFactory,p=c.prototype;
        /**
         * 释放资源
         * @param  disposeData {boolean} (optional) 是否释放所有内部的引用
         */
        p.dispose = function (disposeData) {
            if (disposeData === void 0) { disposeData = true; }
            if (disposeData) {
                for (var skeletonName in this.dragonBonesDataDic) {
                    (this.dragonBonesDataDic[skeletonName]).dispose();
                    delete this.dragonBonesDataDic[skeletonName];
                }
                for (var textureAtlasName in this.textureAtlasDic) {
                    var textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                    if (textureAtlasArr) {
                        for (var i = 0, len = textureAtlasArr.length; i < len; i++) {
                            textureAtlasArr[i].dispose();
                        }
                    }
                    delete this.textureAtlasDic[textureAtlasName];
                }
            }
            this.dragonBonesDataDic = null;
            this.textureAtlasDic = null;
            //_currentDataName = null;
            //_currentTextureAtlasName = null;
        };
        /**
         * 根据名字获取一个DragonBonesData
         * @param name {string} 想要获取的DragonBonesData的名字
         * @returns {dragonBones.DragonBonesData} 返回指定名字的DragonBonesData（如果存在的话）
         */
        p.getDragonBonesData = function (name) {
            return this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字获取一个DragonBonesData（不推荐使用）
         * 建议使用方法getDragonBonesData来代替这个方法
         */
        p.getSkeletonData = function (name) {
            return this.getDragonBonesData(name);
        };
        /**
         * 添加一个DragonBonesData实例
         * @param data {dragonBones.DragonBonesData} 一个DragonBonesData实例
         * @param name {string} (optional) DragonBonesData的名字
         */
        p.addDragonBonesData = function (data, name) {
            if (name === void 0) { name = null; }
            if (!data) {
                throw new Error();
            }
            name = name || data.name;
            if (!name) {
                throw new Error(egret.getString(4002));
            }
            /*
            if(this.dragonBonesDataDic[name]){
                throw new Error();
            }*/
            this.dragonBonesDataDic[name] = data;
        };
        /**
         * 添加一个DragonBonesData实例（不推荐使用）
         * 建议使用方法addDragonBonesData来代替
         */
        p.addSkeletonData = function (data, name) {
            if (name === void 0) { name = null; }
            this.addDragonBonesData(data, name);
        };
        /**
         * 根据名字移除一个DragonBonesData实例.
         * @param name {string} 想要移除的DragonBonesData的名字
         */
        p.removeDragonBonesData = function (name) {
            delete this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字移除一个DragonBonesData实例.（不推荐使用）
         * 建议使用方法removeDragonBonesData代替
         */
        p.removeSkeletonData = function (name) {
            delete this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字获取纹理集TextureAtlas
         * @param name {string} 需要获取的纹理集TextureAtlas的名字
         * @returns {any} 纹理集TextureAtlas
         */
        p.getTextureAtlas = function (name) {
            return this.textureAtlasDic[name];
        };
        /**
         * 添加一个纹理集
         * @param textureAtlas {any} 需要被添加的纹理集
         * @param name {string} (optional) 需要被添加的纹理集的名字
         */
        p.addTextureAtlas = function (textureAtlas, name) {
            if (name === void 0) { name = null; }
            if (!textureAtlas) {
                throw new Error();
            }
            if (!name && textureAtlas.hasOwnProperty("name")) {
                name = textureAtlas.name;
            }
            if (!name) {
                throw new Error(egret.getString(4002));
            }
            var textureAtlasArr = this.textureAtlasDic[name];
            if (textureAtlasArr == null) {
                textureAtlasArr = [];
                this.textureAtlasDic[name] = textureAtlasArr;
            }
            if (textureAtlasArr.indexOf(textureAtlas) != -1) {
                return;
            }
            textureAtlasArr.push(textureAtlas);
        };
        /**
         * 移除指定名字的纹理集
         * @param name {string} 需要移除的纹理集的名字
         */
        p.removeTextureAtlas = function (name) {
            delete this.textureAtlasDic[name];
        };
        /**
         * 获取TextureDisplay
         * @param textureName {string} 纹理的名字
         * @param textureAtlasName {string} 纹理集的名字
         * @param pivotX {number} 轴点的x坐标
         * @param pivotY {number} 轴点的y坐标
         * @returns {any} 返回的TextureDisplay
         */
        p.getTextureDisplay = function (textureName, textureAtlasName, pivotX, pivotY) {
            if (textureAtlasName === void 0) { textureAtlasName = null; }
            if (pivotX === void 0) { pivotX = NaN; }
            if (pivotY === void 0) { pivotY = NaN; }
            var targetTextureAtlas;
            var textureAtlasArr;
            var i;
            var len;
            if (textureAtlasName) {
                textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                if (textureAtlasArr) {
                    for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                        targetTextureAtlas = textureAtlasArr[i];
                        if (targetTextureAtlas.getRegion(textureName)) {
                            break;
                        }
                        targetTextureAtlas = null;
                    }
                }
            }
            else {
                for (textureAtlasName in this.textureAtlasDic) {
                    textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                    if (textureAtlasArr) {
                        for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                            targetTextureAtlas = textureAtlasArr[i];
                            if (targetTextureAtlas.getRegion(textureName)) {
                                break;
                            }
                            targetTextureAtlas = null;
                        }
                        if (targetTextureAtlas != null) {
                            break;
                        }
                    }
                }
            }
            if (!targetTextureAtlas) {
                return null;
            }
            if (isNaN(pivotX) || isNaN(pivotY)) {
                //默认dragonBonesData的名字和和纹理集的名字是一致的
                var data = this.dragonBonesDataDic[textureAtlasName];
                data = data ? data : this.findFirstDragonBonesData();
                if (data) {
                    var displayData = data.getDisplayDataByName(textureName);
                    if (displayData) {
                        pivotX = displayData.pivot.x;
                        pivotY = displayData.pivot.y;
                    }
                }
            }
            return this._generateDisplay(targetTextureAtlas, textureName, pivotX, pivotY);
        };
        /**
         * 构建骨架
         * 一般情况下dragonBonesData和textureAtlas是一对一的，通过相同的key对应。
         * TO DO 以后会支持一对多的情况
         * @param armatureName 骨架的名字
         * @param fromDragonBonesDataName 骨架数据的名字 可选参数
         * @param fromTextureAtlasName 纹理集的名字 可选参数
         * @param skinName 皮肤的名字 可选参数
         * @returns {*}
         */
        p.buildArmature = function (armatureName, fromDragonBonesDataName, fromTextureAtlasName, skinName) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (fromTextureAtlasName === void 0) { fromTextureAtlasName = null; }
            if (skinName === void 0) { skinName = null; }
            var buildArmatureDataPackage = {};
            this.fillBuildArmatureDataPackageArmatureInfo(armatureName, fromDragonBonesDataName, buildArmatureDataPackage);
            if (fromTextureAtlasName == null) {
                fromTextureAtlasName = buildArmatureDataPackage.dragonBonesDataName;
            }
            var dragonBonesData = buildArmatureDataPackage.dragonBonesData;
            var armatureData = buildArmatureDataPackage.armatureData;
            if (!armatureData) {
                return null;
            }
            return this.buildArmatureUsingArmatureDataFromTextureAtlas(dragonBonesData, armatureData, fromTextureAtlasName, skinName);
        };
        /**
         * 构建fast骨架
         * 一般情况下dragonBonesData和textureAtlas是一对一的，通过相同的key对应。
         * @param armatureName 骨架的名字
         * @param fromDragonBonesDataName 骨架数据的名字 可选参数
         * @param fromTextureAtlasName 纹理集的名字 可选参数
         * @param skinName 皮肤的名字 可选参数
         * @returns {*}
         */
        p.buildFastArmature = function (armatureName, fromDragonBonesDataName, fromTextureAtlasName, skinName) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (fromTextureAtlasName === void 0) { fromTextureAtlasName = null; }
            if (skinName === void 0) { skinName = null; }
            var buildArmatureDataPackage = new BuildArmatureDataPackage();
            this.fillBuildArmatureDataPackageArmatureInfo(armatureName, fromDragonBonesDataName, buildArmatureDataPackage);
            if (fromTextureAtlasName == null) {
                fromTextureAtlasName = buildArmatureDataPackage.dragonBonesDataName;
            }
            var dragonBonesData = buildArmatureDataPackage.dragonBonesData;
            var armatureData = buildArmatureDataPackage.armatureData;
            if (!armatureData) {
                return null;
            }
            return this.buildFastArmatureUsingArmatureDataFromTextureAtlas(dragonBonesData, armatureData, fromTextureAtlasName, skinName);
        };
        /**
         * 用dragonBones数据，骨架数据，纹理集数据来构建骨架
         * @param dragonBonesData dragonBones数据
         * @param armatureData 骨架数据
         * @param textureAtlas 纹理集
         * @param skinName 皮肤名称 可选参数
         * @returns {Armature}
         */
        p.buildArmatureUsingArmatureDataFromTextureAtlas = function (dragonBonesData, armatureData, textureAtlasName, skinName) {
            if (skinName === void 0) { skinName = null; }
            var outputArmature = this._generateArmature();
            outputArmature.name = armatureData.name;
            outputArmature.__dragonBonesData = dragonBonesData;
            outputArmature._armatureData = armatureData;
            outputArmature._skewEnable = dragonBonesData.version >= 4.5;
            outputArmature.animation.animationDataList = armatureData.animationDataList;
            this._buildBones(outputArmature);
            outputArmature.buildIK();
            +outputArmature.updateBoneCache();
            this._buildSlots(outputArmature, skinName, textureAtlasName);
            outputArmature.advanceTime(0);
            return outputArmature;
        };
        /**
         * 用dragonBones数据，骨架数据，纹理集数据来构建骨架
         * @param dragonBonesData dragonBones数据
         * @param armatureData 骨架数据
         * @param textureAtlas 纹理集
         * @param skinName 皮肤名称 可选参数
         * @returns {Armature}
         */
        p.buildFastArmatureUsingArmatureDataFromTextureAtlas = function (dragonBonesData, armatureData, textureAtlasName, skinName) {
            if (skinName === void 0) { skinName = null; }
            var outputArmature = this._generateFastArmature();
            outputArmature.name = armatureData.name;
            outputArmature.__dragonBonesData = dragonBonesData;
            outputArmature._armatureData = armatureData;
            outputArmature._skewEnable = dragonBonesData.version >= 4.5;
            outputArmature.animation.animationDataList = armatureData.animationDataList;
            this._buildFastBones(outputArmature);
            outputArmature.buildIK();
            +outputArmature.updateBoneCache();
            this._buildFastSlots(outputArmature, skinName, textureAtlasName);
            outputArmature.advanceTime(0);
            return outputArmature;
        };
        /**
         * 拷贝动画到骨架中
         * 暂时不支持ifRemoveOriginalAnimationList为false的情况
         * @param toArmature  拷贝到的那个骨架
         * @param fromArmatreName 从哪个骨架里拷贝，骨架的名字
         * @param fromDragonBonesDataName 从哪个DragonBones数据中拷贝，Dragonbones数据的名字
         * @param ifRemoveOriginalAnimationList 是否移除原骨架里的动画，暂时不支持为false的情况
         * @returns {boolean}
         */
        p.copyAnimationsToArmature = function (toArmature, fromArmatreName, fromDragonBonesDataName, ifRemoveOriginalAnimationList) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (ifRemoveOriginalAnimationList === void 0) { ifRemoveOriginalAnimationList = true; }
            var buildArmatureDataPackage = {};
            if (!this.fillBuildArmatureDataPackageArmatureInfo(fromArmatreName, fromDragonBonesDataName, buildArmatureDataPackage)) {
                return false;
            }
            var fromArmatureData = buildArmatureDataPackage.armatureData;
            toArmature.animation.animationDataList = fromArmatureData.animationDataList;
            //处理子骨架的复制
            var fromSkinData = fromArmatureData.getSkinData("");
            var fromSlotData;
            var fromDisplayData;
            var toSlotList = toArmature.getSlots(false);
            var toSlot;
            var toSlotDisplayList;
            var toSlotDisplayListLength = 0;
            var toDisplayObject;
            var toChildArmature;
            var length1 = toSlotList.length;
            for (var i1 = 0; i1 < length1; i1++) {
                toSlot = toSlotList[i1];
                toSlotDisplayList = toSlot.displayList;
                toSlotDisplayListLength = toSlotDisplayList.length;
                for (var i = 0; i < toSlotDisplayListLength; i++) {
                    toDisplayObject = toSlotDisplayList[i];
                    if (toDisplayObject instanceof dragonBones.Armature) {
                        toChildArmature = toDisplayObject;
                        fromSlotData = fromSkinData.getSlotData(toSlot.name);
                        fromDisplayData = fromSlotData.displayDataList[i];
                        if (fromDisplayData.type == dragonBones.DisplayData.ARMATURE) {
                            this.copyAnimationsToArmature(toChildArmature, fromDisplayData.name, buildArmatureDataPackage.dragonBonesDataName, ifRemoveOriginalAnimationList);
                        }
                    }
                }
            }
            return true;
        };
        p.fillBuildArmatureDataPackageArmatureInfo = function (armatureName, dragonBonesDataName, outputBuildArmatureDataPackage) {
            if (dragonBonesDataName) {
                outputBuildArmatureDataPackage.dragonBonesDataName = dragonBonesDataName;
                outputBuildArmatureDataPackage.dragonBonesData = this.dragonBonesDataDic[dragonBonesDataName];
                outputBuildArmatureDataPackage.armatureData = outputBuildArmatureDataPackage.dragonBonesData.getArmatureDataByName(armatureName);
                return true;
            }
            else {
                for (dragonBonesDataName in this.dragonBonesDataDic) {
                    outputBuildArmatureDataPackage.dragonBonesData = this.dragonBonesDataDic[dragonBonesDataName];
                    outputBuildArmatureDataPackage.armatureData = outputBuildArmatureDataPackage.dragonBonesData.getArmatureDataByName(armatureName);
                    if (outputBuildArmatureDataPackage.armatureData) {
                        outputBuildArmatureDataPackage.dragonBonesDataName = dragonBonesDataName;
                        return true;
                    }
                }
            }
            return false;
        };
        p.fillBuildArmatureDataPackageTextureInfo = function (fromTextureAtlasName, outputBuildArmatureDataPackage) {
            outputBuildArmatureDataPackage.textureAtlas = this.textureAtlasDic[fromTextureAtlasName ? fromTextureAtlasName : outputBuildArmatureDataPackage.dragonBonesDataName];
        };
        p.findFirstDragonBonesData = function () {
            for (var key in this.dragonBonesDataDic) {
                var outputDragonBonesData = this.dragonBonesDataDic[key];
                if (outputDragonBonesData) {
                    return outputDragonBonesData;
                }
            }
            return null;
        };
        p.findFirstTextureAtlas = function () {
            for (var key in this.textureAtlasDic) {
                var outputTextureAtlas = this.textureAtlasDic[key];
                if (outputTextureAtlas) {
                    return outputTextureAtlas;
                }
            }
            return null;
        };
        p._buildBones = function (armature) {
            //按照从属关系的顺序建立
            var boneDataList = armature.armatureData.boneDataList;
            var boneData;
            var bone;
            var parent;
            for (var i = 0; i < boneDataList.length; i++) {
                boneData = boneDataList[i];
                bone = dragonBones.Bone.initWithBoneData(boneData);
                parent = boneData.parent;
                if (parent && armature.armatureData.getBoneData(parent) == null) {
                    parent = null;
                }
                //Todo use a internal addBone method to avoid sortBones every time.
                armature.addBone(bone, parent, true);
            }
            armature._updateAnimationAfterBoneListChanged();
        };
        p._buildSlots = function (armature, skinName, textureAtlasName) {
            var skinData = armature.armatureData.getSkinData(skinName);
            if (!skinData) {
                return;
            }
            armature.armatureData.setSkinData(skinName);
            var displayList = [];
            var slotDataList = armature.armatureData.slotDataList;
            var slotData;
            var slot;
            var bone;
            for (var i = 0; i < slotDataList.length; i++) {
                slotData = slotDataList[i];
                bone = armature.getBone(slotData.parent);
                if (!bone) {
                    continue;
                }
                slot = this._generateSlot();
                slot.initWithSlotData(slotData);
                bone.addSlot(slot);
                displayList.length = 0;
                var l = slotData.displayDataList.length;
                while (l--) {
                    var displayData = slotData.displayDataList[l];
                    switch (displayData.type) {
                        case dragonBones.DisplayData.ARMATURE:
                            var childArmature = this.buildArmatureUsingArmatureDataFromTextureAtlas(armature.__dragonBonesData, armature.__dragonBonesData.getArmatureDataByName(displayData.name), textureAtlasName, skinName);
                            displayList[l] = childArmature;
                            break;
                        case dragonBones.DisplayData.IMAGE:
                        default:
                            displayList[l] = this.getTextureDisplay(displayData.name, textureAtlasName, displayData.pivot.x, displayData.pivot.y);
                            break;
                    }
                }
                //==================================================
                //如果显示对象有name属性并且name属性可以设置的话，将name设置为与slot同名，dragonBones并不依赖这些属性，只是方便开发者
                for (var j = 0, jLen = displayList.length; j < jLen; j++) {
                    var displayObject = displayList[j];
                    if (!displayObject) {
                        continue;
                    }
                    if (displayObject instanceof dragonBones.Armature) {
                        displayObject = displayObject.display;
                    }
                    if (displayObject.hasOwnProperty("name")) {
                        try {
                            displayObject["name"] = slot.name;
                        }
                        catch (err) {
                        }
                    }
                }
                //==================================================
                slot.displayList = displayList;
                slot._changeDisplay(slotData.displayIndex);
            }
        };
        p._buildFastBones = function (armature) {
            //按照从属关系的顺序建立
            var boneDataList = armature.armatureData.boneDataList;
            var boneData;
            var bone;
            for (var i = 0; i < boneDataList.length; i++) {
                boneData = boneDataList[i];
                bone = dragonBones.FastBone.initWithBoneData(boneData);
                armature.addBone(bone, boneData.parent);
            }
        };
        p._buildFastSlots = function (armature, skinName, textureAtlasName) {
            //根据皮肤初始化SlotData的DisplayDataList
            var skinData = armature.armatureData.getSkinData(skinName);
            if (!skinData) {
                return;
            }
            armature.armatureData.setSkinData(skinName);
            var displayList = [];
            var slotDataList = armature.armatureData.slotDataList;
            var slotData;
            var slot;
            for (var i = 0; i < slotDataList.length; i++) {
                displayList.length = 0;
                slotData = slotDataList[i];
                slot = this._generateFastSlot();
                slot.initWithSlotData(slotData);
                var l = slotData.displayDataList.length;
                while (l--) {
                    var displayData = slotData.displayDataList[l];
                    switch (displayData.type) {
                        case dragonBones.DisplayData.ARMATURE:
                            var childArmature = this.buildFastArmatureUsingArmatureDataFromTextureAtlas(armature.__dragonBonesData, armature.__dragonBonesData.getArmatureDataByName(displayData.name), textureAtlasName, skinName);
                            displayList[l] = childArmature;
                            slot.hasChildArmature = true;
                            break;
                        case dragonBones.DisplayData.IMAGE:
                        default:
                            displayList[l] = this.getTextureDisplay(displayData.name, textureAtlasName, displayData.pivot.x, displayData.pivot.y);
                            break;
                    }
                }
                //==================================================
                //如果显示对象有name属性并且name属性可以设置的话，将name设置为与slot同名，dragonBones并不依赖这些属性，只是方便开发者
                var length1 = displayList.length;
                for (var i1 = 0; i1 < length1; i1++) {
                    var displayObject = displayList[i1];
                    if (!displayObject) {
                        continue;
                    }
                    if (displayObject instanceof dragonBones.FastArmature) {
                        displayObject = displayObject.display;
                    }
                    if (displayObject.hasOwnProperty("name")) {
                        try {
                            displayObject["name"] = slot.name;
                        }
                        catch (err) {
                        }
                    }
                }
                //==================================================
                slot.initDisplayList(displayList.concat());
                armature.addSlot(slot, slotData.parent);
                slot._changeDisplayIndex(slotData.displayIndex);
            }
        };
        /**
         * @private
         * Generates an Armature instance.
         * @returns {dragonBones.Armature} Armature An Armature instance.
         */
        p._generateArmature = function () {
            return null;
        };
        /**
         * @private
         * Generates an Slot instance.
         * @returns {dragonBones.Slot} Slot An Slot instance.
         */
        p._generateSlot = function () {
            return null;
        };
        /**
         * @private
         * Generates an Armature instance.
         * @returns {dragonBones.Armature} Armature An Armature instance.
         */
        p._generateFastArmature = function () {
            return null;
        };
        /**
         * @private
         * Generates an Slot instance.
         * @returns {dragonBones.Slot} Slot An Slot instance.
         */
        p._generateFastSlot = function () {
            return null;
        };
        /**
         * @private
         * Generates a DisplayObject
         * @param textureAtlas {any} The TextureAtlas.
         * @param fullName {string} A qualified name.
         * @param pivotX {number} A pivot x based value.
         * @param pivotY {number} A pivot y based value.
         * @returns {any}
         */
        p._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
            return null;
        };
        BaseFactory._helpMatrix = new dragonBones.Matrix();
        return BaseFactory;
    }(dragonBones.EventDispatcher));
    dragonBones.BaseFactory = BaseFactory;

    var BuildArmatureDataPackage = (function () {
        function BuildArmatureDataPackage() {
        }
        var d = __define,c=BuildArmatureDataPackage,p=c.prototype;
        return BuildArmatureDataPackage;
    }());
    dragonBones.BuildArmatureDataPackage = BuildArmatureDataPackage;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastArmature
     * @classdesc
     * FastArmature 是 DragonBones 高效率的骨骼动画系统。他能缓存动画数据，大大减少动画播放的计算
     * 不支持动态添加Bone和Slot，换装请通过更换Slot的dispaly或子骨架childArmature来实现
     * @extends dragonBones.EventDispatcher
     * @see dragonBones.ArmatureData
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastArmature = (function (_super) {
        __extends(FastArmature, _super);
        function FastArmature(display) {
            _super.call(this);
            /**
             * 保证CacheManager是独占的前提下可以开启，开启后有助于性能提高
             */
            this.isCacheManagerExclusive = false;
            this._boneIKList = [];
            this._enableEventDispatch = true;
            this.useCache = true;
            this._display = display;
            this._animation = new dragonBones.FastAnimation(this);
            this._slotsZOrderChanged = false;
            this._armatureData = null;
            this.boneList = [];
            this._boneDic = {};
            this.slotList = [];
            this._slotDic = {};
            this.slotHasChildArmatureList = [];
            this._eventList = [];
            this._ikList = [];
            this._delayDispose = false;
            this._lockDispose = false;
        }
        var d = __define,c=FastArmature,p=c.prototype;
        /**
         * Cleans up any resources used by this instance.
         */
        p.dispose = function () {
            this._delayDispose = true;
            if (!this._animation || this._lockDispose) {
                return;
            }
            this.userData = null;
            this._animation.dispose();
            var i = this.slotList.length;
            while (i--) {
                this.slotList[i].dispose();
            }
            i = this.boneList.length;
            while (i--) {
                this.boneList[i].dispose();
            }
            i = this._ikList.length;
            while (i--) {
                this._ikList[i].dispose();
            }
            this.slotList.length = 0;
            this.boneList.length = 0;
            this._armatureData = null;
            this._animation = null;
            this.slotList = null;
            this.boneList = null;
            this._eventList = null;
            this._ikList = null;
        };
        /**
         * Update the animation using this method typically in an ENTERFRAME Event or with a Timer.
         * @param The amount of second to move the playhead ahead.
         */
        p.advanceTime = function (passedTime) {
            this._lockDispose = true;
            this._animation.advanceTime(passedTime);
            var bone;
            var slot;
            var i = 0;
            var len = this._boneIKList.length;
            var j;
            var jLen;
            if (this._animation.animationState.isUseCache()) {
                if (!this.useCache) {
                    this.useCache = true;
                }
                i = this.slotList.length;
                while (i--) {
                    slot = this.slotList[i];
                    slot.updateByCache();
                }
            }
            else {
                if (this.useCache) {
                    this.useCache = false;
                    i = this.slotList.length;
                    while (i--) {
                        slot = this.slotList[i];
                        slot.switchTransformToBackup();
                    }
                }
                for (i = 0; i < len; i++) {
                    for (j = 0, jLen = this._boneIKList[i].length; j < jLen; j++) {
                        bone = this._boneIKList[i][j];
                        bone.update();
                        bone.rotationIK = bone.global.rotation;
                        if (i != 0 && bone.isIKConstraint) {
                            this._ikList[i - 1].compute();
                            bone.adjustGlobalTransformMatrixByIK();
                        }
                    }
                }
                i = this.slotList.length;
                while (i--) {
                    slot = this.slotList[i];
                    slot._update();
                }
            }
            i = this.slotHasChildArmatureList.length;
            while (i--) {
                slot = this.slotHasChildArmatureList[i];
                var childArmature = slot.childArmature;
                if (childArmature) {
                    childArmature.advanceTime(passedTime);
                }
            }
            if (this._slotsZOrderChanged) {
                this.updateSlotsZOrder();
            }
            while (this._eventList.length > 0) {
                this.dispatchEvent(this._eventList.shift());
            }
            this._lockDispose = false;
            if (this._delayDispose) {
                this.dispose();
            }
        };
        /**
         * 开启动画缓存
         * @param  {number} 帧速率，每秒缓存多少次数据，越大越流畅,若值小于零会被设置为动画数据中的默认帧率
         * @param  {Array<any>} 需要缓存的动画列表，如果为null，则全部动画都缓存
         * @param  {boolean} 动画是否是循环动画，仅在3.0以下的数据格式使用，如果动画不是循环动画请设置为false，默认为true。
         * @return {AnimationCacheManager}  返回缓存管理器，可以绑定到其他armature以减少内存
         */
        p.enableAnimationCache = function (frameRate, animationList, loop) {
            if (animationList === void 0) { animationList = null; }
            if (loop === void 0) { loop = true; }
            var animationCacheManager = dragonBones.AnimationCacheManager.initWithArmatureData(this.armatureData, frameRate);
            if (animationList) {
                var length = animationList.length;
                for (var i = 0; i < length; i++) {
                    var animationName = animationList[i];
                    animationCacheManager.initAnimationCache(animationName);
                }
            }
            else {
                animationCacheManager.initAllAnimationCache();
            }
            animationCacheManager.setCacheGeneratorArmature(this);
            animationCacheManager.generateAllAnimationCache(loop);
            animationCacheManager.bindCacheUserArmature(this);
            this.enableCache = true;
            return animationCacheManager;
        };
        /**
         * 获取指定名称的 Bone
         * @param boneName {string} Bone名称
         * @returns {FastBone}
         */
        p.getBone = function (boneName) {
            return this._boneDic[boneName];
        };
        /**
         * 获取指定名称的 Slot
         * @param slotName {string} Slot名称
         * @returns {FastSlot}
         */
        p.getSlot = function (slotName) {
            return this._slotDic[slotName];
        };
        /**
         * 获取包含指定显示对象的 Bone
         * @param display {any} 显示对象实例
         * @returns {FastBone}
         */
        p.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot ? slot.parent : null;
        };
        /**
         * 获取包含指定显示对象的 Slot
         * @param displayObj {any} 显示对象实例
         * @returns {FastSlot}
         */
        p.getSlotByDisplay = function (displayObj) {
            if (displayObj) {
                for (var i = 0, len = this.slotList.length; i < len; i++) {
                    if (this.slotList[i].display == displayObj) {
                        return this.slotList[i];
                    }
                }
            }
            return null;
        };
        /**
         * 获取骨架包含的所有插槽
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastSlot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.slotList.concat() : this.slotList;
        };
        p._updateBonesByCache = function () {
            var i = this.boneList.length;
            var bone;
            while (i--) {
                bone = this.boneList[i];
                bone.update();
            }
        };
        /**
         * 在骨架中为指定名称的 FastBone 添加一个子 FastBone.
         * 和Armature不同,FastArmature的这个方法不能在运行时动态添加骨骼
         * @param bone {FastBone} FastBone 实例
         * @param parentName {string} 父骨头名称 默认：null
         */
        p.addBone = function (bone, parentName) {
            if (parentName === void 0) { parentName = null; }
            var parentBone;
            if (parentName) {
                parentBone = this.getBone(parentName);
                parentBone.boneList.push(bone);
            }
            bone.armature = this;
            bone.parentBoneData = parentBone;
            this.boneList.unshift(bone);
            this._boneDic[bone.name] = bone;
        };
        /**
         * 为指定名称的 FastBone 添加一个子 FastSlot.
         * 和Armature不同,FastArmature的这个方法不能在运行时动态添加插槽
         * @param slot {FastSlot} FastSlot 实例
         * @param boneName {string}
         * @see dragonBones.Bone
         */
        p.addSlot = function (slot, parentBoneName) {
            var bone = this.getBone(parentBoneName);
            if (bone) {
                slot.armature = this;
                slot.setParent(bone);
                bone.slotList.push(slot);
                slot._addDisplayToContainer(this.display);
                this.slotList.push(slot);
                this._slotDic[slot.name] = slot;
                if (slot.hasChildArmature) {
                    this.slotHasChildArmatureList.push(slot);
                }
            }
            else {
                throw new Error();
            }
        };
        /**
         * 按照显示层级为所有 Slot 排序
         */
        p.updateSlotsZOrder = function () {
            this.slotList.sort(this.sortSlot);
            var i = this.slotList.length;
            while (i--) {
                var slot = this.slotList[i];
                if ((slot._frameCache && (slot._frameCache).displayIndex >= 0)
                    || (!slot._frameCache && slot.displayIndex >= 0)) {
                    slot._addDisplayToContainer(this._display);
                }
            }
            this._slotsZOrderChanged = false;
        };
        p.sortBoneList = function () {
            var i = this.boneList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var level = 0;
                var bone = this.boneList[i];
                var boneParent = bone;
                while (boneParent) {
                    level++;
                    boneParent = boneParent.parent;
                }
                helpArray[i] = [level, bone];
            }
            helpArray.sort(dragonBones.ArmatureData.sortBoneDataHelpArrayDescending);
            i = helpArray.length;
            while (i--) {
                this.boneList[i] = helpArray[i][1];
            }
            helpArray.length = 0;
        };
        /** @private When AnimationState enter a key frame, call this func*/
        p.arriveAtFrame = function (frame, animationState) {
            if (frame.event && this.hasEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT);
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this._addEvent(frameEvent);
            }
            if (frame.action) {
                this.animation.gotoAndPlay(frame.action);
            }
        };
        p.invalidUpdate = function (boneName) {
            if (boneName === void 0) { boneName = null; }
            if (boneName) {
                var bone = this.getBone(boneName);
                if (bone) {
                    bone.invalidUpdate();
                }
            }
            else {
                var i = this.boneList.length;
                while (i--) {
                    this.boneList[i].invalidUpdate();
                }
            }
        };
        p.resetAnimation = function () {
            this.animation.animationState._resetTimelineStateList();
            var length = this.boneList.length;
            for (var i = 0; i < length; i++) {
                var boneItem = this.boneList[i];
                boneItem._timelineState = null;
            }
            this.animation.stop();
        };
        p.sortSlot = function (slot1, slot2) {
            return slot1.zOrder < slot2.zOrder ? 1 : -1;
        };
        /**
         * 获取FastAnimation实例
         * @returns {any} FastAnimation实例
         */
        p.getAnimation = function () {
            return this._animation;
        };
        d(p, "armatureData"
            /**
             * ArmatureData.
             * @see dragonBones.ArmatureData.
             */
            ,function () {
                return this._armatureData;
            }
        );
        d(p, "animation"
            /**
             * An Animation instance
             * @see dragonBones.Animation
             */
            ,function () {
                return this._animation;
            }
        );
        d(p, "display"
            /**
             * Armature's display object. It's instance type depends on render engine. For example "flash.display.DisplayObject" or "startling.display.DisplayObject"
             */
            ,function () {
                return this._display;
            }
        );
        d(p, "enableCache"
            ,function () {
                return this._enableCache;
            }
            ,function (value) {
                this._enableCache = value;
            }
        );
        d(p, "enableEventDispatch"
            ,function () {
                return this._enableEventDispatch;
            }
            ,function (value) {
                this._enableEventDispatch = value;
            }
        );
        p._addEvent = function (event) {
            if (this._enableEventDispatch) {
                this._eventList.push(event);
            }
        };
        p.getIKs = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._ikList.concat() : this._ikList;
        };
        p.buildIK = function () {
            var ikConstraintData;
            this._ikList.length = 0;
            for (var i = 0, len = this._armatureData.ikDataList.length; i < len; i++) {
                ikConstraintData = this._armatureData.ikDataList[i];
                this._ikList.push(new dragonBones.FastIKConstraint(ikConstraintData, this));
            }
        };
        p.updateBoneCache = function () {
            this.boneList.reverse();
            var temp = {};
            var ikConstraintsCount = this._ikList.length;
            var arrayCount = ikConstraintsCount + 1;
            var i;
            var len;
            var j;
            var jLen;
            var bone;
            var currentBone;
            this._boneIKList = [];
            while (this._boneIKList.length < arrayCount) {
                this._boneIKList[this._boneIKList.length] = [];
            }
            temp[this.boneList[0].name] = 0;
            for (i = 0, len = this._ikList.length; i < len; i++) {
                temp[this._ikList[i].bones[0].name] = i + 1;
            }
            next: for (i = 0, len = this.boneList.length; i < len; i++) {
                bone = this.boneList[i];
                currentBone = bone;
                while (currentBone) {
                    if (currentBone.parent == null) {
                        temp[currentBone.name] = 0;
                    }
                    if (temp.hasOwnProperty(currentBone.name)) {
                        this._boneIKList[temp[currentBone.name]].push(bone);
                        continue next;
                    }
                    currentBone = currentBone.parent;
                }
            }
        };
        p.getIKTargetData = function (bone) {
            var target = [];
            var ik;
            for (var i = 0, len = this._ikList.length; i < len; i++) {
                ik = this._ikList[i];
                if (bone.name == ik.target.name) {
                    target.push(ik);
                }
            }
            return target;
        };
        return FastArmature;
    }(dragonBones.EventDispatcher));
    dragonBones.FastArmature = FastArmature;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastDBObject
     * @classdesc
     * FastDBObject 是 FastBone 和 FastSlot 的基类
     * @see dragonBones.FastBone
     * @see dragonBones.FastSlot
     */
    var FastDBObject = (function () {
        function FastDBObject() {
            this._globalTransformMatrix = new dragonBones.Matrix();
            this._global = new dragonBones.DBTransform();
            this._origin = new dragonBones.DBTransform();
            this._visible = true;
            this.armature = null;
            this._parent = null;
            this.userData = null;
            this.inheritRotation = true;
            this.inheritScale = true;
            this.inheritTranslation = true;
        }
        var d = __define,c=FastDBObject,p=c.prototype;
        /** @private */
        p.updateByCache = function () {
            this._global = this._frameCache.globalTransform;
            this._globalTransformMatrix = this._frameCache.globalTransformMatrix;
        };
        /** @private */
        p.switchTransformToBackup = function () {
            if (!this._globalBackup) {
                this._globalBackup = new dragonBones.DBTransform();
                this._globalTransformMatrixBackup = new dragonBones.Matrix();
            }
            this._global = this._globalBackup;
            this._globalTransformMatrix = this._globalTransformMatrixBackup;
        };
        /** @private */
        p.setParent = function (value) {
            this._parent = value;
        };
        /**
         * Cleans up any resources used by this DBObject instance.
         */
        p.dispose = function () {
            this.userData = null;
            this._globalTransformMatrix = null;
            this._global = null;
            this._origin = null;
            this.armature = null;
            this._parent = null;
        };
        p._calculateParentTransform = function () {
            if (this.parent && (this.inheritTranslation || this.inheritRotation || this.inheritScale)) {
                var parentGlobalTransform = this._parent._global;
                var parentGlobalTransformMatrix = this._parent._globalTransformMatrix;
                /*
                if(	!this.inheritTranslation && (parentGlobalTransform.x != 0 || parentGlobalTransform.y != 0) ||
                    !this.inheritRotation && (parentGlobalTransform.skewX != 0 || parentGlobalTransform.skewY != 0) ||
                    !this.inheritScale && (parentGlobalTransform.scaleX != 1 || parentGlobalTransform.scaleY != 1)){
                    parentGlobalTransform = FastDBObject._tempParentGlobalTransform;
                    parentGlobalTransform.copy(this._parent._global);
                    if(!this.inheritTranslation){
                        parentGlobalTransform.x = 0;
                        parentGlobalTransform.y = 0;
                    }
                    if(!this.inheritScale){
                        parentGlobalTransform.scaleX = 1;
                        parentGlobalTransform.scaleY = 1;
                    }
                    if(!this.inheritRotation){
                        parentGlobalTransform.skewX = 0;
                        parentGlobalTransform.skewY = 0;
                    }
                    
                    parentGlobalTransformMatrix = DBObject._tempParentGlobalTransformMatrix;
                    TransformUtil.transformToMatrix(parentGlobalTransform, parentGlobalTransformMatrix);
                }
                */
                return dragonBones.ParentTransformObject.create().setTo(parentGlobalTransform, parentGlobalTransformMatrix);
            }
            return null;
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                //计算绝对坐标
                var x = this._global.x;
                var y = this._global.y;
                this._global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                this._global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;
                if (this.inheritRotation) {
                    this._global.skewX += parentGlobalTransform.skewX;
                    this._global.skewY += parentGlobalTransform.skewY;
                }
                if (this.inheritScale) {
                    this._global.scaleX *= parentGlobalTransform.scaleX;
                    this._global.scaleY *= parentGlobalTransform.scaleY;
                }
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return output;
        };
        p._calculateRelativeParentTransform = function () {
        };
        d(p, "name"
            ,function () {
                return this._name;
            }
            ,function (value) {
                this._name = value;
            }
        );
        d(p, "global"
            /**
             * This DBObject instance global transform instance.
             * @see dragonBones.DBTransform
             */
            ,function () {
                return this._global;
            }
        );
        d(p, "globalTransformMatrix"
            ,function () {
                return this._globalTransformMatrix;
            }
        );
        d(p, "origin"
            /**
             * This DBObject instance related to parent transform instance.
             * @see dragonBones.DBTransform
             */
            ,function () {
                return this._origin;
            }
        );
        d(p, "parent"
            /**
             * Indicates the Bone instance that directly contains this DBObject instance if any.
             */
            ,function () {
                return this._parent;
            }
        );
        d(p, "visible"
            ,function () {
                return this._visible;
            }
            ,function (value) {
                this._visible = value;
            }
        );
        d(p, "frameCache",undefined
            ,function (cache) {
                this._frameCache = cache;
            }
        );
        FastDBObject._tempParentGlobalTransform = new dragonBones.DBTransform();
        return FastDBObject;
    }());
    dragonBones.FastDBObject = FastDBObject;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastBone
     * @classdesc
     * FastBone 实例代表 FastArmature 中的一个骨头。一个FastArmature实例可以由很多 FastBone组成。
     * FastBone 在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移旋转缩放的实现
     * 和Bone相比，FastBone不能动态添加子骨骼和子插槽
     * @extends dragonBones.FastDBObject
     * @see dragonBones.FastArmature
     * @see dragonBones.FastSlot
     * @see dragonBones.BoneData
     */
    var FastBone = (function (_super) {
        __extends(FastBone, _super);
        function FastBone() {
            _super.call(this);
            this.slotList = [];
            this.boneList = [];
            /** @private */
            this._needUpdate = 0;
            this.isIKConstraint = false;
            this.childrenBones = [];
            this._needUpdate = 2;
            this._tweenPivot = new dragonBones.Point();
        }
        var d = __define,c=FastBone,p=c.prototype;
        FastBone.initWithBoneData = function (boneData) {
            var outputBone = new FastBone();
            outputBone.name = boneData.name;
            outputBone.length = boneData.length;
            outputBone.inheritRotation = boneData.inheritRotation;
            outputBone.inheritScale = boneData.inheritScale;
            outputBone.origin.copy(boneData.transform);
            return outputBone;
        };
        /**
         * 获取当前骨头包含的所有 FastBone 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastBone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.boneList.concat() : this.boneList;
        };
        /**
         * 获取当前骨头包含的所有 FastSlot 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastSlot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.slotList.concat() : this.slotList;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this._timelineState = null;
            this._tweenPivot = null;
        };
        //动画
        /**
         * 在下一帧强制更新当前 Bone 实例及其包含的所有 Slot 的动画。
         */
        p.invalidUpdate = function () {
            this._needUpdate = 2;
            this.operationInvalidUpdate(this);
            var i;
            var len;
            for (i = 0, len = this.childrenBones.length; i < len; i++) {
                if (this.childrenBones[i]._needUpdate != 2) {
                    this.operationInvalidUpdate(this.childrenBones[i]);
                    this.childrenBones[i].invalidUpdate();
                }
            }
        };
        p.operationInvalidUpdate = function (bone) {
            var arr = this.armature.getIKTargetData(bone);
            var i;
            var len;
            var j;
            var jLen;
            var ik;
            var bo;
            for (i = 0, len = arr.length; i < len; i++) {
                ik = arr[i];
                for (j = 0, jLen = ik.bones.length; j < jLen; j++) {
                    bo = ik.bones[j];
                    if (bo._needUpdate != 2) {
                        bo.invalidUpdate();
                    }
                }
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.copy(this._origin);
            if (this._timelineState) {
                this._global.add(this._timelineState._transform);
            }
        };
        /** @private */
        p.updateByCache = function () {
            _super.prototype.updateByCache.call(this);
            this._global = this._frameCache.globalTransform;
            this._globalTransformMatrix = this._frameCache.globalTransformMatrix;
        };
        /** @private */
        p.update = function (needUpdate) {
            if (needUpdate === void 0) { needUpdate = false; }
            this._needUpdate--;
            if (needUpdate || this._needUpdate > 0 || (this._parent && this._parent._needUpdate > 0)) {
                this._needUpdate = 1;
            }
            else {
                return;
            }
            this.blendingTimeline();
            //计算global
            var result = this._updateGlobal();
            if (result) {
                result.release();
            }
        };
        p._updateGlobal = function () {
            if (!this.armature._skewEnable) {
                return _super.prototype._updateGlobal.call(this);
            }
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null && output.parentGlobalTransformMatrix && output.parentGlobalTransform) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                var scaleXF = this._global.scaleX * parentGlobalTransform.scaleX > 0;
                var scaleYF = this._global.scaleY * parentGlobalTransform.scaleY > 0;
                var relativeRotation = this._global.rotation;
                var relativeScaleX = this._global.scaleX;
                var relativeScaleY = this._global.scaleY;
                var parentRotation = this.parentBoneRotation;
                this._localTransform = this._global;
                if (this.inheritScale && !this.inheritRotation) {
                    if (parentRotation != 0) {
                        this._localTransform = this._localTransform.clone();
                        this._localTransform.rotation -= parentRotation;
                    }
                }
                dragonBones.TransformUtil.transformToMatrix(this._localTransform, this._globalTransformMatrix);
                this._globalTransformMatrix.concat(parentMatrix);
                if (this.inheritScale) {
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, scaleXF, scaleYF);
                }
                else {
                    dragonBones.TransformUtil.matrixToTransformPosition(this._globalTransformMatrix, this._global);
                    this._global.scaleX = this._localTransform.scaleX;
                    this._global.scaleY = this._localTransform.scaleY;
                    this._global.rotation = this._localTransform.rotation + (this.inheritRotation ? parentRotation : 0);
                    dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
                }
            }
            return output;
        };
        p.adjustGlobalTransformMatrixByIK = function () {
            if (!this.parent) {
                return;
            }
            this.global.rotation = this.rotationIK;
            dragonBones.TransformUtil.transformToMatrix(this.global, this._globalTransformMatrix);
        };
        /** @private */
        p._hideSlots = function () {
            var length = this.slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this.slotList[i];
                childSlot.hideSlots();
            }
        };
        p.blendingTimeline = function () {
            if (this._timelineState) {
                this._tweenPivot.x = this._timelineState._pivot.x;
                this._tweenPivot.y = this._timelineState._pivot.y;
            }
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p.arriveAtFrame = function (frame, animationState) {
            var childSlot;
            if (frame.event && this.armature.hasEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.BONE_FRAME_EVENT);
                frameEvent.bone = this;
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this.armature._addEvent(frameEvent);
            }
        };
        d(p, "childArmature"
            /**
             * 不推荐的API,建议使用 slot.childArmature 替代
             */
            ,function () {
                var s = this.slot;
                if (s) {
                    return s.childArmature;
                }
                return null;
            }
        );
        d(p, "display"
            /**
             * 不推荐的API,建议使用 slot.display 替代
             */
            ,function () {
                var s = this.slot;
                if (s) {
                    return s.display;
                }
                return null;
            }
            ,function (value) {
                var s = this.slot;
                if (s) {
                    s.display = value;
                }
            }
        );
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    for (var i = 0, len = this.armature.slotList.length; i < len; i++) {
                        if (this.armature.slotList[i].parent == this) {
                            this.armature.slotList[i]._updateDisplayVisible(this._visible);
                        }
                    }
                }
            }
        );
        d(p, "slot"
            /**
             * 返回当前 FastBone 实例包含的第一个 FastSlot 实例
             * @member {FastSlot} dragonBones.FastBone#slot
             */
            ,function () {
                return this.slotList.length > 0 ? this.slotList[0] : null;
            }
        );
        d(p, "parentBoneRotation"
            ,function () {
                return this.parent ? this.parent.rotationIK : 0;
            }
        );
        d(p, "parentBoneData",undefined
            ,function (value) {
                if (this._parent != value) {
                    if (this._parent != null) {
                        var index = this._parent.childrenBones.indexOf(this);
                        if (index >= 0) {
                            this._parent.childrenBones.splice(index, 1);
                        }
                    }
                    this.setParent(value);
                    if (this._parent != null) {
                        var indexs = this._parent.childrenBones.indexOf(this);
                        if (indexs < 0) {
                            this._parent.childrenBones.push(this);
                        }
                    }
                }
            }
        );
        return FastBone;
    }(dragonBones.FastDBObject));
    dragonBones.FastBone = FastBone;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var FastIKConstraint = (function () {
        function FastIKConstraint(data, armatureData) {
            this.animationCacheBend = 0;
            this.animationCacheWeight = -1;
            this.ikdata = data;
            this.armature = armatureData;
            this.weight = data.weight;
            this.bendDirection = (data.bendPositive ? 1 : -1);
            this.bones = [];
            var bone;
            if (data.chain) {
                bone = armatureData.getBone(data.bones).parent;
                bone.isIKConstraint = true;
                this.bones.push(bone);
            }
            bone = armatureData.getBone(data.bones);
            bone.isIKConstraint = true;
            this.bones.push(bone);
            this.target = armatureData.getBone(data.target);
        }
        var d = __define,c=FastIKConstraint,p=c.prototype;
        p.dispose = function () {
        };
        p.compute = function () {
            switch (this.bones.length) {
                case 1:
                    var weig1 = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    this.compute1(this.bones[0], this.target, weig1);
                    break;
                case 2:
                    var bend = this.animationCacheBend != 0 ? this.animationCacheBend : this.bendDirection;
                    var weig = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    var tt = this.compute2(this.bones[0], this.bones[1], this.target.global.x, this.target.global.y, bend, weig);
                    this.bones[0].rotationIK = tt.x;
                    this.bones[1].rotationIK = tt.y + tt.x;
                    break;
            }
        };
        p.compute1 = function (bone, target, weightA) {
            var parentRotation = (!bone.inheritRotation || bone.parent == null) ? 0 : bone.parent.global.rotation;
            var rotation = bone.global.rotation;
            var rotationIK = Math.atan2(target.global.y - bone.global.y, target.global.x - bone.global.x);
            bone.rotationIK = rotation + (rotationIK - rotation) * weightA;
        };
        p.compute2 = function (parent, child, targetX, targetY, bendDirection, weightA) {
            //添加斜切后的算法，现在用的
            if (weightA == 0) {
                return new dragonBones.Point(parent.global.rotation, child.global.rotation);
            }
            var tt = new dragonBones.Point();
            /**父的绝对坐标**/
            var p1 = new dragonBones.Point(parent.global.x, parent.global.y);
            /**子的绝对坐标**/
            var p2 = new dragonBones.Point(child.global.x, child.global.y);
            var psx = parent.global.scaleX;
            var psy = parent.global.scaleY;
            var csx = child.global.scaleX;
            var csy = child.global.scaleY;
            var cx = child.origin.x * psx;
            var cy = child.origin.y * psy;
            var initalRotation = Math.atan2(cy, cx); //差值等于子在父落点到父的角度
            var childX = p2.x - p1.x;
            var childY = p2.y - p1.y;
            /**d1的长度**/
            var len1 = Math.sqrt(childX * childX + childY * childY);
            var parentAngle;
            var childAngle;
            outer: if (Math.abs(psx - psy) <= 0.001) {
                var childlength = child.length;
                var len2 = childlength * csx;
                targetX = targetX - p1.x;
                targetY = targetY - p1.y;
                var cosDenom = 2 * len1 * len2;
                if (cosDenom < 0.0001) {
                    var temp = Math.atan2(targetY, targetX);
                    tt.x = temp * weightA - initalRotation;
                    tt.y = temp * weightA + initalRotation; //+ tt.x ;
                    this.normalize(tt.x);
                    this.normalize(tt.y);
                    return tt;
                }
                var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                childAngle = Math.acos(cos) * bendDirection; //o2
                var adjacent = len1 + len2 * cos; //ae
                var opposite = len2 * Math.sin(childAngle); //be
                parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite); //o1
                tt.x = parentAngle * weightA - initalRotation;
                tt.y = childAngle * weightA + initalRotation; //+tt.x;
            }
            else {
                var l1 = len1;
                var tx = targetX - p1.x;
                var ty = targetY - p1.y;
                var l2 = child.length * child.origin.scaleX; //child.currentLocalTransform.scaleX;
                var a = psx * l2;
                var b = psy * l2;
                var ta = Math.atan2(ty, tx);
                var aa = a * a;
                var bb = b * b;
                var ll = l1 * l1;
                var dd = tx * tx + ty * ty;
                var c0 = bb * ll + aa * dd - aa * bb;
                var c1 = -2 * bb * l1;
                var c2 = bb - aa;
                var d = c1 * c1 - 4 * c2 * c0;
                if (d >= 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0) {
                        q = -q;
                    }
                    q = -(c1 + q) / 2;
                    var r0 = q / c2;
                    var r1 = c0 / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        var y1 = Math.sqrt(dd - r * r) * bendDirection;
                        parentAngle = ta - Math.atan2(y1, r);
                        childAngle = Math.atan2(y1 / psy, (r - l1) / psx);
                        tt.x = parentAngle * weightA - initalRotation;
                        tt.y = childAngle * weightA + initalRotation; //+tt.x;
                        break outer;
                    }
                }
                var minAngle = 0;
                var minDist = Number.MAX_VALUE;
                var minX = 0;
                var minY = 0;
                var maxAngle = 0;
                var maxDist = 0;
                var maxX = 0;
                var maxY = 0;
                var x2 = l1 + a;
                var dist = x2 * x2;
                if (dist > maxDist) {
                    maxAngle = 0;
                    maxDist = dist;
                    maxX = x2;
                }
                x2 = l1 - a;
                dist = x2 * x2;
                if (dist < minDist) {
                    minAngle = Math.PI;
                    minDist = dist;
                    minX = x2;
                }
                var angle1 = Math.acos(-a * l1 / (aa - bb));
                x2 = a * Math.cos(angle1) + l1;
                var y2 = b * Math.sin(angle1);
                dist = x2 * x2 + y2 * y2;
                if (dist < minDist) {
                    minAngle = angle1;
                    minDist = dist;
                    minX = x2;
                    minY = y2;
                }
                if (dist > maxDist) {
                    maxAngle = angle1;
                    maxDist = dist;
                    maxX = x2;
                    maxY = y2;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    parentAngle = ta - Math.atan2(minY * bendDirection, minX);
                    childAngle = minAngle * bendDirection;
                }
                else {
                    parentAngle = ta - Math.atan2(maxY * bendDirection, maxX);
                    childAngle = maxAngle * bendDirection;
                }
                tt.x = parentAngle * weightA - initalRotation;
                tt.y = childAngle * weightA + initalRotation; //;
            }
            this.normalize(tt.x);
            this.normalize(tt.y);
            return tt;
        };
        p.normalize = function (rotation) {
            if (rotation > Math.PI) {
                rotation -= Math.PI * 2;
            }
            else if (rotation < -Math.PI) {
                rotation += Math.PI * 2;
            }
        };
        return FastIKConstraint;
    }());
    dragonBones.FastIKConstraint = FastIKConstraint;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastSlot
     * @classdesc
     * FastSlot 实例是骨头上的一个插槽，是显示图片的容器。
     * 一个 FastBone 上可以有多个FastSlot，每个FastSlot中同一时间都会有一张图片用于显示，不同的FastSlot中的图片可以同时显示。
     * 每个 FastSlot 中可以包含多张图片，同一个 FastSlot 中的不同图片不能同时显示，但是可以在动画进行的过程中切换，用于实现帧动画。
     * @extends dragonBones.DBObject
     * @see dragonBones.FastArmature
     * @see dragonBones.FastBone
     * @see dragonBones.SlotData
     */
    var FastSlot = (function (_super) {
        __extends(FastSlot, _super);
        function FastSlot() {
            _super.call(this);
            this._currentDisplayIndex = 0;
            this.hasChildArmature = false;
            this._currentDisplayIndex = -1;
            this._originZOrder = 0;
            this._tweenZOrder = 0;
            this._offsetZOrder = 0;
            this._colorTransform = new dragonBones.ColorTransform();
            this._isColorChanged = false;
            this._displayDataList = null;
            this._currentDisplay = null;
            this.inheritRotation = true;
            this.inheritScale = true;
        }
        var d = __define,c=FastSlot,p=c.prototype;
        /**
         * 通过传入 SlotData 初始化FastSlot
         * @param slotData
         */
        p.initWithSlotData = function (slotData) {
            this.name = slotData.name;
            this.blendMode = slotData.blendMode;
            this._defaultGotoAndPlay = slotData.gotoAndPlay;
            this._originZOrder = slotData.zOrder;
            this._displayDataList = slotData.displayDataList;
            this._originDisplayIndex = slotData.displayIndex;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._displayList) {
                return;
            }
            _super.prototype.dispose.call(this);
            this._displayDataList = null;
            this._displayList = null;
            this._currentDisplay = null;
        };
        //动画
        /** @private */
        p.updateByCache = function () {
            _super.prototype.updateByCache.call(this);
            this._updateTransform();
            //颜色
            var cacheColor = (this._frameCache).colorTransform;
            var cacheColorChanged = cacheColor != null;
            if (this.colorChanged != cacheColorChanged ||
                (this.colorChanged && cacheColorChanged && !dragonBones.ColorTransformUtil.isEqual(this._colorTransform, cacheColor))) {
                cacheColor = cacheColor || dragonBones.ColorTransformUtil.originalColor;
                this._updateDisplayColor(cacheColor.alphaOffset, cacheColor.redOffset, cacheColor.greenOffset, cacheColor.blueOffset, cacheColor.alphaMultiplier, cacheColor.redMultiplier, cacheColor.greenMultiplier, cacheColor.blueMultiplier, cacheColorChanged);
            }
            //displayIndex
            this._changeDisplayIndex((this._frameCache).displayIndex);
            this.gotoAndPlay = (this._frameCache).gotoAndPlay;
        };
        /** @private */
        p._update = function () {
            if (this._parent._needUpdate <= 0) {
                return;
            }
            var result = this._updateGlobal();
            if (result) {
                result.release();
            }
            this._updateTransform();
        };
        p._calculateRelativeParentTransform = function () {
            this._global.copy(this._origin);
            this._global.x += this._parent._tweenPivot.x;
            this._global.y += this._parent._tweenPivot.y;
        };
        p.updateChildArmatureAnimation = function () {
            if (this.childArmature) {
                if (this._currentDisplayIndex >= 0) {
                    var curAnimation = this._gotoAndPlay;
                    if (curAnimation == null) {
                        curAnimation = this._defaultGotoAndPlay;
                        if (curAnimation == null) {
                            this.childArmature.armatureData.defaultAnimation;
                        }
                    }
                    if (curAnimation == null) {
                        if (this.armature && this.armature.animation.lastAnimationState) {
                            curAnimation = this.armature.animation.lastAnimationState.name;
                        }
                    }
                    if (curAnimation && this.childArmature.animation.hasAnimation(curAnimation)) {
                        this.childArmature.animation.gotoAndPlay(curAnimation);
                    }
                    else {
                        this.childArmature.animation.play();
                    }
                }
                else {
                    this.childArmature.animation.stop();
                    this.childArmature.animation._lastAnimationState = null;
                }
            }
        };
        p.initDisplayList = function (newDisplayList) {
            this._displayList = newDisplayList;
        };
        p.clearCurrentDisplay = function () {
            if (this.hasChildArmature) {
                var targetArmature = this.childArmature;
                if (targetArmature) {
                    targetArmature.resetAnimation();
                }
            }
            var slotIndex = this._getDisplayIndex();
            this._removeDisplayFromContainer();
            return slotIndex;
        };
        /** @private */
        p._changeDisplayIndex = function (displayIndex) {
            if (displayIndex === void 0) { displayIndex = 0; }
            if (this._currentDisplayIndex == displayIndex) {
                return;
            }
            var slotIndex = -1;
            if (this._currentDisplayIndex >= 0) {
                slotIndex = this.clearCurrentDisplay();
            }
            this._currentDisplayIndex = displayIndex;
            if (this._currentDisplayIndex >= 0) {
                this._origin.copy(this._displayDataList[this._currentDisplayIndex].transform);
                this.initCurrentDisplay(slotIndex);
            }
        };
        //currentDisplayIndex不变，改变内容，必须currentDisplayIndex >=0
        p.changeSlotDisplay = function (value) {
            var slotIndex = this.clearCurrentDisplay();
            this._displayList[this._currentDisplayIndex] = value;
            this.initCurrentDisplay(slotIndex);
        };
        p.initCurrentDisplay = function (slotIndex) {
            if (slotIndex === void 0) { slotIndex = 0; }
            var display = this._displayList[this._currentDisplayIndex];
            if (display) {
                if (display instanceof dragonBones.FastArmature) {
                    this._currentDisplay = display.display;
                }
                else {
                    this._currentDisplay = display;
                }
            }
            else {
                this._currentDisplay = null;
            }
            this._updateDisplay(this._currentDisplay);
            if (this._currentDisplay) {
                if (slotIndex != -1) {
                    this._addDisplayToContainer(this.armature.display, slotIndex);
                }
                else {
                    this.armature._slotsZOrderChanged = true;
                    this._addDisplayToContainer(this.armature.display);
                }
                if (this._blendMode) {
                    this._updateDisplayBlendMode(this._blendMode);
                }
                if (this._isColorChanged) {
                    this._updateDisplayColor(this._colorTransform.alphaOffset, this._colorTransform.redOffset, this._colorTransform.greenOffset, this._colorTransform.blueOffset, this._colorTransform.alphaMultiplier, this._colorTransform.redMultiplier, this._colorTransform.greenMultiplier, this._colorTransform.blueMultiplier, true);
                }
                this._updateTransform();
                if (display instanceof dragonBones.FastArmature) {
                    var targetArmature = (display);
                    if (this.armature &&
                        this.armature.animation.animationState &&
                        targetArmature.animation.hasAnimation(this.armature.animation.animationState.name)) {
                        targetArmature.animation.gotoAndPlay(this.armature.animation.animationState.name);
                    }
                    else {
                        targetArmature.animation.play();
                    }
                }
            }
        };
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    this._updateDisplayVisible(this._visible);
                }
            }
        );
        d(p, "displayList"
            /**
             * 显示对象列表(包含 display 或者 子骨架)
             * @member {any[]} dragonBones.FastSlot#displayList
             */
            ,function () {
                return this._displayList;
            }
            ,function (value) {
                //todo: 考虑子骨架变化的各种情况
                if (!value) {
                    throw new Error();
                }
                var newDisplay = value[this._currentDisplayIndex];
                var displayChanged = this._currentDisplayIndex >= 0 && this._displayList[this._currentDisplayIndex] != newDisplay;
                this._displayList = value;
                if (displayChanged) {
                    this.changeSlotDisplay(newDisplay);
                }
            }
        );
        d(p, "display"
            /**
             * 当前的显示对象(可能是 display 或者 子骨架)
             * @member {any} dragonBones.FastSlot#display
             */
            ,function () {
                return this._currentDisplay;
            }
            ,function (value) {
                //todo: 考虑子骨架变化的各种情况
                if (this._currentDisplayIndex < 0) {
                    return;
                }
                if (this._displayList[this._currentDisplayIndex] == value) {
                    return;
                }
                this.changeSlotDisplay(value);
            }
        );
        d(p, "childArmature"
            /**
             * 当前的子骨架
             * @member {FastArmature} dragonBones.Slot#childArmature
             */
            ,function () {
                return (this._displayList[this._currentDisplayIndex] instanceof dragonBones.Armature
                    || this._displayList[this._currentDisplayIndex] instanceof dragonBones.FastArmature) ? this._displayList[this._currentDisplayIndex] : null;
            }
            ,function (value) {
                this.display = value;
            }
        );
        d(p, "zOrder"
            /**
             * 显示顺序。(支持小数用于实现动态插入slot)
             * @member {number} dragonBones.FastSlot#zOrder
             */
            ,function () {
                return this._originZOrder + this._tweenZOrder + this._offsetZOrder;
            }
            ,function (value) {
                if (this.zOrder != value) {
                    this._offsetZOrder = value - this._originZOrder - this._tweenZOrder;
                    if (this.armature) {
                        this.armature._slotsZOrderChanged = true;
                    }
                }
            }
        );
        d(p, "blendMode"
            /**
             * 混合模式
             * @member {string} dragonBones.FastSlot#blendMode
             */
            ,function () {
                return this._blendMode;
            }
            ,function (value) {
                if (this._blendMode != value) {
                    this._blendMode = value;
                    this._updateDisplayBlendMode(this._blendMode);
                }
            }
        );
        d(p, "gotoAndPlay"
            ,function () {
                return this._gotoAndPlay;
            }
            /**
             * 播放子骨架动画
             * @member {string} dragonBones.FastSlot#gotoAndPlay
             */
            ,function (value) {
                if (this._gotoAndPlay != value) {
                    this._gotoAndPlay = value;
                    this.updateChildArmatureAnimation();
                }
            }
        );
        d(p, "colorTransform"
            ,function () {
                return this._colorTransform;
            }
        );
        d(p, "displayIndex"
            ,function () {
                return this._currentDisplayIndex;
            }
        );
        d(p, "colorChanged"
            ,function () {
                return this._isColorChanged;
            }
        );
        //Abstract method
        /**
         * @private
         */
        p._updateDisplay = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         */
        p._getDisplayIndex = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Adds the original display object to another display object.
         * @param container
         * @param index
         */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * remove the original display object from its parent.
         */
        p._removeDisplayFromContainer = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Updates the transform of the slot.
         */
        p._updateTransform = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         */
        p._updateDisplayVisible = function (value) {
            /**
             * bone.visible && slot.visible && updateVisible
             * this._parent.visible && this._visible && value;
             */
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Updates the color of the display object.
         * @param a
         * @param r
         * @param g
         * @param b
         * @param aM
         * @param rM
         * @param gM
         * @param bM
         */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            if (colorChanged === void 0) { colorChanged = false; }
            this._colorTransform.alphaOffset = aOffset;
            this._colorTransform.redOffset = rOffset;
            this._colorTransform.greenOffset = gOffset;
            this._colorTransform.blueOffset = bOffset;
            this._colorTransform.alphaMultiplier = aMultiplier;
            this._colorTransform.redMultiplier = rMultiplier;
            this._colorTransform.greenMultiplier = gMultiplier;
            this._colorTransform.blueMultiplier = bMultiplier;
            this._isColorChanged = colorChanged;
        };
        /**
         * @private
         * Update the blend mode of the display object.
         * @param value The blend mode to use.
         */
        p._updateDisplayBlendMode = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private When slot timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, animationState) {
            var slotFrame = frame;
            var displayIndex = slotFrame.displayIndex;
            this._changeDisplayIndex(displayIndex);
            this._updateDisplayVisible(slotFrame.visible);
            if (displayIndex >= 0) {
                if (!isNaN(slotFrame.zOrder) && slotFrame.zOrder != this._tweenZOrder) {
                    this._tweenZOrder = slotFrame.zOrder;
                    this.armature._slotsZOrderChanged = true;
                }
            }
            //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
            //后续会扩展更多的action，目前只有gotoAndPlay的含义
            if (frame.action) {
                var targetArmature = this.childArmature;
                if (targetArmature) {
                    targetArmature.getAnimation().gotoAndPlay(frame.action);
                }
            }
            else {
                this.gotoAndPlay = slotFrame.gotoAndPlay;
            }
        };
        /** @private */
        p.hideSlots = function () {
            this._changeDisplayIndex(-1);
            this._removeDisplayFromContainer();
            if (this._frameCache) {
                this._frameCache.clear();
            }
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            var output = this._calculateParentTransform();
            if (output) {
                this._globalTransformMatrix.concat(output.parentGlobalTransformMatrix);
                dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, this._global.scaleX * output.parentGlobalTransform.scaleX >= 0, this._global.scaleY * output.parentGlobalTransform.scaleY >= 0);
            }
            return output;
        };
        p._resetToOrigin = function () {
            this._changeDisplayIndex(this._originDisplayIndex);
            this._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, true);
        };
        return FastSlot;
    }(dragonBones.FastDBObject));
    dragonBones.FastSlot = FastSlot;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastAnimation
     * @classdesc
     * FastAnimation实例隶属于FastArmature,用于控制FastArmature的动画播放。
     * 和Animation相比，FastAnimation为了优化性能，不支持动画融合，在开启缓存的情况下，不支持无极的平滑补间
     * @see dragonBones.FastBone
     * @see dragonBones.FastArmature
     * @see dragonBones.FastAnimationState
     * @see dragonBones.AnimationData.
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastAnimation = (function () {
        /**
         * 创建一个新的FastAnimation实例并赋给传入的FastArmature实例
         * @param armature {FastArmature} 骨架实例
         */
        function FastAnimation(armature) {
            /**
             * 当前正在运行的动画实例.
             * @member {FastAnimationState} dragonBones.FastAnimation#animationState
             */
            this.animationState = new dragonBones.FastAnimationState();
            this._armature = armature;
            this.animationState._armature = armature;
            this.animationList = [];
            this._animationDataObj = {};
            this._isPlaying = false;
            this._timeScale = 1;
        }
        var d = __define,c=FastAnimation,p=c.prototype;
        /**
         * Qualifies all resources used by this Animation instance for garbage collection.
         */
        p.dispose = function () {
            if (!this._armature) {
                return;
            }
            this._armature = null;
            this._animationDataList = null;
            this.animationList = null;
            this.animationState = null;
        };
        /**
         * 开始播放指定名称的动画。
         * 要播放的动画将经过指定时间的淡入过程，然后开始播放，同时之前播放的动画会经过相同时间的淡出过程。
         * @param animationName {string} 指定播放动画的名称.
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param playTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         * @see dragonBones.FastAnimationState.
         */
        p.gotoAndPlay = function (animationName, fadeInTime, duration, playTimes) {
            if (fadeInTime === void 0) { fadeInTime = -1; }
            if (duration === void 0) { duration = -1; }
            if (playTimes === void 0) { playTimes = NaN; }
            if (!this._animationDataList) {
                return null;
            }
            var animationData = this._animationDataObj[animationName];
            if (!animationData) {
                return null;
            }
            this._isPlaying = true;
            fadeInTime = fadeInTime < 0 ? (animationData.fadeTime < 0 ? 0.3 : animationData.fadeTime) : fadeInTime;
            var durationScale;
            if (duration < 0) {
                durationScale = animationData.scale < 0 ? 1 : animationData.scale;
            }
            else {
                durationScale = duration * 1000 / animationData.duration;
            }
            playTimes = isNaN(playTimes) ? animationData.playTimes : playTimes;
            //播放新动画
            this.animationState._fadeIn(animationData, playTimes, 1 / durationScale, fadeInTime);
            if (this._armature.enableCache && this.animationCacheManager) {
                this.animationState.animationCache = this.animationCacheManager.getAnimationCache(animationName);
            }
            var i = this._armature.slotHasChildArmatureList.length;
            while (i--) {
                var slot = this._armature.slotHasChildArmatureList[i];
                var childArmature = slot.childArmature;
                if (childArmature) {
                    childArmature.getAnimation().gotoAndPlay(animationName);
                }
            }
            return this.animationState;
        };
        /**
         * 播放指定名称的动画并停止于某个时间点
         * @param animationName {string} 指定播放的动画名称.
         * @param time {number} 动画停止的绝对时间
         * @param normalizedTime {number} 动画停止的相对动画总时间的系数，这个参数和time参数是互斥的（例如 0.2：动画停止总时间的20%位置） 默认值：-1 意味着使用绝对时间。
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：0
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @see dragonBones.FastAnimationState.
         */
        p.gotoAndStop = function (animationName, time, normalizedTime, fadeInTime, duration) {
            if (normalizedTime === void 0) { normalizedTime = -1; }
            if (fadeInTime === void 0) { fadeInTime = 0; }
            if (duration === void 0) { duration = -1; }
            if (this.animationState.name != animationName) {
                this.gotoAndPlay(animationName, fadeInTime, duration);
            }
            if (normalizedTime >= 0) {
                this.animationState.setCurrentTime(this.animationState.totalTime * normalizedTime);
            }
            else {
                this.animationState.setCurrentTime(time);
            }
            this.animationState.stop();
            return this.animationState;
        };
        /**
         * 从当前位置继续播放动画
         */
        p.play = function () {
            if (!this._animationDataList) {
                return;
            }
            if (!this.animationState.name) {
                this.gotoAndPlay(this._animationDataList[0].name);
            }
            else if (!this._isPlaying) {
                this._isPlaying = true;
            }
            else {
                this.gotoAndPlay(this.animationState.name);
            }
        };
        /**
         * 暂停动画播放
         */
        p.stop = function () {
            this._isPlaying = false;
        };
        /** @private */
        p.advanceTime = function (passedTime) {
            if (!this._isPlaying) {
                return;
            }
            this.animationState._advanceTime(passedTime * this._timeScale);
        };
        /**
         * check if contains a AnimationData by name.
         * @return Boolean.
         * @see dragonBones.AnimationData.
         */
        p.hasAnimation = function (animationName) {
            return this._animationDataObj[animationName] != null;
        };
        d(p, "timeScale"
            /**
             * 时间缩放倍数
             * @member {number} dragonBones.FastAnimation#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        d(p, "animationDataList"
            /**
             * 包含的所有动画数据列表
             * @member {AnimationData[]} dragonBones.FastAnimation#animationDataList
             * @see dragonBones.AnimationData.
             */
            ,function () {
                return this._animationDataList;
            }
            ,function (value) {
                this._animationDataList = value;
                this.animationList.length = 0;
                var length = this._animationDataList.length;
                for (var i = 0; i < length; i++) {
                    var animationData = this._animationDataList[i];
                    this.animationList.push(animationData.name);
                    this._animationDataObj[animationData.name] = animationData;
                }
            }
        );
        d(p, "movementList"
            /**
             * Unrecommended API. Recommend use animationList.
             */
            ,function () {
                return this.animationList;
            }
        );
        d(p, "movementID"
            /**
             * Unrecommended API. Recommend use lastAnimationName.
             */
            ,function () {
                return this.lastAnimationName;
            }
        );
        /**
         * 是否正在播放
         * @member {boolean} dragonBones.FastAnimation#isPlaying
         */
        p.isPlaying = function () {
            return this._isPlaying && !this.isComplete;
        };
        d(p, "isComplete"
            /**
             * 是否播放完成.
             * @member {boolean} dragonBones.FastAnimation#isComplete
             */
            ,function () {
                return this.animationState.isComplete;
            }
        );
        d(p, "lastAnimationState"
            /**
             * 当前播放动画的实例.
             * @member {FastAnimationState} dragonBones.FastAnimation#lastAnimationState
             */
            ,function () {
                return this.animationState;
            }
        );
        d(p, "lastAnimationName"
            /**
             * 当前播放动画的名字.
             * @member {string} dragonBones.FastAnimation#lastAnimationName
             */
            ,function () {
                return this.animationState ? this.animationState.name : null;
            }
        );
        return FastAnimation;
    }());
    dragonBones.FastAnimation = FastAnimation;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastAnimationState
     * @classdesc
     * FastAnimationState 实例代表播放的动画， 可以对单个动画的播放进行最细致的调节。
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
      
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
      
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        
        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);
      
       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastAnimationState = (function () {
        function FastAnimationState() {
            this._boneTimelineStateList = [];
            this._slotTimelineStateList = [];
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._currentPlayTimes = 0;
            this._totalTime = 0; //毫秒
            this._currentTime = 0;
            this._lastTime = 0;
            this._playTimes = 0;
            this._fading = false;
        }
        var d = __define,c=FastAnimationState,p=c.prototype;
        p.dispose = function () {
            this._resetTimelineStateList();
            this._armature = null;
        };
        /**
         * 播放当前动画。如果动画已经播放完毕, 将不会继续播放.
         * @returns {FastAnimationState} 动画播放状态实例
         */
        p.play = function () {
            this._isPlaying = true;
            return this;
        };
        /**
         * 暂停当前动画的播放。
         * @returns {AnimationState} 动画播放状态实例
         */
        p.stop = function () {
            this._isPlaying = false;
            return this;
        };
        p.setCurrentTime = function (value) {
            if (value < 0 || isNaN(value)) {
                value = 0;
            }
            this._time = value;
            this._currentTime = this._time * 1000;
            return this;
        };
        p._resetTimelineStateList = function () {
            var i = this._boneTimelineStateList.length;
            while (i--) {
                dragonBones.FastBoneTimelineState.returnObject(this._boneTimelineStateList[i]);
            }
            this._boneTimelineStateList.length = 0;
            i = this._slotTimelineStateList.length;
            while (i--) {
                dragonBones.FastSlotTimelineState.returnObject(this._slotTimelineStateList[i]);
            }
            this._slotTimelineStateList.length = 0;
            this.name = null;
        };
        /** @private */
        p._fadeIn = function (aniData, playTimes, timeScale, fadeTotalTime) {
            this.animationData = aniData;
            this.name = this.animationData.name;
            this._totalTime = this.animationData.duration;
            this.autoTween = aniData.autoTween;
            this.setTimeScale(timeScale);
            this.setPlayTimes(playTimes);
            //reset
            this._isComplete = false;
            this._currentFrameIndex = -1;
            this._currentPlayTimes = -1;
            if (Math.round(this._totalTime * this.animationData.frameRate * 0.001) < 2) {
                this._currentTime = this._totalTime;
            }
            else {
                this._currentTime = -1;
            }
            this._fadeTotalTime = fadeTotalTime * this._timeScale;
            this._fading = this._fadeTotalTime > 0;
            //default
            this._isPlaying = true;
            if (this._armature.enableCache && this.animationCache && this._fading && this._boneTimelineStateList) {
                this.updateTransformTimeline(this.progress);
            }
            this._time = 0;
            this._progress = 0;
            this._updateTimelineStateList();
            this.hideBones();
            return;
        };
        /**
         * @private
         * Update timeline state based on mixing transforms and clip.
         */
        p._updateTimelineStateList = function () {
            this._resetTimelineStateList();
            var timelineName;
            var length = this.animationData.timelineList.length;
            for (var i = 0; i < length; i++) {
                var boneTimeline = this.animationData.timelineList[i];
                timelineName = boneTimeline.name;
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    var boneTimelineState = dragonBones.FastBoneTimelineState.borrowObject();
                    boneTimelineState.fadeIn(bone, this, boneTimeline);
                    this._boneTimelineStateList.push(boneTimelineState);
                }
            }
            var length1 = this.animationData.slotTimelineList.length;
            for (var i1 = 0; i1 < length1; i1++) {
                var slotTimeline = this.animationData.slotTimelineList[i1];
                timelineName = slotTimeline.name;
                var slot = this._armature.getSlot(timelineName);
                if (slot && slot.displayList.length > 0) {
                    var slotTimelineState = dragonBones.FastSlotTimelineState.borrowObject();
                    slotTimelineState.fadeIn(slot, this, slotTimeline);
                    this._slotTimelineStateList.push(slotTimelineState);
                }
            }
        };
        /** @private */
        p._advanceTime = function (passedTime) {
            passedTime *= this._timeScale;
            if (this._fading) {
                //计算progress
                this._time += passedTime;
                this._progress = this._time / this._fadeTotalTime;
                if (this._progress >= 1) {
                    this._progress = 0;
                    this._time = 0;
                    this._fading = false;
                }
            }
            if (this._fading) {
                //update boneTimelie
                var length = this._boneTimelineStateList.length;
                for (var i = 0; i < length; i++) {
                    var timeline = this._boneTimelineStateList[i];
                    timeline.updateFade(this.progress);
                }
                //update slotTimelie
                var length1 = this._slotTimelineStateList.length;
                for (var i1 = 0; i1 < length1; i1++) {
                    var slotTimeline = this._slotTimelineStateList[i1];
                    slotTimeline.updateFade(this.progress);
                }
            }
            else {
                this.advanceTimelinesTime(passedTime);
            }
        };
        p.advanceTimelinesTime = function (passedTime) {
            if (this._isPlaying) {
                this._time += passedTime;
            }
            //计算是否已经播放完成isThisComplete
            var startFlg = false;
            var loopCompleteFlg = false;
            var completeFlg = false;
            var isThisComplete = false;
            var currentPlayTimes = 0;
            var currentTime = this._time * 1000;
            if (this._playTimes == 0 ||
                currentTime < this._playTimes * this._totalTime) {
                isThisComplete = false;
                this._progress = currentTime / this._totalTime;
                currentPlayTimes = Math.ceil(this.progress) || 1;
                this._progress -= Math.floor(this.progress);
                currentTime %= this._totalTime;
            }
            else {
                currentPlayTimes = this._playTimes;
                currentTime = this._totalTime;
                isThisComplete = true;
                this._progress = 1;
            }
            this._isComplete = isThisComplete;
            if (this.isUseCache()) {
                this.animationCache.update(this.progress);
            }
            else {
                this.updateTransformTimeline(this.progress);
            }
            //update main timeline
            if (this._currentTime != currentTime) {
                if (this._currentPlayTimes != currentPlayTimes) {
                    if (this._currentPlayTimes > 0 && currentPlayTimes > 1) {
                        loopCompleteFlg = true;
                    }
                    this._currentPlayTimes = currentPlayTimes;
                }
                if (this._currentTime < 0) {
                    startFlg = true;
                }
                if (this._isComplete) {
                    completeFlg = true;
                }
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                this.updateMainTimeline(isThisComplete);
            }
            //抛事件
            var event;
            if (startFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.START)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.START);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
            if (completeFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.COMPLETE);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
            else if (loopCompleteFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.LOOP_COMPLETE);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
        };
        p.updateTransformTimeline = function (progress) {
            var i = this._boneTimelineStateList.length;
            var boneTimeline;
            var slotTimeline;
            if (this._isComplete) {
                //update boneTimelie
                while (i--) {
                    boneTimeline = this._boneTimelineStateList[i];
                    boneTimeline.update(progress);
                    this._isComplete = boneTimeline._isComplete && this._isComplete;
                }
                i = this._slotTimelineStateList.length;
                //update slotTimelie
                while (i--) {
                    slotTimeline = this._slotTimelineStateList[i];
                    slotTimeline.update(progress);
                    this._isComplete = slotTimeline._isComplete && this._isComplete;
                }
            }
            else {
                //update boneTimelie
                while (i--) {
                    boneTimeline = this._boneTimelineStateList[i];
                    boneTimeline.update(progress);
                }
                i = this._slotTimelineStateList.length;
                //update slotTimelie
                while (i--) {
                    slotTimeline = this._slotTimelineStateList[i];
                    slotTimeline.update(progress);
                }
            }
        };
        p.updateMainTimeline = function (isThisComplete) {
            var frameList = this.animationData.frameList;
            if (frameList.length > 0) {
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this.animationData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._lastTime = this._currentTime;
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (isThisComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = frameList[this._currentFrameIndex];
                    if (prevFrame) {
                        this._armature.arriveAtFrame(prevFrame, this);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._armature.arriveAtFrame(currentFrame, this);
                }
            }
        };
        p.setTimeScale = function (value) {
            if (isNaN(value) || value == Infinity) {
                value = 1;
            }
            this._timeScale = value;
            return this;
        };
        p.setPlayTimes = function (value) {
            if (value === void 0) { value = 0; }
            //如果动画只有一帧  播放一次就可以
            if (Math.round(this._totalTime * 0.001 * this.animationData.frameRate) < 2) {
                this._playTimes = 1;
            }
            else {
                this._playTimes = value;
            }
            return this;
        };
        d(p, "playTimes"
            /**
             * 播放次数 (0:循环播放， >0:播放次数)
             * @member {number} dragonBones.FastAnimationState#playTimes
             */
            ,function () {
                return this._playTimes;
            }
        );
        d(p, "currentPlayTimes"
            /**
             * 当前播放次数
             * @member {number} dragonBones.FastAnimationState#currentPlayTimes
             */
            ,function () {
                return this._currentPlayTimes < 0 ? 0 : this._currentPlayTimes;
            }
        );
        d(p, "isComplete"
            /**
             * 是否播放完成
             * @member {boolean} dragonBones.FastAnimationState#isComplete
             */
            ,function () {
                return this._isComplete;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.FastAnimationState#isPlaying
             */
            ,function () {
                return (this._isPlaying && !this._isComplete);
            }
        );
        d(p, "totalTime"
            /**
             * 动画总时长（单位：秒）
             * @member {number} dragonBones.FastAnimationState#totalTime
             */
            ,function () {
                return this._totalTime * 0.001;
            }
        );
        d(p, "currentTime"
            /**
             * 动画当前播放时间（单位：秒）
             * @member {number} dragonBones.FastAnimationState#currentTime
             */
            ,function () {
                return this._currentTime < 0 ? 0 : this._currentTime * 0.001;
            }
        );
        /**
         * 是否使用缓存
         * @member {boolean} dragonBones.FastAnimationState#isUseCache
         */
        p.isUseCache = function () {
            return this._armature.enableCache && this.animationCache && !this._fading;
        };
        p.hideBones = function () {
            var length = this.animationData.hideTimelineNameMap.length;
            for (var i = 0; i < length; i++) {
                var timelineName = this.animationData.hideTimelineNameMap[i];
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    bone._hideSlots();
                }
            }
            var slotTimelineName;
            for (i = 0, length = this.animationData.hideSlotTimelineNameMap.length; i < length; i++) {
                slotTimelineName = this.animationData.hideSlotTimelineNameMap[i];
                var slot = this._armature.getSlot(slotTimelineName);
                if (slot) {
                    slot._resetToOrigin();
                }
            }
        };
        d(p, "progress"
            /**
             * 动画播放进度
             * @member {number} dragonBones.FastAnimationState#progress
             */
            ,function () {
                return this._progress;
            }
        );
        return FastAnimationState;
    }());
    dragonBones.FastAnimationState = FastAnimationState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastBoneTimelineState
     * @classdesc
     * FastBoneTimelineState 负责计算 Bone 的时间轴动画。
     * FastBoneTimelineState 实例隶属于 FastAnimationState. FastAnimationState在创建时会为每个包含动作的 FastBone生成一个 FastBoneTimelineState 实例.
     * @see dragonBones.FastAnimation
     * @see dragonBones.FastAnimationState
     * @see dragonBones.FastBone
     */
    var FastBoneTimelineState = (function () {
        function FastBoneTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._lastTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._updateMode = 0;
            this._transform = new dragonBones.DBTransform();
            this._durationTransform = new dragonBones.DBTransform();
            this._transformToFadein = new dragonBones.DBTransform();
            this._pivot = new dragonBones.Point();
            this._durationPivot = new dragonBones.Point();
        }
        var d = __define,c=FastBoneTimelineState,p=c.prototype;
        /** @private */
        FastBoneTimelineState.borrowObject = function () {
            if (FastBoneTimelineState._pool.length == 0) {
                return new FastBoneTimelineState();
            }
            return FastBoneTimelineState._pool.pop();
        };
        /** @private */
        FastBoneTimelineState.returnObject = function (timeline) {
            if (FastBoneTimelineState._pool.indexOf(timeline) < 0) {
                FastBoneTimelineState._pool[FastBoneTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        FastBoneTimelineState.clear = function () {
            var i = FastBoneTimelineState._pool.length;
            while (i--) {
                FastBoneTimelineState._pool[i].clear();
            }
            FastBoneTimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._bone) {
                this._bone._timelineState = null;
                this._bone = null;
            }
            this._animationState = null;
            this._timelineData = null;
            this._originPivot = null;
        };
        /** @private */
        p.fadeIn = function (bone, animationState, timelineData) {
            this._bone = bone;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._isComplete = false;
            this._tweenTransform = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._durationPivot.x = 0;
            this._durationPivot.y = 0;
            this._pivot.x = 0;
            this._pivot.y = 0;
            this._originPivot = this._timelineData.originPivot;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
            if (animationState._fadeTotalTime > 0) {
                var pivotToFadein;
                if (this._bone._timelineState) {
                    this._transformToFadein.copy(this._bone._timelineState._transform);
                }
                else {
                    this._transformToFadein = new dragonBones.DBTransform();
                }
                var firstFrame = (this._timelineData.frameList[0]);
                this._durationTransform.copy(firstFrame.transform);
                this._durationTransform.minus(this._transformToFadein);
            }
            this._bone._timelineState = this;
        };
        /** @private */
        p.updateFade = function (progress) {
            this._transform.x = this._transformToFadein.x + this._durationTransform.x * progress;
            this._transform.y = this._transformToFadein.y + this._durationTransform.y * progress;
            this._transform.scaleX = this._transformToFadein.scaleX * (1 + (this._durationTransform.scaleX - 1) * progress);
            this._transform.scaleY = this._transformToFadein.scaleX * (1 + (this._durationTransform.scaleY - 1) * progress);
            this._transform.rotation = this._transformToFadein.rotation + this._durationTransform.rotation * progress;
            this._bone.invalidUpdate();
        };
        /** @private */
        p.update = function (progress) {
            if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
            else if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._bone.arriveAtFrame(currentFrame, this._animationState);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenTransform = false;
            this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
            this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
            this._transform.copy(currentFrame.transform);
            this._bone.invalidUpdate();
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
            }
            if (this._currentTime != currentTime) {
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._bone.arriveAtFrame(prevFrame, this._animationState);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._bone.arriveAtFrame(currentFrame, this._animationState);
                    this.updateToNextFrame(currentPlayTimes);
                }
                if (this._tweenTransform) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 && (this._animationState.playTimes &&
                this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999)) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.animationData.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //transform
                this._durationTransform.x = nextFrame.transform.x - currentFrame.transform.x;
                this._durationTransform.y = nextFrame.transform.y - currentFrame.transform.y;
                this._durationTransform.skewX = nextFrame.transform.skewX - currentFrame.transform.skewX;
                this._durationTransform.skewY = nextFrame.transform.skewY - currentFrame.transform.skewY;
                this._durationTransform.scaleX = nextFrame.transform.scaleX - currentFrame.transform.scaleX + nextFrame.scaleOffset.x;
                this._durationTransform.scaleY = nextFrame.transform.scaleY - currentFrame.transform.scaleY + nextFrame.scaleOffset.y;
                this._durationPivot.x = nextFrame.pivot.x - currentFrame.pivot.x;
                this._durationPivot.y = nextFrame.pivot.y - currentFrame.pivot.y;
                this._durationTransform.normalizeRotation();
                if (nextFrameIndex == 0) {
                    this._durationTransform.skewX = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewX);
                    this._durationTransform.skewY = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewY);
                }
                if (this._durationTransform.x ||
                    this._durationTransform.y ||
                    this._durationTransform.skewX ||
                    this._durationTransform.skewY ||
                    this._durationTransform.scaleX != 1 ||
                    this._durationTransform.scaleY != 1 ||
                    this._durationPivot.x ||
                    this._durationPivot.y) {
                    this._tweenTransform = true;
                }
                else {
                    this._tweenTransform = false;
                }
            }
            else {
                this._tweenTransform = false;
            }
            if (!this._tweenTransform) {
                this._transform.copy(currentFrame.transform);
                this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
                this._bone.invalidUpdate();
            }
        };
        p.updateTween = function () {
            var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
            if (this._tweenCurve) {
                progress = this._tweenCurve.getValueByProgress(progress);
            }
            else if (this._tweenEasing) {
                progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var currentTransform = currentFrame.transform;
            var currentPivot = currentFrame.pivot;
            //normal blending
            this._transform.x = currentTransform.x + this._durationTransform.x * progress;
            this._transform.y = currentTransform.y + this._durationTransform.y * progress;
            this._transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress;
            this._transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress;
            this._transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress;
            this._transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress;
            this._pivot.x = currentPivot.x + this._durationPivot.x * progress;
            this._pivot.y = currentPivot.y + this._durationPivot.y * progress;
            this._bone.invalidUpdate();
        };
        FastBoneTimelineState._pool = [];
        return FastBoneTimelineState;
    }());
    dragonBones.FastBoneTimelineState = FastBoneTimelineState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastSlotTimelineState
     * @classdesc
     * FastSlotTimelineState 负责计算 Slot 的时间轴动画。
     * FastSlotTimelineState 实例隶属于 FastAnimationState. FastAnimationState在创建时会为每个包含动作的 Slot生成一个 FastSlotTimelineState 实例.
     * @see dragonBones.FastAnimation
     * @see dragonBones.FastAnimationState
     * @see dragonBones.FastSlot
     */
    var FastSlotTimelineState = (function () {
        function FastSlotTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=FastSlotTimelineState,p=c.prototype;
        /** @private */
        FastSlotTimelineState.borrowObject = function () {
            if (FastSlotTimelineState._pool.length == 0) {
                return new FastSlotTimelineState();
            }
            return FastSlotTimelineState._pool.pop();
        };
        /** @private */
        FastSlotTimelineState.returnObject = function (timeline) {
            if (FastSlotTimelineState._pool.indexOf(timeline) < 0) {
                FastSlotTimelineState._pool[FastSlotTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        FastSlotTimelineState.clear = function () {
            var i = FastSlotTimelineState._pool.length;
            while (i--) {
                FastSlotTimelineState._pool[i].clear();
            }
            FastSlotTimelineState._pool.length = 0;
        };
        p.clear = function () {
            this._slot = null;
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
        };
        //动画开始结束
        /** @private */
        p.fadeIn = function (slot, animationState, timelineData) {
            this._slot = slot;
            this._armature = this._slot.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._isComplete = false;
            this._blendEnabled = false;
            this._tweenColor = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
        };
        //动画进行中
        /** @private */
        p.updateFade = function (progress) {
        };
        /** @private */
        p.update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
            }
            if (this._currentTime != currentTime) {
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration) {
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._slot._arriveAtFrame(prevFrame, this._animationState);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._slot._arriveAtFrame(currentFrame, this._animationState);
                    this._blendEnabled = currentFrame.displayIndex >= 0;
                    if (this._blendEnabled) {
                        this.updateToNextFrame(currentPlayTimes);
                    }
                    else {
                        this._tweenEasing = NaN;
                        this._tweenColor = false;
                    }
                }
                if (this._blendEnabled) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (this._animationState.playTimes &&
                    this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                    ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999)) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.animationData.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                if (currentFrame.color || nextFrame.color) {
                    dragonBones.ColorTransformUtil.minus(nextFrame.color || dragonBones.ColorTransformUtil.originalColor, currentFrame.color || dragonBones.ColorTransformUtil.originalColor, this._durationColor);
                    this._tweenColor = this._durationColor.alphaOffset != 0 ||
                        this._durationColor.redOffset != 0 ||
                        this._durationColor.greenOffset != 0 ||
                        this._durationColor.blueOffset != 0 ||
                        this._durationColor.alphaMultiplier != 0 ||
                        this._durationColor.redMultiplier != 0 ||
                        this._durationColor.greenMultiplier != 0 ||
                        this._durationColor.blueMultiplier != 0;
                }
                else {
                    this._tweenColor = false;
                }
            }
            else {
                this._tweenColor = false;
            }
            if (!this._tweenColor) {
                var targetColor;
                var colorChanged;
                if (currentFrame.color) {
                    targetColor = currentFrame.color;
                    colorChanged = true;
                }
                else {
                    targetColor = dragonBones.ColorTransformUtil.originalColor;
                    colorChanged = false;
                }
                if ((this._slot._isColorChanged || colorChanged)) {
                    if (!dragonBones.ColorTransformUtil.isEqual(this._slot._colorTransform, targetColor)) {
                        this._slot._updateDisplayColor(targetColor.alphaOffset, targetColor.redOffset, targetColor.greenOffset, targetColor.blueOffset, targetColor.alphaMultiplier, targetColor.redMultiplier, targetColor.greenMultiplier, targetColor.blueMultiplier, colorChanged);
                    }
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenColor) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, currentFrame.color.redOffset + this._durationColor.redOffset * progress, currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true);
                }
                else {
                    this._slot._updateDisplayColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, this._durationColor.alphaMultiplier * progress + 1, this._durationColor.redMultiplier * progress + 1, this._durationColor.greenMultiplier * progress + 1, this._durationColor.blueMultiplier * progress + 1, true);
                }
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._slot._arriveAtFrame(currentFrame, this._animationState);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenColor = false;
            this._blendEnabled = currentFrame.displayIndex >= 0;
            if (this._blendEnabled) {
                var targetColor;
                var colorChanged;
                if (currentFrame.color) {
                    targetColor = currentFrame.color;
                    colorChanged = true;
                }
                else {
                    targetColor = dragonBones.ColorTransformUtil.originalColor;
                    colorChanged = false;
                }
                if ((this._slot._isColorChanged || colorChanged)) {
                    if (!dragonBones.ColorTransformUtil.isEqual(this._slot._colorTransform, targetColor)) {
                        this._slot._updateDisplayColor(targetColor.alphaOffset, targetColor.redOffset, targetColor.greenOffset, targetColor.blueOffset, targetColor.alphaMultiplier, targetColor.redMultiplier, targetColor.greenMultiplier, targetColor.blueMultiplier, colorChanged);
                    }
                }
            }
        };
        FastSlotTimelineState.HALF_PI = Math.PI * 0.5;
        FastSlotTimelineState.DOUBLE_PI = Math.PI * 2;
        FastSlotTimelineState._pool = [];
        return FastSlotTimelineState;
    }());
    dragonBones.FastSlotTimelineState = FastSlotTimelineState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Point
     * @classdesc
     * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     * 下面的代码在 (0,0) 处创建一个点：
     *   var myPoint:Point = new Point();
     */
    var Point = (function () {
        /**
         *创建一个新点。
         * @param x 该点的水平坐标。
         * @param y 该点的垂直坐标。
         */
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        var d = __define,c=Point,p=c.prototype;
        /**
         *返回包含 x 和 y 坐标的值的字符串。
         * @returns {string}
         */
        p.toString = function () {
            return "[Point (x=" + this.x + " y=" + this.y + ")]";
        };
        return Point;
    }());
    dragonBones.Point = Point;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones
     * @classdesc
     * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     */
    var Rectangle = (function () {
        /**
         *创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度（以像素为单位）
         * @param height 矩形的高度（以像素为单位）。
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        var d = __define,c=Rectangle,p=c.prototype;
        return Rectangle;
    }());
    dragonBones.Rectangle = Rectangle;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Timeline
     * @classdesc
     * 保存时间轴相关的数据，包括关键帧，持续时间，时间缩放
     */
    var Timeline = (function () {
        /**
         * 初始化数据duration为0，scale为1
         */
        function Timeline() {
            /**
             * 持续时间，单位是帧
             * @member {number} dragonBones.Timeline#duration
             */
            this.duration = 0;
            this._frameList = [];
            this.duration = 0;
            this.scale = 1;
        }
        var d = __define,c=Timeline,p=c.prototype;
        p.dispose = function () {
            var i = this._frameList.length;
            while (i--) {
                this._frameList[i].dispose();
            }
            this._frameList = null;
        };
        /**
         * 添加一个关键帧数据
         * @param frame 关键帧数据
         * @see extension.dragonbones.model.Frame
         */
        p.addFrame = function (frame) {
            if (!frame) {
                throw new Error();
            }
            if (this._frameList.indexOf(frame) < 0) {
                this._frameList[this._frameList.length] = frame;
            }
            else {
                throw new Error();
            }
        };
        d(p, "frameList"
            /**
             * 获取关键帧列表
             * @returns {Array<Frame>}
             */
            ,function () {
                return this._frameList;
            }
        );
        return Timeline;
    }());
    dragonBones.Timeline = Timeline;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonbones.AnimationData
     * @extends dragonbones.Timeline
     * @classdesc
     * 保存动画数据
     */
    var AnimationData = (function (_super) {
        __extends(AnimationData, _super);
        /**
         * 创建一个AnimationData实例
         */
        function AnimationData() {
            _super.call(this);
            /**
             * 动画的帧率，表示每一秒钟播放多少帧
             * @member {number} dragonBones.AnimationData#frameRate
             */
            this.frameRate = 0;
            /**
             * 	播放次数 0为一直播放，默认为0
             * @member {number} dragonBones.AnimationData#playTimes
             */
            this.playTimes = 0;
            /**
             * 最后一帧持续的帧数
             * @member {number} dragonBones.AnimationData#lastFrameDuration
             */
            this.lastFrameDuration = 0;
            this.fadeTime = 0;
            this.playTimes = 0;
            this.autoTween = true;
            this.tweenEasing = NaN;
            this.hideTimelineNameMap = [];
            this.hideSlotTimelineNameMap = [];
            this._timelineList = [];
            this._slotTimelineList = [];
        }
        var d = __define,c=AnimationData,p=c.prototype;
        d(p, "timelineList"
            /**
             * 时间轴列表
             * @returns {Array<TransformTimeline>}
             */
            ,function () {
                return this._timelineList;
            }
        );
        d(p, "slotTimelineList"
            ,function () {
                return this._slotTimelineList;
            }
        );
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.hideTimelineNameMap = null;
            var i = 0;
            var len = 0;
            for (i = 0, len = this._timelineList.length; i < len; i++) {
                var timeline = this._timelineList[i];
                timeline.dispose();
            }
            this._timelineList = null;
            for (i = 0, len = this._slotTimelineList.length; i < len; i++) {
                var slotTimeline = this._slotTimelineList[i];
                slotTimeline.dispose();
            }
            this._slotTimelineList = null;
        };
        /**
         * 根据时间轴的名字获取时间轴数据
         * @param timelineName 时间轴的名字
         * @returns {*} 时间轴数据
         */
        p.getTimeline = function (timelineName) {
            var i = this._timelineList.length;
            while (i--) {
                if (this._timelineList[i].name == timelineName) {
                    return this._timelineList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个时间轴数据
         * @param timeline 需要被添加的时间轴数据
         */
        p.addTimeline = function (timeline) {
            if (!timeline) {
                throw new Error();
            }
            if (this._timelineList.indexOf(timeline) < 0) {
                this._timelineList[this._timelineList.length] = timeline;
            }
        };
        p.getSlotTimeline = function (timelineName) {
            var i = this._slotTimelineList.length;
            while (i--) {
                if (this._slotTimelineList[i].name == timelineName) {
                    return this._slotTimelineList[i];
                }
            }
            return null;
        };
        p.addSlotTimeline = function (timeline) {
            if (!timeline) {
                throw new Error();
            }
            if (this._slotTimelineList.indexOf(timeline) < 0) {
                this._slotTimelineList[this._slotTimelineList.length] = timeline;
            }
        };
        return AnimationData;
    }(dragonBones.Timeline));
    dragonBones.AnimationData = AnimationData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ArmatureData
     * @classdesc
     * armature数据 一个armature数据包含一个角色的骨骼，皮肤，动画的数据
     * @see  dragonBones.BoneData
     * @see  dragonBones.SkinData
     * @see  dragonBones.AnimationData
     */
    var ArmatureData = (function () {
        /**
         * 创建一个ArmatureData实例
         */
        function ArmatureData() {
            this._boneDataList = [];
            this._ikDataList = [];
            this._skinDataList = [];
            this._slotDataList = [];
            this._animationDataList = [];
            //_areaDataList = new Vector.<IAreaData>(0, true);
        }
        var d = __define,c=ArmatureData,p=c.prototype;
        ArmatureData.sortBoneDataHelpArray = function (object1, object2) {
            return object1[0] > object2[0] ? 1 : -1;
        };
        ArmatureData.sortBoneDataHelpArrayDescending = function (object1, object2) {
            return object1[0] > object2[0] ? -1 : 1;
        };
        p.setSkinData = function (skinName) {
            var i = 0;
            var len = this._slotDataList.length;
            for (i = 0; i < len; i++) {
                this._slotDataList[i].dispose();
            }
            var skinData;
            if (!skinName && this._skinDataList.length > 0) {
                skinData = this._skinDataList[0];
            }
            else {
                i = 0,
                    len = this._skinDataList.length;
                for (; i < len; i++) {
                    if (this._skinDataList[i].name == skinName) {
                        skinData = this._skinDataList[i];
                        break;
                    }
                }
            }
            if (skinData) {
                var slotData;
                i = 0, len = skinData.slotDataList.length;
                for (i = 0; i < len; i++) {
                    slotData = this.getSlotData(skinData.slotDataList[i].name);
                    if (slotData) {
                        var j = 0;
                        var jLen = skinData.slotDataList[i].displayDataList.length;
                        for (j = 0; j < jLen; j++) {
                            slotData.addDisplayData(skinData.slotDataList[i].displayDataList[j]);
                        }
                    }
                }
            }
        };
        /**
         * 释放资源
         */
        p.dispose = function () {
            var i = this._boneDataList.length;
            while (i--) {
                this._boneDataList[i].dispose();
            }
            i = this._ikDataList.length;
            while (i--) {
                this._ikDataList[i].dispose();
            }
            i = this._skinDataList.length;
            while (i--) {
                this._skinDataList[i].dispose();
            }
            i = this._slotDataList.length;
            while (i--) {
                this._slotDataList[i].dispose();
            }
            i = this._animationDataList.length;
            while (i--) {
                this._animationDataList[i].dispose();
            }
            this._boneDataList = null;
            this._ikDataList = null;
            this._slotDataList = null;
            this._skinDataList = null;
            this._animationDataList = null;
        };
        /**
         * 根据骨骼的名字获取到骨骼数据
         * @param boneName 骨骼的名字
         * @returns {*} 骨骼数据
         */
        p.getBoneData = function (boneName) {
            var i = this._boneDataList.length;
            while (i--) {
                if (this._boneDataList[i].name == boneName) {
                    return this._boneDataList[i];
                }
            }
            return null;
        };
        p.getIKData = function (ikName) {
            var i = this._ikDataList.length;
            while (i--) {
                if (this._ikDataList[i].name == ikName) {
                    return this._ikDataList[i];
                }
            }
            return null;
        };
        p.getSlotData = function (slotName) {
            var i = this._slotDataList.length;
            while (i--) {
                if (this._slotDataList[i].name == slotName) {
                    return this._slotDataList[i];
                }
            }
            return null;
        };
        /**
         * 根据皮肤的名字获取到皮肤数据
         * @param skinName  皮肤的名字
         * @returns {*}  皮肤数据
         */
        p.getSkinData = function (skinName) {
            if (!skinName && this._skinDataList.length > 0) {
                return this._skinDataList[0];
            }
            var i = this._skinDataList.length;
            while (i--) {
                if (this._skinDataList[i].name == skinName) {
                    return this._skinDataList[i];
                }
            }
            return null;
        };
        /**
         * 根据动画的名字获取动画数据
         * @param animationName 动画的名字
         * @returns {*} 动画数据
         */
        p.getAnimationData = function (animationName) {
            var i = this._animationDataList.length;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    return this._animationDataList[i];
                }
            }
            return null;
        };
        /**
         *添加一个骨骼数据
         * @param boneData
         */
        p.addBoneData = function (boneData) {
            if (!boneData) {
                throw new Error();
            }
            if (this._boneDataList.indexOf(boneData) < 0) {
                this._boneDataList[this._boneDataList.length] = boneData;
            }
            else {
                throw new Error();
            }
        };
        p.addIKData = function (ikData) {
            if (!ikData) {
                throw new Error();
            }
            if (this._ikDataList.indexOf(ikData) < 0) {
                this._ikDataList[this._ikDataList.length] = ikData;
            }
            else {
                throw new Error();
            }
        };
        p.addSlotData = function (slotData) {
            if (!slotData) {
                throw new Error();
            }
            if (this._slotDataList.indexOf(slotData) < 0) {
                this._slotDataList[this._slotDataList.length] = slotData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 添加一个皮肤数据
         * @param skinData
         */
        p.addSkinData = function (skinData) {
            if (!skinData) {
                throw new Error();
            }
            if (this._skinDataList.indexOf(skinData) < 0) {
                this._skinDataList[this._skinDataList.length] = skinData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 添加一个动画数据
         * @param animationData
         */
        p.addAnimationData = function (animationData) {
            if (!animationData) {
                throw new Error();
            }
            if (this._animationDataList.indexOf(animationData) < 0) {
                this._animationDataList[this._animationDataList.length] = animationData;
            }
        };
        /**
         * 对骨骼按照骨骼数的层级关系排序
         */
        p.sortBoneDataList = function () {
            var i = this._boneDataList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var boneData = this._boneDataList[i];
                var level = 0;
                var parentData = boneData;
                while (parentData) {
                    level++;
                    parentData = this.getBoneData(parentData.parent);
                }
                helpArray[i] = [level, boneData];
            }
            helpArray.sort(ArmatureData.sortBoneDataHelpArray);
            i = helpArray.length;
            while (i--) {
                this._boneDataList[i] = helpArray[i][1];
            }
        };
        d(p, "boneDataList"
            /**
             * 获取骨骼数据列表
             * @returns {Array<BoneData>}
             */
            ,function () {
                return this._boneDataList;
            }
        );
        d(p, "ikDataList"
            ,function () {
                return this._ikDataList;
            }
        );
        d(p, "slotDataList"
            ,function () {
                return this._slotDataList;
            }
        );
        d(p, "skinDataList"
            /**
             * 获取皮肤数据列表
             * @returns {Array<SkinData>}
             */
            ,function () {
                return this._skinDataList;
            }
        );
        d(p, "animationDataList"
            /**
             * 获得动画数据列表
             * @returns {Array<AnimationData>}
             */
            ,function () {
                return this._animationDataList;
            }
        );
        return ArmatureData;
    }());
    dragonBones.ArmatureData = ArmatureData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.BoneData
     * @classdesc
     * 骨骼数据
     */
    var BoneData = (function () {
        /**
         * 初始化各个属性
         */
        function BoneData() {
            this.length = 0;
            this.global = new dragonBones.DBTransform();
            this.transform = new dragonBones.DBTransform();
            this.inheritRotation = true;
            this.inheritScale = false;
        }
        var d = __define,c=BoneData,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            this.global = null;
            this.transform = null;
        };
        return BoneData;
    }());
    dragonBones.BoneData = BoneData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ColorTransform
     * @classdesc
     * 表示颜色的transform
     */
    var ColorTransform = (function () {
        function ColorTransform() {
            this.alphaMultiplier = 1;
            this.alphaOffset = 0;
            this.blueMultiplier = 1;
            this.blueOffset = 0;
            this.greenMultiplier = 1;
            this.greenOffset = 0;
            this.redMultiplier = 1;
            this.redOffset = 0;
        }
        var d = __define,c=ColorTransform,p=c.prototype;
        return ColorTransform;
    }());
    dragonBones.ColorTransform = ColorTransform;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var CurveData = (function () {
        function CurveData() {
            this._dataChanged = false;
            this._pointList = [];
            this.sampling = new Array(CurveData.SamplingTimes);
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                this.sampling[i] = new dragonBones.Point();
            }
        }
        var d = __define,c=CurveData,p=c.prototype;
        p.getValueByProgress = function (progress) {
            if (this._dataChanged) {
                this.refreshSampling();
            }
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                var point = this.sampling[i];
                if (point.x >= progress) {
                    if (i == 0) {
                        return point.y * progress / point.x;
                    }
                    else {
                        var prevPoint = this.sampling[i - 1];
                        return prevPoint.y + (point.y - prevPoint.y) * (progress - prevPoint.x) / (point.x - prevPoint.x);
                    }
                }
            }
            return point.y + (1 - point.y) * (progress - point.x) / (1 - point.x);
        };
        p.refreshSampling = function () {
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                this.bezierCurve(CurveData.SamplingStep * (i + 1), this.sampling[i]);
            }
            this._dataChanged = false;
        };
        p.bezierCurve = function (t, outputPoint) {
            var l_t = 1 - t;
            outputPoint.x = 3 * this.point1.x * t * l_t * l_t + 3 * this.point2.x * t * t * l_t + Math.pow(t, 3);
            outputPoint.y = 3 * this.point1.y * t * l_t * l_t + 3 * this.point2.y * t * t * l_t + Math.pow(t, 3);
        };
        d(p, "pointList"
            ,function () {
                return this._pointList;
            }
            ,function (value) {
                this._pointList = value;
                this._dataChanged = true;
            }
        );
        p.isCurve = function () {
            return this.point1.x != 0 || this.point1.y != 0 || this.point2.x != 1 || this.point2.y != 1;
        };
        d(p, "point1"
            ,function () {
                return this.pointList[0];
            }
        );
        d(p, "point2"
            ,function () {
                return this.pointList[1];
            }
        );
        CurveData.SamplingTimes = 20;
        CurveData.SamplingStep = 0.05;
        return CurveData;
    }());
    dragonBones.CurveData = CurveData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DisplayData
     * @classdesc
     * 显示对象的数据，目前支持图片和子骨架
     */
    var DisplayData = (function () {
        /**
         * 初始化变换矩阵为单位矩阵
         * 注册点为{0，0}点
         */
        function DisplayData() {
            this.transform = new dragonBones.DBTransform();
            this.pivot = new dragonBones.Point();
        }
        var d = __define,c=DisplayData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            this.transform = null;
            this.pivot = null;
        };
        /**
         * 子骨架类型
         */
        DisplayData.ARMATURE = "armature";
        /**
         * 图片类型
         */
        DisplayData.IMAGE = "image";
        return DisplayData;
    }());
    dragonBones.DisplayData = DisplayData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DragonBonesData
     * @classdesc
     * DragonBones的数据，包含了骨架数据和显示对象数据
     */
    var DragonBonesData = (function () {
        /**
         * 构造函数，实例化一个DragonBonesData类
         */
        function DragonBonesData() {
            /**
             * 数据版本
             */
            this.version = 0;
            this._armatureDataList = [];
            this._displayDataDictionary = {};
        }
        var d = __define,c=DragonBonesData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            for (var i = 0, len = this._armatureDataList.length; i < len; i++) {
                var armatureData = this._armatureDataList[i];
                armatureData.dispose();
            }
            this._armatureDataList = null;
            this.removeAllDisplayData();
            this._displayDataDictionary = null;
        };
        d(p, "armatureDataList"
            /**
             * 获取所有的骨架数据
             * @returns {Array<ArmatureData>}
             */
            ,function () {
                return this._armatureDataList;
            }
        );
        /**
         * 通过骨架的名字获取骨架的数据
         * @param armatureName 想要获取的骨架的名字
         * @returns {*} 骨架数据 ArmatureData
         */
        p.getArmatureDataByName = function (armatureName) {
            var i = this._armatureDataList.length;
            while (i--) {
                if (this._armatureDataList[i].name == armatureName) {
                    return this._armatureDataList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个骨架数据
         * @param armatureData
         */
        p.addArmatureData = function (armatureData) {
            if (!armatureData) {
                throw new Error();
            }
            if (this._armatureDataList.indexOf(armatureData) < 0) {
                this._armatureDataList[this._armatureDataList.length] = armatureData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 移除一个骨架数据
         * @param armatureData
         */
        p.removeArmatureData = function (armatureData) {
            var index = this._armatureDataList.indexOf(armatureData);
            if (index >= 0) {
                this._armatureDataList.splice(index, 1);
            }
        };
        /**
         * 根据骨架的名字，移除该骨架的数据
         * @param armatureName 想要移除的骨架的名字
         */
        p.removeArmatureDataByName = function (armatureName) {
            var i = this._armatureDataList.length;
            while (i--) {
                if (this._armatureDataList[i].name == armatureName) {
                    this._armatureDataList.splice(i, 1);
                }
            }
        };
        /**
         * 根据名字获取显示对象数据
         * @param name 想要获取的显示对象数据的名字
         * @returns {any} 显示对象数据 DisplayData
         */
        p.getDisplayDataByName = function (name) {
            return this._displayDataDictionary[name];
        };
        /**
         *添加一个显示对象数据
         * @param displayData 需要被添加的显示对象数据
         */
        p.addDisplayData = function (displayData) {
            this._displayDataDictionary[displayData.name] = displayData;
        };
        /**
         *根据显示对象的名字移除该显示对象数据
         * @param name 显示对象的名字
         */
        p.removeDisplayDataByName = function (name) {
            delete this._displayDataDictionary[name];
        };
        /**
         *移除所有的显示对象数据
         */
        p.removeAllDisplayData = function () {
            for (var name in this._displayDataDictionary) {
                delete this._displayDataDictionary[name];
            }
        };
        return DragonBonesData;
    }());
    dragonBones.DragonBonesData = DragonBonesData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Frame
     * @classdesc
     *关键帧数据
     */
    var Frame = (function () {
        /**
         *构造函数
         */
        function Frame() {
            /**
             *位置
             * @member {number} dragonBones.Frame#position
             */
            this.position = 0;
            /**
             *持续时间
             * @member {number} dragonBones.Frame#duration
             */
            this.duration = 0;
            this.position = 0;
            this.duration = 0;
        }
        var d = __define,c=Frame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
        };
        return Frame;
    }());
    dragonBones.Frame = Frame;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var IKData = (function () {
        function IKData() {
        }
        var d = __define,c=IKData,p=c.prototype;
        p.constructora = function () {
        };
        p.dispose = function () {
        };
        return IKData;
    }());
    dragonBones.IKData = IKData;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * optimized by freem-trg
     * Intermediate class for store the results of the parent transformation
     */
    var ParentTransformObject = (function () {
        function ParentTransformObject() {
        }
        var d = __define,c=ParentTransformObject,p=c.prototype;
        /// Method to set properties after its creation/pooling
        p.setTo = function (parentGlobalTransform, parentGlobalTransformMatrix) {
            this.parentGlobalTransform = parentGlobalTransform;
            this.parentGlobalTransformMatrix = parentGlobalTransformMatrix;
            return this;
        };
        /// Cleanup object and return it to the object pool
        p.release = function () {
            ParentTransformObject.dispose(this);
        };
        /// Create/take new clean object from the object pool
        ParentTransformObject.create = function () {
            if (ParentTransformObject._poolSize > 0) {
                ParentTransformObject._poolSize--;
                return ParentTransformObject._pool.pop();
            }
            return new ParentTransformObject();
        };
        /// Cleanup object and return it to the object pool
        ParentTransformObject.dispose = function (parentTransformObject) {
            parentTransformObject.parentGlobalTransform = null;
            parentTransformObject.parentGlobalTransformMatrix = null;
            ParentTransformObject._pool[ParentTransformObject._poolSize++] = parentTransformObject;
        };
        /// Object pool to reduce GC load
        ParentTransformObject._pool = [];
        ParentTransformObject._poolSize = 0;
        return ParentTransformObject;
    }());
    dragonBones.ParentTransformObject = ParentTransformObject;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SkinData
     * @classdesc
     * 皮肤数据，皮肤是由一些插槽组成，每个插槽都有一个骨骼控制，骨骼的运动带动插槽的运动形成动画，
     * 插槽里可以放置显示对象，目前支持的显示对象有图片和子骨架两种
     */
    var SkinData = (function () {
        /**
         * 构造函数，实例化一个SkinData类
         */
        function SkinData() {
            this._slotDataList = [];
        }
        var d = __define,c=SkinData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            var i = this._slotDataList.length;
            while (i--) {
                this._slotDataList[i].dispose();
            }
            this._slotDataList = null;
        };
        /**
         * 根据插槽的名字获取插槽数据
         * @param slotName 想要获取的插槽的名字
         * @returns {*} 返回的插槽数据
         */
        p.getSlotData = function (slotName) {
            var i = this._slotDataList.length;
            while (i--) {
                if (this._slotDataList[i].name == slotName) {
                    return this._slotDataList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个插槽数据
         * @param slotData
         */
        p.addSlotData = function (slotData) {
            if (!slotData) {
                throw new Error();
            }
            if (this._slotDataList.indexOf(slotData) < 0) {
                this._slotDataList[this._slotDataList.length] = slotData;
            }
            else {
                throw new Error();
            }
        };
        d(p, "slotDataList"
            /**
             * 获取所有的插槽数据
             * @returns {Array<SlotData>}
             */
            ,function () {
                return this._slotDataList;
            }
        );
        return SkinData;
    }());
    dragonBones.SkinData = SkinData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotData
     * @classdesc
     * 插槽数据，插槽是由骨骼控制的，可以装入显示对象的容器，显示对象可以是图片或者子骨架
     * 插槽可插入一个或者多个显示对象，但是同一时刻只能显示一个显示对象
     * 插槽支持关键帧动画，如果有多个显示对象，可以指定哪一帧显示哪一个显示对象
     */
    var SlotData = (function () {
        /**
         * 构造函数，实例化一个SlotData类
         */
        function SlotData() {
            this._displayDataList = [];
            this.zOrder = 0;
        }
        var d = __define,c=SlotData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            this._displayDataList.length = 0;
        };
        /**
         * 添加一个显示对象数据
         * @param displayData
         */
        p.addDisplayData = function (displayData) {
            if (!displayData) {
                throw new Error();
            }
            if (this._displayDataList.indexOf(displayData) < 0) {
                this._displayDataList[this._displayDataList.length] = displayData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 根据显示对象的名字获取显示对象数据
         * @param displayName 想要获取的显示对象的名字
         * @returns {*} 返回显示对象昂数据，如果没有返回null
         */
        p.getDisplayData = function (displayName) {
            var i = this._displayDataList.length;
            while (i--) {
                if (this._displayDataList[i].name == displayName) {
                    return this._displayDataList[i];
                }
            }
            return null;
        };
        d(p, "displayDataList"
            /**
             * 获取所有的显示对象
             * @returns {Array<DisplayData>}
             */
            ,function () {
                return this._displayDataList;
            }
        );
        return SlotData;
    }());
    dragonBones.SlotData = SlotData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotFrame
     * @extends dragonBones.Frame
     * @classdesc
     * 插槽的关键帧数据，包含
     * 插槽的显示序号，可见度，zOrder，colorTransform数据
     */
    var SlotFrame = (function (_super) {
        __extends(SlotFrame, _super);
        /**
         *构造函数，实例化一个SlotFrame
         */
        function SlotFrame() {
            _super.call(this);
            /**
             *绑定到该插槽的显示序号，当插槽有多个显示对象时，指定显示哪一个显示对象
             * @member {number} dragonBones.SlotFrame#displayIndex
             */
            this.displayIndex = 0;
            this.tweenEasing = 10;
            this.displayIndex = 0;
            this.visible = true;
            this.zOrder = NaN;
        }
        var d = __define,c=SlotFrame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.color = null;
        };
        return SlotFrame;
    }(dragonBones.Frame));
    dragonBones.SlotFrame = SlotFrame;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimeline
     * @extends dragonBones.Timeline
     * @classdesc
     * 插槽的时间轴数据，包含一个和多个关键帧数据
     */
    var SlotTimeline = (function (_super) {
        __extends(SlotTimeline, _super);
        /**
         * 构造函数，实例化一个SlotTimeline
         */
        function SlotTimeline() {
            _super.call(this);
            this.offset = 0;
        }
        var d = __define,c=SlotTimeline,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return SlotTimeline;
    }(dragonBones.Timeline));
    dragonBones.SlotTimeline = SlotTimeline;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformFrame
     * @extends dragonBones.Frame
     * @classdesc
     * 骨骼的关键帧数据，包含骨骼的缓动，旋转，transform数据和
     * 插槽的显示序号，可见度，zOrder，colorTransform数据
     */
    var TransformFrame = (function (_super) {
        __extends(TransformFrame, _super);
        /**
         *构造函数，实例化一个TransformFrame
         */
        function TransformFrame() {
            _super.call(this);
            /**
             * 旋转几圈
             * @member {number} dragonBones.TransformFrame#tweenRotate
             */
            this.tweenRotate = 0;
            /**
             *绑定到该骨骼的插槽的显示序号，当插槽有多个显示对象时，指定显示哪一个显示对象
             * @member {number} dragonBones.TransformFrame#displayIndex
             */
            this.displayIndex = 0;
            this.tweenEasing = 10;
            this.tweenRotate = 0;
            this.tweenScale = true;
            this.displayIndex = 0;
            this.visible = true;
            this.zOrder = NaN;
            this.global = new dragonBones.DBTransform();
            this.transform = new dragonBones.DBTransform();
            this.pivot = new dragonBones.Point();
            this.scaleOffset = new dragonBones.Point();
        }
        var d = __define,c=TransformFrame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.global = null;
            this.transform = null;
            this.pivot = null;
            this.scaleOffset = null;
            this.color = null;
        };
        return TransformFrame;
    }(dragonBones.Frame));
    dragonBones.TransformFrame = TransformFrame;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformTimeline
     * @extends dragonBones.Timeline
     * @classdesc
     * 骨骼的时间轴数据，包含一个和多个关键帧数据
     */
    var TransformTimeline = (function (_super) {
        __extends(TransformTimeline, _super);
        /**
         * 构造函数，实例化一个TransformTimeline
         */
        function TransformTimeline() {
            _super.call(this);
            this.originTransform = new dragonBones.DBTransform();
            this.originTransform.scaleX = 1;
            this.originTransform.scaleY = 1;
            this.originPivot = new dragonBones.Point();
            this.offset = 0;
        }
        var d = __define,c=TransformTimeline,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.originTransform = null;
            this.originPivot = null;
        };
        return TransformTimeline;
    }(dragonBones.Timeline));
    dragonBones.TransformTimeline = TransformTimeline;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *@class dragonBones.DataParser
     * @classdesc
     * 老版本数据解析
     */
    var Data3Parser = (function () {
        function Data3Parser() {
        }
        var d = __define,c=Data3Parser,p=c.prototype;
        Data3Parser.parseDragonBonesData = function (rawDataToParse) {
            if (!rawDataToParse) {
                throw new Error();
            }
            var version = rawDataToParse[dragonBones.ConstValues.A_VERSION];
            version = version.toString();
            if (version.toString() != dragonBones.DragonBones.DATA_VERSION &&
                version.toString() != dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION &&
                version.toString() != "2.3") {
                throw new Error("Nonsupport version!");
            }
            var frameRate = Data3Parser.getNumber(rawDataToParse, dragonBones.ConstValues.A_FRAME_RATE, 0) || 0;
            var outputDragonBonesData = new dragonBones.DragonBonesData();
            outputDragonBonesData.name = rawDataToParse[dragonBones.ConstValues.A_NAME];
            outputDragonBonesData.isGlobal = rawDataToParse[dragonBones.ConstValues.A_IS_GLOBAL] == "0" ? false : true;
            Data3Parser.tempDragonBonesData = outputDragonBonesData;
            var armatureList = rawDataToParse[dragonBones.ConstValues.ARMATURE];
            for (var i = 0, len = armatureList.length; i < len; i++) {
                var armatureObject = armatureList[i];
                outputDragonBonesData.addArmatureData(Data3Parser.parseArmatureData(armatureObject, frameRate));
            }
            Data3Parser.tempDragonBonesData = null;
            return outputDragonBonesData;
        };
        Data3Parser.parseArmatureData = function (armatureDataToParse, frameRate) {
            var outputArmatureData = new dragonBones.ArmatureData();
            outputArmatureData.name = armatureDataToParse[dragonBones.ConstValues.A_NAME];
            var i;
            var len;
            var boneList = armatureDataToParse[dragonBones.ConstValues.BONE];
            for (i = 0, len = boneList.length; i < len; i++) {
                var boneObject = boneList[i];
                outputArmatureData.addBoneData(Data3Parser.parseBoneData(boneObject));
            }
            var skinList = armatureDataToParse[dragonBones.ConstValues.SKIN];
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinSlotList = skinList[i];
                var skinSlotObject = skinSlotList[dragonBones.ConstValues.SLOT];
                for (var j = 0, jLen = skinSlotObject.length; j < jLen; j++) {
                    var slotObject = skinSlotObject[j];
                    outputArmatureData.addSlotData(Data3Parser.parseSlotData(slotObject));
                }
            }
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinObject = skinList[i];
                outputArmatureData.addSkinData(Data3Parser.parseSkinData(skinObject));
            }
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                dragonBones.DBDataUtil.transformArmatureData(outputArmatureData);
            }
            outputArmatureData.sortBoneDataList();
            var animationList = armatureDataToParse[dragonBones.ConstValues.ANIMATION];
            for (i = 0, len = animationList.length; i < len; i++) {
                var animationObject = animationList[i];
                var animationData = Data3Parser.parseAnimationData(animationObject, frameRate);
                dragonBones.DBDataUtil.addHideTimeline(animationData, outputArmatureData);
                dragonBones.DBDataUtil.transformAnimationData(animationData, outputArmatureData, Data3Parser.tempDragonBonesData.isGlobal);
                outputArmatureData.addAnimationData(animationData);
            }
            return outputArmatureData;
        };
        //把bone的初始transform解析并返回
        Data3Parser.parseBoneData = function (boneObject) {
            var boneData = new dragonBones.BoneData();
            boneData.name = boneObject[dragonBones.ConstValues.A_NAME];
            boneData.parent = boneObject[dragonBones.ConstValues.A_PARENT];
            boneData.length = Number(boneObject[dragonBones.ConstValues.A_LENGTH]) || 0;
            boneData.inheritRotation = Data3Parser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_ROTATION, true);
            boneData.inheritScale = Data3Parser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_SCALE, true);
            Data3Parser.parseTransform(boneObject[dragonBones.ConstValues.TRANSFORM], boneData.transform);
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                boneData.global.copy(boneData.transform);
            }
            return boneData;
        };
        Data3Parser.parseSkinData = function (skinObject) {
            var skinData = new dragonBones.SkinData();
            skinData.name = skinObject[dragonBones.ConstValues.A_NAME];
            var slotList = skinObject[dragonBones.ConstValues.SLOT];
            for (var i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                skinData.addSlotData(Data3Parser.parseSkinSlotData(slotObject));
            }
            return skinData;
        };
        Data3Parser.parseSkinSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = (slotObject[dragonBones.ConstValues.A_Z_ORDER]);
            slotData.zOrder = Data3Parser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            var displayList = slotObject[dragonBones.ConstValues.DISPLAY];
            if (displayList) {
                for (var i = 0, len = displayList.length; i < len; i++) {
                    var displayObject = displayList[i];
                    slotData.addDisplayData(Data3Parser.parseDisplayData(displayObject));
                }
            }
            return slotData;
        };
        Data3Parser.parseSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = (slotObject[dragonBones.ConstValues.A_Z_ORDER]);
            slotData.zOrder = Data3Parser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            slotData.displayIndex = 0;
            return slotData;
        };
        Data3Parser.parseDisplayData = function (displayObject) {
            var displayData = new dragonBones.DisplayData();
            displayData.name = displayObject[dragonBones.ConstValues.A_NAME];
            displayData.type = displayObject[dragonBones.ConstValues.A_TYPE];
            Data3Parser.parseTransform(displayObject[dragonBones.ConstValues.TRANSFORM], displayData.transform, displayData.pivot);
            if (Data3Parser.tempDragonBonesData != null) {
                Data3Parser.tempDragonBonesData.addDisplayData(displayData);
            }
            return displayData;
        };
        /** @private */
        Data3Parser.parseAnimationData = function (animationObject, frameRate) {
            var animationData = new dragonBones.AnimationData();
            animationData.name = animationObject[dragonBones.ConstValues.A_NAME];
            animationData.frameRate = frameRate;
            animationData.duration = Math.round((Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_DURATION, 1) || 1) * 1000 / frameRate);
            animationData.playTimes = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_LOOP, 1);
            animationData.playTimes = animationData.playTimes != NaN ? animationData.playTimes : 1;
            animationData.fadeTime = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_FADE_IN_TIME, 0) || 0;
            animationData.scale = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            //use frame tweenEase, NaN
            //overwrite frame tweenEase, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            animationData.tweenEasing = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_TWEEN_EASING, NaN);
            animationData.autoTween = Data3Parser.getBoolean(animationObject, dragonBones.ConstValues.A_AUTO_TWEEN, true);
            var frameObjectList = animationObject[dragonBones.ConstValues.FRAME];
            var i = 0;
            var len = 0;
            if (frameObjectList) {
                for (i = 0, len = frameObjectList.length; i < len; i++) {
                    var frameObject = frameObjectList[i];
                    var frame = Data3Parser.parseTransformFrame(frameObject, null, frameRate);
                    animationData.addFrame(frame);
                }
            }
            Data3Parser.parseTimeline(animationObject, animationData);
            var lastFrameDuration = animationData.duration;
            var displayIndexChangeSlotTimelines = [];
            var displayIndexChangeTimelines = [];
            var timelineObjectList = animationObject[dragonBones.ConstValues.TIMELINE];
            var displayIndexChange;
            if (timelineObjectList) {
                for (i = 0, len = timelineObjectList.length; i < len; i++) {
                    var timelineObject = timelineObjectList[i];
                    var timeline = Data3Parser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                    timeline = Data3Parser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                    lastFrameDuration = Math.min(lastFrameDuration, timeline.frameList[timeline.frameList.length - 1].duration);
                    animationData.addTimeline(timeline);
                    var slotTimeline = Data3Parser.parseSlotTimeline(timelineObject, animationData.duration, frameRate);
                    animationData.addSlotTimeline(slotTimeline);
                    if (animationData.autoTween && !displayIndexChange) {
                        var slotFrame;
                        for (var j = 0, jlen = slotTimeline.frameList.length; j < jlen; j++) {
                            slotFrame = slotTimeline.frameList[j];
                            if (slotFrame && slotFrame.displayIndex < 0) {
                                displayIndexChange = true;
                                break;
                            }
                        }
                    }
                }
                /**
                 * 如果有slot的displayIndex为空的情况，那么当autoTween为ture时，它对应的bone的补间应该去掉
                 * 以下就是处理这种情况，把autoTween的全局的tween应用到每一帧上，然后把autoTween变为false
                 * 此时autoTween就不起任何作用了
                 */
                var animationTween = animationData.tweenEasing;
                if (displayIndexChange) {
                    len = animationData.slotTimelineList.length;
                    for (i = 0; i < len; i++) {
                        slotTimeline = animationData.slotTimelineList[i];
                        timeline = animationData.timelineList[i];
                        var curFrame;
                        var curSlotFrame;
                        var nextSlotFrame;
                        for (j = 0, jlen = slotTimeline.frameList.length; j < jlen; j++) {
                            curSlotFrame = slotTimeline.frameList[j];
                            curFrame = timeline.frameList[j];
                            nextSlotFrame = (j == jlen - 1) ? slotTimeline.frameList[0] : slotTimeline.frameList[j + 1];
                            if (curSlotFrame.displayIndex < 0 || nextSlotFrame.displayIndex < 0) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = NaN;
                            }
                            else if (animationTween == 10) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = 0;
                            }
                            else if (!isNaN(animationTween)) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = animationTween;
                            }
                            else if (curFrame.tweenEasing == 10) {
                                curFrame.tweenEasing = 0;
                            }
                        }
                    }
                    animationData.autoTween = false;
                }
            }
            if (animationData.frameList.length > 0) {
                lastFrameDuration = Math.min(lastFrameDuration, animationData.frameList[animationData.frameList.length - 1].duration);
            }
            //取得timeline中最小的lastFrameDuration并保存
            animationData.lastFrameDuration = lastFrameDuration;
            return animationData;
        };
        Data3Parser.parseSlotTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.SlotTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = Data3Parser.parseSlotFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            Data3Parser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        Data3Parser.parseSlotFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.SlotFrame();
            Data3Parser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.displayIndex = Math.floor(Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            //如果为NaN，则说明没有改变过zOrder
            outputFrame.zOrder = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_Z_ORDER, Data3Parser.tempDragonBonesData.isGlobal ? NaN : 0);
            var colorTransformObject = frameObject[dragonBones.ConstValues.COLOR_TRANSFORM];
            if (colorTransformObject) {
                outputFrame.color = new dragonBones.ColorTransform();
                Data3Parser.parseColorTransform(colorTransformObject, outputFrame.color);
            }
            return outputFrame;
        };
        Data3Parser.parseTransformTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.TransformTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.originPivot.x = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
            outputTimeline.originPivot.y = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            var nextFrameObject;
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                if (i < len - 1) {
                    nextFrameObject = frameList[i + 1];
                }
                else if (i != 0) {
                    nextFrameObject = frameList[0];
                }
                else {
                    nextFrameObject = null;
                }
                var frame = Data3Parser.parseTransformFrame(frameObject, nextFrameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            Data3Parser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        Data3Parser.parseTransformFrame = function (frameObject, nextFrameObject, frameRate) {
            var outputFrame = new dragonBones.TransformFrame();
            Data3Parser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.tweenRotate = Math.floor(Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_ROTATE, 0) || 0);
            outputFrame.tweenScale = Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_TWEEN_SCALE, true);
            //outputFrame.displayIndex = Math.floor(Data3Parser.getNumber(frameObject, ConstValues.A_DISPLAY_INDEX, 0)|| 0);
            if (nextFrameObject && Math.floor(Data3Parser.getNumber(nextFrameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0) == -1) {
                outputFrame.tweenEasing = NaN;
            }
            Data3Parser.parseTransform(frameObject[dragonBones.ConstValues.TRANSFORM], outputFrame.transform, outputFrame.pivot);
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                outputFrame.global.copy(outputFrame.transform);
            }
            outputFrame.scaleOffset.x = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_X_OFFSET, 0) || 0;
            outputFrame.scaleOffset.y = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_Y_OFFSET, 0) || 0;
            return outputFrame;
        };
        Data3Parser.parseTimeline = function (timelineObject, outputTimeline) {
            var position = 0;
            var frame;
            var frameList = outputTimeline.frameList;
            for (var i = 0, len = frameList.length; i < len; i++) {
                frame = frameList[i];
                frame.position = position;
                position += frame.duration;
            }
            //防止duration计算有误差
            if (frame) {
                frame.duration = outputTimeline.duration - frame.position;
            }
        };
        Data3Parser.parseFrame = function (frameObject, outputFrame, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            outputFrame.duration = Math.round(((frameObject[dragonBones.ConstValues.A_DURATION]) || 1) * 1000 / frameRate);
            outputFrame.action = frameObject[dragonBones.ConstValues.A_ACTION];
            outputFrame.event = frameObject[dragonBones.ConstValues.A_EVENT];
            outputFrame.sound = frameObject[dragonBones.ConstValues.A_SOUND];
        };
        Data3Parser.parseTransform = function (transformObject, transform, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (transformObject) {
                if (transform) {
                    transform.x = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_X, 0) || 0;
                    transform.y = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_Y, 0) || 0;
                    transform.skewX = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_X, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.skewY = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_Y, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.scaleX = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_X, 1) || 0;
                    transform.scaleY = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_Y, 1) || 0;
                }
                if (pivot) {
                    pivot.x = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
                    pivot.y = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
                }
            }
        };
        Data3Parser.parseColorTransform = function (colorTransformObject, colorTransform) {
            if (colorTransformObject) {
                if (colorTransform) {
                    colorTransform.alphaOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_OFFSET, 0);
                    colorTransform.redOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_OFFSET, 0);
                    colorTransform.greenOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_OFFSET, 0);
                    colorTransform.blueOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_OFFSET, 0);
                    colorTransform.alphaMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_MULTIPLIER, 100) * 0.01;
                    colorTransform.redMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_MULTIPLIER, 100) * 0.01;
                    colorTransform.greenMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_MULTIPLIER, 100) * 0.01;
                    colorTransform.blueMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_MULTIPLIER, 100) * 0.01;
                }
            }
        };
        Data3Parser.getBoolean = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "0":
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return false;
                    case "1":
                    case "true":
                    default:
                        return true;
                }
            }
            return defaultValue;
        };
        Data3Parser.getNumber = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return NaN;
                    default:
                        return Number(data[key]);
                }
            }
            return defaultValue;
        };
        return Data3Parser;
    }());
    dragonBones.Data3Parser = Data3Parser;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *@class dragonBones.DataParser
     * @classdesc
     * 数据解析
     *
     * @example
       <pre>
         //获取动画数据
         var skeletonData = RES.getRes("skeleton");
         //获取纹理集数据
         var textureData = RES.getRes("textureConfig");
         //获取纹理集图片
         var texture = RES.getRes("texture");
      
         //创建一个工厂，用来创建Armature
         var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
         //把动画数据添加到工厂里
         factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
         //把纹理集数据和图片添加到工厂里
         factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
         //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
         var armatureName:string = skeletonData.armature[0].name;
         //从工厂里创建出Armature
         var armature:dragonBones.Armature = factory.buildArmature(armatureName);
         //获取装载Armature的容器
         var armatureDisplay = armature.display;
         //把它添加到舞台上
         this.addChild(armatureDisplay);
         //取得这个Armature动画列表中的第一个动画的名字
         var curAnimationName = armature.animation.animationList[0];
         //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
         //第一个参数 animationName {string} 指定播放动画的名称.
         //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
      
         //把Armature添加到心跳时钟里
         dragonBones.WorldClock.clock.add(armature);
         //心跳时钟开启
         egret.Ticker.getInstance().register(function (advancedTime) {
             dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
         }, this);
       </pre>
     */
    var DataParser = (function () {
        function DataParser() {
        }
        var d = __define,c=DataParser,p=c.prototype;
        /**
         *解析纹理集数据
         * @param rawData纹理集数据xml或者json
         * @param scale纹理资源的缩放，默认为1，不缩放
         * @returns {any}返回纹理集数据，存放TexutrueData的字典类型
         */
        DataParser.parseTextureAtlasData = function (rawData, scale) {
            if (scale === void 0) { scale = 1; }
            var textureAtlasData = {};
            var subTextureFrame;
            var subTextureList = rawData[dragonBones.ConstValues.SUB_TEXTURE];
            for (var i = 0, len = subTextureList.length; i < len; i++) {
                var subTextureObject = subTextureList[i];
                var subTextureName = subTextureObject[dragonBones.ConstValues.A_NAME];
                var subTextureRegion = new dragonBones.Rectangle();
                subTextureRegion.x = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_X, 0) / scale;
                subTextureRegion.y = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_Y, 0) / scale;
                subTextureRegion.width = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_WIDTH, 0) / scale;
                subTextureRegion.height = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_HEIGHT, 0) / scale;
                var rotated = subTextureObject[dragonBones.ConstValues.A_ROTATED] == "true";
                var frameWidth = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_WIDTH, 0) / scale;
                var frameHeight = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_HEIGHT, 0) / scale;
                if (frameWidth > 0 && frameHeight > 0) {
                    subTextureFrame = new dragonBones.Rectangle();
                    subTextureFrame.x = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_X, 0) / scale;
                    subTextureFrame.y = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_Y, 0) / scale;
                    subTextureFrame.width = frameWidth;
                    subTextureFrame.height = frameHeight;
                }
                else {
                    subTextureFrame = null;
                }
                textureAtlasData[subTextureName] = new dragonBones.TextureData(subTextureRegion, subTextureFrame, rotated);
            }
            return textureAtlasData;
        };
        /**
         * 解析DragonBones的数据，xml或者json，该数据包含了骨骼，皮肤，动画的数据
         * @param rawDataToParse DragonBones的数据，xml或者json格式
         * @returns {DragonBonesData} 返回DragonBones引擎使用的数据格式
         */
        DataParser.parseDragonBonesData = function (rawDataToParse) {
            if (!rawDataToParse) {
                throw new Error();
            }
            var version = rawDataToParse[dragonBones.ConstValues.A_VERSION];
            version = version.toString();
            if (version.toString() != dragonBones.DragonBones.DATA_VERSION &&
                version.toString() != dragonBones.DragonBones.DATA_VERSION_4_5 &&
                version.toString() != dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION &&
                version.toString() != "2.3") {
                throw new Error(egret.getString(4003));
            }
            else if (version.toString() == dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION ||
                version.toString() == "2.3") {
                return dragonBones.Data3Parser.parseDragonBonesData(rawDataToParse);
            }
            var frameRate = DataParser.getNumber(rawDataToParse, dragonBones.ConstValues.A_FRAME_RATE, 0) || 0;
            var outputDragonBonesData = new dragonBones.DragonBonesData();
            outputDragonBonesData.name = rawDataToParse[dragonBones.ConstValues.A_NAME];
            outputDragonBonesData.isGlobal = rawDataToParse[dragonBones.ConstValues.A_IS_GLOBAL] == "0" ? false : true;
            outputDragonBonesData.version = parseFloat(version);
            DataParser.tempDragonBonesData = outputDragonBonesData;
            var armatureList = rawDataToParse[dragonBones.ConstValues.ARMATURE];
            for (var i = 0, len = armatureList.length; i < len; i++) {
                var armatureObject = armatureList[i];
                outputDragonBonesData.addArmatureData(DataParser.parseArmatureData(armatureObject, frameRate));
            }
            DataParser.tempDragonBonesData = null;
            return outputDragonBonesData;
        };
        DataParser.parseArmatureData = function (armatureDataToParse, frameRate) {
            var outputArmatureData = new dragonBones.ArmatureData();
            outputArmatureData.name = armatureDataToParse[dragonBones.ConstValues.A_NAME];
            outputArmatureData.defaultAnimation = armatureDataToParse[dragonBones.ConstValues.A_DEFAULT_ANIMATION];
            outputArmatureData.frameRate = armatureDataToParse[dragonBones.ConstValues.A_FRAME_RATE];
            if (isNaN(outputArmatureData.frameRate) || outputArmatureData.frameRate <= 0) {
                outputArmatureData.frameRate = frameRate;
            }
            frameRate = outputArmatureData.frameRate;
            var boneList = armatureDataToParse[dragonBones.ConstValues.BONE];
            var i;
            var len;
            for (i = 0, len = boneList.length; i < len; i++) {
                var boneObject = boneList[i];
                outputArmatureData.addBoneData(DataParser.parseBoneData(boneObject));
            }
            var ikList = armatureDataToParse[dragonBones.ConstValues.IK];
            if (ikList) {
                for (i = 0, len = ikList.length; i < len; i++) {
                    var ikObject = ikList[i];
                    outputArmatureData.addIKData(DataParser.parseIKData(ikObject));
                }
            }
            var slotList = armatureDataToParse[dragonBones.ConstValues.SLOT];
            for (i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                outputArmatureData.addSlotData(DataParser.parseSlotData(slotObject));
            }
            var skinList = armatureDataToParse[dragonBones.ConstValues.SKIN];
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinObject = skinList[i];
                outputArmatureData.addSkinData(DataParser.parseSkinData(skinObject));
            }
            if (DataParser.tempDragonBonesData.isGlobal) {
                dragonBones.DBDataUtil.transformArmatureData(outputArmatureData);
            }
            outputArmatureData.sortBoneDataList();
            var animationList = armatureDataToParse[dragonBones.ConstValues.ANIMATION];
            for (i = 0, len = animationList.length; i < len; i++) {
                var animationObject = animationList[i];
                var animationData = DataParser.parseAnimationData(animationObject, frameRate);
                dragonBones.DBDataUtil.addHideTimeline(animationData, outputArmatureData, true);
                dragonBones.DBDataUtil.transformAnimationData(animationData, outputArmatureData, DataParser.tempDragonBonesData.isGlobal);
                outputArmatureData.addAnimationData(animationData);
            }
            return outputArmatureData;
        };
        //把bone的初始transform解析并返回
        DataParser.parseBoneData = function (boneObject) {
            var boneData = new dragonBones.BoneData();
            boneData.name = boneObject[dragonBones.ConstValues.A_NAME];
            boneData.parent = boneObject[dragonBones.ConstValues.A_PARENT];
            boneData.length = Number(boneObject[dragonBones.ConstValues.A_LENGTH]) || 0;
            boneData.inheritRotation = DataParser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_ROTATION, true);
            boneData.inheritScale = DataParser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_SCALE, true);
            DataParser.parseTransform(boneObject[dragonBones.ConstValues.TRANSFORM], boneData.transform);
            if (DataParser.tempDragonBonesData.isGlobal) {
                boneData.global.copy(boneData.transform);
            }
            return boneData;
        };
        DataParser.parseIKData = function (ikObject) {
            var ikData = new dragonBones.IKData();
            ikData.name = ikObject[dragonBones.ConstValues.A_NAME];
            ikData.target = ikObject[dragonBones.ConstValues.A_TARGET];
            if (ikObject.hasOwnProperty(dragonBones.ConstValues.A_WEIGHT)) {
                ikData.weight = Number(ikObject[dragonBones.ConstValues.A_WEIGHT]);
            }
            else {
                ikData.weight = 1;
            }
            ikData.bendPositive = DataParser.getBoolean(ikObject, dragonBones.ConstValues.A_BENDPOSITIVE, true);
            if (ikObject.hasOwnProperty(dragonBones.ConstValues.A_CHAIN)) {
                ikData.chain = ikObject[dragonBones.ConstValues.A_CHAIN];
            }
            else {
                ikData.chain = 0;
            }
            ikData.bones = ikObject[dragonBones.ConstValues.A_BONES];
            return ikData;
        };
        DataParser.parseSkinData = function (skinObject) {
            var skinData = new dragonBones.SkinData();
            skinData.name = skinObject[dragonBones.ConstValues.A_NAME];
            var slotList = skinObject[dragonBones.ConstValues.SLOT];
            for (var i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                skinData.addSlotData(DataParser.parseSlotDisplayData(slotObject));
            }
            return skinData;
        };
        DataParser.parseSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.gotoAndPlay = slotObject[dragonBones.ConstValues.A_GOTOANDPLAY];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.displayIndex = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0);
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            return slotData;
        };
        DataParser.parseSlotDisplayData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            var displayList = slotObject[dragonBones.ConstValues.DISPLAY];
            if (displayList) {
                for (var i = 0, len = displayList.length; i < len; i++) {
                    var displayObject = displayList[i];
                    slotData.addDisplayData(DataParser.parseDisplayData(displayObject));
                }
            }
            return slotData;
        };
        DataParser.parseDisplayData = function (displayObject) {
            var displayData = new dragonBones.DisplayData();
            displayData.name = displayObject[dragonBones.ConstValues.A_NAME];
            displayData.type = displayObject[dragonBones.ConstValues.A_TYPE];
            DataParser.parseTransform(displayObject[dragonBones.ConstValues.TRANSFORM], displayData.transform, displayData.pivot);
            displayData.pivot.x = NaN;
            displayData.pivot.y = NaN;
            if (DataParser.tempDragonBonesData != null) {
                DataParser.tempDragonBonesData.addDisplayData(displayData);
            }
            return displayData;
        };
        /** @private */
        DataParser.parseAnimationData = function (animationObject, frameRate) {
            var animationData = new dragonBones.AnimationData();
            animationData.name = animationObject[dragonBones.ConstValues.A_NAME];
            animationData.frameRate = frameRate;
            animationData.duration = Math.ceil((DataParser.getNumber(animationObject, dragonBones.ConstValues.A_DURATION, 1) || 1) * 1000 / frameRate);
            animationData.playTimes = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_PLAY_TIMES, 1);
            animationData.playTimes = animationData.playTimes != NaN ? animationData.playTimes : 1;
            animationData.fadeTime = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_FADE_IN_TIME, 0) || 0;
            animationData.scale = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            //use frame tweenEase, NaN
            //overwrite frame tweenEase, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            animationData.tweenEasing = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_TWEEN_EASING, NaN);
            animationData.autoTween = DataParser.getBoolean(animationObject, dragonBones.ConstValues.A_AUTO_TWEEN, true);
            var frameObjectList = animationObject[dragonBones.ConstValues.FRAME];
            var i = 0;
            var len = 0;
            if (frameObjectList) {
                for (i = 0, len = frameObjectList.length; i < len; i++) {
                    var frameObject = frameObjectList[i];
                    var frame = DataParser.parseTransformFrame(frameObject, frameRate);
                    animationData.addFrame(frame);
                }
            }
            DataParser.parseTimeline(animationObject, animationData);
            var lastFrameDuration = animationData.duration;
            var timelineObjectList = animationObject[dragonBones.ConstValues.BONE];
            if (timelineObjectList) {
                for (i = 0, len = timelineObjectList.length; i < len; i++) {
                    var timelineObject = timelineObjectList[i];
                    if (timelineObject) {
                        var timeline = DataParser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                        if (timeline.frameList.length > 0) {
                            lastFrameDuration = Math.min(lastFrameDuration, timeline.frameList[timeline.frameList.length - 1].duration);
                        }
                        animationData.addTimeline(timeline);
                    }
                }
            }
            var slotTimelineObjectList = animationObject[dragonBones.ConstValues.SLOT];
            if (slotTimelineObjectList) {
                for (i = 0, len = slotTimelineObjectList.length; i < len; i++) {
                    var slotTimelineObject = slotTimelineObjectList[i];
                    if (slotTimelineObject) {
                        var slotTimeline = DataParser.parseSlotTimeline(slotTimelineObject, animationData.duration, frameRate);
                        if (slotTimeline.frameList.length > 0) {
                            lastFrameDuration = Math.min(lastFrameDuration, slotTimeline.frameList[slotTimeline.frameList.length - 1].duration);
                            animationData.addSlotTimeline(slotTimeline);
                        }
                    }
                }
            }
            if (animationData.frameList.length > 0) {
                lastFrameDuration = Math.min(lastFrameDuration, animationData.frameList[animationData.frameList.length - 1].duration);
            }
            //取得timeline中最小的lastFrameDuration并保存
            animationData.lastFrameDuration = lastFrameDuration;
            return animationData;
        };
        DataParser.parseTransformTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.TransformTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.originPivot.x = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
            outputTimeline.originPivot.y = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = DataParser.parseTransformFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            DataParser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        DataParser.parseSlotTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.SlotTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = DataParser.parseSlotFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            DataParser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        DataParser.parseTransformFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.TransformFrame();
            DataParser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.tweenRotate = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_ROTATE, 0) || 0);
            outputFrame.tweenScale = DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_TWEEN_SCALE, true);
            outputFrame.displayIndex = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            DataParser.parseTransform(frameObject[dragonBones.ConstValues.TRANSFORM], outputFrame.transform, outputFrame.pivot);
            if (DataParser.tempDragonBonesData.isGlobal) {
                outputFrame.global.copy(outputFrame.transform);
            }
            outputFrame.scaleOffset.x = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_X_OFFSET, 0) || 0;
            outputFrame.scaleOffset.y = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_Y_OFFSET, 0) || 0;
            return outputFrame;
        };
        DataParser.parseSlotFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.SlotFrame();
            DataParser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.displayIndex = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            outputFrame.gotoAndPlay = frameObject[dragonBones.ConstValues.A_GOTOANDPLAY];
            //如果为NaN，则说明没有改变过zOrder
            outputFrame.zOrder = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_Z_ORDER, DataParser.tempDragonBonesData.isGlobal ? NaN : 0);
            var colorTransformObject = frameObject[dragonBones.ConstValues.COLOR];
            if (colorTransformObject) {
                outputFrame.color = new dragonBones.ColorTransform();
                DataParser.parseColorTransform(colorTransformObject, outputFrame.color);
            }
            return outputFrame;
        };
        DataParser.parseTimeline = function (timelineObject, outputTimeline) {
            var position = 0;
            var frame;
            var frameList = outputTimeline.frameList;
            for (var i = 0, len = frameList.length; i < len; i++) {
                frame = frameList[i];
                frame.position = position;
                position += frame.duration;
            }
            //防止duration计算有误差
            if (frame) {
                frame.duration = outputTimeline.duration - frame.position;
            }
        };
        DataParser.parseFrame = function (frameObject, outputFrame, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            outputFrame.duration = Math.round(((frameObject[dragonBones.ConstValues.A_DURATION]) || 1) * 1000 / frameRate);
            outputFrame.action = frameObject[dragonBones.ConstValues.A_ACTION];
            outputFrame.event = frameObject[dragonBones.ConstValues.A_EVENT];
            outputFrame.sound = frameObject[dragonBones.ConstValues.A_SOUND];
            var curve = frameObject[dragonBones.ConstValues.A_CURVE];
            if (curve != null && curve.length == 4) {
                outputFrame.curve = new dragonBones.CurveData();
                outputFrame.curve.pointList = [new dragonBones.Point(curve[0], curve[1]),
                    new dragonBones.Point(curve[2], curve[3])];
            }
        };
        DataParser.parseTransform = function (transformObject, transform, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (transformObject) {
                if (transform) {
                    transform.x = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_X, 0) || 0;
                    transform.y = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_Y, 0) || 0;
                    transform.skewX = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_X, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.skewY = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_Y, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.scaleX = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_X, 1) || 0;
                    transform.scaleY = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_Y, 1) || 0;
                }
                if (pivot) {
                    pivot.x = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
                    pivot.y = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
                }
            }
        };
        DataParser.parseColorTransform = function (colorTransformObject, colorTransform) {
            if (colorTransform) {
                colorTransform.alphaOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_OFFSET, 0);
                colorTransform.redOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_OFFSET, 0);
                colorTransform.greenOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_OFFSET, 0);
                colorTransform.blueOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_OFFSET, 0);
                colorTransform.alphaMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_MULTIPLIER, 100) * 0.01;
                colorTransform.redMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_MULTIPLIER, 100) * 0.01;
                colorTransform.greenMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_MULTIPLIER, 100) * 0.01;
                colorTransform.blueMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_MULTIPLIER, 100) * 0.01;
            }
        };
        DataParser.getBoolean = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "0":
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return false;
                    case "1":
                    case "true":
                    default:
                        return true;
                }
            }
            return defaultValue;
        };
        DataParser.getNumber = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return NaN;
                    default:
                        return Number(data[key]);
                }
            }
            return defaultValue;
        };
        return DataParser;
    }());
    dragonBones.DataParser = DataParser;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TextureData
     * @classdesc
     * 纹理数据
     *
     * @example
     * <pre>
     *   //获取动画数据
     *   var skeletonData = RES.getRes("skeleton");
     *   //获取纹理集数据
     *   var textureData = RES.getRes("textureConfig");
     *   //获取纹理集图片
     *   var texture = RES.getRes("texture");
     *
     *   //创建一个工厂，用来创建Armature
     *   var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
     *   //把动画数据添加到工厂里
     *   factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
     *   //把纹理集数据和图片添加到工厂里
     *   factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
     *   //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
     *   var armatureName:string = skeletonData.armature[0].name;
     *   //从工厂里创建出Armature
     *   var armature:dragonBones.Armature = factory.buildArmature(armatureName);
     *   //获取装载Armature的容器
     *   var armatureDisplay = armature.display;
     *   //把它添加到舞台上
     *   this.addChild(armatureDisplay);
     *   //取得这个Armature动画列表中的第一个动画的名字
     *   var curAnimationName = armature.animation.animationList[0];
     *   //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
     *   //第一个参数 animationName {string} 指定播放动画的名称.
     *   //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
     *   //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
     *   //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
     *   armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
     *
     *   //把Armature添加到心跳时钟里
     *   dragonBones.WorldClock.clock.add(armature);
     *   //心跳时钟开启
     *   egret.Ticker.getInstance().register(function (advancedTime) {
     *       dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
     *   }, this);
     * </pre>
     */
    var TextureData = (function () {
        /**
         *创建一个 TextureData 实例
         * @param region 区域
         * @param frame 帧的区域
         * @param rotated
         */
        function TextureData(region, frame, rotated) {
            this.region = region;
            this.frame = frame;
            this.rotated = rotated;
        }
        var d = __define,c=TextureData,p=c.prototype;
        return TextureData;
    }());
    dragonBones.TextureData = TextureData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var ColorTransformUtil = (function () {
        function ColorTransformUtil() {
        }
        var d = __define,c=ColorTransformUtil,p=c.prototype;
        ColorTransformUtil.cloneColor = function (color) {
            var c = new dragonBones.ColorTransform();
            c.redMultiplier = color.redMultiplier;
            c.greenMultiplier = color.greenMultiplier;
            c.blueMultiplier = color.blueMultiplier;
            c.alphaMultiplier = color.alphaMultiplier;
            c.redOffset = color.redOffset;
            c.greenOffset = color.greenOffset;
            c.blueOffset = color.blueOffset;
            c.alphaOffset = color.alphaOffset;
            return c;
        };
        ColorTransformUtil.isEqual = function (color1, color2) {
            return color1.alphaOffset == color2.alphaOffset &&
                color1.redOffset == color2.redOffset &&
                color1.greenOffset == color2.greenOffset &&
                color1.blueOffset == color2.blueOffset &&
                color1.alphaMultiplier == color2.alphaMultiplier &&
                color1.redMultiplier == color2.redMultiplier &&
                color1.greenMultiplier == color2.greenMultiplier &&
                color1.blueMultiplier == color2.blueMultiplier;
        };
        ColorTransformUtil.minus = function (color1, color2, outputColor) {
            outputColor.alphaOffset = color1.alphaOffset - color2.alphaOffset;
            outputColor.redOffset = color1.redOffset - color2.redOffset;
            outputColor.greenOffset = color1.greenOffset - color2.greenOffset;
            outputColor.blueOffset = color1.blueOffset - color2.blueOffset;
            outputColor.alphaMultiplier = color1.alphaMultiplier - color2.alphaMultiplier;
            outputColor.redMultiplier = color1.redMultiplier - color2.redMultiplier;
            outputColor.greenMultiplier = color1.greenMultiplier - color2.greenMultiplier;
            outputColor.blueMultiplier = color1.blueMultiplier - color2.blueMultiplier;
        };
        ColorTransformUtil.originalColor = new dragonBones.ColorTransform();
        return ColorTransformUtil;
    }());
    dragonBones.ColorTransformUtil = ColorTransformUtil;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ConstValues
     * @classdesc
     *定义了常用的常量
     */
    var ConstValues = (function () {
        function ConstValues() {
        }
        var d = __define,c=ConstValues,p=c.prototype;
        /**
         * 角度转换为弧度
         */
        ConstValues.ANGLE_TO_RADIAN = Math.PI / 180;
        /**
         * 弧度转换为角度
         */
        ConstValues.RADIAN_TO_ANGLE = 180 / Math.PI;
        /**
         *龙骨
         */
        ConstValues.DRAGON_BONES = "dragonBones";
        /**
         * 骨架
         */
        ConstValues.ARMATURE = "armature";
        /**
         *皮肤
         */
        ConstValues.SKIN = "skin";
        /**
         * 骨骼
         */
        ConstValues.BONE = "bone";
        /**
         * ik
         */
        ConstValues.IK = "ik";
        /**
         * 插槽
         */
        ConstValues.SLOT = "slot";
        /**
         * 显示对象
         */
        ConstValues.DISPLAY = "display";
        /**
         * 动画
         */
        ConstValues.ANIMATION = "animation";
        /**
         * 时间轴
         */
        ConstValues.TIMELINE = "timeline";
        /**
         * 帧
         */
        ConstValues.FRAME = "frame";
        /**
         * 变换
         */
        ConstValues.TRANSFORM = "transform";
        /**
         * 颜色变换
         */
        ConstValues.COLOR_TRANSFORM = "colorTransform";
        ConstValues.COLOR = "color";
        /**
         * 矩形
         */
        ConstValues.RECTANGLE = "rectangle";
        /**
         * 椭圆
         */
        ConstValues.ELLIPSE = "ellipse";
        /**
         * 纹理集
         */
        ConstValues.TEXTURE_ATLAS = "TextureAtlas";
        /**
         * 子纹理
         */
        ConstValues.SUB_TEXTURE = "SubTexture";
        /**
         * 旋转
         */
        ConstValues.A_ROTATED = "rotated";
        /**
         * 帧的x坐标
         */
        ConstValues.A_FRAME_X = "frameX";
        /**
         * 帧的y坐标
         */
        ConstValues.A_FRAME_Y = "frameY";
        /**
         * 帧的宽度
         */
        ConstValues.A_FRAME_WIDTH = "frameWidth";
        /**
         * 帧的高度
         */
        ConstValues.A_FRAME_HEIGHT = "frameHeight";
        /**
         * 版本
         */
        ConstValues.A_VERSION = "version";
        /**
         * 图片路径
         */
        ConstValues.A_IMAGE_PATH = "imagePath";
        /**
         * 帧速率
         */
        ConstValues.A_FRAME_RATE = "frameRate";
        /**
         * 名字
         */
        ConstValues.A_NAME = "name";
        /**
         * 是否是全局
         */
        ConstValues.A_IS_GLOBAL = "isGlobal";
        /**
         * 父亲
         */
        ConstValues.A_PARENT = "parent";
        /**
         * 长度
         */
        ConstValues.A_LENGTH = "length";
        /**
         * 类型
         */
        ConstValues.A_TYPE = "type";
        /**
         * 缓入事件
         */
        ConstValues.A_FADE_IN_TIME = "fadeInTime";
        /**
         * 持续时长
         */
        ConstValues.A_DURATION = "duration";
        /**
         * 缩放
         */
        ConstValues.A_SCALE = "scale";
        /**
         * 偏移
         */
        ConstValues.A_OFFSET = "offset";
        /**
         * 循环
         */
        ConstValues.A_LOOP = "loop";
        ConstValues.A_PLAY_TIMES = "playTimes";
        /**
         * 事件
         */
        ConstValues.A_EVENT = "event";
        /**
         * 事件参数
         */
        ConstValues.A_EVENT_PARAMETERS = "eventParameters";
        /**
         * 声音
         */
        ConstValues.A_SOUND = "sound";
        /**
         * 动作
         */
        ConstValues.A_ACTION = "action";
        /**
         * 隐藏
         */
        ConstValues.A_HIDE = "hide";
        /**
         * 自动补间
         */
        ConstValues.A_AUTO_TWEEN = "autoTween";
        /**
         * 补间缓动
         */
        ConstValues.A_TWEEN_EASING = "tweenEasing";
        /**
         * 补间旋转
         */
        ConstValues.A_TWEEN_ROTATE = "tweenRotate";
        /**
         * 补间缩放
         */
        ConstValues.A_TWEEN_SCALE = "tweenScale";
        /**
         * 显示对象序号
         */
        ConstValues.A_DISPLAY_INDEX = "displayIndex";
        /**
         * z轴
         */
        ConstValues.A_Z_ORDER = "z";
        /**
         * 混合模式
         */
        ConstValues.A_BLENDMODE = "blendMode";
        /**
         * 宽度
         */
        ConstValues.A_WIDTH = "width";
        /**
         * 高度
         */
        ConstValues.A_HEIGHT = "height";
        /**
         * 继承缩放
         */
        ConstValues.A_INHERIT_SCALE = "inheritScale";
        /**
         * 继承旋转
         */
        ConstValues.A_INHERIT_ROTATION = "inheritRotation";
        /**
         * x轴
         */
        ConstValues.A_X = "x";
        /**
         * y轴
         */
        ConstValues.A_Y = "y";
        /**
         * x方向斜切
         */
        ConstValues.A_SKEW_X = "skX";
        /**
         * y方向斜切
         */
        ConstValues.A_SKEW_Y = "skY";
        /**
         * x方向缩放
         */
        ConstValues.A_SCALE_X = "scX";
        /**
         * y方向缩放
         */
        ConstValues.A_SCALE_Y = "scY";
        /**
         * 轴点的x坐标
         */
        ConstValues.A_PIVOT_X = "pX";
        /**
         * 轴点的y坐标
         */
        ConstValues.A_PIVOT_Y = "pY";
        /**
         * 透明度的偏移
         */
        ConstValues.A_ALPHA_OFFSET = "aO";
        /**
         * 红色的偏移
         */
        ConstValues.A_RED_OFFSET = "rO";
        /**
         * 绿色的偏移
         */
        ConstValues.A_GREEN_OFFSET = "gO";
        /**
         * 蓝色的偏移
         */
        ConstValues.A_BLUE_OFFSET = "bO";
        /**
         * 透明度的倍数
         */
        ConstValues.A_ALPHA_MULTIPLIER = "aM";
        /**
         * 红色的倍数
         */
        ConstValues.A_RED_MULTIPLIER = "rM";
        /**
         * 绿色的倍数
         */
        ConstValues.A_GREEN_MULTIPLIER = "gM";
        /**
         * 蓝色的倍数
         */
        ConstValues.A_BLUE_MULTIPLIER = "bM";
        /**
         * 动画曲线
         */
        ConstValues.A_CURVE = "curve";
        /**
         * x方向缩放的偏移
         */
        ConstValues.A_SCALE_X_OFFSET = "scXOffset";
        /**
         * y方向的偏移
         */
        ConstValues.A_SCALE_Y_OFFSET = "scYOffset";
        /**
         * 缩放模式
         */
        ConstValues.A_SCALE_MODE = "scaleMode";
        /**
         * 旋转修正
         */
        ConstValues.A_FIXED_ROTATION = "fixedRotation";
        /**
         * 默认动画
         */
        ConstValues.A_DEFAULT_ANIMATION = "defaultAnimation";
        /**
         * 播放子骨架的动画
         */
        ConstValues.A_GOTOANDPLAY = "gotoAndPlay";
        ConstValues.A_TARGET = "target";
        ConstValues.A_WEIGHT = "weight";
        ConstValues.A_BONES = "bone";
        ConstValues.A_BENDPOSITIVE = "bendPositive";
        ConstValues.A_CHAIN = "chain";
        return ConstValues;
    }());
    dragonBones.ConstValues = ConstValues;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBDataUtil
     * @classdesc
     * DragonBons的数据工具类，提供一些对数据处理的静态方法
     */
    var DBDataUtil = (function () {
        function DBDataUtil() {
        }
        var d = __define,c=DBDataUtil,p=c.prototype;
        /**
         * 把ArmatureData的绝对数据转成成相对数据
         * @param armatureData
         */
        DBDataUtil.transformArmatureData = function (armatureData) {
            var boneDataList = armatureData.boneDataList;
            var i = boneDataList.length;
            while (i--) {
                var boneData = boneDataList[i];
                if (boneData.parent) {
                    var parentBoneData = armatureData.getBoneData(boneData.parent);
                    if (parentBoneData) {
                        boneData.transform.copy(boneData.global);
                        dragonBones.TransformUtil.globalToLocal(boneData.transform, parentBoneData.global);
                    }
                }
            }
        };
        /**
         * 转换骨架数据中的动画数据
         * 把动画数据中的绝对的数据转换成相对的数据
         * @param armatureData
         */
        DBDataUtil.transformArmatureDataAnimations = function (armatureData) {
            var animationDataList = armatureData.animationDataList;
            var i = animationDataList.length;
            while (i--) {
                DBDataUtil.transformAnimationData(animationDataList[i], armatureData, false);
            }
        };
        /**
         *
         * @param animationData
         * @param armatureData
         */
        DBDataUtil.transformRelativeAnimationData = function (animationData, armatureData) {
        };
        /**
         * 把动画数据中的绝对的数据转换成相对的数据
         * @param animationData 动画数据
         * @param armatureData 骨架数据
         * @param isGlobalData 是否是绝对数据
         */
        DBDataUtil.transformAnimationData = function (animationData, armatureData, isGlobalData) {
            if (!isGlobalData) {
                DBDataUtil.transformRelativeAnimationData(animationData, armatureData);
                return;
            }
            var skinData = armatureData.getSkinData(null);
            var boneDataList = armatureData.boneDataList;
            var slotDataList;
            if (skinData) {
                slotDataList = skinData.slotDataList;
            }
            for (var i = 0; i < boneDataList.length; i++) {
                var boneData = boneDataList[i];
                var timeline = animationData.getTimeline(boneData.name);
                var slotTimeline = animationData.getSlotTimeline(boneData.name);
                if (!timeline && !slotTimeline) {
                    continue;
                }
                var slotData = null;
                if (slotDataList) {
                    for (var j = 0, jLen = slotDataList.length; j < jLen; j++) {
                        slotData = slotDataList[j];
                        //找到属于当前Bone的slot(FLash Pro制作的动画一个Bone只包含一个slot)
                        if (slotData.parent == boneData.name) {
                            break;
                        }
                    }
                }
                var frameList = timeline.frameList;
                if (slotTimeline) {
                    var slotFrameList = slotTimeline.frameList;
                }
                var originTransform = null;
                var originPivot = null;
                var prevFrame = null;
                var frameListLength = frameList.length;
                for (var j = 0; j < frameListLength; j++) {
                    var frame = (frameList[j]);
                    //计算frame的transoform信息
                    DBDataUtil.setFrameTransform(animationData, armatureData, boneData, frame);
                    frame.transform.x -= boneData.transform.x;
                    frame.transform.y -= boneData.transform.y;
                    frame.transform.skewX -= boneData.transform.skewX;
                    frame.transform.skewY -= boneData.transform.skewY;
                    frame.transform.scaleX /= boneData.transform.scaleX;
                    frame.transform.scaleY /= boneData.transform.scaleY;
                    //如果originTransform不存在说明当前帧是第一帧，将当前帧的transform保存至timeline的originTransform
                    /*
                    if(!originTransform){
                        originTransform = timeline.originTransform;
                        originTransform.copy(frame.transform);
                        originTransform.skewX = TransformUtil.formatRadian(originTransform.skewX);
                        originTransform.skewY = TransformUtil.formatRadian(originTransform.skewY);
                        originPivot = timeline.originPivot;
                        originPivot.x = frame.pivot.x;
                        originPivot.y = frame.pivot.y;
                    }
                    
                    frame.transform.x -= originTransform.x;
                    frame.transform.y -= originTransform.y;
                    frame.transform.skewX = TransformUtil.formatRadian(frame.transform.skewX - originTransform.skewX);
                    frame.transform.skewY = TransformUtil.formatRadian(frame.transform.skewY - originTransform.skewY);
                    frame.transform.scaleX /= originTransform.scaleX;
                    frame.transform.scaleY /= originTransform.scaleY;
                    
                    if(!timeline.transformed){
                        frame.pivot.x -= originPivot.x;
                        frame.pivot.y -= originPivot.y;
                    }
                    */
                    if (prevFrame) {
                        var dLX = frame.transform.skewX - prevFrame.transform.skewX;
                        if (prevFrame.tweenRotate) {
                            if (prevFrame.tweenRotate > 0) {
                                if (dLX < 0) {
                                    frame.transform.skewX += Math.PI * 2;
                                    frame.transform.skewY += Math.PI * 2;
                                }
                                if (prevFrame.tweenRotate > 1) {
                                    frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                    frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                }
                            }
                            else {
                                if (dLX > 0) {
                                    frame.transform.skewX -= Math.PI * 2;
                                    frame.transform.skewY -= Math.PI * 2;
                                }
                                if (prevFrame.tweenRotate < 1) {
                                    frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                    frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                }
                            }
                        }
                        else {
                            frame.transform.skewX = prevFrame.transform.skewX + dragonBones.TransformUtil.formatRadian(frame.transform.skewX - prevFrame.transform.skewX);
                            frame.transform.skewY = prevFrame.transform.skewY + dragonBones.TransformUtil.formatRadian(frame.transform.skewY - prevFrame.transform.skewY);
                        }
                    }
                    prevFrame = frame;
                }
                if (slotTimeline && slotFrameList) {
                    frameListLength = slotFrameList.length;
                    for (var j = 0; j < frameListLength; j++) {
                        var slotFrame = slotFrameList[j];
                        if (!slotTimeline.transformed) {
                            if (slotData) {
                                slotFrame.zOrder -= slotData.zOrder;
                            }
                        }
                    }
                    slotTimeline.transformed = true;
                }
                timeline.transformed = true;
            }
        };
        //计算frame的transoform信息
        DBDataUtil.setFrameTransform = function (animationData, armatureData, boneData, frame) {
            frame.transform.copy(frame.global);
            //找到当前bone的父亲列表 并将timeline信息存入parentTimelineList 将boneData信息存入parentDataList
            var parentData = armatureData.getBoneData(boneData.parent);
            if (parentData) {
                var parentTimeline = animationData.getTimeline(parentData.name);
                if (parentTimeline) {
                    var parentTimelineList = [];
                    var parentDataList = [];
                    while (parentTimeline) {
                        parentTimelineList.push(parentTimeline);
                        parentDataList.push(parentData);
                        parentData = armatureData.getBoneData(parentData.parent);
                        if (parentData) {
                            parentTimeline = animationData.getTimeline(parentData.name);
                        }
                        else {
                            parentTimeline = null;
                        }
                    }
                    var i = parentTimelineList.length;
                    var globalTransform;
                    var globalTransformMatrix = new dragonBones.Matrix();
                    var currentTransform = new dragonBones.DBTransform();
                    var currentTransformMatrix = new dragonBones.Matrix();
                    //从根开始遍历
                    while (i--) {
                        parentTimeline = parentTimelineList[i];
                        parentData = parentDataList[i];
                        //一级一级找到当前帧对应的每个父节点的transform(相对transform)
                        DBDataUtil.getTimelineTransform(parentTimeline, frame.position, currentTransform, !globalTransform);
                        if (!globalTransform) {
                            globalTransform = new dragonBones.DBTransform();
                            globalTransform.copy(currentTransform);
                        }
                        else {
                            currentTransform.x += parentTimeline.originTransform.x + parentData.transform.x;
                            currentTransform.y += parentTimeline.originTransform.y + parentData.transform.y;
                            currentTransform.skewX += parentTimeline.originTransform.skewX + parentData.transform.skewX;
                            currentTransform.skewY += parentTimeline.originTransform.skewY + parentData.transform.skewY;
                            currentTransform.scaleX *= parentTimeline.originTransform.scaleX * parentData.transform.scaleX;
                            currentTransform.scaleY *= parentTimeline.originTransform.scaleY * parentData.transform.scaleY;
                            dragonBones.TransformUtil.transformToMatrix(currentTransform, currentTransformMatrix);
                            currentTransformMatrix.concat(globalTransformMatrix);
                            dragonBones.TransformUtil.matrixToTransform(currentTransformMatrix, globalTransform, currentTransform.scaleX * globalTransform.scaleX >= 0, currentTransform.scaleY * globalTransform.scaleY >= 0);
                        }
                        dragonBones.TransformUtil.transformToMatrix(globalTransform, globalTransformMatrix);
                    }
                    dragonBones.TransformUtil.globalToLocal(frame.transform, globalTransform);
                }
            }
        };
        DBDataUtil.getTimelineTransform = function (timeline, position, retult, isGlobal) {
            var frameList = timeline.frameList;
            var i = frameList.length;
            while (i--) {
                var currentFrame = (frameList[i]);
                //找到穿越当前帧的关键帧
                if (currentFrame.position <= position && currentFrame.position + currentFrame.duration > position) {
                    //是最后一帧或者就是当前帧
                    if (i == frameList.length - 1 || position == currentFrame.position) {
                        retult.copy(isGlobal ? currentFrame.global : currentFrame.transform);
                    }
                    else {
                        var tweenEasing = currentFrame.tweenEasing;
                        var progress = (position - currentFrame.position) / currentFrame.duration;
                        if (tweenEasing && tweenEasing != 10) {
                            progress = dragonBones.MathUtil.getEaseValue(progress, tweenEasing);
                        }
                        var nextFrame = frameList[i + 1];
                        var currentTransform = isGlobal ? currentFrame.global : currentFrame.transform;
                        var nextTransform = isGlobal ? nextFrame.global : nextFrame.transform;
                        retult.x = currentTransform.x + (nextTransform.x - currentTransform.x) * progress;
                        retult.y = currentTransform.y + (nextTransform.y - currentTransform.y) * progress;
                        retult.skewX = dragonBones.TransformUtil.formatRadian(currentTransform.skewX + (nextTransform.skewX - currentTransform.skewX) * progress);
                        retult.skewY = dragonBones.TransformUtil.formatRadian(currentTransform.skewY + (nextTransform.skewY - currentTransform.skewY) * progress);
                        retult.scaleX = currentTransform.scaleX + (nextTransform.scaleX - currentTransform.scaleX) * progress;
                        retult.scaleY = currentTransform.scaleY + (nextTransform.scaleY - currentTransform.scaleY) * progress;
                    }
                    break;
                }
            }
        };
        /**
         * 添加进隐藏的时间轴
         * @param animationData
         * @param armatureData
         */
        DBDataUtil.addHideTimeline = function (animationData, armatureData, addHideSlot) {
            if (addHideSlot === void 0) { addHideSlot = false; }
            var boneDataList = armatureData.boneDataList;
            var slotDataList = armatureData.slotDataList;
            var i = boneDataList.length;
            while (i--) {
                var boneData = boneDataList[i];
                var boneName = boneData.name;
                if (!animationData.getTimeline(boneName)) {
                    if (animationData.hideTimelineNameMap.indexOf(boneName) < 0) {
                        animationData.hideTimelineNameMap.push(boneName);
                    }
                }
            }
            if (addHideSlot) {
                i = slotDataList.length;
                var slotData;
                var slotName;
                while (i--) {
                    slotData = slotDataList[i];
                    slotName = slotData.name;
                    if (!animationData.getSlotTimeline(slotName)) {
                        if (animationData.hideSlotTimelineNameMap.indexOf(slotName) < 0) {
                            animationData.hideSlotTimelineNameMap.push(slotName);
                        }
                    }
                }
            }
        };
        return DBDataUtil;
    }());
    dragonBones.DBDataUtil = DBDataUtil;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.MathUtil
     * @classdesc
     * 内部使用的有关数学计算的工具类
     */
    var MathUtil = (function () {
        function MathUtil() {
        }
        var d = __define,c=MathUtil,p=c.prototype;
        /** @private */
        MathUtil.getEaseValue = function (value, easing) {
            var valueEase = 1;
            if (easing > 1) {
                //valueEase = 0.5 * (1 - NumberUtils.cos(value * Math.PI));
                valueEase = 0.5 * (1 - MathUtil.cos(value * Math.PI));
                easing -= 1;
            }
            else if (easing > 0) {
                valueEase = 1 - Math.pow(1 - value, 2);
            }
            else if (easing < 0) {
                easing *= -1;
                valueEase = Math.pow(value, 2);
            }
            return (valueEase - value) * easing + value;
        };
        MathUtil.isNumber = function (value) {
            return typeof (value) === "number" && !isNaN(value);
        };
        /**
         * 得到对应角度值的sin近似值
         * @param value {number} 角度值
         * @returns {number} sin值
         */
        MathUtil.sin = function (value) {
            value *= MathUtil.RADIAN_TO_ANGLE;
            var valueFloor = Math.floor(value);
            var valueCeil = valueFloor + 1;
            var resultFloor = MathUtil.sinInt(valueFloor);
            var resultCeil = MathUtil.sinInt(valueCeil);
            return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
        };
        MathUtil.sinInt = function (value) {
            value = value % 360;
            if (value < 0) {
                value += 360;
            }
            if (value < 90) {
                return db_sin_map[value];
            }
            if (value < 180) {
                return db_sin_map[180 - value];
            }
            if (value < 270) {
                return -db_sin_map[value - 180];
            }
            return -db_sin_map[360 - value];
        };
        /**
         * 得到对应角度值的cos近似值
         * @param value {number} 角度值
         * @returns {number} cos值
         */
        MathUtil.cos = function (value) {
            return MathUtil.sin(Math.PI / 2 - value);
        };
        /**
         * 角度转换为弧度
         */
        MathUtil.ANGLE_TO_RADIAN = Math.PI / 180;
        /**
         * 弧度转换为角度
         */
        MathUtil.RADIAN_TO_ANGLE = 180 / Math.PI;
        return MathUtil;
    }());
    dragonBones.MathUtil = MathUtil;

})(dragonBones || (dragonBones = {}));
var db_sin_map = {};
for (var dbMathIndex = 0; dbMathIndex <= 90; dbMathIndex++) {
    db_sin_map[dbMathIndex] = Math.sin(dbMathIndex * dragonBones.MathUtil.ANGLE_TO_RADIAN);
}
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformUtils
     * @classdesc
     * 提供了一些常用的转换的静态方法
     */
    var TransformUtil = (function () {
        function TransformUtil() {
        }
        var d = __define,c=TransformUtil,p=c.prototype;
        TransformUtil.isEqual = function (n1, n2) {
            if (n1 >= n2) {
                return (n1 - n2) <= TransformUtil.ACCURACY;
            }
            else {
                return (n2 - n1) <= TransformUtil.ACCURACY;
            }
        };
        /**
         * 全局坐标系转成成局部坐标系
         * @param transform 全局坐标系下的变换
         * @param parent 父亲的坐标变换
         */
        TransformUtil.globalToLocal = function (transform, parent) {
            TransformUtil.transformToMatrix(transform, TransformUtil._helpTransformMatrix);
            TransformUtil.transformToMatrix(parent, TransformUtil._helpParentTransformMatrix);
            TransformUtil._helpParentTransformMatrix.invert();
            TransformUtil._helpTransformMatrix.concat(TransformUtil._helpParentTransformMatrix);
            TransformUtil.matrixToTransform(TransformUtil._helpTransformMatrix, transform, transform.scaleX * parent.scaleX >= 0, transform.scaleY * parent.scaleY >= 0);
        };
        /**
         *把transform数据转成成矩阵数据
         * @param transform 需要转换的transform数据
         * @param matrix 转换后的矩阵数据
         * @param keepScale 是否保持缩放
         */
        TransformUtil.transformToMatrix = function (transform, matrix) {
            matrix.a = transform.scaleX * dragonBones.MathUtil.cos(transform.skewY);
            matrix.b = transform.scaleX * dragonBones.MathUtil.sin(transform.skewY);
            matrix.c = -transform.scaleY * dragonBones.MathUtil.sin(transform.skewX);
            matrix.d = transform.scaleY * dragonBones.MathUtil.cos(transform.skewX);
            matrix.tx = transform.x;
            matrix.ty = transform.y;
        };
        /**
         *把 矩阵数据转成成transform数据
         * @param matrix 需要转换的矩阵数据
         * @param transform 转换后的transform数据
         * @param scaleXF x方向的缩放
         * @param scaleYF y方向的缩放
         */
        TransformUtil.matrixToTransform = function (matrix, transform, scaleXF, scaleYF) {
            transform.x = matrix.tx;
            transform.y = matrix.ty;
            transform.scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b) * (scaleXF ? 1 : -1);
            transform.scaleY = Math.sqrt(matrix.d * matrix.d + matrix.c * matrix.c) * (scaleYF ? 1 : -1);
            TransformUtil.tmpSkewXArray[0] = Math.acos(matrix.d / transform.scaleY);
            TransformUtil.tmpSkewXArray[1] = -TransformUtil.tmpSkewXArray[0];
            TransformUtil.tmpSkewXArray[2] = Math.asin(-matrix.c / transform.scaleY);
            TransformUtil.tmpSkewXArray[3] = TransformUtil.tmpSkewXArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewXArray[2] : TransformUtil.tmpSkewXArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[3])) {
                transform.skewX = TransformUtil.tmpSkewXArray[0];
            }
            else {
                transform.skewX = TransformUtil.tmpSkewXArray[1];
            }
            TransformUtil.tmpSkewYArray[0] = Math.acos(matrix.a / transform.scaleX);
            TransformUtil.tmpSkewYArray[1] = -TransformUtil.tmpSkewYArray[0];
            TransformUtil.tmpSkewYArray[2] = Math.asin(matrix.b / transform.scaleX);
            TransformUtil.tmpSkewYArray[3] = TransformUtil.tmpSkewYArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewYArray[2] : TransformUtil.tmpSkewYArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[3])) {
                transform.skewY = TransformUtil.tmpSkewYArray[0];
            }
            else {
                transform.skewY = TransformUtil.tmpSkewYArray[1];
            }
        };
        /**
         * 标准化弧度值，把弧度制换算到[-PI，PI]之间
         * @param radian 输入一个弧度值
         * @returns {number} 输出标准化后的弧度制
         */
        TransformUtil.formatRadian = function (radian) {
            //radian %= DOUBLE_PI;
            if (radian > Math.PI) {
                radian -= TransformUtil.DOUBLE_PI;
            }
            if (radian < -Math.PI) {
                radian += TransformUtil.DOUBLE_PI;
            }
            return radian;
        };
        /**
         *  确保角度在-180到180之间
         */
        TransformUtil.normalizeRotation = function (rotation) {
            rotation = (rotation + Math.PI) % (2 * Math.PI);
            rotation = rotation > 0 ? rotation : 2 * Math.PI + rotation;
            return rotation - Math.PI;
        };
        TransformUtil.matrixToTransformPosition = function (matrix, transform) {
            transform.x = matrix.tx;
            transform.y = matrix.ty;
        };
        TransformUtil.matrixToTransformScale = function (matrix, transform, scaleXF, scaleYF) {
            transform.scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b) * (scaleXF ? 1 : -1);
            transform.scaleY = Math.sqrt(matrix.d * matrix.d + matrix.c * matrix.c) * (scaleYF ? 1 : -1);
        };
        TransformUtil.matrixToTransformRotation = function (matrix, transform, scaleX, scaleY) {
            TransformUtil.tmpSkewXArray[0] = Math.acos(matrix.d / scaleY);
            TransformUtil.tmpSkewXArray[1] = -TransformUtil.tmpSkewXArray[0];
            TransformUtil.tmpSkewXArray[2] = Math.asin(-matrix.c / scaleY);
            TransformUtil.tmpSkewXArray[3] = TransformUtil.tmpSkewXArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewXArray[2] : TransformUtil.tmpSkewXArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[3])) {
                transform.skewX = TransformUtil.tmpSkewXArray[0];
            }
            else {
                transform.skewX = TransformUtil.tmpSkewXArray[1];
            }
            TransformUtil.tmpSkewYArray[0] = Math.acos(matrix.a / scaleX);
            TransformUtil.tmpSkewYArray[1] = -TransformUtil.tmpSkewYArray[0];
            TransformUtil.tmpSkewYArray[2] = Math.asin(matrix.b / scaleX);
            TransformUtil.tmpSkewYArray[3] = TransformUtil.tmpSkewYArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewYArray[2] : TransformUtil.tmpSkewYArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[3])) {
                transform.skewY = TransformUtil.tmpSkewYArray[0];
            }
            else {
                transform.skewY = TransformUtil.tmpSkewYArray[1];
            }
        };
        TransformUtil.HALF_PI = Math.PI * 0.5;
        TransformUtil.DOUBLE_PI = Math.PI * 2;
        TransformUtil._helpTransformMatrix = new dragonBones.Matrix();
        TransformUtil._helpParentTransformMatrix = new dragonBones.Matrix();
        //optimized by freem-trg
        TransformUtil.tmpSkewXArray = [];
        TransformUtil.tmpSkewYArray = [];
        TransformUtil.ACCURACY = 0.0001;
        return TransformUtil;
    }());
    dragonBones.TransformUtil = TransformUtil;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EgretFactory
     * @extends dragonBones.BaseFactory
     * @classdesc
     * Egret引擎中DragonBones工厂的基类实现
     */
    var EgretFactory = (function (_super) {
        __extends(EgretFactory, _super);
        function EgretFactory() {
            _super.call(this);
        }
        var d = __define,c=EgretFactory,p=c.prototype;
        /** @private */
        p._generateArmature = function () {
            var armature = new dragonBones.Armature(new DisplayObjectContainer());
            return armature;
        };
        /** @private */
        p._generateSlot = function () {
            var slot = new dragonBones.EgretSlot();
            return slot;
        };
        /** @private */
        p._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
            var bitmap = new Bitmap();
            bitmap.texture = textureAtlas.getTexture(fullName);
            if (isNaN(pivotX) || isNaN(pivotY)) {
                var subTextureFrame = (textureAtlas).getFrame(fullName);
                if (subTextureFrame != null) {
                    pivotX = subTextureFrame.width / 2;
                    pivotY = subTextureFrame.height / 2;
                }
                else {
                    pivotX = bitmap.width / 2;
                    pivotY = bitmap.height / 2;
                }
            }
            bitmap.anchorOffsetX = pivotX;
            bitmap.anchorOffsetY = pivotY;
            return bitmap;
        };
        p._generateFastArmature = function () {
            var armature = new dragonBones.FastArmature(new DisplayObjectContainer());
            return armature;
        };
        p._generateFastSlot = function () {
            var slot = new dragonBones.EgretFastSlot();
            return slot;
        };
        return EgretFactory;
    }(dragonBones.BaseFactory));
    dragonBones.EgretFactory = EgretFactory;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EgretSlot
     * @extends dragonBones.Slot
     * @classdesc
     * egret引擎使用的插槽
     */
    var EgretFastSlot = (function (_super) {
        __extends(EgretFastSlot, _super);
        /**
         * 创建一个新的 EgretSlot 实例
         */
        function EgretFastSlot() {
            _super.call(this);
            this._egretDisplay = null;
        }
        var d = __define,c=EgretFastSlot,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            if (this._displayList) {
                var length = this._displayList.length;
                for (var i = 0; i < length; i++) {
                    var content = this._displayList[i];
                    if (content instanceof dragonBones.FastArmature) {
                        content.dispose();
                    }
                }
            }
            _super.prototype.dispose.call(this);
            this._egretDisplay = null;
        };
        /** @private */
        p._updateDisplay = function (value) {
            this._egretDisplay = value;
        };
        //Abstract method
        /** @private */
        p._getDisplayIndex = function () {
            if (this._egretDisplay && this._egretDisplay.parent) {
                return this._egretDisplay.parent.getChildIndex(this._egretDisplay);
            }
            return -1;
        };
        /** @private */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            var egretContainer = container;
            if (this._egretDisplay && egretContainer) {
                if (index < 0) {
                    egretContainer.addChild(this._egretDisplay);
                }
                else {
                    egretContainer.addChildAt(this._egretDisplay, Math.min(index, egretContainer.numChildren));
                }
            }
        };
        /** @private */
        p._removeDisplayFromContainer = function () {
            if (this._egretDisplay && this._egretDisplay.parent) {
                this._egretDisplay.parent.removeChild(this._egretDisplay);
            }
        };
        /** @private */
        p._updateTransform = function () {
            if (this._egretDisplay) {
                //this._egretDisplay.$setMatrix(this._globalTransformMatrix, false);
                this._egretDisplay.__hack_local_matrix = this._globalTransformMatrix;
            }
        };
        /** @private */
        p._updateDisplayVisible = function (value) {
            //if(this._egretDisplay && this._parent){
            //    this._egretDisplay.visible = this._parent._visible && this._visible && value;
            //}
        };
        /** @private */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            if (colorChanged === void 0) { colorChanged = false; }
            _super.prototype._updateDisplayColor.call(this, aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged);
            if (this._egretDisplay) {
                this._egretDisplay.alpha = aMultiplier;
            }
        };
        /** @private */
        p._updateDisplayBlendMode = function (value) {
            if (this._egretDisplay && value) {
                this._egretDisplay.blendMode = value;
            }
        };
        return EgretFastSlot;
    }(dragonBones.FastSlot));
    dragonBones.EgretFastSlot = EgretFastSlot;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////

//var dragonBones;
//(function (dragonBones) {
//    /**
//     * @class dragonBones.EgretSheetAtlas
//     * @implements dragonBones.ITextureAtlas
//     * @classdesc
//     * Egret 引擎使用的sheet纹理集
//     */
//    var EgretSheetAtlas = (function () {
//        /**
//         * 创建一个新的EgretSheetAltas 实例
//         * @param texture 纹理
//         * @param textureData 纹理数据
//         * @param scale 缩放
//         */
//        function EgretSheetAtlas(texture, textureData, scale) {
//            if (scale === void 0) { scale = 1; }
//            this.texture = texture;
//            this.textureData = textureData;
//            this._textureDatas = {};
//            this.scale = scale;
//            this.name = textureData[dragonBones.ConstValues.A_NAME];
//            this.spriteSheet = new egret.SpriteSheet(texture);
//            this._textureDatas = textureData["frames"];
//        }
//        var d = __define,c=EgretSheetAtlas;p=c.prototype;
//        /**
//         *通过纹理的名字来获取纹理
//         * @param fullName 纹理的名字
//         * @returns {egret.Texture} 获取到的纹理
//         */
//        p.getTexture = function (fullName) {
//            var result = this.spriteSheet.getTexture(fullName);
//            if (!result) {
//                var config = this._textureDatas[fullName];
//                result = this.spriteSheet.createTexture(fullName, config.x, config.y, config.w, config.h, config.offX, config.offY, config.sourceW, config.sourceH);
//            }
//            return result;
//        };
//        /**
//         *释放资源
//         */
//        p.dispose = function () {
//            this.texture = null;
//        };
//        /**
//         * 根据子纹理的名字获取子纹理的矩形区域
//         * @param subTextureName 子纹理的名字
//         * @returns {*} 获取到的矩形区域
//         */
//        p.getRegion = function (subTextureName) {
//            var textureData = this._textureDatas[subTextureName];
//            if (textureData) {
//                return EgretSheetAtlas.Region;
//            }
//            return null;
//        };
//        EgretSheetAtlas.Region = new Rectangle();
//        return EgretSheetAtlas;
//    })();
//    dragonBones.EgretSheetAtlas = EgretSheetAtlas;
//
//})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EgretSlot
     * @extends dragonBones.Slot
     * @classdesc
     * egret引擎使用的插槽
     */
    var EgretSlot = (function (_super) {
        __extends(EgretSlot, _super);
        /**
         * 创建一个新的 EgretSlot 实例
         */
        function EgretSlot() {
            _super.call(this);
            this._egretDisplay = null;
        }
        var d = __define,c=EgretSlot,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            if (this._displayList) {
                var length = this._displayList.length;
                for (var i = 0; i < length; i++) {
                    var content = this._displayList[i];
                    if (content instanceof dragonBones.Armature) {
                        content.dispose();
                    }
                }
            }
            _super.prototype.dispose.call(this);
            this._egretDisplay = null;
        };
        /** @private */
        p._updateDisplay = function (value) {
            this._egretDisplay = value;
        };
        //Abstract method
        /** @private */
        p._getDisplayIndex = function () {
            if (this._egretDisplay && this._egretDisplay.parent) {
                return this._egretDisplay.parent.getChildIndex(this._egretDisplay);
            }
            return -1;
        };
        /** @private */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            var egretContainer = container;
            if (this._egretDisplay && egretContainer) {
                if (index < 0) {
                    egretContainer.addChild(this._egretDisplay);
                }
                else {
                    egretContainer.addChildAt(this._egretDisplay, Math.min(index, egretContainer.numChildren));
                }
            }
        };
        /** @private */
        p._removeDisplayFromContainer = function () {
            if (this._egretDisplay && this._egretDisplay.parent) {
                this._egretDisplay.parent.removeChild(this._egretDisplay);
            }
        };
        /** @private */
        p._updateTransform = function () {
            if(this._egretDisplay) {
                //this._egretDisplay.$setMatrix(this._globalTransformMatrix, false);
                this._egretDisplay.__hack_local_matrix = this._globalTransformMatrix;
            }
        };
        /** @private */
        p._updateDisplayVisible = function (value) {
            if (this._egretDisplay && this._parent) {
                this._egretDisplay.visible = this._parent._visible && this._visible && value;
            }
        };
        /** @private */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChange) {
            if (colorChange === void 0) { colorChange = false; }
            _super.prototype._updateDisplayColor.call(this, aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChange);
            if (this._egretDisplay) {
                this._egretDisplay.alpha = aMultiplier;
            }
        };
        /** @private */
        p._updateDisplayBlendMode = function (value) {
            if (this._egretDisplay && value) {
                this._egretDisplay.blendMode = value;
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.scaleX = this._origin.scaleX * this._offset.scaleX;
            this._global.scaleY = this._origin.scaleY * this._offset.scaleY;
            this._global.skewX = this._origin.skewX + this._offset.skewX;
            this._global.skewY = this._origin.skewY + this._offset.skewY;
            this._global.x = this._origin.x + this._offset.x + this._parent._tweenPivot.x;
            this._global.y = this._origin.y + this._offset.y + this._parent._tweenPivot.y;
            if (this._displayDataList &&
                this._currentDisplayIndex >= 0 &&
                this._displayDataList[this._currentDisplayIndex] &&
                dragonBones.EgretTextureAtlas.rotatedDic[this._displayDataList[this._currentDisplayIndex].name] == 1) {
                this._global.skewX -= 1.57;
                this._global.skewY -= 1.57;
            }
        };
        return EgretSlot;
    }(dragonBones.Slot));
    dragonBones.EgretSlot = EgretSlot;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EgretTextureAtlas
     * @implements dragonBones.ITextureAtlas
     * @classdesc
     * egret引擎使用的纹理集
     */
    var EgretTextureAtlas = (function () {
        /**
         * 创建一个新的EgretTextureAtlas实例
         * @param texture 纹理集
         * @param textureAtlasRawData 纹理集数据
         * @param scale 缩放
         */
        function EgretTextureAtlas(texture, textureAtlasRawData, scale) {
            if (scale === void 0) { scale = 1; }
            this.texture = texture;
            this.textureAtlasRawData = textureAtlasRawData;
            this._textureDatas = {};
            this.scale = scale;
            this.name = textureAtlasRawData[dragonBones.ConstValues.A_NAME];
            this.parseData(textureAtlasRawData);
            this.spriteSheet = new SpriteSheet(texture);
        }
        var d = __define,c=EgretTextureAtlas,p=c.prototype;
        /**
         * 根据名字获取纹理
         * @param fullName 纹理的名字
         * @returns {egret.Texture} 获取到的纹理
         */
        p.getTexture = function (fullName) {
            var result = this.spriteSheet.getTexture(fullName);
            if (!result) {
                var data = this._textureDatas[fullName];
                if (data) {
                    var frame = data.frame;
                    if (frame) {
                        result = this.spriteSheet.createTexture(fullName, data.region.x, data.region.y, data.region.width, data.region.height, -frame.x, -frame.y, frame.width, frame.height);
                    }
                    else {
                        result = this.spriteSheet.createTexture(fullName, data.region.x, data.region.y, data.region.width, data.region.height);
                    }
                    if (data.rotated) {
                        EgretTextureAtlas.rotatedDic[fullName] = 1;
                    }
                }
            }
            return result;
        };
        /**
         * 释放资源
         */
        p.dispose = function () {
            this.texture = null;
        };
        /**
         * 根据子纹理的名字获取子纹理所在的实际矩形区域
         * @param subTextureName 子纹理的名字
         * @returns {*} 子纹理所在的矩形区域
         */
        p.getRegion = function (subTextureName) {
            var textureData = this._textureDatas[subTextureName];
            if (textureData && textureData instanceof dragonBones.TextureData) {
                return textureData.region;
            }
            return null;
        };
        /**
         * 根据子纹理的名字获取子纹理所在的真实矩形区域
         * @param subTextureName 子纹理的名字
         * @returns {*} 子纹理所在的矩形区域
         */
        p.getFrame = function (subTextureName) {
            var textureData = this._textureDatas[subTextureName];
            if (textureData && textureData instanceof dragonBones.TextureData) {
                return textureData.frame;
            }
            return null;
        };
        p.parseData = function (textureAtlasRawData) {
            this._textureDatas = dragonBones.DataParser.parseTextureAtlasData(textureAtlasRawData, this.scale);
        };
        EgretTextureAtlas.rotatedDic = {};
        return EgretTextureAtlas;
    }());
    dragonBones.EgretTextureAtlas = EgretTextureAtlas;
})(dragonBones || (dragonBones = {}));
/*
 * File:   ui-revolute-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIRevoluteJoint
 * @extends UIElement
 * 转动关节。它将两个刚体钉在一起，或者把一个刚体钉在场景上。
 * 可以设置马达参数、 角度限制和其他参数，来决定两个刚体之间的相对运动。
 *
 */
function UIRevoluteJoint() {
	return;
}

UIRevoluteJoint.prototype = new UIOneJoint();
UIRevoluteJoint.prototype.isUIJoint = true;
UIRevoluteJoint.prototype.isUIRevoluteJoint = true;

UIRevoluteJoint.prototype.saveProps = ["enableMotor", "enableLimit", "lowerAngle", "upperAngle", "maxMotorTorque", "motorSpeed"];
UIRevoluteJoint.prototype.initUIRevoluteJoint = function(type) {
	this.initUIOneJoint(type);	
	
	return this;
}

/**
 * @method setMotorSpeed
 * 设置马达的转速（只有在启用马达时有效）。
 * @param {Number} motorSpeed 转速。单位为幅度，正数顺时针转，负数逆时针转。 
 * @return {UIElement} 返回控件本身。
 *
 */
UIRevoluteJoint.prototype.setValue = UIRevoluteJoint.prototype.setMotorSpeed = function(motorSpeed) {
	if(this.joint) {
		this.joint.SetMotorSpeed(motorSpeed);
	}

	return this;
}

/**
 * @method getJoint
 * 获取Box2d的Joint对象。
 * @return {Object} 返回Joint对象。
 *
 * 参考：http://bacon2d.com/docs/qml-bacon2d-revolutejoint.html
 *
 */
UIRevoluteJoint.prototype.getJoint = function() { 
	return this.joint;
}

/**
 * @method getMotorSpeed
 * 获取马达的转速。
 * @return {Number} 返回马达的转速。
 *
 */
UIRevoluteJoint.prototype.getValue = UIRevoluteJoint.prototype.getMotorSpeed = function() {
	if(this.joint) {
		return this.joint.GetMotorSpeed();
	}

	return 0;
}

UIRevoluteJoint.prototype.recreateJoint = function() {
	var world = this.getWindow().world;

	if(world) {
		Physics.destroyJointForElement(world, this);
		Physics.createJoint(world, this);
	}

	return;
}

function UIRevoluteJointCreator() {
	var args = ["ui-revolute-joint", "ui-revolute-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIRevoluteJoint();
		return g.initUIRevoluteJoint(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIRevoluteJointCreator());

/*
 * File: utils.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: some functions to help load dragbones.
 * Web: https://github.com/drawapp8 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */


function loadDragonBoneArmature(textureJsonURL, skeletonJsonURL, textureURL, onDone) {
	var texture = new Image();

	texture.onload = function()	{
		httpGetJSON(textureJsonURL, function(data) {
			var textureData = data;
			if(!data) {
				console.log("Get Json Failed:" + textureJsonURL);
				return;
			}

			httpGetJSON(skeletonJsonURL, function(data) {
				if(!data) {
					console.log("Get Json Failed:" + skeletonJsonURL);
					return;
				}

				var skeletonData = data;
				var factory = new dragonBones.factorys.GeneralFactory();

				factory.addSkeletonData(dragonBones.objects.DataParser.parseSkeletonData(skeletonData));
				factory.addTextureAtlas(new dragonBones.textures.GeneralTextureAtlas(texture, textureData));
			
				for(var i = 0; i < skeletonData.armature.length; i++) {
					var name = skeletonData.armature[i].name;
					var armature = factory.buildArmature(name);

					if(i === 0) {
						onDone(armature);
					}
				}
			});
		});
	}

	texture.src = textureURL;

	return;
}

function onArmatureCreated(armature) {
	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");

	armature.setPosition(300, 300);

	function update() {
		ctx.clearRect(0,0,canvas.width, canvas.height);

		dragonBones.animation.WorldClock.clock.advanceTime(1/60);

		armature.draw(ctx);

		setTimeout(update, 16);
	}
	
	function changeAnimation() 	{
		do	{
			var index = Math.floor(Math.random() * armature.animation.animationNameList.length);
			var animationName = armature.animation.animationNameList[index];
		}while (animationName == armature.animation.getLastAnimationName());

		armature.animation.gotoAndPlay(animationName);
	}
	
	canvas.onclick = changeAnimation;
	dragonBones.animation.WorldClock.clock.add(armature);

	changeAnimation();
	update();

	return;
}

/*
 * File:   ui-sound.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sound for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISoundMusic
 * @extends UICheckBox
 * 背景音乐。在运行时它是控制背景音乐的开关，在设计时它是添加背景音乐文件的接口。
 *
 * 添加的背景音乐文件是全局的，删除背景音乐控件并不会删除背景音乐文件。
 *
 * 可以通过任何一个控件调用playSoundMusic播放背景音乐。
 *
 */
function UISoundMusic() {
	return;
}

UISoundMusic.prototype = new UICheckBox();
UISoundMusic.prototype.isUISoundMusic = true;

UISoundMusic.prototype.initUISoundMusic = function(type) {
	this.initUICheckBox(type);	

	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UISoundMusic.prototype.shapeCanBeChild = function(shape) {
	return false;
}


UISoundMusic.prototype.setValue = function(value) {
	var wm = this.getWindowManager();

	if(!wm) {
		return this;
	}

	if(this.mode === Shape.MODE_EDITING) {
		return this;
	}
	
	wm.setSoundMusicsEnable(value);
	
	return this;
}

UISoundMusic.prototype.getValue = function(value) {
	var wm = this.getWindowManager();

	if(!wm) {
		return true;
	}

	if(this.mode === Shape.MODE_EDITING) {
		return wm.soundMusicAutoPlay;
	}
	else {
		return wm.soundMusicsPlaying;
	}
}

UISoundMusic.prototype.isPlaying = UISoundMusic.prototype.getValue;

function UISoundMusicCreator() {
	var args = ["ui-sound-music", "ui-sound-music", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISoundMusic();
		return g.initUISoundMusic(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISoundMusicCreator());

/*
 * File:   ui-art-text.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic art-text for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIArtText() {
	return;
}

UIArtText.prototype = new UIElement();
UIArtText.prototype.isUIArtText = true;

UIArtText.prototype.initUIArtText = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	this.setImage(UIElement.IMAGE_DEFAULT, null);

	this.setCanRectSelectable(false, true);
	this.addEventNames(["onUpdateTransform"]);

	return this;
}

UIArtText.prototype.setText = function(text) {
	var url = null;
	if(this.text !== text) {
		this.text = text;
		this.setImage(UIElement.IMAGE_DEFAULT, null);
	}

	return this;
}

UIArtText.prototype.getBgImage = function() {
	var image = this.getImageByType(UIElement.IMAGE_DEFAULT);

	if((!image || !image.src) && this.text) {
		var url = UIElement.createArtTextImage(this.text, this.style);	
		this.setImage(UIElement.IMAGE_DEFAULT, url);
		image = this.getImageByType(UIElement.IMAGE_DEFAULT);
	}

	return image;
}

UIArtText.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIArtTextCreator() {
	var args = ["ui-art-text", "ui-art-text", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIArtText();
		return g.initUIArtText(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIArtTextCreator());

/*
 * File:   ui-pulley-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  pulley joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPulleyJoint() {
	return;
}

UIPulleyJoint.prototype = new UIFourJoint();
UIPulleyJoint.prototype.isUIJoint = true;
UIPulleyJoint.prototype.isUIPulleyJoint = true;

UIPulleyJoint.prototype.initUIPulleyJoint = function(type, w, h) {
	this.initUIFourJoint(type, w, h);	
	this.visibleAtRunTime = true;

	return this;
}

function UIPulleyJointCreator() {
	var args = ["ui-pulley-joint", "ui-pulley-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPulleyJoint();
		return g.initUIPulleyJoint(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPulleyJointCreator());

/*
 * File:   ui-edge.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  edge shape
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIEdge
 * @extends UITwoPoints
 * 边刚体。可以用一些线段来模拟复杂的地形。边刚体是静态刚体，只能设置摩擦力和弹力系数。
 */
function UIEdge() {
	return;
}

UIEdge.prototype = new UITwoPoints();
UIEdge.prototype.isUIEdge = true;
UIEdge.prototype.isUIPhysicsShape = true;
UIEdge.prototype.saveProps = ["friction", "restitution", "density", "groupIndex"];

UIEdge.prototype.initUIEdge = function(type, w, h) {
	this.initUITwoPoints(type);	

	return this;
}

UIEdge.prototype.setEnable = function(enable) {
	this.enable = enable;
	if(this.body) {
		this.body.SetActive(enable);
	}

	return this;
}


UIEdge.prototype.onBodyCreated = function() {
}

function UIEdgeCreator() {
	var args = ["ui-edge", "ui-edge", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIEdge();
		return g.initUIEdge(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIEdgeCreator());

/*
 * File:   ui-status.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Use color to present a value.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIStatus
 * @extends UIElement
 * 用来表示的事物状态，比如怪物的血量，角色的生命值。可以用setValue来改变当前的状态，value取值0-100。
 * 值为0触发onBecomeZero事件。
 * 值为100触发onBecomeFull事件。
 * 值有变化触发onChanged事件。
 *
 */

/**
 * @event onBecomeZero
 * value变为0时触发本事件。
 */

/**
 * @event onBecomeFull
 * value变为100时触发本事件。
 */

/**
 * @event onChanged
 * value变化时触发本事件。
 * @param {Number} value 当前的值。
 */

function UIStatus() {
	return;
}

UIStatus.prototype = new UIElement();
UIStatus.prototype.isUIStatus = true;

UIStatus.prototype.saveProps = ["horizonal", "realValue"];
UIStatus.prototype.initUIStatus = function(type, w, h) {
	this.initUIElement(type);	

	this.realValue = 0.5;
	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onBecomeZero", "onBecomeFull", "onChanged", "onUpdateTransform"]);

	return this;
}

UIStatus.prototype.shapeCanBeChild = function(shape) {
	return this.children.length===0 && shape.isUILabel;
}

UIStatus.prototype.setValue = function(value) {
	this.realValue = Math.max(0, Math.min(100, value))/100;

	if(this.realValue === 0) {
		this.callOnBecomeZeroHandler();
	}
	else if(this.realValue === 1) {
		this.callOnBecomeFullHandler();
	}

	this.callOnChangedHandler(this.getValue());

	return this.getValue();
}

UIStatus.prototype.getValue = function() {
	return Math.round(this.realValue * 100);
}

UIStatus.prototype.paintSelfOnly = function(canvas) {
	var value = this.realValue;
	var r = this.roundRadius;
	var bh = Math.round(value * this.h);
	var th = Math.round((1-value) * this.h);
	var lw = Math.round(value * this.w);
	var rw = Math.round((1-value) * this.w);

	canvas.save();
	canvas.beginPath();
	drawRoundRect(canvas, this.w, this.h, r);
	canvas.clip();

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.beginPath();
		if(this.horizonal) {
			canvas.translate(lw, 0);
			canvas.rect(0, 0, rw, this.h);
			canvas.translate(-lw, 0);
		}
		else {
			canvas.rect(0, 0, this.w, th);
		}
		canvas.fill();
	}

	if(!this.isTextColorTransparent()) {
		canvas.fillStyle = this.style.textColor;
		canvas.beginPath();
		if(this.horizonal) {
			canvas.rect(0, 0, lw, this.h);
		}
		else {
			canvas.translate(0, th);
			canvas.rect(0, 0, this.w, bh);
			canvas.translate(0, -th);
		}
		canvas.fill();
	}
	canvas.restore();

	if(!this.isStrokeColorTransparent() && this.style.lineWidth) {
		canvas.beginPath();
		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.BL | RoundRect.BR | RoundRect.TL | RoundRect.TR);
		canvas.stroke();
	}
	canvas.beginPath();

	return;
}

function UIStatusCreator() {
	var args = ["ui-status", "ui-status", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStatus();
		return g.initUIStatus(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIStatusCreator());

/*
 * File:   ui-timer.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic timer for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

/**
 * @class UITimer
 * @extends UIElement
 * 定时器。用于实现定时操作，可以通过setEnable启用或关闭定时器。定时器用来代替javascript原生的setInterval和setTimeout方法，它会在窗口退到后台自动暂停，取消预览时自动停止。可以使用setEnable来启用或禁用定时器。
 */

/**
 * @property {Number} times
 * 触发的次数，默认为100000000。
 */

/**
 * @property {String} durationType 
 * "random"使用随机时长，否则使用固定时长。
 */

/**
 * @property {Number} duration 
 * 使用固定时长的时长，默认为500，单位为毫秒。
 */

/**
 * @property {Number} durationMin
 * 使用随机时长的最小时长。
 */

/**
 * @property {Number} durationMax
 * 使用随机时长的最大时长。
 */
function UITimer() {
	return;
}

UITimer.prototype = new UIElement();
UITimer.prototype.isUITimer = true;
UITimer.prototype.saveProps = ["times", "delayStart", "durationType", "duration", "durationMin", "durationMax"];

UITimer.prototype.initUITimer = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_AUTO;
	this.addEventNames(["onTimeout"]);

	return this;
}

UITimer.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UITimer.prototype.onInit = function() {
	if(this.enable) {
		this.start();
		console.log("start timer.");
	}
	else {
		console.log("not start disable timer.");
	}

	return;
}

UITimer.prototype.setEnable = function(enable) {
	var parent = this.getParent();
	if(!parent || this.enable == enable) {
		return this;
	}
	
	this.enable = enable;
	if(enable) {
		this.start();
	}
	else {
		this.stop();
	}

	return;
}

UITimer.prototype.getDuration = function() {
	if(this.durationType === "random") {
		var duration = this.durationMin + Math.random() * (this.durationMax - this.durationMin);
		
		return duration;
	}
	else {
		return this.duration;
	}
}

UITimer.prototype.start = function() {
	if(!this.enable) {
		console.log("can not start disabled timer, please call setEnable first.");
	}

	if(this.timerID) {
		console.log("Timer is alread started:" + this.timerID);
		return;
	}

	var me = this;
	this.paused = false;
	this.startTime = Date.now();
	
	function onTimer() {
		if(!me.enable || !me.timerID || !me.parentShape || !me.win) {
			me.timerID = null;
			return;
		}

		if(me.paused) {
			me.timerID = setTimeout(onTimer, me.getDuration());
			return;
		}

		if(me.timeScaleIsZero()) {
			me.timerID = setTimeout(onTimer, me.getDuration());
			return;	
		}

		if(me.win.isVisible()) {
			me.callOnTimeoutHandler();
			me.times--;
		}

		if(me.times <= 0) {
			me.timerID = null;
			console.log("timer stop " + me.name);
		}
		else {
			me.timerID = setTimeout(onTimer, me.getDuration());
		}
	}

	if(this.delayStart) {
		this.timerID = setTimeout(function() {
			me.timerID = setTimeout(onTimer, me.getDuration());
		}, this.delayStart);
	}
	else {
		this.timerID = setTimeout(onTimer, me.getDuration());
	}

	return this;
}

UITimer.prototype.stop = function() {
	if(this.timerID) {
		clearTimeout(this.timerID);
		this.timerID = null;
	}

	return this;
}

/**
 * @method pause
 * 暂停。
 * @return {UIElement} 返回控件本身。
 *
 */
UITimer.prototype.pause = function() {
	this.paused = true;

	return this;
}

/**
 * @method resume 
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UITimer.prototype.resume = function() {
	this.paused = false;

	return this;
}

UITimer.prototype.getElapsedTime = function() {
	return Date.now() - this.startTime;
}

function UITimerCreator() {
	var args = ["ui-timer", "ui-timer", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITimer();
		return g.initUITimer(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITimerCreator());

/*
 * File:   ui-skeleton-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  SkelentonAnimation
 *
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 *
 */

/**
 * @class UISkeletonAnimation
 * @extends UIElement
 * 骨骼动画。目前支持[DragonBones](https://github.com/DragonBones)和[Spine](https://github.com/EsotericSoftware/spine-runtimes)两种格式。
 */
function UISkeletonAnimation() {
	return;
}

UISkeletonAnimation.prototype = new UIElement();
UISkeletonAnimation.prototype.isUISkeletonAnimation = true;

UISkeletonAnimation.prototype.saveProps = ["animationName", "skinName", "animationScaleX", "animationScaleY",
"textureJsonURL", "skeletonJsonURL", "textureURL"];

UISkeletonAnimation.prototype.urlProps = ["textureJsonURL", "skeletonJsonURL", "textureURL"];

UISkeletonAnimation.prototype.initUISkeletonAnimation = function(type, w, h) {
	this.initUIElement(type);

	this.setDefSize(w, h);
	this.setSizeLimit(50, 50);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onDoubleClick", "onUpdateTransform", "onLoadDone"]);

	this.animTimeScale = 1;
	this.animationScaleX = 1;
	this.animationScaleY = 1;
	this.animationNames = [];

	return this;
}

/**
 * @method play
 * 播放动画。
 * @param {String} name 动作名称。
 * @param {Number} repeatTimes 播放次数。
 * @param {Function} onDone (可选) 播放指定次数后的回调函数。
 * @param {Function} onOneCycle (可选) 每播放一次的回调函数。
 * @param {Number} useFadeIn (可选) 启用渐变。
 * @return {Object} 返回Promise
 *
 */
UISkeletonAnimation.prototype.play = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	var me = this;
	var deferred = Deferred();
	this.resume();
	this.doPlay(animationName, repeatTimes, function() {
		if(typeof onDone === 'function') {
			onDone.call(me);
		}
		deferred.resolve();
	}, function() {
		if(typeof onOneCycle === 'function') {
			onOneCycle.call(me);
		}
	}, useFadeIn, duration);

	return deferred.promise;
};


UISkeletonAnimation.prototype.setSkeletonJsonURL = function(skeletonJsonURL) {
	this.skeletonJsonURL = skeletonJsonURL;

	return this;
}

UISkeletonAnimation.prototype.getSkeletonJsonURL = function() {
	return this.skeletonJsonURL ? this.skeletonJsonURL : "";
}

UISkeletonAnimation.prototype.setTextureJsonURL = function(textureJsonURL) {
	this.textureJsonURL = textureJsonURL;

	return this;
}

UISkeletonAnimation.prototype.getTextureJsonURL = function() {
	return this.textureJsonURL ? this.textureJsonURL : "";
}

UISkeletonAnimation.prototype.setTextureURL = function(textureURL) {
	this.textureURL = textureURL;

	return this;
}

UISkeletonAnimation.prototype.getTextureURL = function() {
	return this.textureURL ? this.textureURL : "";
}

UISkeletonAnimation.prototype.loadSheletonData = function(textureJsonURL, skeletonJsonURL, textureURL, onDone) {
	var me = this;
	ResLoader.loadImage(textureURL, function(texture) {
		var loadFunc = ResLoader.loadJson;
		if(textureJsonURL.indexOf(".atlas") > 0) {
			loadFunc = ResLoader.loadData;
		}

		loadFunc(textureJsonURL, function(data) {
			var textureData = data;
			if(!data) {
				console.log("Get Json Failed:" + textureJsonURL);
				return;
			}

			ResLoader.loadJson(skeletonJsonURL, function(data) {
				if(!data) {
					console.log("Get Json Failed:" + skeletonJsonURL);
					return;
				}

				var skeletonData = data;
				onDone(texture, textureData, skeletonData);
			});
		});
	});

	return;
}

UISkeletonAnimation.prototype.createSkelentonAnimation = function(onDone) {
	var me = this;
	this.destroyArmature();

	function onDataLoad(texture, textureData, skeletonData) {
		me.createArmature(texture, textureData, skeletonData);
		var animationName = me.getAnimationName();
		if(me.skinName) {
			me.setSkin(me.skinName);
		}
		me.play(animationName);
		me.callOnLoadDoneHandler();
		if(onDone) {
			onDone();
		}
	}

	this.loadSheletonData(this.textureJsonURL, this.skeletonJsonURL, this.textureURL, onDataLoad);

	return;
}

UISkeletonAnimation.prototype.onFromJsonDone = function(js) {
	if(this.textureURL && this.textureJsonURL && this.skeletonJsonURL) {

		function onDataLoad(texture, textureData, skeletonData) {
			console.log("skeleton preload data done.");
		}

		this.loadSheletonData(this.textureJsonURL, this.skeletonJsonURL, this.textureURL, onDataLoad);
	}

	if(js && js.animationScale) {
		if(!js.animationScaleX) {
			this.animationScaleX = js.animationScale;
		}

		if(!js.animationScaleY) {
			this.animationScaleY = js.animationScale;
		}
		delete this.animationScale;
	}

	return;
}

UISkeletonAnimation.prototype.onInit = function() {
	this.reload();

	return;
}

UISkeletonAnimation.prototype.reload = function(onDone) {
	if(this.textureURL && this.textureJsonURL && this.skeletonJsonURL) {
		this.createSkelentonAnimation(onDone);
	}

	return;
}

UISkeletonAnimation.prototype.destroy = function() {
	this.destroyArmature();
	Shape.prototype.destroy.call(this);

	return;
}

UISkeletonAnimation.prototype.callOnLoadDoneHandler = function() {
	if(this.mode === Shape.MODE_EDITING) {
		return;
	}

	if(!this.handleOnLoadDone) {
		var sourceCode = this.events["onLoadDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnLoadDone = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleOnLoadDone) {
		try {
			this.handleOnLoadDone();
		}catch(e) {
			console.log("this.handleOnLoadDone:" + e.message);
		}
	}

	return true;
}

UISkeletonAnimation.prototype.destroyArmature = function() {
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.pause = function() {
	return this;
}

/**
 * @method resume
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.resume = function() {
	return this;
}

/**
 * @method getAnimationDuration
 * 获取指定动作的时长。
 * @param {String} animaName 动作名称。
 * @return {UIElement} 返回指定动画的时长。
 *
 */
UISkeletonAnimation.prototype.getAnimationDuration = function(animaName) {
}

UISkeletonAnimation.prototype.getAnimationNames = function() {
	return this.animationNames;
}

UISkeletonAnimation.prototype.setAnimationName = function(animationName) {
	this.animationName = animationName;

	return this;
}

/**
 * @method getAnimationName
 * 获取当前播放动画得名称。
 * @return {String} 返回当前播放的动画名称
 *
 */
UISkeletonAnimation.prototype.getAnimationName = function() {
	if(this.animationName) return this.animationName;

	var animationNames = this.getAnimationNames();
	return animationNames ? animationNames[0] : "";
}

UISkeletonAnimation.prototype.setScale = function(animationScale) {
	this.animationScaleX = animationScale;
	this.animationScaleY = animationScale;
	return this;
}

UISkeletonAnimation.prototype.getScale = function() {
	return this.animationScaleX;
}

UISkeletonAnimation.prototype.setScaleX = function(animationScale) {
	this.animationScaleX = animationScale;
	return this;
}

UISkeletonAnimation.prototype.setScaleY = function(animationScale) {
	this.animationScaleY = animationScale;
	return this;
}

UISkeletonAnimation.prototype.getScaleX = function(animationScale) {
	return this.animationScaleX;
}

UISkeletonAnimation.prototype.getScaleY = function(animationScale) {
	return this.animationScaleY;
}

UISkeletonAnimation.prototype.applyScale = function(canvas) {
}

/**
 * @method setTimeScale
 * 设置时间缩放比例, 小于1变慢，大于1变快。
 * @param {Number} animTimeScale 时间缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.setTimeScale = function(animTimeScale) {
	this.animTimeScale = animTimeScale;

	return this;
}

UISkeletonAnimation.prototype.setDuration = function(duration) {
//TODO
}

UISkeletonAnimation.prototype.preprocessTextureAtlas = function(skeletonData) {
	return skeletonData;
}

/**
 * @method setSkin
 * 设置当前皮肤的名称。
 * @param {String} skinName 皮肤的名称。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.setSkin = function(skinName) {
	this.skinName = skinName;

	return this;
}

/**
 * @method getSkin
 * 获取当前皮肤的名称。
 * @return {String} 返回当前皮肤的名称。
 *
 */
UISkeletonAnimation.prototype.getSkin = function() {
	return this.skinName;
}

UISkeletonAnimation.prototype.getSkins = function() {
	return ["default"];
}

UISkeletonAnimation.prototype.isPaused = function() {
	return this.timeScaleIsZero();
}

UISkeletonAnimation.prototype.shapeCanBeChild = UISprite.prototype.shapeCanBeChild;


/*
 * File:   ui-skeleton-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  SkelentonAnimation
 *
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 *
 */

/**
 * @class UIDragonBones
 * @extends UISkeletonAnimation
 * 龙骨骨骼动画。参考：[DragonBones](https://github.com/DragonBones)
 */
function UIDragonBones() {
	return;
}

UIDragonBones.prototype = new UISkeletonAnimation();
UIDragonBones.prototype.isUIDragonBones = true;
UIDragonBones.prototype.initUIDragonBones = UISkeletonAnimation.prototype.initUISkeletonAnimation;

UIDragonBones.prototype.pause = function() {
	if(this.armature) {
		this.armature.animation.stop();
	}

	return this;
}

UIDragonBones.prototype.resume = function() {
	if(this.armature) {
		this.armature.animation.play();
	}

	return this;
}

UIDragonBones.prototype.setupLoop = function(animationName, repeatTimes, onDone, onOneCycle) {
	var me = this;
	function loopComplete(e) {
		if(!e || !e.animationState
			|| e.animationState.name != animationName) {
			return;
		}
		if(me.onOneCycle) {
			try {
				me.onOneCycle();
			} catch(e) {
				console.debug('onOneCycle:', e);
			}
		}
	}

	function complete() {
		//me.stop();
		if(me.onDone) {
			try {
				me.onDone();
			} catch(e) {
				console.debug('onDone:', e);
			}
		}
	}

	if(!isNaN(repeatTimes)) {
		this.onDone = onDone;
		this.onOneCycle = onOneCycle;
		this._armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, complete);
		this._armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, loopComplete);
	}
}

UIDragonBones.prototype.doPlay = UIDragonBones.prototype.gotoAndPlay = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	this.animationName = animationName;

	if(this.armature) {
		var armature = this.armature;

		if(animationName && armature.animation.animationList.indexOf(animationName) >= 0) {
			//if(onDone || onOneCycle || repeatTimes || typeof repeatTimes === 'undefined') {
			if(onDone || onOneCycle || repeatTimes) {
				repeatTimes = isNaN(repeatTimes) ? 0xFFFFFFFF : repeatTimes;
				this.setupLoop.apply(armature.animation, arguments);
			}
			var fadeIn = !useFadeIn ? 0 : undefined;
			armature.animation.gotoAndPlay(animationName, fadeIn, duration, repeatTimes);
		}
		else if(this.animations && animationName) {
			this.animate(animationName);
		}
		else {
			console.log("Unknow animation name: " + animationName);
		}
	}

	return this;
}

UIDragonBones.prototype.destroyArmature = function() {
	if(this.armature) {
		this.armature = null;
	}

	return;
}

UISkeletonAnimation.prototype.destroy = function() {
	this.destroyArmature();
	Shape.prototype.destroy.call(this);

	return;
}

UISkeletonAnimation.prototype.getSlotRect = function(name) {
	if(!this.armature) {
		return null;
	}

	var slotList = this.armature._slotList;
	for(var i = 0; i < slotList.length; i++) {
		var iter = slotList[i];
		if(iter.name === name) {
			var display = iter.getDisplay();
			return display.textureAtlasRect;
		}
	}

	return null;
}

UISkeletonAnimation.prototype.replaceSlotImage = function(name, image, imageRect) {
	if(!this.armature) {
		return this;
	}

	if(imageRect && imageRect.w) {
		imageRect.width = imageRect.w;
	}
	if(imageRect && imageRect.h) {
		imageRect.height = imageRect.h;
	}

	var slotList = this.armature._slotList;
	for(var i = 0; i < slotList.length; i++) {
		var iter = slotList[i];
		if(iter.name === name) {
			iter.image = image;
			iter.imageRect = imageRect;
		}
	}

	return;
}

UIDragonBones.prototype.advanceTime = function() {
	var self = this;
	var armature = this.armature;

	armature.advanceTime = function() {
		if(self.isVisible()) {
			dragonBones.Armature.prototype.advanceTime.apply(this, arguments);
		}
	}

	return this;
}

UIDragonBones.prototype.createArmature = function(texture, textureData, skeletonData) {
	if(this.armature) {
		this.armature = null;
	}

	if(!this.rendererContext) {
		this.rendererContext = new CanvasRenderer();
		this.rendererContext.container = new DisplayObjectContainer();
        MainContext.instance.rendererContext = this.rendererContext;
	}
	else {
		this.rendererContext.container.removeChildren();
	}

	var factory = null;
	if(!MainContext.instance.factory) {
		factory = new dragonBones.EgretFactory();
		MainContext.instance.factory = factory;
	}
	else {
		factory = MainContext.instance.factory;
	}

	if(!factory.getSkeletonData(skeletonData.name)) {
		factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
	}

	if(!factory.getTextureAtlas(textureData.name)) {
		factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
	}

	var armature = factory.buildArmature(skeletonData.armature[0].name, skeletonData.name);
	this.rendererContext.container.addChild(armature.display);

	this.armature = armature;
	this.animationNames = armature.animation.animationList;
	this.animationName = this.animationNames.indexOf(this.animationName) > -1 ? this.animationName : this.animationNames[0];
}

UIDragonBones.prototype.getDuration = UIDragonBones.prototype.getAnimationDuration = function(animaName) {
	if(!this.armature) return 0;

	animaName = animaName || this.animationName;

	var index = this.armature.animation.animationList.indexOf(animaName);
	if(index > -1) {
		return this.armature.animation.animationDataList[index].duration;
	}

	return 0;
}

UIDragonBones.prototype.paintSelfOnly = function(canvas) {
	if(this.armature) {
		if(!this.isPaused()) {
			var dt = (canvas.timeStep * this.animTimeScale)/1000;
			this.armature.advanceTime(dt);
		}

		var x = this.w >> 1;
		var y = this.h >> 1;
		canvas.save();
		var scaleX = (this.animationScaleX) === 1 ? 1.01 : this.animationScaleX;
		var scaleY = (this.animationScaleY) === 1 ? 1.01 : this.animationScaleY;

		this.rendererContext.setScale(scaleX, scaleY);
		this.rendererContext.setPosition(x, y);
		MainContext.instance.renderLoop.call(this.rendererContext, canvas);
		canvas.restore();

		canvas.needRedraw++;
	}

	return;
}

function UISkeletonAnimationCreator(type) {
	var args = [type, type, null, 1];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDragonBones();
		return g.initUIDragonBones(this.type, 200, 200);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UISkeletonAnimationCreator("ui-dragonbones"));
ShapeFactoryGet().addShapeCreator(new UISkeletonAnimationCreator("ui-skeleton-animation"));

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  // void 0 always evaluates to undefined and hence we do not need to depend on
  // the definition of the global variable named 'undefined'.
  return val !== void 0;
};


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler
 * options or the value set in the CLOSURE_DEFINES object.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else if (goog.global.CLOSURE_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.define('goog.DEBUG', true);


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode
 *
 */
goog.define('goog.STRICT_MODE_COMPATIBLE', false);


/**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */
goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);


/**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */
goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);


/**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
  }

  goog.constructNamespace_(name);
};


/**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {Object=} opt_obj The object to embed in the namespace.
 * @private
 */
goog.constructNamespace_ = function(name, opt_obj) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name, opt_obj);
};


/**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;


/**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 */
goog.module = function(name) {
  if (!goog.isString(name) ||
      !name ||
      name.search(goog.VALID_MODULE_RE_) == -1) {
    throw Error('Invalid module identifier');
  }
  if (!goog.isInModuleLoader_()) {
    throw Error('Module ' + name + ' has been loaded incorrectly.');
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw Error('goog.module may only be called once per module.');
  }

  // Store the module name for the loader.
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      // goog.require only return a value with-in goog.module files.
      return name in goog.loadedModules_ ?
          goog.loadedModules_[name] :
          goog.getObjectByName(name);
    } else {
      return null;
    }
  }
};


/**
 * @private {?{moduleName: (string|undefined)}}
 */
goog.moduleLoaderState_ = null;


/**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */
goog.isInModuleLoader_ = function() {
  return goog.moduleLoaderState_ != null;
};


/**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw new Error('goog.module.declareLegacyNamespace must be called from ' +
        'within a goog.module');
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw Error('goog.module must be called prior to ' +
        'goog.module.declareLegacyNamespace.');
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


/**
 * Forward declare type information. Used to assign types to goog.global
 * referenced object that would otherwise result in unknown type references
 * and thus block property disambiguation.
 */
goog.forwardDeclare('Document');
goog.forwardDeclare('XMLHttpRequest');


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return (name in goog.loadedModules_) ||
        (!goog.implicitNamespaces_[name] &&
            goog.isDefAndNotNull(goog.getObjectByName(name)));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */
  goog.implicitNamespaces_ = {'goog.module': true};

  // NOTE: We add goog.module as an implicit namespace as goog.module is defined
  // here and because the existing module package has not been moved yet out of
  // the goog.module namespace. This satisifies both the debug loader and
  // ahead-of-time dependency management.
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {!Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean=} opt_isModule Whether this dependency must be loaded as
 *     a module as declared by goog.module.
 */
goog.addDependency = function(relPath, provides, requires, opt_isModule) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      deps.pathIsModule[path] = !!opt_isModule;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * @param {string} msg
 * @private
 */
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console['error'](msg);
  }
};


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 * @return {?} If called within a goog.module file, the associated namespace or
 *     module otherwise null.
 */
goog.require = function(name) {

  // If the object already exists we do not need do do anything.
  if (!COMPILED) {
    if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
      goog.maybeProcessDeferredDep_(name);
    }

    if (goog.isProvided_(name)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(name);
      } else {
        return null;
      }
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return null;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    goog.logToConsole_(errorMessage);

    throw Error(errorMessage);
  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * @define {boolean} Whether to load goog.modules using {@code eval} when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of {@code eval} is banned
 * so we provide an alternative.
 */
goog.define('goog.LOAD_MODULE_USING_EVAL', true);


/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);


/**
 * The registry of initialized modules:
 * the module identifier to module exports map.
 * @private @const {!Object<string, ?>}
 */
goog.loadedModules_ = {};


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * Object used to keep track of urls that have already been added. This record
   * allows the prevention of circular dependencies.
   * @private {!Object<string, boolean>}
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {{
   *   pathIsModule: !Object<string, boolean>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */
  goog.dependencies_ = {
    pathIsModule: {}, // 1 to 1

    nameToPath: {}, // 1 to 1

    requires: {}, // 1 to many

    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},

    written: {}, // Used to keep track of script files we have written.

    deferred: {} // Used to track deferred module evaluations in old IEs
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    /** @type {Document} */
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    /** @type {Document} */
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('SCRIPT');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);
      if(!script || !script.src) break;
      var src = script.src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @private
   */
  goog.importScript_ = function(src, opt_sourceText) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (importScript(src, opt_sourceText)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /** @const @private {boolean} */
  goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document &&
      goog.global.document.all);


  /**
   * Given a URL initiate retrieval and execution of the module.
   * @param {string} src Script source URL.
   * @private
   */
  goog.importModule_ = function(src) {
    // In an attempt to keep browsers from timing out loading scripts using
    // synchronous XHRs, put each load in its own script block.
    var bootstrap = 'goog.retrieveAndExecModule_("' + src + '");';

    if (goog.importScript_('', bootstrap)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /** @private {!Array<string>} */
  goog.queuedModules_ = [];


  /**
   * Return an appropriate module text. Suitable to insert into
   * a script tag (that is unescaped).
   * @param {string} srcUrl
   * @param {string} scriptText
   * @return {string}
   * @private
   */
  goog.wrapModule_ = function(srcUrl, scriptText) {
    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
      return '' +
          'goog.loadModule(function(exports) {' +
          '"use strict";' +
          scriptText +
          '\n' + // terminate any trailing single line comment.
          ';return exports' +
          '});' +
          '\n//# sourceURL=' + srcUrl + '\n';
    } else {
      return '' +
          'goog.loadModule(' +
          goog.global.JSON.stringify(
              scriptText + '\n//# sourceURL=' + srcUrl + '\n') +
          ');';
    }
  };

  // On IE9 and earlier, it is necessary to handle
  // deferred module loads. In later browsers, the
  // code to be evaluated is simply inserted as a script
  // block in the correct order. To eval deferred
  // code at the right time, we piggy back on goog.require to call
  // goog.maybeProcessDeferredDep_.
  //
  // The goog.requires are used both to bootstrap
  // the loading process (when no deps are available) and
  // declare that they should be available.
  //
  // Here we eval the sources, if all the deps are available
  // either already eval'd or goog.require'd.  This will
  // be the case when all the dependencies have already
  // been loaded, and the dependent module is loaded.
  //
  // But this alone isn't sufficient because it is also
  // necessary to handle the case where there is no root
  // that is not deferred.  For that there we register for an event
  // and trigger goog.loadQueuedModules_ handle any remaining deferred
  // evaluations.

  /**
   * Handle any remaining deferred goog.module evals.
   * @private
   */
  goog.loadQueuedModules_ = function() {
    var count = goog.queuedModules_.length;
    if (count > 0) {
      var queue = goog.queuedModules_;
      goog.queuedModules_ = [];
      for (var i = 0; i < count; i++) {
        var path = queue[i];
        goog.maybeProcessDeferredPath_(path);
      }
    }
  };


  /**
   * Eval the named module if its dependencies are
   * available.
   * @param {string} name The module to load.
   * @private
   */
  goog.maybeProcessDeferredDep_ = function(name) {
    if (goog.isDeferredModule_(name) &&
        goog.allDepsAreAvailable_(name)) {
      var path = goog.getPathFromDeps_(name);
      goog.maybeProcessDeferredPath_(goog.basePath + path);
    }
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose evaluation has been deferred.
   * @private
   */
  goog.isDeferredModule_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && goog.dependencies_.pathIsModule[path]) {
      var abspath = goog.basePath + path;
      return (abspath) in goog.dependencies_.deferred;
    }
    return false;
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose declared dependencies have all been loaded
   *     (eval'd or a deferred module load)
   * @private
   */
  goog.allDepsAreAvailable_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && (path in goog.dependencies_.requires)) {
      for (var requireName in goog.dependencies_.requires[path]) {
        if (!goog.isProvided_(requireName) &&
            !goog.isDeferredModule_(requireName)) {
          return false;
        }
      }
    }
    return true;
  };


  /**
   * @param {string} abspath
   * @private
   */
  goog.maybeProcessDeferredPath_ = function(abspath) {
    if (abspath in goog.dependencies_.deferred) {
      var src = goog.dependencies_.deferred[abspath];
      delete goog.dependencies_.deferred[abspath];
      goog.globalEval(src);
    }
  };


  /**
   * @param {function(?):?|string} moduleDef The module definition.
   */
  goog.loadModule = function(moduleDef) {
    // NOTE: we allow function definitions to be either in the from
    // of a string to eval (which keeps the original source intact) or
    // in a eval forbidden environment (CSP) we allow a function definition
    // which in its body must call {@code goog.module}, and return the exports
    // of the module.
    var previousState = goog.moduleLoaderState_;
    try {
      goog.moduleLoaderState_ = {moduleName: undefined};
      var exports;
      if (goog.isFunction(moduleDef)) {
        exports = moduleDef.call(goog.global, {});
      } else if (goog.isString(moduleDef)) {
        exports = goog.loadModuleFromSource_.call(goog.global, moduleDef);
      } else {
        throw Error('Invalid module definition');
      }

      var moduleName = goog.moduleLoaderState_.moduleName;
      if (!goog.isString(moduleName) || !moduleName) {
        throw Error('Invalid module name \"' + moduleName + '\"');
      }

      // Don't seal legacy namespaces as they may be uses as a parent of
      // another namespace
      if (goog.moduleLoaderState_.declareLegacyNamespace) {
        goog.constructNamespace_(moduleName, exports);
      } else if (goog.SEAL_MODULE_EXPORTS && Object.seal) {
        Object.seal(exports);
      }

      goog.loadedModules_[moduleName] = exports;
    } finally {
      goog.moduleLoaderState_ = previousState;
    }
  };


  /**
   * @private @const {function(string):?}
   */
  goog.loadModuleFromSource_ = function() {
    // NOTE: we avoid declaring parameters or local variables here to avoid
    // masking globals or leaking values into the module definition.
    'use strict';
    var exports = {};
    eval(arguments[0]);
    return exports;
  };


  /**
   * Writes a new script pointing to {@code src} directly into the DOM.
   *
   * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
   * the fallback mechanism.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.writeScriptSrcNode_ = function(src) {
    goog.global.document.write(
        '<script type="text/javascript" src="' + src + '"></' + 'script>');
  };


  /**
   * Appends a new script node to the DOM using a CSP-compliant mechanism. This
   * method exists as a fallback for document.write (which is not allowed in a
   * strict CSP context, e.g., Chrome apps).
   *
   * NOTE: This method is not analogous to using document.write to insert a
   * <script> tag; specifically, the user agent will execute a script added by
   * document.write immediately after the current script block finishes
   * executing, whereas the DOM-appended script node will not be executed until
   * the entire document is parsed and executed. That is to say, this script is
   * added to the end of the script execution queue.
   *
   * The page must not attempt to call goog.required entities until after the
   * document has loaded, e.g., in or after the window.onload callback.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.appendScriptSrcNode_ = function(src) {
    /** @type {Document} */
    var doc = goog.global.document;
    var scriptEl = doc.createElement('script');
    scriptEl.type = 'text/javascript';
    scriptEl.src = src;
    scriptEl.defer = false;
    scriptEl.async = false;
    doc.head.appendChild(scriptEl);
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      /** @type {Document} */
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page. This does not apply to the CSP-compliant method
      // of writing script tags.
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
          doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      var isOldIE = goog.IS_OLD_IE_;

      if (opt_sourceText === undefined) {
        if (!isOldIE) {
          if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            goog.appendScriptSrcNode_(src);
          } else {
            goog.writeScriptSrcNode_(src);
          }
        } else {
          var state = " onreadystatechange='goog.onScriptLoad_(this, " +
              ++goog.lastNonModuleScriptIndex_ + ")' ";
          doc.write(
              '<script type="text/javascript" src="' +
                  src + '"' + state + '></' + 'script>');
        }
      } else {
        doc.write(
            '<script type="text/javascript">' +
            opt_sourceText +
            '</' + 'script>');
      }
      return true;
    } else {
      return false;
    }
  };


  /** @private {number} */
  goog.lastNonModuleScriptIndex_ = 0;


  /**
   * A readystatechange handler for legacy IE
   * @param {!HTMLScriptElement} script
   * @param {number} scriptIndex
   * @return {boolean}
   * @private
   */
  goog.onScriptLoad_ = function(script, scriptIndex) {
    // for now load the modules when we reach the last script,
    // later allow more inter-mingling.
    if (script.readyState == 'complete' &&
        goog.lastNonModuleScriptIndex_ == scriptIndex) {
      goog.loadQueuedModules_();
    }
    return true;
  };

  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    /** @type {!Array<string>} The scripts we need to write this time. */
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    /** @param {string} path */
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    // record that we are going to load all these scripts.
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      goog.dependencies_.written[path] = true;
    }

    // If a module is loaded synchronously then we need to
    // clear the current inModuleLoader value, and restore it when we are
    // done loading the current "requires".
    var moduleState = goog.moduleLoaderState_;
    goog.moduleLoaderState_ = null;

    var loadingModule = false;
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      if (path) {
        if (!deps.pathIsModule[path]) {
          goog.importScript_(goog.basePath + path);
        } else {
          loadingModule = true;
          goog.importModule_(goog.basePath + path);
        }
      } else {
        goog.moduleLoaderState_ = moduleState;
        throw Error('Undefined script input');
      }
    }

    // restore the current "module loading state"
    goog.moduleLoaderState_ = moduleState;
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}


/**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */
goog.normalizePath_ = function(path) {
  var components = path.split('/');
  var i = 0;
  while (i < components.length) {
    if (components[i] == '.') {
      components.splice(i, 1);
    } else if (i && components[i] == '..' &&
        components[i - 1] && components[i - 1] != '..') {
      components.splice(--i, 2);
    } else {
      i++;
    }
  }
  return components.join('/');
};


/**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {string} File contents.
 * @private
 */
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    /** @type {XMLHttpRequest} */
    var xhr = new goog.global['XMLHttpRequest']();
    xhr.open('get', src, false);
    xhr.send();
    return xhr.responseText;
  }
};


/**
 * Retrieve and execute a module.
 * @param {string} src Script source URL.
 * @private
 */
goog.retrieveAndExecModule_ = function(src) {
  if (!COMPILED) {
    // The full but non-canonicalized URL for later use.
    var originalPath = src;
    // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
    // console doesn't auto-canonicalize XHR loads as it does <script> srcs.
    src = goog.normalizePath_(src);

    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;

    var scriptText = goog.loadFileSync_(src);

    if (scriptText != null) {
      var execModuleScript = goog.wrapModule_(src, scriptText);
      var isOldIE = goog.IS_OLD_IE_;
      if (isOldIE) {
        goog.dependencies_.deferred[originalPath] = execModuleScript;
        goog.queuedModules_.push(originalPath);
      } else {
        importScript(src, execModuleScript);
      }
    } else {
      throw new Error('load of ' + src + 'failed');
    }
  }
};


//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. As a special case, a function value is not array like, because its
 * length property is fixed to correspond to the number of expected arguments.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  // We do not use goog.isObject here in order to exclude function values.
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _evalTest_ = 1;');
      if (typeof goog.global['_evalTest_'] != 'undefined') {
        try {
          delete goog.global['_evalTest_'];
        } catch (ignore) {
          // Microsoft edge fails the deletion above in strict mode.
        }
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      /** @type {Document} */
      var doc = goog.global.document;
      var scriptElt = doc.createElement('SCRIPT');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
    throw Error('arguments.caller not defined.  goog.base() cannot be used ' +
                'with strict mode code. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
  }

  if (caller.superClass_) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var ctorArgs = new Array(arguments.length - 1);
    for (var i = 1; i < arguments.length; i++) {
      ctorArgs[i - 1] = arguments[i];
    }
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(me, ctorArgs);
  }

  // Copying using loop to avoid deop due to passing arguments object to
  // function. This is faster in many JS engines as of late 2014.
  var args = new Array(arguments.length - 2);
  for (var i = 2; i < arguments.length; i++) {
    args[i - 2] = arguments[i];
  }
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}



//==============================================================================
// goog.defineClass implementation
//==============================================================================


/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw Error('cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {
 *     !Object|
 *     {constructor:!Function}|
 *     {constructor:!Function, statics:(Object|function(Function):void)}}
 * @suppress {missingProvide}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by
 * goog.defineClass should be sealed when possible.
 */
goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (goog.defineClass.SEAL_CLASS_INSTANCES &&
      Object.seal instanceof Function) {
    // Don't seal subclasses of unsealable-tagged legacy classes.
    if (superClass && superClass.prototype &&
        superClass.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
      return ctr;
    }
    /**
     * @this {Object}
     * @return {?}
     */
    var wrappedCtr = function() {
      // Don't seal an instance of a subclass when it calls the constructor of
      // its super class as there is most likely still setup to do.
      var instance = ctr.apply(this, arguments) || this;
      instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];
      if (this.constructor === wrappedCtr) {
        Object.seal(instance);
      }
      return instance;
    };
    return wrappedCtr;
  }
  return ctr;
};


// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properties from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};


/**
 * Sealing classes breaks the older idiom of assigning properties on the
 * prototype rather than in the constructor.  As such, goog.defineClass
 * must not seal subclasses of these old-style classes until they are fixed.
 * Until then, this marks a class as "broken", instructing defineClass
 * not to seal subclasses.
 * @param {!Function} ctr The legacy constructor to tag as unsealable.
 */
goog.tagUnsealableClass = function(ctr) {
  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
  }
};


/**
 * Name for unsealable tag property.
 * @const @private {string}
 */
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';
/**
 * Copyright (c) Flyover Games, LLC
 *
 * Isaac Burns isaacburns@gmail.com
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to
 * whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * A JavaScript API for the Spine JSON animation data format.
 */
goog.provide('spine');

/**
 * @return {boolean}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {boolean=} def
 */
spine.loadBool = function (json, key, def)
{
	var value = json[key];
	switch (typeof(value))
	{
	case 'string': return (value === 'true') ? true : false;
	case 'boolean': return value;
	default: return def || false;
	}
}

/**
 * @return {void}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {boolean} value
 * @param {boolean=} def
 */
spine.saveBool = function (json, key, value, def)
{
	if ((typeof(def) !== 'boolean') || (value !== def))
	{
		json[key] = value;
	}
}

/**
 * @return {number}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {number=} def
 */
spine.loadFloat = function (json, key, def)
{
	var value = json[key];
	switch (typeof(value))
	{
	case 'string': return parseFloat(value);
	case 'number': return value;
	default: return def || 0;
	}
}

/**
 * @return {void}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {number} value
 * @param {number=} def
 */
spine.saveFloat = function (json, key, value, def)
{
	if ((typeof(def) !== 'number') || (value !== def))
	{
		json[key] = value;
	}
}

/**
 * @return {number}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {number=} def
 */
spine.loadInt = function (json, key, def)
{
	var value = json[key];
	switch (typeof(value))
	{
	case 'string': return parseInt(value, 10);
	case 'number': return 0 | value;
	default: return def || 0;
	}
}

/**
 * @return {void}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {number} value
 * @param {number=} def
 */
spine.saveInt = function (json, key, value, def)
{
	if ((typeof(def) !== 'number') || (value !== def))
	{
		json[key] = value;
	}
}

/**
 * @return {string}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {string=} def
 */
spine.loadString = function (json, key, def)
{
	var value = json[key];
	switch (typeof(value))
	{
	case 'string': return value;
	default: return def || "";
	}
}

/**
 * @return {void}
 * @param {Object.<string,?>|Array.<?>} json
 * @param {string|number} key
 * @param {string} value
 * @param {string=} def
 */
spine.saveString = function (json, key, value, def)
{
	if ((typeof(def) !== 'string') || (value !== def))
	{
		json[key] = value;
	}
}

/**
 * @constructor
 */
spine.Color = function ()
{
}

/** @type {number} */
spine.Color.prototype.r = 1;
/** @type {number} */
spine.Color.prototype.g = 1;
/** @type {number} */
spine.Color.prototype.b = 1;
/** @type {number} */
spine.Color.prototype.a = 1;

/**
 * @return {spine.Color}
 * @param {spine.Color} other
 */
spine.Color.prototype.copy = function (other)
{
	var color = this;
	color.r = other.r;
	color.g = other.g;
	color.b = other.b;
	color.a = other.a;
	return color;
}

/**
 * @return {spine.Color}
 * @param {Object.<string,?>} json
 */
spine.Color.prototype.load = function (json)
{
	var color = this;
	var rgba = 0xffffffff;
	switch (typeof(json))
	{
	case 'string': rgba = parseInt(json, 16); break;
	case 'number': rgba = 0 | json; break;
	default: rgba = 0xffffffff; break;
	}
	color.r = ((rgba >> 24) & 0xff) / 255;
	color.g = ((rgba >> 16) & 0xff) / 255;
	color.b = ((rgba >> 8) & 0xff) / 255;
	color.a = (rgba & 0xff) / 255;
	return color;
}

/**
 * @return {string}
 */
spine.Color.prototype.toString = function ()
{
	var color = this;
	return "rgba(" + (color.r * 255).toFixed(0) + "," + (color.g * 255).toFixed(0) + "," + (color.b * 255).toFixed(0) + "," + color.a + ")";
}

// from: http://github.com/arian/cubic-bezier
/**
 * @return {function(number):number}
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number=} epsilon
 */
spine.BezierCurve = function (x1, y1, x2, y2, epsilon)
{
	epsilon = epsilon || 1e-6;

	/*
	function orig_curveX(t){
		var v = 1 - t;
		return 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;
	};

	function orig_curveY(t){
		var v = 1 - t;
		return 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;
	};

	function orig_derivativeCurveX(t){
		var v = 1 - t;
		return 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (- t * t * t + 2 * v * t) * x2;
	};
	*/

	/*

	B(t) = P0*(1-t)^3 + 3*P1*(1-t)^2*t + 3*P2*(1-t)*t^2 + P3*t^3
	B'(t) = P0 - 3*(P0 - P1)*t + 3*(P0 - 2*P1 + P2)*t^2 - (P0 - 3*P1 + 3*P2 - P3)*t^3

	if P0:(0,0) and P3:(1,1)
	B(t) = 3*P1*(1-t)^2*t + 3*P2*(1-t)*t^2 + t^3
	B'(t) = 3*P1*t - 3*(2*P1 - P2)*t^2 + (3*P1 - 3*P2 + 1)*t^3

	*/

	function curveX(t)
	{
		var t2 = t*t;
		var t3 = t2*t;
		var v = 1-t;
		var v2 = v*v;
		return 3*x1*v2*t + 3*x2*v*t2 + t3;
	};

	function curveY(t)
	{
		var t2 = t*t;
		var t3 = t2*t;
		var v = 1-t;
		var v2 = v*v;
		return 3*y1*v2*t + 3*y2*v*t2 + t3;
	};

	function derivativeCurveX(t)
	{
		var t2 = t * t;
		var t3 = t2 * t;
		return 3*x1*t - 3*(2*x1-x2)*t2 + (3*x1-3*x2+1)*t3;
	};

	return function (percent)
	{
		var x = percent, t0, t1, t2, x2, d2, i;

		// First try a few iterations of Newton's method -- normally very fast.
		for (t2 = x, i = 0; i < 8; ++i)
		{
			x2 = curveX(t2) - x;
			if (Math.abs(x2) < epsilon) return curveY(t2);
			d2 = derivativeCurveX(t2);
			if (Math.abs(d2) < 1e-6) break;
			t2 = t2 - (x2 / d2);
		}

		t0 = 0, t1 = 1, t2 = x;

		if (t2 < t0) return curveY(t0);
		if (t2 > t1) return curveY(t1);

		// Fallback to the bisection method for reliability.
		while (t0 < t1)
		{
			x2 = curveX(t2);
			if (Math.abs(x2 - x) < epsilon) return curveY(t2);
			if (x > x2) t0 = t2;
			else t1 = t2;
			t2 = (t1 - t0) * 0.5 + t0;
		}

		// Failure
		return curveY(t2);
	};
}

// from: spine-libgdx/src/com/esotericsoftware/spine/Animation.java
/**
 * @return {function(number):number}
 * @param {number} cx1
 * @param {number} cy1
 * @param {number} cx2
 * @param {number} cy2
 */
spine.StepBezierCurve = function (cx1, cy1, cx2, cy2)
{
	var bezierSegments = 10;
	var subdiv_step = 1 / bezierSegments;
	var subdiv_step2 = subdiv_step * subdiv_step;
	var subdiv_step3 = subdiv_step2 * subdiv_step;
	var pre1 = 3 * subdiv_step;
	var pre2 = 3 * subdiv_step2;
	var pre4 = 6 * subdiv_step2;
	var pre5 = 6 * subdiv_step3;
	var tmp1x = -cx1 * 2 + cx2;
	var tmp1y = -cy1 * 2 + cy2;
	var tmp2x = (cx1 - cx2) * 3 + 1;
	var tmp2y = (cy1 - cy2) * 3 + 1;
	var curves_0 = (cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3);
	var curves_1 = (cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3);
	var curves_2 = (tmp1x * pre4 + tmp2x * pre5);
	var curves_3 = (tmp1y * pre4 + tmp2y * pre5);
	var curves_4 = (tmp2x * pre5);
	var curves_5 = (tmp2y * pre5);

	return function (percent)
	{
		var dfx   = curves_0;
		var dfy   = curves_1;
		var ddfx  = curves_2;
		var ddfy  = curves_3;
		var dddfx = curves_4;
		var dddfy = curves_5;

		var x = dfx, y = dfy;
		var i = bezierSegments - 2;
		while (true) {
			if (x >= percent) {
				var lastX = x - dfx;
				var lastY = y - dfy;
				return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
			}
			if (i === 0) break;
			i--;
			dfx += ddfx;
			dfy += ddfy;
			ddfx += dddfx;
			ddfy += dddfy;
			x += dfx;
			y += dfy;
		}
		return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
	};
}

/**
 * @constructor
 */
spine.Curve = function ()
{
}

/**
 * @type {function(number):number}
 */
spine.Curve.prototype.evaluate = function (t) { return t; };

/**
 * @return {spine.Curve}
 * @param {?} json
 */
spine.Curve.prototype.load = function (json)
{
	var curve = this;

	// default: linear
	curve.evaluate = function (t) { return t; };

	if ((typeof(json) === 'string') && (json === 'stepped'))
	{
		// stepped
		curve.evaluate = function (t) { return 0; };
	}
	else if ((typeof(json) === 'object') && (typeof(json.length) === 'number') && (json.length === 4))
	{
		// bezier
		var x1 = spine.loadFloat(json, 0, 0);
		var y1 = spine.loadFloat(json, 1, 0);
		var x2 = spine.loadFloat(json, 2, 1);
		var y2 = spine.loadFloat(json, 3, 1);
		//curve.evaluate = spine.BezierCurve(x1, y1, x2, y2);
		curve.evaluate = spine.StepBezierCurve(x1, y1, x2, y2);
	}
	return curve;
}

/**
 * @return {number}
 * @param {number} num
 * @param {number} min
 * @param {number} max
 */
spine.wrap = function (num, min, max)
{
	if (min < max)
	{
		if (num < min)
		{
			return max - ((min - num) % (max - min));
		}
		else
		{
			return min + ((num - min) % (max - min));
		}
	}
	else if (min === max)
	{
		return min;
	}
	else
	{
		return num;
	}
}

/**
 * @return {number}
 * @param {number} a
 * @param {number} b
 * @param {number} t
 */
spine.tween = function (a, b, t)
{
	return a + ((b - a) * t);
}

/**
 * @return {number}
 * @param {number} angle
 */
spine.wrapAngleRadians = function (angle)
{
	if (angle <= 0)
	{
		return ((angle - Math.PI) % (2*Math.PI)) + Math.PI;
	}
	else
	{
		return ((angle + Math.PI) % (2*Math.PI)) - Math.PI;
	}
}

/**
 * @return {number}
 * @param {number} a
 * @param {number} b
 * @param {number} t
 */
spine.tweenAngle = function (a, b, t)
{
	return spine.wrapAngleRadians(a + (spine.wrapAngleRadians(b - a) * t));
}

/**
 * @constructor
 * @param {number=} rad
 */
spine.Angle = function (rad)
{
	this.rad = rad || 0;
}

Object.defineProperty(spine.Angle.prototype, 'deg',
{
	/** @this {spine.Angle} */
	get: function () { return this.rad * 180 / Math.PI; },
	/** @this {spine.Angle} */
	set: function (value) { this.rad = value * Math.PI / 180; }
});

Object.defineProperty(spine.Angle.prototype, 'cos',
{
	/** @this {spine.Angle} */
	get: function () { return Math.cos(this.rad); }
});

Object.defineProperty(spine.Angle.prototype, 'sin',
{
	/** @this {spine.Angle} */
	get: function () { return Math.sin(this.rad); }
});

/**
 * @return {spine.Angle}
 */
spine.Angle.prototype.selfIdentity = function ()
{
	this.rad = 0;
	return this;
}

/**
 * @return {spine.Angle}
 * @param {spine.Angle} other
 */
spine.Angle.prototype.copy = function (other)
{
	this.rad = other.rad;
	return this;
}

/**
 * @constructor
 * @param {number=} x
 * @param {number=} y
 */
spine.Vector = function (x, y)
{
	this.x = x || 0;
	this.y = y || 0;
}

/** @type {number} */
spine.Vector.prototype.x = 0;
/** @type {number} */
spine.Vector.prototype.y = 0;

/**
 * @return {spine.Vector}
 * @param {spine.Vector} other
 */
spine.Vector.prototype.copy = function (other)
{
	this.x = other.x;
	this.y = other.y;
	return this;
}

/**
 * @return {boolean}
 * @param {spine.Vector} a
 * @param {spine.Vector} b
 * @param {number=} epsilon
 */
spine.Vector.equal = function (a, b, epsilon)
{
	epsilon = epsilon || 1e-6;
	if (Math.abs(a.x - b.x) > epsilon) { return false; }
	if (Math.abs(a.y - b.y) > epsilon) { return false; }
	return true;
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} a
 * @param {spine.Vector} b
 * @param {spine.Vector=} out
 */
spine.Vector.add = function (a, b, out)
{
	out = out || new spine.Vector();
	out.x = a.x + b.x;
	out.y = a.y + b.y;
	return out;
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} other
 * @param {spine.Vector=} out
 */
spine.Vector.prototype.add = function (other, out)
{
	return spine.Vector.add(this, other, out);
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} other
 */
spine.Vector.prototype.selfAdd = function (other)
{
	//return spine.Vector.add(this, other, this);
	this.x += other.x;
	this.y += other.y;
	return this;
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} a
 * @param {spine.Vector} b
 * @param {number} pct
 * @param {spine.Vector=} out
 */
spine.Vector.tween = function (a, b, pct, out)
{
	out = out || new spine.Vector();
	out.x = spine.tween(a.x, b.x, pct);
	out.y = spine.tween(a.y, b.y, pct);
	return out;
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} other
 * @param {number} pct
 * @param {spine.Vector=} out
 */
spine.Vector.prototype.tween = function (other, pct, out)
{
	return spine.Vector.tween(this, other, pct, out);
}

/**
 * @return {spine.Vector}
 * @param {spine.Vector} other
 * @param {number} pct
 */
spine.Vector.prototype.selfTween = function (other, pct)
{
	return spine.Vector.tween(this, other, pct, this);
}

/**
 * @constructor
 * @extends {spine.Vector}
 */
spine.Position = function ()
{
	goog.base(this, 0, 0);
}

goog.inherits(spine.Position, spine.Vector);

/**
 * @constructor
 * @extends {spine.Angle}
 */
spine.Rotation = function ()
{
	goog.base(this, 0);
}

goog.inherits(spine.Rotation, spine.Angle);

/**
 * @constructor
 * @extends {spine.Vector}
 */
spine.Scale = function ()
{
	goog.base(this, 1, 1);
}

goog.inherits(spine.Scale, spine.Vector);

/**
 * @return {spine.Scale}
 */
spine.Scale.prototype.selfIdentity = function ()
{
	this.x = 1;
	this.y = 1;
	return this;
}

/**
 * @constructor
 * @extends {spine.Vector}
 */
spine.Flip = function ()
{
	goog.base(this, 1, 1);
}

goog.inherits(spine.Flip, spine.Vector);

/**
 * @constructor
 */
spine.Space = function ()
{
	var space = this;
	space.position = new spine.Position();
	space.rotation = new spine.Rotation();
	space.scale = new spine.Scale();
	space.flip = new spine.Flip();
}

/** @type {spine.Position} */
spine.Space.prototype.position;
/** @type {spine.Rotation} */
spine.Space.prototype.rotation;
/** @type {spine.Scale} */
spine.Space.prototype.scale;
/** @type {spine.Flip} */
spine.Space.prototype.flip;

/**
 * @return {spine.Space}
 * @param {spine.Space} other
 */
spine.Space.prototype.copy = function (other)
{
	var space = this;
	space.position.copy(other.position);
	space.rotation.copy(other.rotation);
	space.scale.copy(other.scale);
	space.flip.copy(other.flip);
	return space;
}

/**
 * @return {spine.Space}
 * @param {Object.<string,?>} json
 */
spine.Space.prototype.load = function (json)
{
	var space = this;
	space.position.x = spine.loadFloat(json, 'x', 0);
	space.position.y = spine.loadFloat(json, 'y', 0);
	space.rotation.deg = spine.loadFloat(json, 'rotation', 0);
	space.scale.x = spine.loadFloat(json, 'scaleX', 1);
	space.scale.y = spine.loadFloat(json, 'scaleY', 1);
	space.flip.x = (spine.loadBool(json, 'flipX', false))?(-1):(1);
	space.flip.y = (spine.loadBool(json, 'flipY', false))?(-1):(1);
	return space;
}

/**
 * @return {boolean}
 * @param {spine.Space} a
 * @param {spine.Space} b
 * @param {number=} epsilon
 */
spine.Space.equal = function (a, b, epsilon)
{
	epsilon = epsilon || 1e-6;
	if (Math.abs(a.position.x - b.position.x) > epsilon) { return false; }
	if (Math.abs(a.position.y - b.position.y) > epsilon) { return false; }
	if (Math.abs(a.rotation.rad - b.rotation.rad) > epsilon) { return false; }
	if (Math.abs(a.scale.x - b.scale.x) > epsilon) { return false; }
	if (Math.abs(a.scale.y - b.scale.y) > epsilon) { return false; }
	if (Math.abs(a.flip.x - b.flip.x) > epsilon) { return false; }
	if (Math.abs(a.flip.y - b.flip.y) > epsilon) { return false; }
	return true;
}

/**
 * @return {spine.Space}
 * @param {spine.Space=} out
 */
spine.Space.identity = function (out)
{
	out = out || new spine.Space();
	out.position.x = 0;
	out.position.y = 0;
	out.rotation.rad = 0;
	out.scale.x = 1;
	out.scale.y = 1;
	out.flip.x = 1;
	out.flip.y = 1;
	return out;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} space
 * @param {number} x
 * @param {number} y
 */
spine.Space.translate = function (space, x, y)
{
	x *= space.scale.x * space.flip.x;
	y *= space.scale.y * space.flip.y;
	var rad = space.rotation.rad * space.flip.x * space.flip.y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	space.position.x += tx;
	space.position.y += ty;
	return space;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} space
 * @param {number} rad
 */
spine.Space.rotate = function (space, rad)
{
	space.rotation.rad += rad;
	space.rotation.rad = spine.wrapAngleRadians(space.rotation.rad);
	return space;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} space
 * @param {number} x
 * @param {number} y
 */
spine.Space.scale = function (space, x, y)
{
	space.scale.x *= x;
	space.scale.y *= y;
	return space;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} space
 * @param {boolean} x
 * @param {boolean} y
 */
spine.Space.flip = function (space, x, y)
{
	space.flip.x *= (x)?(-1):(1);
	space.flip.y *= (y)?(-1):(1);
	return space;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} space
 * @param {spine.Space=} out
 */
spine.Space.invert = function (space, out)
{
	// invert
	// out.sca = space.sca.inv();
	// out.rot = space.rot.inv();
	// out.pos = space.pos.neg().rotate(space.rot.inv()).mul(space.sca.inv());

	out = out || new spine.Space();
	var inv_flip_x = space.flip.x;
	var inv_flip_y = space.flip.y;
	var inv_scale_x = 1 / space.scale.x;
	var inv_scale_y = 1 / space.scale.y;
	var inv_rotation = -space.rotation.rad;
	var inv_x = -space.position.x;
	var inv_y = -space.position.y;
	out.scale.x = inv_scale_x;
	out.scale.y = inv_scale_y;
	out.rotation.rad = inv_rotation;
	out.flip.x = inv_flip_x;
	out.flip.y = inv_flip_y;
	var x = inv_x;
	var y = inv_y;
	var rad = inv_rotation * inv_flip_x * inv_flip_y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	out.position.x = tx * inv_scale_x * inv_flip_x;
	out.position.y = ty * inv_scale_y * inv_flip_y;
	return out;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} a
 * @param {spine.Space} b
 * @param {spine.Space=} out
 */
spine.Space.combine = function (a, b, out)
{
	// combine
	// out.pos = b.pos.mul(a.sca).rotate(a.rot).add(a.pos);
	// out.rot = b.rot.mul(a.rot);
	// out.sca = b.sca.mul(a.sca);

	out = out || new spine.Space();
	var x = b.position.x * a.scale.x * a.flip.x;
	var y = b.position.y * a.scale.y * a.flip.y;
	var rad = a.rotation.rad * a.flip.x * a.flip.y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	out.position.x = tx + a.position.x;
	out.position.y = ty + a.position.y;
	out.rotation.rad = spine.wrapAngleRadians(b.rotation.rad + a.rotation.rad);
	out.scale.x = b.scale.x * a.scale.x;
	out.scale.y = b.scale.y * a.scale.y;
	out.flip.x = b.flip.x * a.flip.x;
	out.flip.y = b.flip.y * a.flip.y;
	return out;
}

/**
 * @return {spine.Space}
 * @param {spine.Space} ab
 * @param {spine.Space} a
 * @param {spine.Space=} out
 */
spine.Space.extract = function (ab, a, out)
{
	// extract
	// out.sca = ab.sca.mul(a.sca.inv());
	// out.rot = ab.rot.mul(a.rot.inv());
	// out.pos = ab.pos.add(a.pos.neg()).rotate(a.rot.inv()).mul(a.sca.inv());

	out = out || new spine.Space();
	out.flip.x = ab.flip.x * a.flip.x;
	out.flip.y = ab.flip.y * a.flip.y;
	out.scale.x = ab.scale.x / a.scale.x;
	out.scale.y = ab.scale.y / a.scale.y;
	out.rotation.rad = spine.wrapAngleRadians(ab.rotation.rad - a.rotation.rad);
	var x = ab.position.x - a.position.x;
	var y = ab.position.y - a.position.y;
	var rad = -a.rotation.rad * a.flip.x * a.flip.y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	out.position.x = tx / a.scale.x * a.flip.x;
	out.position.y = ty / a.scale.y * a.flip.y;
	return out;
}

/**
 * @return {spine.Vector}
 * @param {spine.Space} space
 * @param {spine.Vector} v
 * @param {spine.Vector=} out
 */
spine.Space.transform = function (space, v, out)
{
	out = out || new spine.Vector();
	var x = v.x * space.scale.x * space.flip.x;
	var y = v.y * space.scale.y * space.flip.y;
	var rad = space.rotation.rad * space.flip.x * space.flip.y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	out.x = tx + space.position.x;
	out.y = ty + space.position.y;
	return out;
}

/**
 * @return {spine.Vector}
 * @param {spine.Space} space
 * @param {spine.Vector} v
 * @param {spine.Vector=} out
 */
spine.Space.untransform = function (space, v, out)
{
	out = out || new spine.Vector();
	var x = v.x - space.position.x;
	var y = v.y - space.position.y;
	var rad = -space.rotation.rad * space.flip.x * space.flip.y;
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var tx = c*x - s*y;
	var ty = s*x + c*y;
	out.x = tx / (space.scale.x * space.flip.x);
	out.y = ty / (space.scale.y * space.flip.y);
	return out;
}

/**
 * @constructor
 */
spine.Bone = function ()
{
	var bone = this;
	bone.local_space = new spine.Space();
	bone.world_space = new spine.Space();
}

/** @type {string} */
spine.Bone.prototype.parent_key = "";
/** @type {number} */
spine.Bone.prototype.length = 0;
/** @type {spine.Space} */
spine.Bone.prototype.local_space;
/** @type {spine.Space} */
spine.Bone.prototype.world_space;
/** @type {boolean} */
spine.Bone.prototype.inherit_rotation = true;
/** @type {boolean} */
spine.Bone.prototype.inherit_scale = true;

/**
 * @return {spine.Bone}
 * @param {spine.Bone} other
 */
spine.Bone.prototype.copy = function (other)
{
	var bone = this;
	bone.parent_key = other.parent_key;
	bone.length = other.length;
	bone.local_space.copy(other.local_space);
	bone.world_space.copy(other.world_space);
	bone.inherit_rotation = other.inherit_rotation;
	bone.inherit_scale = other.inherit_scale;
	return bone;
}

/**
 * @return {spine.Bone}
 * @param {Object.<string,?>} json
 */
spine.Bone.prototype.load = function (json)
{
	var bone = this;
	bone.parent_key = spine.loadString(json, 'parent', "");
	bone.length = spine.loadFloat(json, 'length', 0);
	bone.local_space.load(json);
	bone.world_space.copy(bone.local_space);
	bone.inherit_rotation = spine.loadBool(json, 'inheritRotation', true);
	bone.inherit_scale = spine.loadBool(json, 'inheritScale', true);
	return bone;
}

/**
 * @return {spine.Bone}
 * @param {spine.Bone} bone
 * @param {Object.<string,spine.Bone>} bones
 */
spine.Bone.flatten = function (bone, bones)
{
	var parent_bone = bones[bone.parent_key];
	if (parent_bone)
	{
		spine.Bone.flatten(parent_bone, bones);

		//spine.Space.combine(parent_bone.world_space, bone.local_space, bone.world_space);

		var a = parent_bone.world_space;
		var b = bone.local_space;
		var out = bone.world_space;

		var x = b.position.x * a.scale.x * a.flip.x;
		var y = b.position.y * a.scale.y * a.flip.y;
		var rad = a.rotation.rad * a.flip.x * a.flip.y;
		var c = Math.cos(rad);
		var s = Math.sin(rad);
		var tx = c*x - s*y;
		var ty = s*x + c*y;
		out.position.x = tx + a.position.x;
		out.position.y = ty + a.position.y;

		if (bone.inherit_rotation)
		{
			out.rotation.rad = spine.wrapAngleRadians(b.rotation.rad + a.rotation.rad);
		}
		else
		{
			out.rotation.rad = b.rotation.rad;
		}

		if (bone.inherit_scale)
		{
			out.scale.x = b.scale.x * a.scale.x;
			out.scale.y = b.scale.y * a.scale.y;
		}
		else
		{
			out.scale.x = b.scale.x;
			out.scale.y = b.scale.y;
		}
		out.flip.x = b.flip.x * a.flip.x;
		out.flip.y = b.flip.y * a.flip.y;
	}
	else
	{
		bone.world_space.copy(bone.local_space);
	}

	return bone;
}

/**
 * @constructor
 */
spine.Ikc = function ()
{
	var ikc = this;
	ikc.bone_keys = [];
}

/** @type {string} */
spine.Ikc.prototype.name = "";
/** @type {Array.<string>} */
spine.Ikc.prototype.bone_keys;
/** @type {string} */
spine.Ikc.prototype.target_key = "";
/** @type {number} */
spine.Ikc.prototype.mix = 1;
/** @type {boolean} */
spine.Ikc.prototype.bend_positive = true;

/**
 * @return {spine.Ikc}
 * @param {Object.<string,?>} json
 */
spine.Ikc.prototype.load = function (json)
{
	var ikc = this;
	ikc.name = spine.loadString(json, 'name', "");
	ikc.bone_keys = json['bones'] || [];
	ikc.target_key = spine.loadString(json, 'target', "");
	ikc.mix = spine.loadFloat(json, 'mix', 1);
	ikc.bend_positive = spine.loadBool(json, 'bendPositive', true);
	return ikc;
}

/**
 * @constructor
 */
spine.Slot = function ()
{
	var slot = this;
	slot.color = new spine.Color();
}

/** @type {string} */
spine.Slot.prototype.bone_key = "";
/** @type {spine.Color} */
spine.Slot.prototype.color;
/** @type {string} */
spine.Slot.prototype.attachment_key = "";
/** @type {string} */
spine.Slot.prototype.blend = "normal";

/**
 * @return {spine.Slot}
 * @param {spine.Slot} other
 */
spine.Slot.prototype.copy = function (other)
{
	var slot = this;
	slot.bone_key = other.bone_key;
	slot.color.copy(other.color);
	slot.attachment_key = other.attachment_key;
	slot.blend = other.blend;
	return slot;
}

/**
 * @return {spine.Slot}
 * @param {Object.<string,?>} json
 */
spine.Slot.prototype.load = function (json)
{
	var slot = this;
	slot.bone_key = spine.loadString(json, 'bone', "");
	slot.color.load(json.color);
	slot.attachment_key = spine.loadString(json, 'attachment', "");
	slot.blend = spine.loadString(json, 'blend', "normal");
	return slot;
}

/**
 * @constructor
 * @param {string} type
 */
spine.Attachment = function (type)
{
	this.type = type;
}

/** @type {string} */
spine.Attachment.prototype.type = "region";
/** @type {string} */
spine.Attachment.prototype.name = "";
/** @type {string} */
spine.Attachment.prototype.path = "";

/**
 * @return {spine.Attachment}
 * @param {Object.<string,?>} json
 */
spine.Attachment.prototype.load = function (json)
{
	var attachment = this;
	var attachment_type = spine.loadString(json, 'type', "region");
	if (attachment_type !== attachment.type)
	{
		throw new Error();
	}
	attachment.name = spine.loadString(json, 'name', "");
	attachment.path = spine.loadString(json, 'path', "");
	return attachment;
}

/**
 * @constructor
 * @extends {spine.Attachment}
 */
spine.RegionAttachment = function ()
{
	goog.base(this, 'region');
	this.local_space = new spine.Space();
}

goog.inherits(spine.RegionAttachment, spine.Attachment);

/** @type {spine.Space} */
spine.RegionAttachment.prototype.local_space;
/** @type {number} */
spine.RegionAttachment.prototype.width = 0;
/** @type {number} */
spine.RegionAttachment.prototype.height = 0;

/**
 * @return {spine.Attachment}
 * @param {Object.<string,?>} json
 */
spine.RegionAttachment.prototype.load = function (json)
{
	goog.base(this, 'load', json);

	var attachment = this;
	attachment.local_space.load(json);
	attachment.width = spine.loadFloat(json, 'width', 0);
	attachment.height = spine.loadFloat(json, 'height', 0);
	return attachment;
}

/**
 * @constructor
 * @extends {spine.Attachment}
 */
spine.BoundingBoxAttachment = function ()
{
	goog.base(this, 'boundingbox');
	this.vertices = [];
}

goog.inherits(spine.BoundingBoxAttachment, spine.Attachment);

/**
 * @type {Array.<number>}
 */
spine.BoundingBoxAttachment.prototype.vertices;

/**
 * @return {spine.Attachment}
 * @param {Object.<string,?>} json
 */
spine.BoundingBoxAttachment.prototype.load = function (json)
{
	goog.base(this, 'load', json);

	var attachment = this;
	/// The x/y pairs that make up the vertices of the polygon.
	attachment.vertices = json.vertices || [];
	return attachment;
}

/**
 * @constructor
 * @extends {spine.Attachment}
 */
spine.MeshAttachment = function ()
{
	goog.base(this, 'mesh');
	this.color = new spine.Color();
	this.triangles = [];
	this.edges = [];
	this.vertices = [];
	this.uvs = [];
}

goog.inherits(spine.MeshAttachment, spine.Attachment);

/**
 * @type {spine.Color}
 */
spine.MeshAttachment.prototype.color;

/**
 * @type {Array.<number>}
 */
spine.MeshAttachment.prototype.triangles;

/**
 * @type {Array.<number>}
 */
spine.MeshAttachment.prototype.edges;

/**
 * @type {Array.<number>}
 */
spine.MeshAttachment.prototype.vertices;

/**
 * @type {Array.<number>}
 */
spine.MeshAttachment.prototype.uvs;

/**
 * @type {number}
 */
spine.MeshAttachment.prototype.hull = 0;

/**
 * @return {spine.Attachment}
 * @param {Object.<string,?>} json
 */
spine.MeshAttachment.prototype.load = function (json)
{
	goog.base(this, 'load', json);

	var attachment = this;
	attachment.color.load(json.color);
	attachment.triangles = json.triangles || [];
	attachment.edges = json.edges || [];
	attachment.vertices = json.vertices || [];
	attachment.uvs = json.uvs || [];
	attachment.hull = spine.loadInt(json, 'hull', 0);
	return attachment;
}

/**
 * @constructor
 * @extends {spine.Attachment}
 */
spine.SkinnedMeshAttachment = function ()
{
	goog.base(this, 'skinnedmesh');
	this.color = new spine.Color();
	this.triangles = [];
	this.edges = [];
	this.vertices = [];
	this.uvs = [];
}

goog.inherits(spine.SkinnedMeshAttachment, spine.Attachment);

/**
 * @type {spine.Color}
 */
spine.SkinnedMeshAttachment.prototype.color;

/**
 * @type {Array.<number>}
 */
spine.SkinnedMeshAttachment.prototype.triangles;

/**
 * @type {Array.<number>}
 */
spine.SkinnedMeshAttachment.prototype.edges;

/**
 * @type {Array.<number>}
 */
spine.SkinnedMeshAttachment.prototype.vertices;

/**
 * @type {Array.<number>}
 */
spine.SkinnedMeshAttachment.prototype.uvs;

/**
 * @type {number}
 */
spine.SkinnedMeshAttachment.prototype.hull = 0;

/**
 * @return {spine.Attachment}
 * @param {Object.<string,?>} json
 */
spine.SkinnedMeshAttachment.prototype.load = function (json)
{
	goog.base(this, 'load', json);

	var attachment = this;
	attachment.color.load(json.color);
	attachment.triangles = json.triangles || [];
	attachment.edges = json.edges || [];
	attachment.vertices = json.vertices || [];
	attachment.uvs = json.uvs || [];
	attachment.hull = spine.loadInt(json, 'hull', 0);
	return attachment;
}

/**
 * @constructor
 */
spine.SkinSlot = function ()
{
	var skin_slot = this;
	skin_slot.attachments = {};
}

/** @type {Object.<string,spine.Attachment>} */
spine.SkinSlot.prototype.attachments;

/**
 * @return {spine.SkinSlot}
 * @param {Object.<string,?>} json
 */
spine.SkinSlot.prototype.load = function (json)
{
	var skin_slot = this;
	for (var attachment_key in json)
	{
		var json_attachment = json[attachment_key];
		switch (json_attachment.type)
		{
		case 'region':
		default:
			skin_slot.attachments[attachment_key] = new spine.RegionAttachment().load(json_attachment);
			break;
		case 'boundingbox':
			skin_slot.attachments[attachment_key] = new spine.BoundingBoxAttachment().load(json_attachment);
			break;
		case 'mesh':
			skin_slot.attachments[attachment_key] = new spine.MeshAttachment().load(json_attachment);
			break;
		case 'skinnedmesh':
			skin_slot.attachments[attachment_key] = new spine.SkinnedMeshAttachment().load(json_attachment);
			break;
		}
	}
	return skin_slot;
}

/**
 * @constructor
 */
spine.Skin = function ()
{
	var skin = this;
	skin.slots = {};
}

/** @type {Object.<string,spine.SkinSlot>} */
spine.Skin.prototype.slots;

/**
 * @return {spine.Skin}
 * @param {Object.<string,?>} json
 */
spine.Skin.prototype.load = function (json)
{
	var skin = this;
	for (var slot_key in json)
	{
		skin.slots[slot_key] = new spine.SkinSlot().load(json[slot_key]);
	}
	return skin;
}

/**
 * @return {void}
 * @param {function(string, spine.SkinSlot, string, spine.Attachment):void} callback
 */
spine.Skin.prototype.iterateAttachments = function (callback)
{
	var skin = this;
	for (var slot_key in skin.slots)
	{
		var skin_slot = skin.slots[slot_key];
		for (var attachment_key in skin_slot.attachments)
		{
			var attachment = skin_slot.attachments[attachment_key];
			callback(slot_key, skin_slot, attachment.path || attachment.name || attachment_key, attachment);
		}
	}
}

/**
 * @constructor
 */
spine.Event = function ()
{
}

/** @type {string} */
spine.Event.prototype.name = "";
/** @type {number} */
spine.Event.prototype.int_value = 0;
/** @type {number} */
spine.Event.prototype.float_value = 0;
/** @type {string} */
spine.Event.prototype.string_value = "";

/**
 * @return {spine.Event}
 * @param {spine.Event} other
 */
spine.Event.prototype.copy = function (other)
{
	this.name = other.name;
	this.int_value = other.int_value;
	this.float_value = other.float_value;
	this.string_value = other.string_value;
	return this;
}

/**
 * @return {spine.Event}
 * @param {Object.<string,?>} json
 */
spine.Event.prototype.load = function (json)
{
	if (typeof(json['name']) === 'string')
	{
		this.name = spine.loadString(json, 'name', "");
	}
	if (typeof(json['int']) === 'string')
	{
		this.int_value = spine.loadInt(json, 'int', 0);
	}
	if (typeof(json['float']) === 'string')
	{
		this.float_value = spine.loadFloat(json['float'], 0);
	}
	if (typeof(json['string']) === 'string')
	{
		this.string_value = spine.loadString(json, 'string', "");
	}

	return this;
}

/**
 * @constructor
 */
spine.Keyframe = function ()
{
}

/** @type {number} */
spine.Keyframe.prototype.time = 0;

/**
 * @return {spine.Keyframe}
 */
spine.Keyframe.prototype.drop = function ()
{
	this.time = 0;
	return this;
}

/**
 * @return {spine.Keyframe}
 * @param {Object.<string,?>} json
 */
spine.Keyframe.prototype.load = function (json)
{
	this.time = 1000 * spine.loadFloat(json, 'time', 0); // convert to ms
	return this;
}

/**
 * @return {spine.Keyframe}
 * @param {Object.<string,?>} json
 */
spine.Keyframe.prototype.save = function (json)
{
	spine.saveFloat(json, 'time', this.time / 1000, 0); // convert to s
	return this;
}

/**
 * @return {number}
 * @param {Array.<spine.Keyframe>} array
 * @param {number} time
 */
spine.Keyframe.find = function (array, time)
{
	if (!array) { return -1; }
	if (array.length <= 0) { return -1; }
	if (time < array[0].time) { return -1; }
	var last = array.length - 1;
	if (time >= array[last].time) { return last; }
	var lo = 0;
	var hi = last;
	if (hi === 0) { return 0; }
	var current = hi >> 1;
	while (true)
	{
		if (array[current + 1].time <= time) { lo = current + 1; } else { hi = current; }
		if (lo === hi) { return lo; }
		current = (lo + hi) >> 1;
	}
}

/**
 * @return {number}
 * @param {spine.Keyframe} a
 * @param {spine.Keyframe} b
 */
spine.Keyframe.compare = function (a, b)
{
	return a.time - b.time;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.BoneKeyframe = function ()
{
	goog.base(this);
	this.curve = new spine.Curve();
}

goog.inherits(spine.BoneKeyframe, spine.Keyframe);

/** @type {spine.Curve} */
spine.BoneKeyframe.prototype.curve;

/**
 * @return {spine.BoneKeyframe}
 * @param {Object.<string,?>} json
 */
spine.BoneKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.curve.load(json.curve);
	return this;
}

/**
 * @constructor
 * @extends {spine.BoneKeyframe}
 */
spine.TranslateKeyframe = function ()
{
	goog.base(this);
	this.position = new spine.Position();
}

goog.inherits(spine.TranslateKeyframe, spine.BoneKeyframe);

/** @type {spine.Position} */
spine.TranslateKeyframe.prototype.position;

/**
 * @return {spine.TranslateKeyframe}
 * @param {Object.<string,?>} json
 */
spine.TranslateKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.position.x = spine.loadFloat(json, 'x', 0);
	this.position.y = spine.loadFloat(json, 'y', 0);
	return this;
}

/**
 * @constructor
 * @extends {spine.BoneKeyframe}
 */
spine.RotateKeyframe = function ()
{
	goog.base(this);
	this.rotation = new spine.Rotation();
}

goog.inherits(spine.RotateKeyframe, spine.BoneKeyframe);

/** @type {spine.Rotation} */
spine.RotateKeyframe.prototype.rotation;

/**
 * @return {spine.RotateKeyframe}
 * @param {Object.<string,?>} json
 */
spine.RotateKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.rotation.deg = spine.loadFloat(json, 'angle', 0);
	return this;
}

/**
 * @constructor
 * @extends {spine.BoneKeyframe}
 */
spine.ScaleKeyframe = function ()
{
	goog.base(this);
	this.scale = new spine.Scale();
}

goog.inherits(spine.ScaleKeyframe, spine.BoneKeyframe);

/** @type {spine.Scale} */
spine.ScaleKeyframe.prototype.scale;

/**
 * @return {spine.ScaleKeyframe}
 * @param {Object.<string,?>} json
 */
spine.ScaleKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.scale.x = spine.loadFloat(json, 'x', 1);
	this.scale.y = spine.loadFloat(json, 'y', 1);
	return this;
}

/**
 * @constructor
 * @extends {spine.BoneKeyframe}
 */
spine.FlipXKeyframe = function ()
{
	goog.base(this);
}

goog.inherits(spine.FlipXKeyframe, spine.BoneKeyframe);

/** @type {boolean} */
spine.FlipXKeyframe.prototype.flip_x = false;

/**
 * @return {spine.FlipXKeyframe}
 * @param {Object.<string,?>} json
 */
spine.FlipXKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.flip = spine.loadBool(json, 'x', false);
	return this;
}

/**
 * @constructor
 * @extends {spine.BoneKeyframe}
 */
spine.FlipYKeyframe = function ()
{
	goog.base(this);
}

goog.inherits(spine.FlipYKeyframe, spine.BoneKeyframe);

/** @type {boolean} */
spine.FlipYKeyframe.prototype.flip_y = false;

/**
 * @return {spine.FlipYKeyframe}
 * @param {Object.<string,?>} json
 */
spine.FlipYKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.flip = spine.loadBool(json, 'y', false);
	return this;
}

/**
 * @constructor
 */
spine.AnimBone = function ()
{
}

/** @type {number} */
spine.AnimBone.prototype.min_time = 0;
/** @type {number} */
spine.AnimBone.prototype.max_time = 0;
/** @type {Array.<spine.TranslateKeyframe>} */
spine.AnimBone.prototype.translate_keyframes = null;
/** @type {Array.<spine.RotateKeyframe>} */
spine.AnimBone.prototype.rotate_keyframes = null;
/** @type {Array.<spine.ScaleKeyframe>} */
spine.AnimBone.prototype.scale_keyframes = null;
/** @type {Array.<spine.FlipXKeyframe>} */
spine.AnimBone.prototype.flip_x_keyframes = null;
/** @type {Array.<spine.FlipYKeyframe>} */
spine.AnimBone.prototype.flip_y_keyframes = null;

/**
 * @return {spine.AnimBone}
 * @param {Object.<string,?>} json
 */
spine.AnimBone.prototype.load = function (json)
{
	var anim_bone = this;
	anim_bone.min_time = 0;
	anim_bone.max_time = 0;
	anim_bone.translate_keyframes = null;
	anim_bone.rotate_keyframes = null;
	anim_bone.scale_keyframes = null;
	anim_bone.flip_x_keyframes = null;
	anim_bone.flip_y_keyframes = null;

	for (var key in json)
	{
		switch (key)
		{
		case 'translate':
			anim_bone.translate_keyframes = [];
			json.translate.forEach(function (translate_json)
			{
				var translate_keyframe = new spine.TranslateKeyframe().load(translate_json);
				anim_bone.translate_keyframes.push(translate_keyframe);
				anim_bone.min_time = Math.min(anim_bone.min_time, translate_keyframe.time);
				anim_bone.max_time = Math.max(anim_bone.max_time, translate_keyframe.time);
			});
			anim_bone.translate_keyframes = anim_bone.translate_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'rotate':
			anim_bone.rotate_keyframes = [];
			json.rotate.forEach(function (rotate_json)
			{
				var rotate_keyframe = new spine.RotateKeyframe().load(rotate_json);
				anim_bone.rotate_keyframes.push(rotate_keyframe);
				anim_bone.min_time = Math.min(anim_bone.min_time, rotate_keyframe.time);
				anim_bone.max_time = Math.max(anim_bone.max_time, rotate_keyframe.time);
			});
			anim_bone.rotate_keyframes = anim_bone.rotate_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'scale':
			anim_bone.scale_keyframes = [];
			json.scale.forEach(function (scale_json)
			{
				var scale_keyframe = new spine.ScaleKeyframe().load(scale_json);
				anim_bone.scale_keyframes.push(scale_keyframe);
				anim_bone.min_time = Math.min(anim_bone.min_time, scale_keyframe.time);
				anim_bone.max_time = Math.max(anim_bone.max_time, scale_keyframe.time);
			});
			anim_bone.scale_keyframes = anim_bone.scale_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'flipX':
			anim_bone.flip_x_keyframes = [];
			json[key].forEach(function (flip_json)
			{
				var flip_x_keyframe = new spine.FlipXKeyframe().load(flip_json);
				anim_bone.flip_x_keyframes.push(flip_x_keyframe);
				anim_bone.min_time = Math.min(anim_bone.min_time, flip_x_keyframe.time);
				anim_bone.max_time = Math.max(anim_bone.max_time, flip_x_keyframe.time);
			});
			anim_bone.flip_x_keyframes = anim_bone.flip_x_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'flipY':
			anim_bone.flip_y_keyframes = [];
			json[key].forEach(function (flip_json)
			{
				var flip_y_keyframe = new spine.FlipYKeyframe().load(flip_json);
				anim_bone.flip_y_keyframes.push(flip_y_keyframe);
				anim_bone.min_time = Math.min(anim_bone.min_time, flip_y_keyframe.time);
				anim_bone.max_time = Math.max(anim_bone.max_time, flip_y_keyframe.time);
			});
			anim_bone.flip_y_keyframes = anim_bone.flip_y_keyframes.sort(spine.Keyframe.compare);
			break;
		default:
			console.log("TODO: spine.AnimBone::load", key);
			break;
		}
	}

	return anim_bone;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.SlotKeyframe = function ()
{
	goog.base(this);
}

goog.inherits(spine.SlotKeyframe, spine.Keyframe);

/**
 * @return {spine.SlotKeyframe}
 * @param {Object.<string,?>} json
 */
spine.SlotKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	return this;
}

/**
 * @constructor
 * @extends {spine.SlotKeyframe}
 */
spine.ColorKeyframe = function ()
{
	goog.base(this);

	this.color = new spine.Color();
	this.curve = new spine.Curve();
}

goog.inherits(spine.ColorKeyframe, spine.SlotKeyframe);

/** @type {spine.Color} */
spine.ColorKeyframe.prototype.color;
/** @type {spine.Curve} */
spine.ColorKeyframe.prototype.curve;

/**
 * @return {spine.ColorKeyframe}
 * @param {Object.<string,?>} json
 */
spine.ColorKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.color.load(json.color);
	this.curve.load(json.curve);
	return this;
}

/**
 * @constructor
 * @extends {spine.SlotKeyframe}
 */
spine.AttachmentKeyframe = function ()
{
	goog.base(this);
}

goog.inherits(spine.AttachmentKeyframe, spine.SlotKeyframe);


/** @type {string} */
spine.AttachmentKeyframe.prototype.name = "";

/**
 * @return {spine.AttachmentKeyframe}
 * @param {Object.<string,?>} json
 */
spine.AttachmentKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.name = spine.loadString(json, 'name', "");
	return this;
}

/**
 * @constructor
 */
spine.AnimSlot = function ()
{
}

/** @type {number} */
spine.AnimSlot.prototype.min_time = 0;
/** @type {number} */
spine.AnimSlot.prototype.max_time = 0;
/** @type {Array.<spine.ColorKeyframe>} */
spine.AnimSlot.prototype.color_keyframes = null;
/** @type {Array.<spine.AttachmentKeyframe>} */
spine.AnimSlot.prototype.attachment_keyframes = null;

/**
 * @return {spine.AnimSlot}
 * @param {Object.<string,?>} json
 */
spine.AnimSlot.prototype.load = function (json)
{
	var anim_slot = this;
	anim_slot.min_time = 0;
	anim_slot.max_time = 0;
	anim_slot.color_keyframes = null;
	anim_slot.attachment_keyframes = null;

	for (var key in json)
	{
		switch (key)
		{
		case 'color':
			anim_slot.color_keyframes = [];
			json[key].forEach(function (color)
			{
				var color_keyframe = new spine.ColorKeyframe().load(color);
				anim_slot.min_time = Math.min(anim_slot.min_time, color_keyframe.time);
				anim_slot.max_time = Math.max(anim_slot.max_time, color_keyframe.time);
				anim_slot.color_keyframes.push(color_keyframe);
			});
			anim_slot.color_keyframes = anim_slot.color_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'attachment':
			anim_slot.attachment_keyframes = [];
			json[key].forEach(function (attachment)
			{
				;
				var attachment_keyframe = new spine.AttachmentKeyframe().load(attachment);
				anim_slot.min_time = Math.min(anim_slot.min_time, attachment_keyframe.time);
				anim_slot.max_time = Math.max(anim_slot.max_time, attachment_keyframe.time);
				anim_slot.attachment_keyframes.push(attachment_keyframe);
			});
			anim_slot.attachment_keyframes = anim_slot.attachment_keyframes.sort(spine.Keyframe.compare);
			break;
		default:
			console.log("TODO: spine.AnimSlot::load", key);
			break;
		}
	}

	return anim_slot;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.EventKeyframe = function ()
{
	goog.base(this);
}

goog.inherits(spine.EventKeyframe, spine.Keyframe);

/** @type {string} */
spine.EventKeyframe.prototype.name = "";
/** @type {number} */
spine.EventKeyframe.prototype.int_value = 0;
/** @type {number} */
spine.EventKeyframe.prototype.float_value = 0;
/** @type {string} */
spine.EventKeyframe.prototype.string_value = "";

/**
 * @return {spine.EventKeyframe}
 * @param {Object.<string,?>} json
 */
spine.EventKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	if (typeof(json['name']) === 'string')
	{
		this.name = spine.loadString(json, 'name', "");
	}
	if (typeof(json['int']) === 'string')
	{
		this.int_value = spine.loadInt(json, 'int', 0);
	}
	if (typeof(json['float']) === 'string')
	{
		this.float_value = spine.loadFloat(json, 'float', 0);
	}
	if (typeof(json['string']) === 'string')
	{
		this.string_value = spine.loadString(json, 'string', "");
	}
	return this;
}

/**
 * @constructor
 */
spine.SlotOffset = function ()
{
}

/** @type {string} */
spine.SlotOffset.prototype.slot_key = "";
/** @type {number} */
spine.SlotOffset.prototype.offset = 0;

/**
 * @return {spine.SlotOffset}
 * @param {Object.<string,?>} json
 */
spine.SlotOffset.prototype.load = function (json)
{
	this.slot_key = spine.loadString(json, 'slot', "");
	this.offset = spine.loadInt(json, 'offset', 0);
	return this;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.OrderKeyframe = function ()
{
	goog.base(this);

	this.slot_offsets = [];
}

goog.inherits(spine.OrderKeyframe, spine.Keyframe);

/** @type {Array.<spine.SlotOffset>} */
spine.OrderKeyframe.slot_offsets;

/**
 * @return {spine.OrderKeyframe}
 * @param {Object.<string,?>} json
 */
spine.OrderKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	var order_keyframe = this;
	order_keyframe.slot_offsets = [];

	for (var key in json)
	{
		switch (key)
		{
		case 'offsets':
			json[key].forEach(function (offset)
			{
				order_keyframe.slot_offsets.push(new spine.SlotOffset().load(offset));
			});
			break;
		}
	}
	return order_keyframe;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.IkcKeyframe = function ()
{
	goog.base(this);

	this.curve = new spine.Curve();
}

goog.inherits(spine.IkcKeyframe, spine.Keyframe);

/** @type {spine.Curve} */
spine.IkcKeyframe.prototype.curve;

/** @type {number} */
spine.IkcKeyframe.prototype.mix = 1;

/** @type {boolean} */
spine.IkcKeyframe.prototype.bend_positive = true;

/**
 * @return {spine.IkcKeyframe}
 * @param {Object.<string,?>} json
 */
spine.IkcKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.curve.load(json);
	this.mix = spine.loadFloat(json, 'mix', 1);
	this.bend_positive = spine.loadBool(json, 'bendPositive', true);
	return this;
}

/**
 * @constructor
 */
spine.AnimIkc = function ()
{
}

/** @type {number} */
spine.AnimIkc.prototype.min_time = 0;
/** @type {number} */
spine.AnimIkc.prototype.max_time = 0;
/** @type {Array.<spine.IkcKeyframe>} */
spine.AnimIkc.prototype.ikc_keyframes = null;

/**
 * @return {spine.AnimIkc}
 * @param {Object.<string,?>} json
 */
spine.AnimIkc.prototype.load = function (json)
{
	var anim_ikc = this;
	anim_ikc.min_time = 0;
	anim_ikc.max_time = 0;
	anim_ikc.ikc_keyframes = [];

	json.forEach(function (ikc)
	{
		var ikc_keyframe = new spine.IkcKeyframe().load(ikc);
		anim_ikc.min_time = Math.min(anim_ikc.min_time, ikc_keyframe.time);
		anim_ikc.max_time = Math.max(anim_ikc.max_time, ikc_keyframe.time);
		anim_ikc.ikc_keyframes.push(ikc_keyframe);
	});
	anim_ikc.ikc_keyframes = anim_ikc.ikc_keyframes.sort(spine.Keyframe.compare);

	return anim_ikc;
}

/**
 * @constructor
 * @extends {spine.Keyframe}
 */
spine.FfdKeyframe = function ()
{
	goog.base(this);

	this.curve = new spine.Curve();
	this.vertices = [];
}

goog.inherits(spine.FfdKeyframe, spine.Keyframe);

/** @type {spine.Curve} */
spine.FfdKeyframe.prototype.curve;

/** @type {number} */
spine.FfdKeyframe.prototype.offset = 0;

/** @type {Array.<number>} */
spine.FfdKeyframe.prototype.vertices;

/**
 * @return {spine.FfdKeyframe}
 * @param {Object.<string,?>} json
 */
spine.FfdKeyframe.prototype.load = function (json)
{
	goog.base(this, 'load', json);
	this.curve.load(json);
	this.offset = spine.loadInt(json, 'offset', 0);
	this.vertices = json.vertices || [];
	return this;
}

/**
 * @constructor
 */
spine.FfdAttachment = function ()
{
}

/** @type {number} */
spine.FfdAttachment.prototype.min_time = 0;
/** @type {number} */
spine.FfdAttachment.prototype.max_time = 0;
/** @type {Array.<spine.FfdKeyframe>} */
spine.FfdAttachment.prototype.ffd_keyframes = null;

/**
 * @return {spine.FfdAttachment}
 * @param {Object.<string,?>} json
 */
spine.FfdAttachment.prototype.load = function (json)
{
	var ffd_attachment = this;

	ffd_attachment.min_time = 0;
	ffd_attachment.max_time = 0;
	ffd_attachment.ffd_keyframes = [];

	json.forEach(function (ffd_keyframe_json)
	{
		var ffd_keyframe = new spine.FfdKeyframe().load(ffd_keyframe_json);
		ffd_attachment.min_time = Math.min(ffd_attachment.min_time, ffd_keyframe.time);
		ffd_attachment.max_time = Math.max(ffd_attachment.max_time, ffd_keyframe.time);
		ffd_attachment.ffd_keyframes.push(ffd_keyframe);
	});

	ffd_attachment.ffd_keyframes = ffd_attachment.ffd_keyframes.sort(spine.Keyframe.compare);

	return ffd_attachment;
}

/**
 * @constructor
 */
spine.FfdSlot = function ()
{
	var ffd_slot = this;
	ffd_slot.ffd_attachments = {};
}

/** @type {Object.<string,spine.FfdAttachment>} */
spine.FfdSlot.prototype.ffd_attachments;

/**
 * @return {spine.FfdSlot}
 * @param {Object.<string,?>} json
 */
spine.FfdSlot.prototype.load = function (json)
{
	var ffd_slot = this;

	ffd_slot.ffd_attachments = {};

	for (var key in json)
	{
		ffd_slot.ffd_attachments[key] = new spine.FfdAttachment().load(json[key]);
	}

	return ffd_slot;
}

/**
 * @return {void}
 * @param {function(string, spine.FfdAttachment):void} callback
 */
spine.FfdSlot.prototype.iterateAttachments = function (callback)
{
	var ffd_slot = this;

	for (var ffd_attachment_key in ffd_slot.ffd_attachments)
	{
		var ffd_attachment = ffd_slot.ffd_attachments[ffd_attachment_key];

		callback(ffd_attachment_key, ffd_attachment);
	}
}

/**
 * @constructor
 */
spine.AnimFfd = function ()
{
	var anim_ffd = this;
	anim_ffd.ffd_slots = {};
}

/** @type {number} */
spine.AnimFfd.prototype.min_time = 0;
/** @type {number} */
spine.AnimFfd.prototype.max_time = 0;
/** @type {Object.<string,spine.FfdSlot>} */
spine.AnimFfd.prototype.ffd_slots;

/**
 * @return {spine.AnimFfd}
 * @param {Object.<string,?>} json
 */
spine.AnimFfd.prototype.load = function (json)
{
	var anim_ffd = this;

	anim_ffd.min_time = 0;
	anim_ffd.max_time = 0;
	anim_ffd.ffd_slots = {};

	for (var key in json)
	{
		anim_ffd.ffd_slots[key] = new spine.FfdSlot().load(json[key]);
	}

	anim_ffd.iterateAttachments(function (ffd_slot_key, ffd_slot, ffd_attachment_key, ffd_attachment)
	{
		anim_ffd.min_time = Math.min(anim_ffd.min_time, ffd_attachment.min_time);
		anim_ffd.max_time = Math.max(anim_ffd.max_time, ffd_attachment.max_time);
	});

	return anim_ffd;
}

/**
 * @return {void}
 * @param {function(string, spine.FfdSlot, string, spine.FfdAttachment):void} callback
 */
spine.AnimFfd.prototype.iterateAttachments = function (callback)
{
	var anim_ffd = this;

	for (var ffd_slot_key in anim_ffd.ffd_slots)
	{
		var ffd_slot = anim_ffd.ffd_slots[ffd_slot_key];

		ffd_slot.iterateAttachments(function (ffd_attachment_key, ffd_attachment)
		{
			callback(ffd_slot_key, ffd_slot, ffd_attachment_key, ffd_attachment);
		});
	}
}

/**
 * @constructor
 */
spine.Animation = function ()
{
	var anim = this;
	anim.bones = {};
	anim.slots = {};
	anim.ikcs = {};
	anim.ffds = {};
}

/** @type {string} */
spine.Animation.prototype.name = "";

/** @type {Object.<string,spine.AnimBone>} */
spine.Animation.prototype.bones;
/** @type {Object.<string,spine.AnimSlot>} */
spine.Animation.prototype.slots;
/** @type {Array.<spine.EventKeyframe>} */
spine.Animation.prototype.event_keyframes = null;
/** @type {Array.<spine.OrderKeyframe>} */
spine.Animation.prototype.order_keyframes = null;
/** @type {Object.<string,spine.AnimIkc>} */
spine.Animation.prototype.ikcs;
/** @type {Object.<string,spine.AnimFfd>} */
spine.Animation.prototype.ffds;

/** @type {number} */
spine.Animation.prototype.min_time = 0;
/** @type {number} */
spine.Animation.prototype.max_time = 0;
/** @type {number} */
spine.Animation.prototype.length = 0;

/**
 * @return {spine.Animation}
 * @param {Object.<string,?>} json
 */
spine.Animation.prototype.load = function (json)
{
	var anim = this;

	anim.bones = {};
	anim.slots = {};
	anim.event_keyframes = null;
	anim.order_keyframes = null;
	anim.ikcs = {};
	anim.ffds = {};

	anim.min_time = 0;
	anim.max_time = 0;

	for (var key in json)
	{
		switch (key)
		{
		case 'bones':
			for (var bone_key in json[key])
			{
				var anim_bone = new spine.AnimBone().load(json[key][bone_key]);
				anim.min_time = Math.min(anim.min_time, anim_bone.min_time);
				anim.max_time = Math.max(anim.max_time, anim_bone.max_time);
				anim.bones[bone_key] = anim_bone;
			}
			break;
		case 'slots':
			for (var slot_key in json[key])
			{
				var anim_slot = new spine.AnimSlot().load(json[key][slot_key]);
				anim.min_time = Math.min(anim.min_time, anim_slot.min_time);
				anim.max_time = Math.max(anim.max_time, anim_slot.max_time);
				anim.slots[slot_key] = anim_slot;
			}
			break;
		case 'events':
			anim.event_keyframes = [];
			json[key].forEach(function (event)
			{
				var event_keyframe = new spine.EventKeyframe().load(event);
				anim.min_time = Math.min(anim.min_time, event_keyframe.time);
				anim.max_time = Math.max(anim.max_time, event_keyframe.time);
				anim.event_keyframes.push(event_keyframe);
			});
			anim.event_keyframes = anim.event_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'drawOrder':
		case 'draworder':
			anim.order_keyframes = [];
			json[key].forEach(function (order)
			{
				var order_keyframe = new spine.OrderKeyframe().load(order);
				anim.min_time = Math.min(anim.min_time, order_keyframe.time);
				anim.max_time = Math.max(anim.max_time, order_keyframe.time);
				anim.order_keyframes.push(order_keyframe);
			});
			anim.order_keyframes = anim.order_keyframes.sort(spine.Keyframe.compare);
			break;
		case 'ik':
			for (var ikc_key in json[key])
			{
				var anim_ikc = new spine.AnimIkc().load(json[key][ikc_key]);
				anim.min_time = Math.min(anim.min_time, anim_ikc.min_time);
				anim.max_time = Math.max(anim.max_time, anim_ikc.max_time);
				anim.ikcs[ikc_key] = anim_ikc;
			}
			break;
		case 'ffd':
			for (var ffd_key in json[key])
			{
				var anim_ffd = new spine.AnimFfd().load(json[key][ffd_key]);
				anim.min_time = Math.min(anim.min_time, anim_ffd.min_time);
				anim.max_time = Math.max(anim.max_time, anim_ffd.max_time);
				anim.ffds[ffd_key] = anim_ffd;
			}
			break;
		default:
			console.log("TODO: spine.Animation::load", key);
			break;
		}
	}

	anim.length = anim.max_time - anim.min_time;

	return anim;
}

/**
 * @constructor
 */
spine.Skeleton = function ()
{
}

/** @type {string} */
spine.Skeleton.prototype.hash = "";
/** @type {string} */
spine.Skeleton.prototype.spine = "";
/** @type {number} */
spine.Skeleton.prototype.width = 0;
/** @type {number} */
spine.Skeleton.prototype.height = 0;
/** @type {string} */
spine.Skeleton.prototype.images = "";

/**
 * @return {spine.Skeleton}
 * @param {Object.<string,?>} json
 */
spine.Skeleton.prototype.load = function (json)
{
	var skel = this;

	skel.hash = spine.loadString(json, 'hash', "");
	skel.spine = spine.loadString(json, 'spine', "");
	skel.width = spine.loadInt(json, 'width', 0);
	skel.height = spine.loadInt(json, 'height', 0);
	skel.images = spine.loadString(json, 'images', "");

	return skel;
}

/**
 * @constructor
 */
spine.Data = function ()
{
	var data = this;
	data.skeleton = new spine.Skeleton();
	data.bones = {};
	data.bone_keys = [];
	data.ikcs = {};
	data.ikc_keys = [];
	data.slots = {};
	data.slot_keys = [];
	data.skins = {};
	data.skin_keys = [];
	data.events = {};
	data.event_keys = [];
	data.anims = {};
	data.anim_keys = [];
}

/** @type {string} */
spine.Data.prototype.name = "";

/** @type {spine.Skeleton} */
spine.Data.prototype.skeleton;
/** @type {Object.<string,spine.Bone>} */
spine.Data.prototype.bones;
/** @type {Array.<string>} */
spine.Data.prototype.bone_keys;
/** @type {Object.<string,spine.Ikc>} */
spine.Data.prototype.ikcs;
/** @type {Array.<string>} */
spine.Data.prototype.ikc_keys;
/** @type {Object.<string,spine.Slot>} */
spine.Data.prototype.slots;
/** @type {Array.<string>} */
spine.Data.prototype.slot_keys;
/** @type {Object.<string,spine.Skin>} */
spine.Data.prototype.skins;
/** @type {Array.<string>} */
spine.Data.prototype.skin_keys;
/** @type {Object.<string,spine.Event>} */
spine.Data.prototype.events;
/** @type {Array.<string>} */
spine.Data.prototype.event_keys;
/** @type {Object.<string,spine.Animation>} */
spine.Data.prototype.anims;
/** @type {Array.<string>} */
spine.Data.prototype.anim_keys;

/**
 * @return {spine.Data}
 * @param {?} json
 */
spine.Data.prototype.load = function (json)
{
	var data = this;

	data.bones = {};
	data.bone_keys = [];
	data.ikcs = {};
	data.ikc_keys = [];
	data.slots = {};
	data.slot_keys = [];
	data.skins = {};
	data.skin_keys = [];
	data.events = {};
	data.event_keys = [];
	data.anims = {};
	data.anim_keys = [];

	for (var key in json)
	{
		switch (key)
		{
		case 'skeleton':
			data.skeleton.load(json[key]);
			break;
		case 'bones':
			var json_bones = json[key];
			json_bones.forEach(function (bone, bone_index)
			{
				data.bones[bone.name] = new spine.Bone().load(bone);
				data.bone_keys[bone_index] = bone.name;
			});
			break;
		case 'ik':
			var json_ik = json[key];
			json_ik.forEach(function (ikc, ikc_index)
			{
				data.ikcs[ikc.name] = new spine.Ikc().load(ikc);
				data.ikc_keys[ikc_index] = ikc.name;
			});
			break;
		case 'slots':
			var json_slots = json[key];
			json_slots.forEach(function (slot, slot_index)
			{
				data.slots[slot.name] = new spine.Slot().load(slot);
				data.slot_keys[slot_index] = slot.name;
			});
			break;
		case 'skins':
			var json_skins = json[key];
			for (var skin_key in json_skins)
			{
				var skin = data.skins[skin_key] = new spine.Skin().load(json_skins[skin_key]);
				data.skin_keys.push(skin_key);
			}
			break;
		case 'events':
			var json_events = json[key];
			for (var event_key in json_events)
			{
				var event = data.events[event_key] = new spine.Event().load(json_events[event_key]);
				event.name = event.name || event_key;
				data.event_keys.push(event_key);
			}
			break;
		case 'animations':
			var json_animations = json[key];
			for (var anim_key in json_animations)
			{
				var anim = data.anims[anim_key] = new spine.Animation().load(json_animations[anim_key]);
				anim.name = anim.name || anim_key;
				data.anim_keys.push(anim_key);
			}
			break;
		default:
			console.log("TODO: spine.Skeleton::load", key);
			break;
		}
	}

	data.iterateBones(function (bone_key, bone)
	{
		spine.Bone.flatten(bone, data.bones);
	});

	return data;
}

/**
 * @return {spine.Data}
 * @param {?} json
 */
spine.Data.prototype.loadSkeleton = function (json)
{
	var data = this;
	data.skeleton.load(json);
	return data;
}

/**
 * @return {spine.Data}
 * @param {?} json
 */
spine.Data.prototype.loadEvent = function (name, json)
{
	var data = this;
	var event = data.events[name] = new spine.Event().load(json);
	event.name = event.name || name;
	return data;
}

/**
 * @return {spine.Data}
 * @param {?} json
 */
spine.Data.prototype.loadAnimation = function (name, json)
{
	var data = this;
	var anim = data.anims[name] = new spine.Animation().load(json);
	anim.name = anim.name || name;
	return data;
}

/**
 * @return {Object.<string,spine.Skin>}
 */
spine.Data.prototype.getSkins = function ()
{
	var data = this;
	return data.skins;
}

/**
 * @return {Object.<string,spine.Event>}
 */
spine.Data.prototype.getEvents = function ()
{
	var data = this;
	return data.events;
}

/**
 * @return {Object.<string,spine.Animation>}
 */
spine.Data.prototype.getAnims = function ()
{
	var data = this;
	return data.anims;
}

/**
 * @return {void}
 * @param {function(string, spine.Bone):void} callback
 */
spine.Data.prototype.iterateBones = function (callback)
{
	var data = this;
	data.bone_keys.forEach(function (bone_key)
	{
		var data_bone = data.bones[bone_key];
		callback(bone_key, data_bone);
	});
}

/**
 * @return {void}
 * @param {function(string, spine.Slot, spine.SkinSlot, string, spine.Attachment):void} callback
 */
spine.Data.prototype.iterateAttachments = function (skin_key, callback)
{
	var data = this;
	var skin = data.skins[skin_key];
	var default_skin = data.skins['default'];
	data.slot_keys.forEach(function (slot_key)
	{
		var data_slot = data.slots[slot_key];
		var skin_slot = skin && (skin.slots[slot_key] || default_skin.slots[slot_key]);
		var attachment = skin_slot && skin_slot.attachments[data_slot.attachment_key];
		var attachment_key = (attachment && (attachment.path || attachment.name)) || data_slot.attachment_key;
		callback(slot_key, data_slot, skin_slot, attachment_key, attachment);
	});
}

/**
 * @return {void}
 * @param {function(string, spine.Skin):void} callback
 */
spine.Data.prototype.iterateSkins = function (callback)
{
	var data = this;
	for (var skin_key in data.skins)
	{
		var skin = data.skins[skin_key];
		callback(skin_key, skin);
	}
}

/**
 * @return {void}
 * @param {function(string, spine.Event):void} callback
 */
spine.Data.prototype.iterateEvents = function (callback)
{
	var data = this;
	for (var event_key in data.events)
	{
		var event = data.events[event_key];
		callback(event_key, event);
	}
}

/**
 * @return {void}
 * @param {function(string, spine.Animation):void} callback
 */
spine.Data.prototype.iterateAnims = function (callback)
{
	var data = this;
	for (var anim_key in data.anims)
	{
		var anim = data.anims[anim_key];
		callback(anim_key, anim);
	}
}

/**
 * @constructor
 * @param {spine.Data=} data
 */
spine.Pose = function (data)
{
	var pose = this;
	pose.data = data || null;
	pose.bones = {};
	pose.bone_keys = [];
	pose.slots = {};
	pose.slot_keys = [];
	pose.events = [];
}

/** @type {spine.Data} */
spine.Pose.prototype.data;

/** @type {string} */
spine.Pose.prototype.skin_key = "";
/** @type {string} */
spine.Pose.prototype.anim_key = "";
/** @type {number} */
spine.Pose.prototype.time = 0;
/** @type {number} */
spine.Pose.prototype.elapsed_time = 0;

/** @type {boolean} */
spine.Pose.prototype.dirty = true;

/** @type {Object.<string,spine.Bone>} */
spine.Pose.prototype.bones;

/** @type {Array.<string>} */
spine.Pose.prototype.bone_keys;

/** @type {Object.<string,spine.Slot>} */
spine.Pose.prototype.slots;

/** @type {Array.<string>} */
spine.Pose.prototype.slot_keys;

/** @type {Array.<spine.Event>} */
spine.Pose.prototype.events;

/**
 * @return {spine.Skeleton}
 */
spine.Pose.prototype.curSkel = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.skeleton;
}

/**
 * @return {Object.<string,spine.Skin>}
 */
spine.Pose.prototype.getSkins = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.skins;
}

/**
 * @return {spine.Skin}
 */
spine.Pose.prototype.curSkin = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.skins[pose.skin_key];
}

/**
 * @return {string}
 */
spine.Pose.prototype.getSkin = function ()
{
	var pose = this;
	return pose.skin_key;
}

/**
 * @return {void}
 * @param {string} skin_key
 */
spine.Pose.prototype.setSkin = function (skin_key)
{
	var pose = this;
	if (pose.skin_key !== skin_key)
	{
		pose.skin_key = skin_key;
	}
}

/**
 * @return {Object.<string,spine.Event>}
 */
spine.Pose.prototype.getEvents = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.events;
}

/**
 * @return {Object.<string,spine.Animation>}
 */
spine.Pose.prototype.getAnims = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.anims;
}

/**
 * @return {spine.Animation}
 */
spine.Pose.prototype.curAnim = function ()
{
	var pose = this;
	var data = pose.data;
	return data && data.anims[pose.anim_key];
}

/**
 * @return {number}
 */
spine.Pose.prototype.curAnimLength = function ()
{
	var pose = this;
	var data = pose.data;
	var anim = data && data.anims[pose.anim_key];
	return (anim && anim.length) || 0;
}

/**
 * @return {string}
 */
spine.Pose.prototype.getAnim = function ()
{
	var pose = this;
	return pose.anim_key;
}

/**
 * @return {void}
 * @param {string} anim_key
 */
spine.Pose.prototype.setAnim = function (anim_key)
{
	var pose = this;
	if (pose.anim_key !== anim_key)
	{
		pose.anim_key = anim_key;
		var data = pose.data;
		var anim = data && data.anims[pose.anim_key];
		if (anim)
		{
			pose.time = spine.wrap(pose.time, anim.min_time, anim.max_time);
		}
		pose.elapsed_time = 0;
		pose.dirty = true;
	}
}

/**
 * @return {number}
 */
spine.Pose.prototype.getTime = function ()
{
	var pose = this;
	return pose.time;
}

/**
 * @return {void}
 * @param {number} time
 */
spine.Pose.prototype.setTime = function (time)
{
	var pose = this;
	var data = pose.data;
	var anim = data && data.anims[pose.anim_key];
	if (anim)
	{
		time = spine.wrap(time, anim.min_time, anim.max_time);
	}

	if (pose.time !== time)
	{
		pose.time = time;
		pose.elapsed_time = 0;
		pose.dirty = true;
	}
}

/**
 * @return {void}
 * @param {number} elapsed_time
 */
spine.Pose.prototype.update = function (elapsed_time)
{
	var pose = this;
	pose.elapsed_time += elapsed_time;
	pose.dirty = true;
}

/**
 * @return {void}
 */
spine.Pose.prototype.strike = function ()
{
	var pose = this;
	if (!pose.dirty) { return; }
	pose.dirty = false;

	var data = pose.data;

	var anim = data && data.anims[pose.anim_key];

	var prev_time = pose.time;
	var elapsed_time = pose.elapsed_time;

	pose.time = pose.time + pose.elapsed_time; // accumulate elapsed time
	pose.elapsed_time = 0; // reset elapsed time for next strike

	var wrapped_min = false;
	var wrapped_max = false;
	if (anim)
	{
		wrapped_min = (elapsed_time < 0) && (pose.time <= anim.min_time);
		wrapped_max = (elapsed_time > 0) && (pose.time >= anim.max_time);
		pose.time = pose.time !== anim.max_time ? spine.wrap(pose.time, anim.min_time, anim.max_time) : pose.time;
	}

	var time = pose.time;

	data.bone_keys.forEach(function (bone_key)
	{
		var data_bone = data.bones[bone_key];
		var pose_bone = pose.bones[bone_key] || (pose.bones[bone_key] = new spine.Bone());

		// start with a copy of the data bone
		pose_bone.copy(data_bone);

		// tween anim bone if keyframes are available
		var anim_bone = anim && anim.bones[bone_key];
		if (anim_bone)
		{
			var keyframe_index = spine.Keyframe.find(anim_bone.translate_keyframes, time);
			if (keyframe_index !== -1)
			{
				var translate_keyframe0 = anim_bone.translate_keyframes[keyframe_index];
				var translate_keyframe1 = anim_bone.translate_keyframes[keyframe_index + 1];
				if (translate_keyframe1)
				{
					var pct = translate_keyframe0.curve.evaluate((time - translate_keyframe0.time) / (translate_keyframe1.time - translate_keyframe0.time));
					pose_bone.local_space.position.x += spine.tween(translate_keyframe0.position.x, translate_keyframe1.position.x, pct);
					pose_bone.local_space.position.y += spine.tween(translate_keyframe0.position.y, translate_keyframe1.position.y, pct);
				}
				else
				{
					pose_bone.local_space.position.x += translate_keyframe0.position.x;
					pose_bone.local_space.position.y += translate_keyframe0.position.y;
				}
			}

			var keyframe_index = spine.Keyframe.find(anim_bone.rotate_keyframes, time);
			if (keyframe_index !== -1)
			{
				var rotate_keyframe0 = anim_bone.rotate_keyframes[keyframe_index];
				var rotate_keyframe1 = anim_bone.rotate_keyframes[keyframe_index + 1];
				if (rotate_keyframe1)
				{
					var pct = rotate_keyframe0.curve.evaluate((time - rotate_keyframe0.time) / (rotate_keyframe1.time - rotate_keyframe0.time));
					pose_bone.local_space.rotation.rad += spine.tweenAngle(rotate_keyframe0.rotation.rad, rotate_keyframe1.rotation.rad, pct);
				}
				else
				{
					pose_bone.local_space.rotation.rad += rotate_keyframe0.rotation.rad;
				}
			}

			var keyframe_index = spine.Keyframe.find(anim_bone.scale_keyframes, time);
			if (keyframe_index !== -1)
			{
				var scale_keyframe0 = anim_bone.scale_keyframes[keyframe_index];
				var scale_keyframe1 = anim_bone.scale_keyframes[keyframe_index + 1];
				if (scale_keyframe1)
				{
					var pct = scale_keyframe0.curve.evaluate((time - scale_keyframe0.time) / (scale_keyframe1.time - scale_keyframe0.time));
					pose_bone.local_space.scale.x += spine.tween(scale_keyframe0.scale.x, scale_keyframe1.scale.x, pct) - 1;
					pose_bone.local_space.scale.y += spine.tween(scale_keyframe0.scale.y, scale_keyframe1.scale.y, pct) - 1;
				}
				else
				{
					pose_bone.local_space.scale.x += scale_keyframe0.scale.x - 1;
					pose_bone.local_space.scale.y += scale_keyframe0.scale.y - 1;
				}
			}

			var keyframe_index = spine.Keyframe.find(anim_bone.flip_x_keyframes, time);
			if (keyframe_index !== -1)
			{
				var flip_x_keyframe0 = anim_bone.flip_x_keyframes[keyframe_index];
				// no tweening bone flip x
				pose_bone.local_space.flip.x = (flip_x_keyframe0.flip)?(-1):(1);
			}

			var keyframe_index = spine.Keyframe.find(anim_bone.flip_y_keyframes, time);
			if (keyframe_index !== -1)
			{
				var flip_y_keyframe0 = anim_bone.flip_y_keyframes[keyframe_index];
				// no tweening bone flip y
				pose_bone.local_space.flip.y = (flip_y_keyframe0.flip)?(-1):(1);
			}
		}
	});

	pose.bone_keys = data.bone_keys;

	// ik constraints

	data.ikc_keys.forEach(function (ikc_key)
	{
		function clamp (n, lo, hi) { return (n < lo)?(lo):((n > hi)?(hi):(n)); }

		var ikc = data.ikcs[ikc_key];
		var ikc_mix = ikc.mix;
		var ikc_bend_positive = ikc.bend_positive;

		var anim_ikc = anim && anim.ikcs[ikc_key];
		if (anim_ikc)
		{
			var keyframe_index = spine.Keyframe.find(anim_ikc.ikc_keyframes, time);
			if (keyframe_index !== -1)
			{
				var ikc_keyframe0 = anim_ikc.ikc_keyframes[keyframe_index];
				var ikc_keyframe1 = anim_ikc.ikc_keyframes[keyframe_index + 1];
				if (ikc_keyframe1)
				{
					var pct = ikc_keyframe0.curve.evaluate((time - ikc_keyframe0.time) / (ikc_keyframe1.time - ikc_keyframe0.time));
					ikc_mix = spine.tween(ikc_keyframe0.mix, ikc_keyframe1.mix, pct);
				}
				else
				{
					ikc_mix = ikc_keyframe0.mix;
				}
				// no tweening ik bend direction
				ikc_bend_positive = ikc_keyframe0.bend_positive;
			}
		}

		var target = pose.bones[ikc.target_key];
		spine.Bone.flatten(target, pose.bones);
		var target_x = target.world_space.position.x;
		var target_y = target.world_space.position.y;
		var alpha = ikc_mix;
		var bend_direction = (ikc_bend_positive)?(1):(-1);

		if (alpha === 0) { return; }

		switch (ikc.bone_keys.length)
		{
		case 1:
			var bone = pose.bones[ikc.bone_keys[0]];
			spine.Bone.flatten(bone, pose.bones);
			var parent_rotation = 0;
			var bone_parent = pose.bones[bone.parent_key];
			if (bone_parent && bone.inherit_rotation)
			{
				spine.Bone.flatten(bone_parent, pose.bones);
				parent_rotation = bone_parent.world_space.rotation.rad;
			}
			target_x -= bone.world_space.position.x;
			target_y -= bone.world_space.position.y;
			bone.local_space.rotation.rad = spine.tweenAngle(bone.local_space.rotation.rad, Math.atan2(target_y, target_x) - parent_rotation, alpha);
			break;
		case 2:
			var parent = pose.bones[ikc.bone_keys[0]];
			spine.Bone.flatten(parent, pose.bones);
			var child = pose.bones[ikc.bone_keys[1]];
			spine.Bone.flatten(child, pose.bones);
			var position = new spine.Vector();
			var parent_parent = pose.bones[parent.parent_key];
			if (parent_parent)
			{
				position.x = target_x;
				position.y = target_y;
				spine.Bone.flatten(parent_parent, pose.bones);
				spine.Space.untransform(parent_parent.world_space, position, position); // world to local
				target_x = (position.x - parent.local_space.position.x) * parent_parent.world_space.scale.x;
				target_y = (position.y - parent.local_space.position.y) * parent_parent.world_space.scale.y;
			}
			else
			{
				target_x -= parent.local_space.position.x;
				target_y -= parent.local_space.position.y;
			}
			position.copy(child.local_space.position);
			var child_parent = pose.bones[child.parent_key];
			if (child_parent !== parent)
			{
				spine.Bone.flatten(child_parent, pose.bones);
				spine.Space.transform(child_parent.world_space, position, position); // local to world
				spine.Space.untransform(parent.world_space, position, position); // world to local
			}
			var child_x = position.x * parent.world_space.scale.x;
			var child_y = position.y * parent.world_space.scale.y;
			var offset = Math.atan2(child_y, child_x);
			var len1 = Math.sqrt(child_x * child_x + child_y * child_y);
			var len2 = child.length * child.world_space.scale.x;
			var cos_denom = 2 * len1 * len2;
			if (cos_denom < 0.0001)
			{
				child.local_space.rotation.rad = spine.tweenAngle(child.local_space.rotation.rad, Math.atan2(target_y, target_x) - parent.local_space.rotation.rad, alpha);
				return;
			}
			var cos = clamp((target_x * target_x + target_y * target_y - len1 * len1 - len2 * len2) / cos_denom, -1, 1);
			var rad = Math.acos(cos) * bend_direction;
			var sin = Math.sin(rad);
			var adjacent = len2 * cos + len1;
			var opposite = len2 * sin;
			var parent_angle = Math.atan2(target_y * adjacent - target_x * opposite, target_x * adjacent + target_y * opposite);
			parent.local_space.rotation.rad = spine.tweenAngle(parent.local_space.rotation.rad, (parent_angle - offset), alpha);
			var child_angle = rad;
			if (child_parent !== parent)
			{
				child_angle += parent.world_space.rotation.rad - child_parent.world_space.rotation.rad;
			}
			child.local_space.rotation.rad = spine.tweenAngle(child.local_space.rotation.rad, (child_angle + offset), alpha);
			break;
		}
	});

	pose.iterateBones(function (bone_key, bone)
	{
		spine.Bone.flatten(bone, pose.bones);
	});

	data.slot_keys.forEach(function (slot_key)
	{
		var data_slot = data.slots[slot_key];
		var pose_slot = pose.slots[slot_key] || (pose.slots[slot_key] = new spine.Slot());

		// start with a copy of the data slot
		pose_slot.copy(data_slot);

		// tween anim slot if keyframes are available
		var anim_slot = anim && anim.slots[slot_key];
		if (anim_slot)
		{
			var keyframe_index = spine.Keyframe.find(anim_slot.color_keyframes, time);
			if (keyframe_index !== -1)
			{
				var color_keyframe0 = anim_slot.color_keyframes[keyframe_index];
				var color_keyframe1 = anim_slot.color_keyframes[keyframe_index + 1];
				if (color_keyframe1)
				{
					var pct = color_keyframe0.curve.evaluate((time - color_keyframe0.time) / (color_keyframe1.time - color_keyframe0.time));
					pose_slot.color.r = spine.tween(color_keyframe0.color.r, color_keyframe1.color.r, pct);
					pose_slot.color.g = spine.tween(color_keyframe0.color.g, color_keyframe1.color.g, pct);
					pose_slot.color.b = spine.tween(color_keyframe0.color.b, color_keyframe1.color.b, pct);
					pose_slot.color.a = spine.tween(color_keyframe0.color.a, color_keyframe1.color.a, pct);
				}
				else
				{
					pose_slot.color.r = color_keyframe0.color.r;
					pose_slot.color.g = color_keyframe0.color.g;
					pose_slot.color.b = color_keyframe0.color.b;
					pose_slot.color.a = color_keyframe0.color.a;
				}
			}

			var keyframe_index = spine.Keyframe.find(anim_slot.attachment_keyframes, time);
			if (keyframe_index !== -1)
			{
				var attachment_keyframe0 = anim_slot.attachment_keyframes[keyframe_index];
				// no tweening attachments
				pose_slot.attachment_key = attachment_keyframe0.name;
			}
		}
	});

	pose.slot_keys = data.slot_keys;

	if (anim)
	{
		var keyframe_index = spine.Keyframe.find(anim.order_keyframes, time);
		if (keyframe_index !== -1)
		{
			var order_keyframe = anim.order_keyframes[keyframe_index];
			pose.slot_keys = data.slot_keys.slice(0); // copy array before reordering
			order_keyframe.slot_offsets.forEach(function (slot_offset)
			{
				var slot_index = pose.slot_keys.indexOf(slot_offset.slot_key);
				if (slot_index !== -1)
				{
					// delete old position
					pose.slot_keys.splice(slot_index, 1);
					// insert new position
					pose.slot_keys.splice(slot_index + slot_offset.offset, 0, slot_offset.slot_key);
				}
			});
		}
	}

	pose.events.length = 0;

	if (anim)
	{
		var add_event = function (event_keyframe)
		{
			var pose_event = new spine.Event();
			var data_event = data.events[event_keyframe.name];
			if (data_event)
			{
				pose_event.copy(data_event);
			}
			pose_event.int_value = event_keyframe.int_value || pose_event.int_value;
			pose_event.float_value = event_keyframe.float_value || pose_event.float_value;
			pose_event.string_value = event_keyframe.string_value || pose_event.string_value;
			pose.events.push(pose_event);
		}

		if (wrapped_min)
		{
			var keyframe_index = spine.Keyframe.find(anim.event_keyframes, anim.min_time);
			if (keyframe_index !== -1)
			{
				var event_keyframe = anim.event_keyframes[keyframe_index];
				add_event(event_keyframe);
			}
		}
		else if (wrapped_max)
		{
			var keyframe_index = spine.Keyframe.find(anim.event_keyframes, anim.max_time);
			if (keyframe_index !== -1)
			{
				var event_keyframe = anim.event_keyframes[keyframe_index];
				add_event(event_keyframe);
			}
		}

		var keyframe_index = spine.Keyframe.find(anim.event_keyframes, time);
		if (keyframe_index !== -1)
		{
			var event_keyframe = anim.event_keyframes[keyframe_index];
			if (((elapsed_time < 0) && ((time <= event_keyframe.time) && (event_keyframe.time <= prev_time))) ||
				((elapsed_time > 0) && ((prev_time <= event_keyframe.time) && (event_keyframe.time <= time))))
			{
				add_event(event_keyframe);
			}
		}
	}
}

/**
 * @return {void}
 * @param {function(string, spine.Bone):void} callback
 */
spine.Pose.prototype.iterateBones = function (callback)
{
	var pose = this;
	pose.bone_keys.forEach(function (bone_key)
	{
		var bone = pose.bones[bone_key];
		callback(bone_key, bone);
	});
}

/**
 * @return {void}
 * @param {function(string, spine.Slot, spine.SkinSlot, string, spine.Attachment):void} callback
 */
spine.Pose.prototype.iterateAttachments = function (callback)
{
	var pose = this;
	var data = pose.data;
	var skin = data && data.skins[pose.skin_key];
	var default_skin = data && data.skins['default'];
	pose.slot_keys.forEach(function (slot_key)
	{
		var pose_slot = pose.slots[slot_key];
		var skin_slot = skin && (skin.slots[slot_key] || default_skin.slots[slot_key]);
		var attachment = skin_slot && skin_slot.attachments[pose_slot.attachment_key];
		var attachment_key = (attachment && (attachment.path || attachment.name)) || pose_slot.attachment_key;
		callback(slot_key, pose_slot, skin_slot, attachment_key, attachment);
	});
}

spine.deprecated = function ()
{
	console.log("deprecated");
}

Object.defineProperty(spine, 'color', { get: function () { spine.deprecated(); return spine.Color; } });

Object.defineProperty(spine, 'skel_bone', { get: function () { spine.deprecated(); return spine.Bone; } });
Object.defineProperty(spine.Bone.prototype, 'x', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.local_space.position.x; } });
Object.defineProperty(spine.Bone.prototype, 'y', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.local_space.position.y; } });
Object.defineProperty(spine.Bone.prototype, 'rotation', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.local_space.rotation.deg; } });
Object.defineProperty(spine.Bone.prototype, 'scaleX', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.local_space.scale.x; } });
Object.defineProperty(spine.Bone.prototype, 'scaleY', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.local_space.scale.y; } });
Object.defineProperty(spine.Bone.prototype, 'parent', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.parent_key; } });
Object.defineProperty(spine.Bone.prototype, 'inheritRotation', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.inherit_rotation; } });
Object.defineProperty(spine.Bone.prototype, 'inheritScale', { get: /** @this {spine.Bone} */ function () { spine.deprecated(); return this.inherit_scale; } });

Object.defineProperty(spine, 'skel_slot', { get: function () { spine.deprecated(); return spine.Slot; } });
Object.defineProperty(spine.Slot.prototype, 'bone', { get: /** @this {spine.Slot} */ function () { spine.deprecated(); return this.bone_key; } });
Object.defineProperty(spine.Slot.prototype, 'attachment', { get: /** @this {spine.Slot} */ function () { spine.deprecated(); return this.attachment_key; } });
Object.defineProperty(spine.Slot.prototype, 'additive', { get: /** @this {spine.Slot} */ function () { spine.deprecated(); return this.blend === 'additive'; } });

Object.defineProperty(spine, 'attachment', { get: function () { spine.deprecated(); return spine.RegionAttachment; } });
Object.defineProperty(spine.RegionAttachment.prototype, 'x', { get: /** @this {spine.RegionAttachment} */ function () { spine.deprecated(); return this.local_space.position.x; } });
Object.defineProperty(spine.RegionAttachment.prototype, 'y', { get: /** @this {spine.RegionAttachment} */ function () { spine.deprecated(); return this.local_space.position.y; } });
Object.defineProperty(spine.RegionAttachment.prototype, 'rotation', { get: /** @this {spine.RegionAttachment} */ function () { spine.deprecated(); return this.local_space.rotation.deg; } });
Object.defineProperty(spine.RegionAttachment.prototype, 'scaleX', { get: /** @this {spine.RegionAttachment} */ function () { spine.deprecated(); return this.local_space.scale.x; } });
Object.defineProperty(spine.RegionAttachment.prototype, 'scaleY', { get: /** @this {spine.RegionAttachment} */ function () { spine.deprecated(); return this.local_space.scale.y; } });

Object.defineProperty(spine, 'skin_slot', { get: function () { spine.deprecated(); return spine.SkinSlot; } });
Object.defineProperty(spine.SkinSlot.prototype, 'skin_attachments', { get: /** @this {spine.SkinSlot} */ function () { spine.deprecated(); return this.attachments; } });

Object.defineProperty(spine, 'skin', { get: function () { spine.deprecated(); return spine.Skin; } });
Object.defineProperty(spine.Skin.prototype, 'skin_slots', { get: /** @this {spine.Skin} */ function () { spine.deprecated(); return this.slots; } });

Object.defineProperty(spine, 'event', { get: function () { spine.deprecated(); return spine.Event; } });

Object.defineProperty(spine, 'keyframe', { get: function () { spine.deprecated(); return spine.Keyframe; } });

Object.defineProperty(spine, 'bone_keyframe', { get: function () { spine.deprecated(); return spine.BoneKeyframe; } });
Object.defineProperty(spine, 'translate_keyframe', { get: function () { spine.deprecated(); return spine.TranslateKeyframe; } });
Object.defineProperty(spine, 'rotate_keyframe', { get: function () { spine.deprecated(); return spine.RotateKeyframe; } });
Object.defineProperty(spine, 'scale_keyframe', { get: function () { spine.deprecated(); return spine.ScaleKeyframe; } });

Object.defineProperty(spine, 'anim_bone', { get: function () { spine.deprecated(); return spine.AnimBone; } });

Object.defineProperty(spine, 'slot_keyframe', { get: function () { spine.deprecated(); return spine.SlotKeyframe; } });
Object.defineProperty(spine, 'color_keyframe', { get: function () { spine.deprecated(); return spine.ColorKeyframe; } });
Object.defineProperty(spine, 'attachment_keyframe', { get: function () { spine.deprecated(); return spine.AttachmentKeyframe; } });

Object.defineProperty(spine, 'anim_slot', { get: function () { spine.deprecated(); return spine.AnimSlot; } });

Object.defineProperty(spine, 'event_keyframe', { get: function () { spine.deprecated(); return spine.EventKeyframe; } });

Object.defineProperty(spine, 'slot_offset', { get: function () { spine.deprecated(); return spine.SlotOffset; } });
Object.defineProperty(spine, 'order_keyframe', { get: function () { spine.deprecated(); return spine.OrderKeyframe; } });

Object.defineProperty(spine, 'animation', { get: function () { spine.deprecated(); return spine.Animation; } });
Object.defineProperty(spine.Animation.prototype, 'anim_bones', { get: /** @this {spine.Animation} */ function () { spine.deprecated(); return this.bones; } });
Object.defineProperty(spine.Animation.prototype, 'anim_slots', { get: /** @this {spine.Animation} */ function () { spine.deprecated(); return this.slots; } });

Object.defineProperty(spine, 'skeleton', { get: function () { spine.deprecated(); return spine.Skeleton; } });

Object.defineProperty(spine, 'data', { get: function () { spine.deprecated(); return spine.Data; } });
Object.defineProperty(spine.Data.prototype, 'animations', { get: /** @this {spine.Data} */ function () { spine.deprecated(); return this.anims; } });

Object.defineProperty(spine, 'pose', { get: function () { spine.deprecated(); return spine.Pose; } });
Object.defineProperty(spine.Pose.prototype, 'tweened_skel_bones', { get: /** @this {spine.Pose} */ function () { spine.deprecated(); return this.bones; } });
Object.defineProperty(spine.Pose.prototype, 'tweened_skel_slots', { get: /** @this {spine.Pose} */ function () { spine.deprecated(); return this.slots; } });
Object.defineProperty(spine.Pose.prototype, 'tweened_skel_slot_keys', { get: /** @this {spine.Pose} */ function () { spine.deprecated(); return this.slot_keys; } });
Object.defineProperty(spine.Pose.prototype, 'tweened_events', { get: /** @this {spine.Pose} */ function () { spine.deprecated(); return this.events; } });
goog.provide('atlas');
goog.provide('atlas.Data');
goog.provide('atlas.Page');
goog.provide('atlas.Site');

/**
 * @constructor
 */
atlas.Page = function ()
{
	var page = this;
	page.name = "";
	page.w = 0;
	page.h = 0;
	page.format = "RGBA8888";
	page.min_filter = "linear";
	page.mag_filter = "linear";
	page.wrap_s = "clamp-to-edge";
	page.wrap_t = "clamp-to-edge";
}

/**
 * @constructor
 */
atlas.Site = function ()
{
	var site = this;
	site.page = null;
	site.x = 0;
	site.y = 0;
	site.w = 0;
	site.h = 0;
	site.rotate = 0;
	site.offset_x = 0;
	site.offset_y = 0;
	site.original_w = 0;
	site.original_h = 0;
	site.index = -1;
}

/**
 * @constructor
 */
atlas.Data = function ()
{
	var data = this;
	data.pages = [];
	data.sites = {};
}

/**
 * @return {atlas.Data}
 */
atlas.Data.prototype.drop = function ()
{
	var data = this;
	data.pages = [];
	data.sites = {};
	return data;
}

/**
 * @return {atlas.Data}
 * @param {string} text
 */
atlas.Data.prototype.import = function (text)
{
	return this.importAtlasText(text);
}

/**
 * @return {string}
 * @param {string=} text
 */
atlas.Data.prototype.export = function (text)
{
	return this.exportAtlasText(text);
}

/**
 * @return {atlas.Data}
 * @param {string} text
 */
atlas.Data.prototype.importAtlasText = function (text)
{
	var lines = text.split(/\n|\r\n/);
	return this.importAtlasTextLines(lines);
}

/**
 * @return {string}
 * @param {string=} text
 */
atlas.Data.prototype.exportAtlasText = function (text)
{
	var lines = this.exportAtlasTextLines([])
	return (text || "") + lines.join('\n');
}

/**
 * @return {atlas.Data}
 * @param {Array.<string>} lines
 */
atlas.Data.prototype.importAtlasTextLines = function (lines)
{
	var data = this;

	data.pages = [];
	data.sites = {};

	function trim (s) { return s.replace(/^\s+|\s+$/g, ""); }

	var page = null;
	var site = null;

	var match = null;

	lines.forEach(function (line)
	{
		if (trim(line).length === 0)
		{
			page = null;
			site = null;
		}
		else if (match = line.match(/^size: (.*),(.*)$/))
		{
			page.w = parseInt(match[1], 10);
			page.h = parseInt(match[2], 10);
		}
		else if (match = line.match(/^format: (.*)$/))
		{
			page.format = match[1];
		}
		else if (match = line.match(/^filter: (.*),(.*)$/))
		{
			page.min_filter = match[1];
			page.mag_filter = match[2];
		}
		else if (match = line.match(/^repeat: (.*)$/))
		{
			var repeat = match[1];
			page.wrap_s = ((repeat === 'x') || (repeat === 'xy'))?('Repeat'):('ClampToEdge');
			page.wrap_t = ((repeat === 'y') || (repeat === 'xy'))?('Repeat'):('ClampToEdge');
		}
		else if (match = line.match(/^orig: (.*)[,| x] (.*)$/))
		{
			var original_w = parseInt(match[1], 10);
			var original_h = parseInt(match[2], 10);
			console.log("page:orig", original_w, original_h);
		}
		else if (page === null)
		{
			page = new atlas.Page();
			page.name = line;
			data.pages.push(page);
		}
		else
		{
			if (match = line.match(/^  rotate: (.*)$/))
			{
				site.rotate = (match[1] !== 'false')?(-1):(0); // -90 degrees
			}
			else if (match = line.match(/^  xy: (.*), (.*)$/))
			{
				site.x = parseInt(match[1], 10);
				site.y = parseInt(match[2], 10);
			}
			else if (match = line.match(/^  size: (.*), (.*)$/))
			{
				site.w = parseInt(match[1], 10);
				site.h = parseInt(match[2], 10);
			}
			else if (match = line.match(/^  orig: (.*), (.*)$/))
			{
				site.original_w = parseInt(match[1], 10);
				site.original_h = parseInt(match[2], 10);
			}
			else if (match = line.match(/^  offset: (.*), (.*)$/))
			{
				site.offset_x = parseInt(match[1], 10);
				site.offset_y = parseInt(match[2], 10);
			}
			else if (match = line.match(/^  index: (.*)$/))
			{
				site.index = parseInt(match[1], 10);
			}
			else
			{
				if (site)
				{
					site.original_w = site.original_w || site.w;
					site.original_h = site.original_h || site.h;
				}

				site = new atlas.Site();
				site.page = page;
				data.sites[line] = site;
			}
		}
	});

	return data;
}

/**
 * @return {string}
 * @param {Array.<string>=} lines
 */
atlas.Data.prototype.exportAtlasTextLines = function (lines)
{
	lines = lines || [];

	var data = this;

	data.pages.forEach(function (page)
	{
		lines.push(""); // empty line denotes new page
		lines.push(page.name);
		lines.push("size: " + page.w + "," + page.h);
		lines.push("format: " + page.format);
		lines.push("filter: " + page.min_filter + "," + page.mag_filter);
		var repeat = 'none';
		if ((page.wrap_s === 'Repeat') && (page.wrap_t === 'Repeat')) { repeat = 'xy'; }
		else if (page.wrap_s === 'Repeat') { repeat = 'x'; }
		else if (page.wrap_t === 'Repeat') { repeat = 'y'; }
		lines.push("repeat: " + repeat);

		for (var site_key in data.sites)
		{
			var site = data.sites[site_key];
			if (site.page !== page) { continue; }
			lines.push(site_key);
			lines.push("  rotate: " + (site.rotate !== 0?'true':'false'));
			lines.push("  xy: " + site.x + ", " + site.y);
			lines.push("  size: " + site.w + ", " + site.h);
			lines.push("  orig: " + site.original_w + ", " + site.original_h);
			lines.push("  offset: " + site.offset_x + ", " + site.offset_y);
			lines.push("  index: " + site.index);
		}
	});

	return lines;
}

/**
 * @return {atlas.Data}
 * @param {string} tps_text
 */
atlas.Data.prototype.importTpsText = function (tps_text)
{
	var data = this;

	data.pages = [];
	data.sites = {};

	return data.importTpsTextPage(tps_text, 0);
}

/**
 * @return {atlas.Data}
 * @param {string} tps_text
 * @param {number=} page_index
 */
atlas.Data.prototype.importTpsTextPage = function (tps_text, page_index)
{
	var data = this;

	page_index = page_index || 0;

	var tps_json = JSON.parse(tps_text);

	if (tps_json.meta)
	{
		// TexturePacker only supports one page
		var page = data.pages[page_index] = new atlas.Page();
		page.w = tps_json.meta.size.w;
		page.h = tps_json.meta.size.h;
		page.name = tps_json.meta.image;
	}

	if (tps_json.frames) for (var i in tps_json.frames)
	{
		var frame = tps_json.frames[i];
		var site = data.sites[i] = new atlas.Site();
		site.page = page_index;
		site.x = frame.frame.x;
		site.y = frame.frame.y;
		site.w = frame.frame.w;
		site.h = frame.frame.h;
		site.rotate = (frame.rotated)?(1):(0); // 90 degrees
		site.offset_x = (frame.spriteSourceSize && frame.spriteSourceSize.x) || 0;
		site.offset_y = (frame.spriteSourceSize && frame.spriteSourceSize.y) || 0;
		site.original_w = (frame.sourceSize && frame.sourceSize.w) || site.w;
		site.original_h = (frame.sourceSize && frame.sourceSize.h) || site.h;
	}

	return data;
}
goog.provide('renderCtx2D');

/**
 * @constructor
 * @param {CanvasRenderingContext2D} ctx
 */
renderCtx2D = function ()
{
	var render = this;
	//FIXME
//	render.ctx = ctx;
	render.images = {};
    render.replaceSlots = {};
	render.skin_info_map = {};
	render.region_vertex_position = new Float32Array([ -1, -1,  1, -1,  1,  1, -1,  1 ]); // [ x, y ]
	render.region_vertex_texcoord = new Float32Array([  0,  1,  1,  1,  1,  0,  0,  0 ]); // [ u, v ]
	render.region_vertex_triangle = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]); // [ i0, i1, i2 ]
}

renderCtx2D.prototype.setContext = function(ctx) {
	this.ctx = ctx;
};

/**
 * @return {void}
 * @param {spine.Pose} spine_pose
 * @param {atlas.Data} atlas_data
 */
renderCtx2D.prototype.dropPose = function (spine_pose, atlas_data) {
	var render = this;

	for (var image_key in render.images)
	{
		delete render.images[image_key];
	}

	render.images = {};
	render.skin_info_map = {};
}

/**
 * @return {void}
 * @param {spine.Pose} spine_pose
 * @param {atlas.Data} atlas_data
 * @param {Object.<string,HTMLImageElement>} images
 */
renderCtx2D.prototype.loadPose = function (spine_pose, atlas_data, images)
{
	var render = this;

	spine_pose.data.iterateSkins(function (skin_key, skin)
	{
		var skin_info = render.skin_info_map[skin_key] = {};
		var slot_info_map = skin_info.slot_info_map = {};

		skin.iterateAttachments(function (slot_key, skin_slot, attachment_key, attachment)
		{
			if (!attachment) { return; }

			switch (attachment.type)
			{
			case 'mesh':
				var slot_info = slot_info_map[slot_key] = slot_info_map[slot_key] || {};
				var attachment_info_map = slot_info.attachment_info_map = slot_info.attachment_info_map || {};
				var attachment_info = attachment_info_map[attachment_key] = {};
				attachment_info.type = attachment.type;
				var vertex_count = attachment_info.vertex_count = attachment.vertices.length / 2;
				var vertex_position = attachment_info.vertex_position = new Float32Array(attachment.vertices);
				var vertex_texcoord = attachment_info.vertex_texcoord = new Float32Array(attachment.uvs);
				var vertex_triangle = attachment_info.vertex_triangle = new Uint16Array(attachment.triangles);
				break;
			case 'skinnedmesh':
				var slot_info = slot_info_map[slot_key] = slot_info_map[slot_key] || {};
				var attachment_info_map = slot_info.attachment_info_map = slot_info.attachment_info_map || {};
				var attachment_info = attachment_info_map[attachment_key] = {};
				attachment_info.type = attachment.type;
				var vertex_count = attachment_info.vertex_count = attachment.uvs.length / 2;
				var vertex_setup_position = attachment_info.vertex_setup_position = new Float32Array(2 * vertex_count);
				var vertex_blend_position = attachment_info.vertex_blend_position = new Float32Array(2 * vertex_count);
				var vertex_texcoord = attachment_info.vertex_texcoord = new Float32Array(attachment.uvs);
				var vertex_triangle = attachment_info.vertex_triangle = new Uint16Array(attachment.triangles);
				var position = new spine.Vector();
				for (var vertex_index = 0, index = 0; vertex_index < vertex_count; ++vertex_index)
				{
					var blender_count = attachment.vertices[index++];
					var setup_position_x = 0;
					var setup_position_y = 0;
					for (var blender_index = 0; blender_index < blender_count; ++blender_index)
					{
						var bone_index = attachment.vertices[index++];
						var x = position.x = attachment.vertices[index++];
						var y = position.y = attachment.vertices[index++];
						var weight = attachment.vertices[index++];
						var bone_key = spine_pose.data.bone_keys[bone_index];
						var bone = spine_pose.data.bones[bone_key];
						spine.Space.transform(bone.world_space, position, position);
						setup_position_x += position.x * weight;
						setup_position_y += position.y * weight;
					}
					var vertex_setup_position_offset = vertex_index * 2;
					vertex_setup_position[vertex_setup_position_offset++] = setup_position_x;
					vertex_setup_position[vertex_setup_position_offset++] = setup_position_y;
				}
				vertex_blend_position.set(vertex_setup_position);
				break;
			}
		});
	});

	render.images = images;
}

/**
 * @return {void}
 * @param {spine.Pose} spine_pose
 * @param {atlas.Data} atlas_data
 */
renderCtx2D.prototype.updatePose = function (spine_pose, atlas_data)
{
	var render = this;

	spine_pose.iterateAttachments(function (slot_key, slot, skin_slot, attachment_key, attachment)
	{
		if (!attachment) { return; }
		switch (attachment.type)
		{
		case 'mesh':
			var skin_info = render.skin_info_map[spine_pose.skin_key], default_skin_info = render.skin_info_map['default'];
			var slot_info = skin_info.slot_info_map[slot_key] || default_skin_info.slot_info_map[slot_key];
			var attachment_info = slot_info.attachment_info_map[attachment_key];
			var anim = spine_pose.data.anims[spine_pose.anim_key];
			var anim_ffd = anim && anim.ffds && anim.ffds[spine_pose.skin_key];
			var ffd_slot = anim_ffd && anim_ffd.ffd_slots[slot_key];
			var ffd_attachment = ffd_slot && ffd_slot.ffd_attachments[attachment_key];
			var ffd_keyframes = ffd_attachment && ffd_attachment.ffd_keyframes;
			var ffd_keyframe_index = spine.Keyframe.find(ffd_keyframes, spine_pose.time);
			if (ffd_keyframe_index !== -1)
			{
				// ffd

				var pct = 0;
				var ffd_keyframe0 = ffd_keyframes[ffd_keyframe_index];
				var ffd_keyframe1 = ffd_keyframes[ffd_keyframe_index + 1];
				if (ffd_keyframe1)
				{
					pct = ffd_keyframe0.curve.evaluate((spine_pose.time - ffd_keyframe0.time) / (ffd_keyframe1.time - ffd_keyframe0.time));
				}
				else
				{
					ffd_keyframe1 = ffd_keyframe0;
				}

				for (var index = 0; index < attachment_info.vertex_position.length; ++index)
				{
					var v0 = ffd_keyframe0.vertices[index - ffd_keyframe0.offset] || 0;
					var v1 = ffd_keyframe1.vertices[index - ffd_keyframe1.offset] || 0;
					attachment_info.vertex_position[index] = attachment.vertices[index] + spine.tween(v0, v1, pct);
				}
			}
			break;
		case 'skinnedmesh':
			var skin_info = render.skin_info_map[spine_pose.skin_key], default_skin_info = render.skin_info_map['default'];
			var slot_info = skin_info.slot_info_map[slot_key] || default_skin_info.slot_info_map[slot_key];
			var attachment_info = slot_info.attachment_info_map[attachment_key];
			var anim = spine_pose.data.anims[spine_pose.anim_key];
			var anim_ffd = anim && anim.ffds && anim.ffds[spine_pose.skin_key];
			var ffd_slot = anim_ffd && anim_ffd.ffd_slots[slot_key];
			var ffd_attachment = ffd_slot && ffd_slot.ffd_attachments[attachment_key];
			var ffd_keyframes = ffd_attachment && ffd_attachment.ffd_keyframes;
			var ffd_keyframe_index = spine.Keyframe.find(ffd_keyframes, spine_pose.time);
			if (ffd_keyframe_index !== -1)
			{
				// ffd

				var pct = 0;
				var ffd_keyframe0 = ffd_keyframes[ffd_keyframe_index];
				var ffd_keyframe1 = ffd_keyframes[ffd_keyframe_index + 1];
				if (ffd_keyframe1)
				{
					var pct = ffd_keyframe0.curve.evaluate((spine_pose.time - ffd_keyframe0.time) / (ffd_keyframe1.time - ffd_keyframe0.time));
				}
				else
				{
					ffd_keyframe1 = ffd_keyframe0;
				}

				var vertex_blend_position = attachment_info.vertex_blend_position;
				var position = new spine.Vector();
				for (var vertex_index = 0, index = 0, ffd_index = 0; vertex_index < attachment_info.vertex_count; ++vertex_index)
				{
					var blender_count = attachment.vertices[index++];
					var blend_position_x = 0;
					var blend_position_y = 0;
					for (var blender_index = 0; blender_index < blender_count; ++blender_index)
					{
						var bone_index = attachment.vertices[index++];
						position.x = attachment.vertices[index++];
						position.y = attachment.vertices[index++];
						var weight = attachment.vertices[index++];
						var bone_key = spine_pose.bone_keys[bone_index];
						var bone = spine_pose.bones[bone_key];
						var v0 = ffd_keyframe0.vertices[ffd_index - ffd_keyframe0.offset] || 0;
						var v1 = ffd_keyframe1.vertices[ffd_index - ffd_keyframe1.offset] || 0;
						position.x += spine.tween(v0, v1, pct); ++ffd_index;
						var v0 = ffd_keyframe0.vertices[ffd_index - ffd_keyframe0.offset] || 0;
						var v1 = ffd_keyframe1.vertices[ffd_index - ffd_keyframe1.offset] || 0;
						position.y += spine.tween(v0, v1, pct); ++ffd_index;
						spine.Space.transform(bone.world_space, position, position);
						blend_position_x += position.x * weight;
						blend_position_y += position.y * weight;
					}
					var vertex_position_offset = vertex_index * 2;
					vertex_blend_position[vertex_position_offset++] = blend_position_x;
					vertex_blend_position[vertex_position_offset++] = blend_position_y;
				}
			}
			else
			{
				// no ffd

				var vertex_blend_position = attachment_info.vertex_blend_position;
				var position = new spine.Vector();
				for (var vertex_index = 0, index = 0; vertex_index < attachment_info.vertex_count; ++vertex_index)
				{
					var blender_count = attachment.vertices[index++];
					var blend_position_x = 0;
					var blend_position_y = 0;
					for (var blender_index = 0; blender_index < blender_count; ++blender_index)
					{
						var bone_index = attachment.vertices[index++];
						position.x = attachment.vertices[index++];
						position.y = attachment.vertices[index++];
						var weight = attachment.vertices[index++];
						var bone_key = spine_pose.bone_keys[bone_index];
						var bone = spine_pose.bones[bone_key];
						spine.Space.transform(bone.world_space, position, position);
						blend_position_x += position.x * weight;
						blend_position_y += position.y * weight;
					}
					var vertex_position_offset = vertex_index * 2;
					vertex_blend_position[vertex_position_offset++] = blend_position_x;
					vertex_blend_position[vertex_position_offset++] = blend_position_y;
				}
			}
			break;
		}
	});
}

renderCtx2D.prototype.replaceSlotImage = function(name, image, imageRect) {
    this.replaceSlots[name] = {
        image: image,
        rect: imageRect
    };

    return this;
}

/**
 * @return {void}
 * @param {spine.Pose} spine_pose
 * @param {atlas.Data} atlas_data
 */
renderCtx2D.prototype.drawPose = function (spine_pose, atlas_data)
{
	var render = this;
	var ctx = render.ctx;

	render.updatePose(spine_pose, atlas_data);

	spine_pose.iterateAttachments(function (slot_key, slot, skin_slot, attachment_key, attachment)
	{
		if (!attachment) { return; }
		if (attachment.type === 'boundingbox') { return; }

		var site = atlas_data && atlas_data.sites[attachment_key];
        if(!site && attachment_key.indexOf('/') > 0) {
           site = atlas_data && atlas_data.sites[attachment_key.split('/')[1]];
        }
		var page = site && site.page;
		var image_key = (page && page.name) || attachment_key;
		var image = render.images[image_key];

        var replace = render.replaceSlots[slot_key];
        if(replace) {
            image = replace.image;
            if(replace.rect) {
                site = {
                    x: replace.rect.x,
                    y: replace.rect.y,
                    w: replace.rect.w,
                    h: replace.rect.h,
                    offset_x: 0,
                    offset_y: 0,
                    original_w: replace.rect.w,
                    original_h: replace.rect.h
                };
            }
        }

		if (!image || !image.complete) { return; }

		ctx.save();

		// TODO: slot.color.rgb
		ctx.globalAlpha = slot.color.a;

		switch (slot.blend)
		{
		default:
		case 'normal': ctx.globalCompositeOperation = 'source-over'; break;
		case 'additive': ctx.globalCompositeOperation = 'lighter'; break;
		case 'multiply': ctx.globalCompositeOperation = 'multiply'; break;
		case 'screen': ctx.globalCompositeOperation = 'screen'; break;
		}

		switch (attachment.type)
		{
		case 'region':
			var bone = spine_pose.bones[slot.bone_key];
			ctxApplySpace(ctx, bone.world_space);
			ctxApplySpace(ctx, attachment.local_space);
			ctxApplyAtlasSitePosition(ctx, site);
			ctx.scale(attachment.width/2, attachment.height/2);
			if (site)
            {
                if (site.rotate)
                {
                    ctxDrawImageMesh(ctx, render.region_vertex_triangle, render.region_vertex_position, render.region_vertex_texcoord, image, site, page);
                }
                else
                {
                    ctx.scale(1, -1);
                    ctx.drawImage(image, site.x, site.y, site.w, site.h, -1, -1, 2, 2);
                }
            }
            else
            {
                ctx.scale(1, -1);
                ctx.drawImage(image, -1, -1, 2, 2);
            }
			//ctxDrawImageMesh(ctx, render.region_vertex_triangle, render.region_vertex_position, render.region_vertex_texcoord, image, site, page);
			break;
		case 'mesh':
			var skin_info = render.skin_info_map[spine_pose.skin_key], default_skin_info = render.skin_info_map['default'];
			var slot_info = skin_info.slot_info_map[slot_key] || default_skin_info.slot_info_map[slot_key];
			var attachment_info = slot_info.attachment_info_map[attachment_key];
			var bone = spine_pose.bones[slot.bone_key];
			ctxApplySpace(ctx, bone.world_space);
			ctxApplyAtlasSitePosition(ctx, site);
			ctxDrawImageMesh(ctx, attachment_info.vertex_triangle, attachment_info.vertex_position, attachment_info.vertex_texcoord, image, site, page);
			break;
		case 'skinnedmesh':
			var skin_info = render.skin_info_map[spine_pose.skin_key], default_skin_info = render.skin_info_map['default'];
			var slot_info = skin_info.slot_info_map[slot_key] || default_skin_info.slot_info_map[slot_key];
			var attachment_info = slot_info.attachment_info_map[attachment_key];
			ctxApplyAtlasSitePosition(ctx, site);
			ctxDrawImageMesh(ctx, attachment_info.vertex_triangle, attachment_info.vertex_blend_position, attachment_info.vertex_texcoord, image, site, page);
			break;
		}

		ctx.restore();
	});
}

function ctxApplySpace (ctx, space)
{
	if (space)
	{
		ctx.translate(space.position.x, space.position.y);
		ctx.rotate(space.rotation.rad * space.flip.x * space.flip.y);
		ctx.scale(space.scale.x * space.flip.x, space.scale.y * space.flip.y);
	}
}

function ctxApplyAtlasSitePosition (ctx, site)
{
	if (site)
	{
		ctx.scale(1 / site.original_w, 1 / site.original_h);
		ctx.translate(2*site.offset_x - (site.original_w - site.w), (site.original_h - site.h) - 2*site.offset_y);
		ctx.scale(site.w, site.h);
	}
}

function ctxDrawCircle (ctx, color, scale)
{
	scale = scale || 1;
	ctx.beginPath();
	ctx.arc(0, 0, 12*scale, 0, 2*Math.PI, false);
	ctx.strokeStyle = color || 'grey';
	ctx.stroke();
}

function ctxDrawPoint (ctx, color, scale)
{
	scale = scale || 1;
	ctx.beginPath();
	ctx.arc(0, 0, 12*scale, 0, 2*Math.PI, false);
	ctx.strokeStyle = color || 'blue';
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(24*scale, 0);
	ctx.strokeStyle = 'red';
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(0, 24*scale);
	ctx.strokeStyle = 'green';
	ctx.stroke();
}

function ctxDrawMesh (ctx, triangles, positions, stroke_style, fill_style)
{
	ctx.beginPath();
	for (var index = 0; index < triangles.length; )
	{
		var triangle = triangles[index++]*2;
		var x0 = positions[triangle], y0 = positions[triangle+1];
		var triangle = triangles[index++]*2;
		var x1 = positions[triangle], y1 = positions[triangle+1];
		var triangle = triangles[index++]*2;
		var x2 = positions[triangle], y2 = positions[triangle+1];
		ctx.moveTo(x0, y0);
		ctx.lineTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.lineTo(x0, y0);
	};
	if (fill_style)
	{
		ctx.fillStyle = fill_style;
		ctx.fill();
	}
	ctx.strokeStyle = stroke_style || 'grey';
	ctx.stroke();
}


function ctxDrawImageMesh (ctx, triangles, positions, texcoords, image, site, page)
{
	var site_texmatrix = new Float32Array(9);
	var site_texcoord = new Float32Array(2);
	mat3x3Identity(site_texmatrix);
	mat3x3Scale(site_texmatrix, image.width, image.height);
	mat3x3ApplyAtlasPageTexcoord(site_texmatrix, page);
	mat3x3ApplyAtlasSiteTexcoord(site_texmatrix, site);

	/// http://www.irrlicht3d.org/pivot/entry.php?id=1329
	for (var index = 0; index < triangles.length; )
	{
		var triangle = triangles[index++]*2;
		var position = positions.subarray(triangle, triangle+2);
		var x0 = position[0], y0 = position[1];
		var texcoord = mat3x3Transform(site_texmatrix, texcoords.subarray(triangle, triangle+2), site_texcoord);
		var u0 = texcoord[0], v0 = texcoord[1];

		var triangle = triangles[index++]*2;
		var position = positions.subarray(triangle, triangle+2);
		var x1 = position[0], y1 = position[1];
		var texcoord = mat3x3Transform(site_texmatrix, texcoords.subarray(triangle, triangle+2), site_texcoord);
		var u1 = texcoord[0], v1 = texcoord[1];

		var triangle = triangles[index++]*2;
		var position = positions.subarray(triangle, triangle+2);
		var x2 = position[0], y2 = position[1];
		var texcoord = mat3x3Transform(site_texmatrix, texcoords.subarray(triangle, triangle+2), site_texcoord);
		var u2 = texcoord[0], v2 = texcoord[1];

		ctx.save();
		ctx.beginPath();
		ctx.moveTo(x0, y0);
		ctx.lineTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.closePath();
		ctx.clip();
		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;
		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;
		var id = 1 / (u1*v2 - u2*v1);
		var a = id * (v2*x1 - v1*x2);
		var b = id * (v2*y1 - v1*y2);
		var c = id * (u1*x2 - u2*x1);
		var d = id * (u1*y2 - u2*y1);
		var e = x0 - (a*u0 + c*v0);
		var f = y0 - (b*u0 + d*v0);
		ctx.transform(a, b, c, d, e, f);
		ctx.drawImage(image, 0, 0);
		ctx.restore();
	}
}

function ctxDrawIkConstraints (ctx, data, bones)
{
	data.ikc_keys.forEach(function (ikc_key)
	{
		var ikc = data.ikcs[ikc_key];
		var target = bones[ikc.target_key];
		switch (ikc.bone_keys.length)
		{
		case 1:
			var bone = bones[ikc.bone_keys[0]];

			ctx.beginPath();
			ctx.moveTo(target.world_space.position.x, target.world_space.position.y);
			ctx.lineTo(bone.world_space.position.x, bone.world_space.position.y);
			ctx.strokeStyle = 'yellow';
			ctx.stroke();

			ctx.save();
			ctxApplySpace(ctx, target.world_space);
			ctxDrawCircle(ctx, 'yellow', 1.5);
			ctx.restore();

			ctx.save();
			ctxApplySpace(ctx, bone.world_space);
			ctxDrawCircle(ctx, 'yellow', 0.5);
			ctx.restore();
			break;
		case 2:
			var parent = bones[ikc.bone_keys[0]];
			var child = bones[ikc.bone_keys[1]];

			ctx.beginPath();
			ctx.moveTo(target.world_space.position.x, target.world_space.position.y);
			ctx.lineTo(child.world_space.position.x, child.world_space.position.y);
			ctx.lineTo(parent.world_space.position.x, parent.world_space.position.y);
			ctx.strokeStyle = 'yellow';
			ctx.stroke();

			ctx.save();
			ctxApplySpace(ctx, target.world_space);
			ctxDrawCircle(ctx, 'yellow', 1.5);
			ctx.restore();

			ctx.save();
			ctxApplySpace(ctx, child.world_space);
			ctxDrawCircle(ctx, 'yellow', 0.75);
			ctx.restore();

			ctx.save();
			ctxApplySpace(ctx, parent.world_space);
			ctxDrawCircle(ctx, 'yellow', 0.5);
			ctx.restore();
			break;
		}
	});
}

function mat3x3Identity (m)
{
	m[1] = m[2] = m[3] =
	m[5] = m[6] = m[7] = 0.0;
	m[0] = m[4] = m[8] = 1.0;
	return m;
}

function mat3x3Scale (m, x, y)
{
	m[0] *= x; m[1] *= x; m[2] *= x;
	m[3] *= y; m[4] *= y; m[5] *= y;
	return m;
}

function mat3x3ApplyAtlasPageTexcoord (m, page)
{
	if (page)
	{
		mat3x3Scale(m, 1 / page.w, 1 / page.h);
	}
	return m;
}

function mat3x3Translate (m, x, y)
{
	m[6] += m[0] * x + m[3] * y;
	m[7] += m[1] * x + m[4] * y;
	return m;
}

function mat3x3Transform (m, v, out)
{
	var x = m[0]*v[0] + m[3]*v[1] + m[6];
	var y = m[1]*v[0] + m[4]*v[1] + m[7];
	var w = m[2]*v[0] + m[5]*v[1] + m[8];
	var iw = (w)?(1/w):(1);
	out[0] = x * iw;
	out[1] = y * iw;
	return out;
}

function mat3x3RotateCosSin (m, c, s)
{
	var m0 = m[0], m1 = m[1];
	var m3 = m[3], m4 = m[4];
	m[0] = m0 * c + m3 * s;
	m[1] = m1 * c + m4 * s;
	m[3] = m3 * c - m0 * s;
	m[4] = m4 * c - m1 * s;
	return m;
}

function mat3x3ApplyAtlasSiteTexcoord (m, site)
{
	if (site)
	{
		mat3x3Translate(m, site.x, site.y);
		if (site.rotate === -1)
		{
			mat3x3Translate(m, 0, site.w); // bottom-left corner
			mat3x3RotateCosSin(m, 0, -1); // -90 degrees
		}
		else if (site.rotate === 1)
		{
			mat3x3Translate(m, site.h, 0); // top-right corner
			mat3x3RotateCosSin(m, 0, 1); // 90 degrees
		}
		mat3x3Scale(m, site.w, site.h);
	}
	return m;
}
goog.provide('SpineWrapper');
goog.require('spine');
goog.require('atlas');
goog.require('renderCtx2D');

SpineWrapper = function(json_data, atlas_text, image) {
	var images = {};
	this.animTime = 0;
	this.timeScale = 1;
	this.atlas_data = new atlas.Data().import(atlas_text);
	this.render_ctx2d = new renderCtx2D();
	this.spine_pose = new spine.Pose(new spine.Data().load(json_data));
	this.atlas_data.pages.forEach(function(page) {
		var imageKey = 	page.name;
		images[imageKey] = image;
		page.w = page.w || image.width;
		page.h = page.h || image.height;
	});
	this.render_ctx2d.loadPose(this.spine_pose, this.atlas_data, images);
};

SpineWrapper.prototype.dropPose = function() {
	if(this.render_ctx2d) {
		this.render_ctx2d.dropPose();
	}

	if(this.atlas_data) {
		this.atlas_data.drop();
	}

	this.atlas_data = null;
	this.spine_pose = null;
	this.render_ctx2d = null;
};

SpineWrapper.prototype.getAnimationKeys = function() {
	return this.spine_pose.data.anim_keys;
};

SpineWrapper.prototype.getCurrentAnimKey = function() {
	return this.spine_pose.getAnim();
};

SpineWrapper.prototype.getSkinKeys = function() {
	return this.spine_pose.data.skin_keys;
};

SpineWrapper.prototype.getCurrentSkinKey = function() {
	return this.spine_pose.getSkin();
};

SpineWrapper.prototype.setSkinByName = function(skinName) {
	this.spine_pose.setSkin(skinName);
};

SpineWrapper.prototype.getAnimDuration = function(animName) {
	var anims = this.spine_pose.getAnims();

	return anims[animName] ? anims[animName].max_time : 0;
};

SpineWrapper.prototype.setAnimationByName = function(name, skinName, times, onDone, onStep) {
	var animIdx = name === "default" ? 0 : this.spine_pose.data.anim_keys.indexOf(name);
	var skinIdx = skinName == void 0 ? 0 : this.spine_pose.data.skin_keys.indexOf(skinName);

	if(animIdx === -1 || skinIdx === -1) {
		throw new Error('invalid animation time');
	}
	else {
		this.animTime = 0;
		this.repeatTimes = times;
		this.onPlayDone = onDone;
		this.onPlayStep = onStep;
		this.spine_pose.setSkin(this.spine_pose.data.skin_keys[skinIdx]);
		this.spine_pose.setAnim(this.spine_pose.data.anim_keys[animIdx]);
		this.spine_pose.setTime(0);
	}

	return this;
};

SpineWrapper.prototype.setTimeScale = function(scale) {
	this.timeScale = scale;
	return this;
};

SpineWrapper.prototype.setGeometry = function(w, h) {
	this.width = w;
	this.height = h;
	return this;
};

SpineWrapper.prototype.callOnComplete = function() {
	this.repeatTimes--;
	if(this.repeatTimes === 0) {
		if(this.onPlayStep) {
			this.onPlayStep();
		}
		if(this.onPlayDone) {
			this.onPlayDone();
		}
	}
	else {
		if(this.onPlayStep) {
			this.onPlayStep();
		}
	}
};

SpineWrapper.prototype.update = function(ctx, dt) {
	if(!this.repeatTimes) return;

	dt*=this.timeScale;
	this.animTime += dt;

	var anim = this.spine_pose.curAnim();
	var limitTime = anim.max_time;

    if(this.animTime > limitTime) {
		this.callOnComplete();
		this.animTime -= limitTime;
		this.spine_pose.time = limitTime;
		dt = 0;
	}

	this.render_ctx2d.setContext(ctx);
	this.spine_pose.update(dt);
	this.spine_pose.strike();
};

SpineWrapper.prototype.replaceSlotImage = function(name, image, imageRect) {
    var slot_keys = this.spine_pose.slot_keys;

    if(!slot_keys || slot_keys.indexOf(name) == -1) {
        return;
    }

    this.render_ctx2d.replaceSlotImage(name, image, imageRect);
}

SpineWrapper.prototype.paint = function(ctx) {
	ctx.scale(1, -1);
	this.render_ctx2d.drawPose(this.spine_pose, this.atlas_data);
};
/*
 * File:   ui-spine.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Spine Skeleton Animation.
 *
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 *
 */

/**
 * @class UISpine
 * @extends UISkeletonAnimation
 * Spine骨骼动画。参考：[Spine](https://github.com/EsotericSoftware/spine-runtimes)
 */
function UISpine() {
}

UISpine.prototype = new UISkeletonAnimation();
UISpine.prototype.initUISpine = UISkeletonAnimation.prototype.initUISkeletonAnimation;

UISpine.prototype.doPlay = UISpine.prototype.gotoAndPlay = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	var me = this;
	this.animationName = animationName;

	if(this.spineWrapper) {
		var repeatTimes = repeatTimes ? repeatTimes : 0xffffffff;
		this.spineWrapper.setAnimationByName(animationName, this.skinName, repeatTimes, onDone, onOneCycle);
	}

	return this;
}

UISpine.prototype.pause = function() {
	if(this.spineWrapper) {
		this.spineWrapper.setTimeScale(0);
	}

	return this;
}

UISpine.prototype.resume = function() {
	if(this.spineWrapper) {
		this.spineWrapper.setTimeScale(1);
	}
	return this;
}

UISpine.prototype.createArmature = function(texture, textureData, skeletonJSON, onDone) {
	if(this.spineWrapper) {
		this.spineWrapper.dropPose();
	}

	this.spineWrapper = new SpineWrapper(skeletonJSON, textureData, texture);
	this.animationNames = this.spineWrapper.getAnimationKeys();
	this.animationName = this.animationName && this.animationNames.indexOf(this.animationName) > -1 ?
		this.animationName : this.animationNames[0];

	return;
}

UISpine.prototype.update = function(canvas) {
	var dt = (canvas.timeStep * this.animTimeScale);
	this.spineWrapper.update(canvas, dt);
}

UISpine.prototype.destroyArmature = function() {
	if(this.spineWrapper) {
		this.spineWrapper.dropPose();
		this.spineWrapper = void 0;
		this.animaName = void 0;
		this.skinName = void 0;
	}
}

UISpine.prototype.paintSelfOnly = function(canvas) {
	if(!this.spineWrapper) {
		return;
	}

	var ay = this.h;
	var ax = this.w >> 1;

	canvas.translate(ax, ay);
	canvas.scale(this.animationScaleX, this.animationScaleY);

	if(!this.isPaused()) {
		this.update(canvas);
	}
	this.spineWrapper.paint(canvas);

	if(isNaN(canvas.needRedraw)) {
		canvas.needRedraw = 1;
	}
	canvas.needRedraw++;

	return;
}

UISpine.prototype.setSkin = function(skinName) {
	this.skinName = skinName;
	if(this.spineWrapper) {
		this.spineWrapper.setSkinByName(skinName);
	}

	return this;
}

UISpine.prototype.getCurrentSkinKey = function() {
	if(this.spineWrapper) {
		return this.spineWrapper.getCurrentSkinKey();
	}
};

UISpine.prototype.getCurrentAnimKey = function() {
	if(this.spineWrapper) {
		return this.spineWrapper.getCurrentAnimKey();
	}
};

UISpine.prototype.getSkins = function() {
	if(this.spineWrapper) {
		return this.spineWrapper.getSkinKeys();
	}

	return ["default"];
}

UISpine.prototype.getDuration = UISpine.prototype.getAnimationDuration = function(animaName) {
	if(!this.spineWrapper) return 0;
	animaName = animaName || this.animationName;

	return this.spineWrapper.getAnimDuration(animaName);
}

UISpine.prototype.replaceSlotImage = function(name, image, imageRect) {
    if(!this.spineWrapper || !image) {
         return;
    }

    if(image instanceof WImage) {
        imageRect = image.getImageRect();
        image = image.getImage();
    }
    else if(!imageRect) {
        imageRect = {
            x: image.x,
            y: image.y,
            w: image.width,
            h: image.height
        }
    }

    this.spineWrapper.replaceSlotImage(name, image, imageRect);

    return this;
}

function UISpineCreator() {
	var args = ["ui-spine", "ui-spine", null, true];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISpine();
		return g.initUISpine(this.type, 200, 200);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UISpineCreator());
/*
 * File:   ui-line-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  line joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UILineJoint() {
	return;
}

UILineJoint.prototype = new UITwoJoint();
UILineJoint.prototype.isUIJoint = true;
UILineJoint.prototype.isUILineJoint = true;

UILineJoint.prototype.initUILineJoint = function(type, w, h) {
	this.initUITwoJoint(type, w, h);	

	return this;
}

function UILineJointCreator() {
	var args = ["ui-line-joint", "ui-line-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILineJoint();
		return g.initUILineJoint(this.type, 200, 200);
	}
	
	return;
}

/*
 * File:   ui-two-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  two anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UITwoJoint() {
	return;
}

UITwoJoint.prototype = new UITwoPoints();
UITwoJoint.prototype.isUIJoint = true;
UITwoJoint.prototype.isUITwoJoint = true;

UITwoJoint.prototype.initUITwoJoint = function(type, w, h) {
	this.initUITwoPoints(type);	

	return this;
}

function UITwoJointCreator() {
	var args = ["ui-two-joint", "ui-two-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITwoJoint();
		return g.initUITwoJoint(this.type, 200, 200);
	}
	
	return;
}

/*
 * File:   ui-dragger.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  mouse joint, react with pointer event.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIDragger
 * @extends UIElement
 * Dragger。把它放到某个控件上，该控件便可被玩家拖动了。
 *
 */

/**
 * @event onDragStart
 * 拖动开始事件。
 */

/**
 * @event onDragEnd
 * 拖动结束事件。
 */

/**
 * @event onDragging
 * 拖动事件。
 */
function UIDragger() {
	return;
}

UIDragger.prototype = new UIElement();
UIDragger.prototype.isUIDragger = true;

UIDragger.prototype.saveProps = ["enableVer", "enableHor"];
UIDragger.prototype.initUIDragger = function(type, w, h) {
	this.initUIElement(type, w, h);	
	this.enableVer = true;
	this.enableHor = true;
	this.addEventNames(["onDragStart", "onDragging", "onDragEnd"]);

	return this;
}

UIDragger.prototype.onInit = function() {
	var parentShape = this.getParent();

	var enableHor = this.enableHor;
	var enableVer = this.enableVer;

	var dragger = this;
	if(parentShape.isUIPhysicsShape || parentShape.isUIImage || parentShape.isUISkeletonAnimation 
		|| parentShape.isUIFrameAnimation || parentShape.isUIScene) {
		parentShape.handlePointerDown = function(point, beforeChild) {
			if(!beforeChild) return;

			dragger.callOnDragStartHandler();
			return UIDragger.handleSpritePointerDown(parentShape, point);	
		}

		parentShape.handlePointerMove = function(point, beforeChild) {
			if(!beforeChild) return;

			if(parentShape.pointerDown) {
				dragger.callOnDraggingHandler();
			}
			return UIDragger.handleSpritePointerMove(parentShape, point, enableVer, enableHor);	
		}

		parentShape.handlePointerUp = function(point, beforeChild) {
			if(!beforeChild) return;

			dragger.callOnDragEndHandler();
			return UIDragger.handleSpritePointerUp(parentShape, point);	
		}
	}
}

UIDragger.handleSpritePointerDown = function(parentShape, point) {
	if(parentShape.isUIScene) {
		parentShape.saveXOffset = parentShape.xOffset;
		parentShape.saveYOffset = parentShape.yOffset;
	}
	else {
		parentShape.saveX  = parentShape.left;
		parentShape.saveY  = parentShape.top;
	}

	return;
}

UIDragger.handleSpritePointerUp = function(parentShape, point) {
}

UIDragger.handleSpritePointerMove = function(parentShape, point, enableVer, enableHor) {
	if(parentShape.pointerDown) {
		var dx = parentShape.getMoveAbsDeltaX();
		var dy = parentShape.getMoveAbsDeltaY();

		if(parentShape.isUIScene) {
			var x = enableHor ? parentShape.saveXOffset - dx : parentShape.saveXOffset;
			var y = enableVer ? parentShape.saveYOffset - dy : parentShape.saveYOffset;
			parentShape.setOffset(x, y);
		}
		else {
			var x = enableHor ? parentShape.saveX + dx : parentShape.saveX;
			var y = enableVer ? parentShape.saveY + dy : parentShape.saveY;
			parentShape.setLeftTop(x, y);
			parentShape.onPositionChanged();
		}
	}

	return;
}

function UIDraggerCreator() {
	var args = ["ui-dragger", "ui-dragger", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDragger();
		return g.initUIDragger(this.type, 20, 20, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDraggerCreator());

/*
 * File:   ui-footprint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIFootprint() {
	return;
}

UIFootprint.prototype = new UIElement();
UIFootprint.prototype.isUIFootprint = true;

UIFootprint.prototype.initUIFootprint = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);

	return this;
}

UIFootprint.prototype.paintSelfOnly = function(canvas) {
	if(this.mode === Shape.MODE_EDITING) {
		var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
		if(!image) {
			var x = this.w >> 1;
			var y = this.h >> 1;
		
			canvas.arc(x, y, 10, 0, 2 * Math.PI);
			canvas.fill();
		}
	}

	return;
}

UIFootprint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIFootprintCreator() {
	var args = ["ui-foot-print", "ui-foot-print", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFootprint();
		return g.initUIFootprint(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIFootprintCreator());

/*
 * File:   ui-transform-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Animation By Change Transform.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UITransformAnimation
 * @extends UIImage
 * 通过几何变换实现动画效果。它本身只是一张图片，可以放入其它动画在里面，实现更复杂的效果。
 *
 */
function UITransformAnimation() {
	return;
}

UITransformAnimation.prototype = new UIImage();
UITransformAnimation.prototype.isUITransformAnimation = true;

UITransformAnimation.prototype.initUITransformAnimation = function(type, w, h, bg) {
	this.initUIImage(type, w, h, bg);	

	this.animationConfig = {};
	this.animationConfig.opacityFrom = 1;
	this.animationConfig.opacityTo = 1;
	this.animationConfig.scaleXFrom = 1;
	this.animationConfig.scaleXTo = 1;
	this.animationConfig.scaleYFrom = 1;
	this.animationConfig.scaleYTo = 1;
	this.animationConfig.rotationFrom = 0;
	this.animationConfig.rotationTo = 0;
	this.animationConfig.offsetXFrom = 0;
	this.animationConfig.offsetXTo = 0;
	this.animationConfig.offsetYFrom = 0;
	this.animationConfig.offsetYTo = 0;
	this.animationConfig.frequency = 2;
	this.animationConfig.random = 1000 * Math.random();

	return this;
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.pause = function() {
	if(this.highlightConfig) {
		this.highlightConfig.paused = true;
	}

	return this;
}

/**
 * @method resume 
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.resume = function() {
	if(this.highlightConfig) {
		this.highlightConfig.paused = false;
	}

	return this;
}

/**
 * @method play
 * 播放动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.play = function() {
	this.setHighlightConfig(this.animationConfig);

	return this;
}

/**
 * @method stop
 * 停止动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.stop = function() {
	this.setHighlightConfig(null);

	return this;
}

UITransformAnimation.prototype.getScaleXFrom = function() {
	return this.animationConfig.scaleXFrom;
}

UITransformAnimation.prototype.setScaleXFrom = function(scaleXFrom) {
	this.animationConfig.scaleXFrom = scaleXFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleXTo = function() {
	return this.animationConfig.scaleXTo;
}

UITransformAnimation.prototype.setScaleXTo = function(scaleXTo) {
	this.animationConfig.scaleXTo = scaleXTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleYFrom = function() {
	return this.animationConfig.scaleYFrom;
}

UITransformAnimation.prototype.setScaleYFrom = function(scaleYFrom) {
	this.animationConfig.scaleYFrom = scaleYFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleYTo = function() {
	return this.animationConfig.scaleYTo;
}

UITransformAnimation.prototype.setScaleYTo = function(scaleYTo) {
	this.animationConfig.scaleYTo = scaleYTo;
	this.play();

	return this;
}

UITransformAnimation.RADIAN_TO_ANGLE = 180/Math.PI;

UITransformAnimation.prototype.getRotationFrom = function() {
	return this.animationConfig.rotationFrom * UITransformAnimation.RADIAN_TO_ANGLE;
}

UITransformAnimation.prototype.setRotationFrom = function(rotationFrom) {
	this.animationConfig.rotationFrom = rotationFrom/UITransformAnimation.RADIAN_TO_ANGLE;
	this.play();

	return this;
}

UITransformAnimation.prototype.getRotationTo = function() {
	return this.animationConfig.rotationTo * UITransformAnimation.RADIAN_TO_ANGLE;
}

UITransformAnimation.prototype.setRotationTo = function(rotationTo) {
	this.animationConfig.rotationTo = rotationTo/UITransformAnimation.RADIAN_TO_ANGLE;
	this.play();

	return this;
}

UITransformAnimation.prototype.getOpacityFrom = function() {
	return this.animationConfig.opacityFrom;
}

UITransformAnimation.prototype.setOpacityFrom = function(opacityFrom) {
	this.animationConfig.opacityFrom = opacityFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getOpacityTo = function() {
	return this.animationConfig.opacityTo;
}

UITransformAnimation.prototype.setOpacityTo = function(opacityTo) {
	this.animationConfig.opacityTo = opacityTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getXFrom = function() {
	return this.animationConfig.offsetXFrom;
}

UITransformAnimation.prototype.setXFrom = function(offsetXFrom) {
	this.animationConfig.offsetXFrom = offsetXFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getXTo = function() {
	return this.animationConfig.offsetXTo;
}

UITransformAnimation.prototype.setXTo = function(offsetXTo) {
	this.animationConfig.offsetXTo = offsetXTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getYFrom = function() {
	return this.animationConfig.offsetYFrom;
}

UITransformAnimation.prototype.setYFrom = function(offsetYFrom) {
	this.animationConfig.offsetYFrom = offsetYFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getYTo = function() {
	return this.animationConfig.offsetYTo;
}

UITransformAnimation.prototype.setYTo = function(offsetYTo) {
	this.animationConfig.offsetYTo = offsetYTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getFrequency = function() {
	return this.animationConfig.frequency;
}

UITransformAnimation.prototype.setFrequency = function(frequency) {
	this.animationConfig.frequency = frequency;
	this.play();

	return this;
}

UITransformAnimation.prototype.getRandom = function() {
	return this.animationConfig.random;
}

UITransformAnimation.prototype.setRandom = function(random) {
	this.animationConfig.random = random%1000;
	this.play();

	return this;
}

UITransformAnimation.prototype.doFromJson = function(js) {
	UISprite.prototype.doFromJson.call(this, js);

	if(js.animationConfig) {
		this.animationConfig = JSON.parse(JSON.stringify(js.animationConfig));
		this.play();
	}

	return;
}

UITransformAnimation.prototype.doToJson = function(o) {
	UISprite.prototype.doToJson.call(this, o);

	o.animationConfig = JSON.parse(JSON.stringify(this.animationConfig));

	return o;
}

UITransformAnimation.prototype.beforePaintChildren = function(canvas) {
//	this.applyTransform(canvas);

	return this;
}

UITransformAnimation.prototype.onInit = function() {
	this.play();

	return;
}

function UITransformAnimationCreator() {
	var args = ["ui-transform-animation", "ui-transform-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITransformAnimation();
		return g.initUITransformAnimation(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITransformAnimationCreator());

/*
 * File:   ui-scene.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  The game scene
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIScene
 * @extends UINormalWindow
 * 游戏场景。在UINormalWindow上增加了物理引擎和虚拟屏幕的支持。
 *
 */

/**
 * @property {Number} xOffset 
 * 当场景的虚拟大小大于实际大小时，当前可视区域的X偏移量。
 */

/**
 * @property {Number} yOffset 
 * 当场景的虚拟大小大于实际大小时，当前可视区域的Y偏移量。
 */

/**
 * @property {Number} virtualWidth 
 * 当场景的虚拟宽度。
 */

/**
 * @property {Number} virtualHeight 
 * 当场景的虚拟高度。
 */
function UIScene() {
	return;
}

UIScene.prototype = new UINormalWindow();
UIScene.prototype.isUIScene = true;

UIScene.prototype.saveProps = ["enablePhysics", "showFPS", "maxFPSMode", "fps", "gravityX", "gravityY",
	"pixelsPerMeter", "virtualWidth", "virtualHeight", "xOffset", "yOffset", "openAnimationDuration",
	"closeAnimationDuration", "animHint", "windowType", "refLinesV", "refLinesH", "sceneId"];

UIScene.prototype.canRectSelectable = function() {
	return this.virtualHeight <= this.h && this.virtualWidth <= this.w;
}

UIScene.prototype.initUIScene = function(type, w, h, bg) {
	this.initUIWindow(type, 0, 0, w, h, bg);	
	this.widthAttr  = UIElement.WIDTH_FILL_PARENT;
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	this.xOffset = 0;
	this.yOffset = 0;
	this.virtualWidth = 0;
	this.virtualHeight = 0;
	this.autoClearForce = true;
	this.setAnimHint("none");
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onPointerDown", "onPointerMove", "onPointerUp", "onDoubleClick", "onMultiTouch"]);
	this.addEventNames(["onSwipeLeft", "onSwipeRight", "onSwipeUp", "onSwipeDown"]);
	this.setImage(UIElement.IMAGE_TIPS1, null);
	this.setImage(UIElement.IMAGE_TIPS2, null);
	this.setImage(UIElement.IMAGE_TIPS3, null);
	this.setImage(UIElement.IMAGE_TIPS4, null);
	this.setImage(UIElement.IMAGE_TIPS5, null);
	this.setCameraFollowParams(0.5, 0.5, 0.5, 0.5);
	this.velocityTracker = new VelocityTracker();

	return this;
}

UIScene.prototype.resetGame = function() {
	UIElement.logWarning("This API is removed, don't call it anymore! call win.replay() instead. (don't call it in open/beforeopen event.)");

	return;
}

UIScene.prototype.addStickyChild = function(child) {
	if(child.parentShape !== this || child.left >= this.w || child.top >= this.h) {
		console.log("%cWarning: invalid params to addStickyChild.", "color: red; font-weight: bold");

		return this;
	}

	child.orgX = child.left;
	child.orgY = child.top;

	this.stickyChildren.push(child);

	return this;
}

UIScene.prototype.removeStickyChild = function(child) {
	this.stickyChildren.remove(child);

	return this;
}

UIScene.prototype.updateStickyChildren = function() {
	this.stickyChildren = [];
	var a = this.children;
	for(var i = 0; i < a.length; i++) {
		var iter = a[i];
		if(iter.sticky) {
			if(iter.orgX === undefined) {
				iter.orgX = iter.left;
			}
			if(iter.orgY === undefined) {
				iter.orgY = iter.top;
			}
			this.stickyChildren.push(iter);
		}
	}

	return this;
}

UIScene.prototype.doInit = function() {
	this.xOffset = 0;
	this.yOffset = 0;
	this.setTimeScale(1);

	if(this.enablePhysics) {
		Physics.createWorld(this);	
		if(this.world && this.map) {
			this.map.createBodies(this.world);
		}
	}

	if(this.gameName) {
		document.title = this.gameName;
	}

	return;
}

UIScene.prototype.onOpen = function(initData) {
	this.doInit();
	this.play();

	return;
}

UIScene.prototype.onInit = function() {
	var me = this;
	this.initStageOne();
	this.updateStickyChildren();

	return;
}

UIScene.prototype.onDeinit = function() {
	if(this.world) {
		var world = this.world;
		Physics.destroyWorld(world);
		this.world = null;
	}

	this.stop();

	return;
}

UIScene.prototype.getVirtualWidth = function() {
	if(this.virtualWidth < this.w) {
		return this.w;
	}

	return this.virtualWidth;
}

UIScene.prototype.getVirtualHeight = function() {
	if(this.virtualHeight < this.h) {
		return this.h;
	}

	return this.virtualHeight;
}

UIScene.prototype.onScrolled = function() {
	var a = this.stickyChildren;
	if(a && a.length) {
		var ox = this.xOffset;
		var oy = this.yOffset;
		for(var i = 0; i < a.length; i++) {
			var iter = a[i];
			var x = iter.orgX + ox;
			var y = iter.orgY + oy;
			iter.setLeftTop(x, y);
			if(iter.isUIBody) {
				iter.onPositionChanged();
			}
		}
	}

	return;
}

UIScene.prototype.setOffsetDelta = function(x, y) {
	return this.setOffset(this.xOffset+x, this.yOffset+y);
}

/**
 * @method setOffset
 * 设置场景可视区左上角的坐标。
 * @param {Number} xOffset 
 * @param {Number} yOffset
 * @return {UIElement} 返回控件本身。
 *
 */
UIScene.prototype.setOffset = function(xOffset, yOffset) {
	if(xOffset || xOffset === 0) {
		var maxOffset = this.getVirtualWidth() - this.w;
		
		var xOffsetNew = Math.max(0, xOffset);
		if(xOffsetNew > maxOffset) {
			xOffsetNew = maxOffset;
		}
		this.xOffset = xOffsetNew >> 0;
	}

	if(yOffset || yOffset === 0) {
		var maxOffset = this.getVirtualHeight() - this.h;

		var yOffsetNew = Math.max(0, yOffset);
		if(yOffsetNew > maxOffset) {
			yOffsetNew = maxOffset;
		}
		this.yOffset = yOffsetNew >> 0;
	}

	this.onScrolled();

	return this;
}

UIScene.prototype.getRelayoutWidth = function() {
	return this.getWidth();
}

UIScene.prototype.getRelayoutHeight = function() {
	return this.getHeight();
}

UIScene.prototype.defaultPaintChildren = function(canvas) {
	var left = this.xOffset;
	var top = this.yOffset;
	var right = this.xOffset + this.w;
	var bottom = this.yOffset + this.h;

	var k = 0;
	var children = this.children;
	var n = this.children.length;
	var shouldDestroyShapes = [];
	for(var i = 0; i < n; i++) {
		var shape = children[i];
		if(!shape) {
			continue;
		}

		var skipIt = false;
		var x = shape.left;
		var y = shape.top;

		if(!shape.rotation && shape.children && !shape.children.length) { 
			if(x > right || y > bottom || (x + shape.w) < left || (y + shape.h) < top) {
				skipIt = true;
			}
		}

		if(shape.autoDestroyWhenOutside && skipIt) {
			shouldDestroyShapes.push(shape);
			continue;
		}

		if(!shape.visible || skipIt) {
			if(shape.isAnimating()) {
				shape.stepAnimation(canvas);
			}
			continue;
		}
	
		shape.paintSelf(canvas);
	}

	this.paintTargetShape(canvas);

	for(var i = 0; i < shouldDestroyShapes.length; i++) {
		var iter = shouldDestroyShapes[i];
		console.log("Remove " + iter.name + " autoDestroyWhenOutside=" + iter.autoDestroyWhenOutside);
		iter.remove(true);
	}

	return;
}

UIScene.prototype.setMap = function(map) {
	this.map = map;
	if(map) {
		var mapWidth = map.getMapWidth();
		var mapHeight = map.getMapHeight();
		
		if(mapWidth > this.w) {
			this.virtualWidth = mapWidth;
		}

		if(mapHeight > this.h) {
			this.virtualHeight = mapHeight;
		}

		this.setOffset(0, 0);
	}

	return this;
}

UIScene.prototype.getMap = function() {
	return this.map;
}

UIScene.prototype.drawBgImageTile = function(canvas, image, srcRect) {
    var imageWidth = srcRect.w;
    var imageHeight = srcRect.h;

    var dx = 0;
    var dy = 0;
    var dw = this.w;
    var dh = this.h;
    var maxDx = dw;
    var maxDy = dh;
    var adjustX = srcRect.x + this.xOffset % srcRect.w;
    var adjustY = srcRect.y + this.yOffset % srcRect.h;
    var sx = adjustX;
    var sy = adjustY;
    var sw = srcRect.x + srcRect.w - adjustX;
    var sh = srcRect.y + srcRect.h - adjustY;

    while(dy < maxDy) {
        sx = adjustX;
        sw = srcRect.w - adjustX;
        sh = Math.min(sh, Math.min(maxDy-dy, imageHeight));
        while(dx < maxDx) {
            sw = Math.min(sw, Math.min(maxDx-dx, imageWidth));
            canvas.drawImage(image, sx, sy, sw, sh, dx, dy, sw, sh);
            dx += sw;
            sx = srcRect.x;
            sw = srcRect.w;
        }

        dx = 0;
        dy += sh;
        sh = srcRect.h;
        sy = srcRect.y;
    }
}

UIScene.prototype.drawBgImage = function(canvas) {
	if(this.map) {
		var ox = this.xOffset;
		var oy = this.yOffset;

		var rect = {x:ox, y:oy, w:this.w, h:this.h};
		
		canvas.translate(-ox, -oy);
		this.map.draw(canvas, rect);
		canvas.translate(ox, oy);

		return;
	}

	var wImage = this.getBgImage();
	if(wImage && wImage.getImage()) {
		var image = wImage.getImage();
		var srcRect = wImage.getImageRect();
		var display = this.images.display;

		if(display === UIElement.IMAGE_DISPLAY_TILE_V) {
			this.drawBgImageVTile(canvas, image, srcRect);
		}
		else if(display === UIElement.IMAGE_DISPLAY_TILE_H) {
			this.drawBgImageHTile(canvas, image, srcRect);
		}
        else if(display === UIElement.IMAGE_DISPLAY_TILE) {
            this.drawBgImageTile(canvas, image, srcRect);
        }
		else {
			this.drawImageAt(canvas, image, display, 0, 0, this.w, this.h, srcRect);
		}

		return;
	}
}

UIScene.prototype.drawBgImageVTile = function(canvas, image, srcRect) {
	var w = this.w;
	var h = this.h;
	var iw = srcRect.w;
	var ih = srcRect.h;
	var scale = w/iw;

	var dy = 0;
	var sx =  srcRect.x;
	var sy = srcRect.y + this.yOffset%ih;
	var sh = Math.min(srcRect.y + ih-sy, h/scale);
	for(var dy = 0; dy < h; ) {
		var dh = sh * scale;
		canvas.drawImage(image, sx, sy, iw, sh, 0, dy, w, dh);

		dy += dh;
		sh = Math.min(ih, (h - dy)/scale);
		sy = srcRect.y;
	}
}

UIScene.prototype.drawBgImageHTile = function(canvas, image, srcRect) {
	var w = this.w;
	var h = this.h;
	var iw = srcRect.w;
	var ih = srcRect.h;
	var scale = h/ih;

	var dx = 0;
	var sy = srcRect.y;
	var sx = srcRect.x + this.xOffset%iw;
	var sw = Math.min(iw-sx, w/scale);

	for(var dx = 0; dx < w; ) {
		var dw = sw * scale;
		canvas.drawImage(image, sx, sy, sw, ih, dx, 0, dw, h);

		dx += dw;
		sw = Math.min(iw, (w - dx)/scale);
		sx = srcRect.x;
	}

	return;
}

UIScene.prototype.afterPaintChildren = function(canvas) {
	if(this.mode !== Shape.MODE_EDITING) {
		this.drawTipsImage(canvas);
	}

	if(!this.selected || this.mode !== Shape.MODE_EDITING) {
		return;
	}
	
	var y = 10;
	var w = this.w;
	var h = this.h;
	var text = "";
	var x = w >> 1;
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(this.xOffset) {
		text = "XOffset:" + this.xOffset;
	}

	if(this.yOffset) {
		text += " YOffset:" + this.yOffset;
	}

	if(text) {
		canvas.font = "16pt Sans";
		canvas.textBaseline = "top";
		canvas.textAlign = "center";
		canvas.fillStyle = "#202020";
		canvas.fillText(text, x, y);
	}

	if(!this.pointerDown) {
		return;
	}

	if(vw === w && vh === h) {
		return;
	}

	var size = 20;
	var alpha = canvas.globalAlpha;
	canvas.fillStyle = this.style.lineColor;

	if(vw > w) {
		var y = h - size;
		var bw = w * (w/vw);
		var x = w *(this.xOffset/vw);

		canvas.globalAlpha = 0.2;
		canvas.fillRect(0, y, w, size);
		canvas.globalAlpha = 0.5;
		canvas.fillRect(x, y, bw, size);
	}

	if(vh > h) {
		var x = w - size;
		var bh = h * (h/vh);
		var y = h *(this.yOffset/vh);

		canvas.globalAlpha = 0.2;
		canvas.fillRect(x, 0, size, h);
		canvas.globalAlpha = 0.5;
		canvas.fillRect(x, y, size, bh);
	}
	canvas.globalAlpha = alpha;

	return;
}

UIScene.prototype.paintSelf = function(canvas) {
	this.stepAnimation(canvas);
	UIWindow.prototype.paintSelf.call(this, canvas);

	if(this.showFPS && this.mode !== Shape.MODE_EDITING) {
		var seconds = Math.floor(Date.now()/1000);
		if(!this.lastSeconds) {
			this.fps = 0;
			this.drawCount = 0;
			this.lastSeconds = seconds;
		}
		
		this.drawCount++;
		if(seconds > this.lastSeconds) {
			this.fps = this.drawCount;

			this.drawCount = 0;
			this.lastSeconds = seconds;
		}
		
		var h = 30;
		var w = 60;
		var str = this.fps; 

		canvas.save();
		canvas.beginPath();
		canvas.rect(0, 0, w, h);
		canvas.fillStyle = "Black";
		canvas.fill();

		canvas.textAlign = "center";
		canvas.textBaseline = "middle";
		canvas.font = "20px Sans";
		canvas.fillStyle = "White";
		canvas.fillText(str, w >> 1, h >> 1);
		canvas.restore();
	}

	return;
}

UIScene.prototype.paintChildren = function(canvas) {
	canvas.save();	
	canvas.translate(-this.xOffset, -this.yOffset);
	this.defaultPaintChildren(canvas);
	canvas.restore();

	if(this.popupWindow) {
		this.popupWindow.paintSelf(canvas);
	}
	
	return;
}

/**
 * @method setTipsImage
 * 设置提示图片的编号。提示图片通常用于显示游戏玩法之类信息。
 * @param {Number} index index 提示图片的编号，通常是1到5，0表示不显示。
 * @param {Number} display 图片显示方式。
 * @return {UIElement} 返回控件本身。
 *
 */
UIScene.prototype.setTipsImage = function(index, display) {
	this.tipsImageIndex = index;
	this.tipsImageDisplay = display;

	return this;
}

UIScene.prototype.drawTipsImage = function(canvas) {
	if(!this.tipsImageIndex) {
		return;
	}

	var name = "tips_img_" + this.tipsImageIndex;
	var wImage = this.images[name];
	if(wImage) {
		var image = wImage.getImage();

		if(image) {
			var srcRect = wImage.getImageRect();
			var display = this.tipsImageDisplay;

			if(!display && display !== 0) {
				display = this.w < this.h ? UIElement.IMAGE_DISPLAY_FIT_WIDTH : UIElement.IMAGE_DISPLAY_FIT_HEIGHT;
			}
		
			this.drawImageAt(canvas, image, display, 0, 0, this.w, this.h, srcRect);
		}
	}

	return;
}

UIScene.prototype.stepAnimation = function(canvas) {
	var c = this.animatingInfo;
	if(!c) {
		return;	
	}

	var x = this.xOffset;
	var y = this.yOffset;
	var timePercent = Math.min((canvas.now - c.startTime)/c.duration, 1);
	var percent = c.interpolator.get(timePercent);

	console.log("stepAnimation:" + timePercent + " " + percent);
	if(c.xRange) {
		x = c.xStart + percent * c.xRange;
	}

	if(c.yRange) {
		y = c.yStart + percent * c.yRange;
	}

	if(timePercent >= 1) {
		this.animatingInfo = null;
	}

	this.setOffset(x, y);
	canvas.needRedraw++;
}

UIScene.prototype.onPointerMoveEditing = function(point, beforeChild) {
	if(!this.pointerDown || beforeChild || this.targetShape) {
		return;
	}

	return this.onPointerMoveCommon(point);
}

UIScene.prototype.onPointerMoveCommon = function(point) {
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(vw === this.w && vh === this.h) {
		return;
	}

	var dx = this.getMoveDeltaX();
	var dy = this.getMoveDeltaY();

	if(vw === this.w) {
		dx = 0;
	}

	if(vh === this.h) {
		dy = 0;
	}

	this.setOffsetDelta(-dx, -dy);

	return;
}

UIScene.prototype.fixChildSize = function(shape) {
	return;
}

UIScene.prototype.fixChildPosition = function(shape) {
	return;
}

UIScene.prototype.afterRelayoutChild = function(child) {
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = 0;
		child.w = vw;
	}
	else if(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE) {
		child.w = vw - child.left;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = 0;
		child.h = vh;
	}
	else if(child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE) {
		child.h = vh - child.top;
	}

	return;
}

/**
 * @method getWorld
 * 获取Box2d的World对象。
 * @return {Object} 获取Box2d的World对象。
 *
 * 参考：http://www.box2dflash.org/docs/2.1a/reference/
 */
UIScene.prototype.getWorld = function() {
	return this.world;
}

UIScene.prototype.createBodyForElement = function(shape) {
	Physics.createBodyForElement(this.world, this, shape);
}

UIScene.prototype.afterChildAppended = function(shape) {
	if(this.mode === Shape.MODE_EDITING || !this.world) {
		return;
	}

	if(Physics.frozen) {
		console.log("Physics.frozen, so create body async");
		setTimeout(this.createBodyForElement.bind(this, shape), 0);
	}
	else {
		this.createBodyForElement(shape);
	}
}

UIScene.prototype.afterChildRemoved = function(shape) {
	if(this.map === shape) {
		this.map = null;
	}

	if(this.mode === Shape.MODE_EDITING || !this.world) {
		return;
	}

	Physics.destroyBodyForElement(this.world, shape);

	this.postRedraw();

	return;
}

UIScene.prototype.translatePoint = function(point) {
	if(this.popupWindow) {
		return point;
	}
	else {
		var p = {x : (point.x - this.left + this.xOffset), y : (point.y - this.top + this.yOffset)};
		return p;
	}
}

/**
 * @method isPlaying
 * 是否处于暂停状态。
 * @return {Boolean} 是否处于暂停状态。
 *
 */
UIScene.prototype.isPlaying = function() {
	return this.playing && this.mode != Shape.MODE_EDITING;
}

/**
 * @method replay
 * 重置游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.replay = function() {
	this.openScene(name, this.initData);
	this.play();

	return this;
}

/**
 * @method pause
 * 暂停游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.pause = function() {
	this.playing = false;
	this.setTimeScale(0);

	return this;
}

/**
 * @method resume
 * 恢复游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.resume = function() {
	this.playing = true;
	this.setTimeScale(1);

	return this;
}

UIScene.prototype.play = function() {
	this.playing = true;

	return;
}

UIScene.prototype.stop = function() {
	this.playing = false;

	return;
}

/**
 * @method toMeter
 * 把像素转化成米。
 * @param {Number} pixel
 * @return {Number} 米。
 *
 */
UIScene.prototype.toMeter = function(pixel) {
	var pixelsPerMeter = this.pixelsPerMeter ? this.pixelsPerMeter : 10;

	return pixel/pixelsPerMeter;
}

/**
 * @method toPixel
 * 把米转化成像素。
 * @param {Number} meter
 * @return {Number} 像素。
 *
 */
UIScene.prototype.toPixel = function(meter) {
	var pixelsPerMeter = this.pixelsPerMeter ? this.pixelsPerMeter : 10;

	return meter * pixelsPerMeter;
}

UIScene.prototype.getFPS = function() {
	return this.fps ? this.fps : 30;
}

UIScene.prototype.setFPS = function(fps) {
	this.fps = Math.max(5, Math.min(50, fps));

	return this;
}

UIScene.prototype.setVelocityIterations = function(velocityIterations) {
	this.velocityIterations = velocityIterations;

	return this;
}

UIScene.prototype.setPositionIterations = function(positionIterations) {
	this.positionIterations = positionIterations;

	return this;
}

/**
 * @method setAutoClearForce
 * 设置是否自动清除作用力。
 * @param {Boolean} autoClearForce 为真则每个时间片断自动清除作用力，否则力会持续作用。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.setAutoClearForce = function(autoClearForce) {
	this.autoClearForce = autoClearForce;

	return this;
}

/**
 * @method setCameraFollowParams 
 * 设置镜头自动跟随的参数。
 * @param {Number} xMin [0-1] 角色的x < this.w * xMin时向左移动。
 * @param {Number} xMax [0-1] 角色的x > this.w * xMax时向右移动。
 * @param {Number} yMin [0-1] 角色的y < this.h * yMin时向上移动。
 * @param {Number} yMax [0-1] 角色的y > this.h * yMax时向下移动。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.setCameraFollowParams = function(xMin, xMax, yMin, yMax) {
	this.cameraFollowParams = {};
	this.cameraFollowParams.xMin = xMin;
	this.cameraFollowParams.xMax = xMax;
	this.cameraFollowParams.yMin = yMin;
	this.cameraFollowParams.yMax = yMax;

	return this;
}

UIScene.prototype.cameraFollow = function(element) {
	var w = this.w;
	var h = this.h;
	var x = element.left;
	var y = element.top;
	var dx = x - this.xOffset;
	var dy = y - this.yOffset;
	var params = this.cameraFollowParams;

	var xOffset = this.xOffset;
	if(dx > params.xMax * w) {
		xOffset = Math.round(x - params.xMax * w) + (element.w >> 1);
	}
	else if(dx < params.xMin * w){
		xOffset = Math.round(x - params.xMin * w) + (element.w >> 1);
	}

	var yOffset = this.yOffset;
	if(dy > params.yMax * h) {
		yOffset = Math.round(y - params.yMax * h) + (element.h >> 1);
	}
	else if(dy < params.yMin * h) {
		yOffset = Math.round(y - params.yMin * h) + (element.h >> 1);
	}

	this.setOffset(xOffset, yOffset);

	return;
}

UIScene.prototype.prepareForOpen = function() {
	if(this.world) {
		var world = this.world;
		Physics.destroyWorld(world);
		this.world = null;
	}

	UIWindow.prototype.prepareForOpen.call(this);
}

function UISceneCreator() {
	var args = ["ui-scene", "ui-scene", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScene();
		return g.initUIScene(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISceneCreator());

function Physics() {
};

Physics.pixelsPerMeter = 10;

Physics.toMeter = function(pixel) {
	return pixel / Physics.pixelsPerMeter;
}

Physics.toPixel = function(meter) {
	return meter * Physics.pixelsPerMeter;
}

Physics.createFixtureDef = function(world, element) {
	var hw = element.w >> 1;
	var hh = element.h >> 1;
	var fixtureDef = new b2FixtureDef();
	var x = element.left + hw;
	var y = element.top + hh;

	fixtureDef.density = element.density;
	fixtureDef.friction = element.friction;
	fixtureDef.restitution = element.restitution;

	if(element.categoryBits) {
		fixtureDef.filter.categoryBits = element.categoryBits;
	}

	if(element.maskBits) {
		fixtureDef.filter.maskBits = element.maskBits;
	}

	if(element.groupIndex) {
		fixtureDef.filter.groupIndex = element.groupIndex;
	}

	if(element.isSensor) {
		fixtureDef.isSensor = true;
	}

	if(element.isUICircle || element.physicsShape === "circle") {
		hw = element.getWidth(true) >> 1;
		hh = element.getHeight(true) >> 1;
		var radius = Physics.toMeter(Math.min(hw, hh));
		fixtureDef.shape = new b2CircleShape(radius);
	}
	else if(element.isUIBox || element.physicsShape ===	"rectangle") {
	        hw = element.getWidth(true) >> 1;
	        hh = element.getHeight(true) >> 1;
	        fixtureDef.shape = new b2PolygonShape();
	        fixtureDef.shape.SetAsBox(Physics.toMeter(hw),	Physics.toMeter(hh));
	}
	else if(element.isUIPolygon) {
		var cx = hw;
	        var cy = hh;
	        var arr = [];
	        var fixtureDefs = [];
	        var n = element.children.length;
			if(n < 3) {
				alert("Polygon has no enough points");
				return null;
			}

	        for(var i = 0; i < n; i++) {
	                var p = {};
	                var iter = element.children[i];

	                if(!iter.isUIPoint) {
	                        continue;
	                }

	                p.x = Physics.toMeter(iter.left + (iter.w >>1) - cx);
	                p.y = Physics.toMeter(iter.top + (iter.h >> 1) - cy);

	                if(arr.length === 5) {
	                        fixtureDef = new b2FixtureDef();
	                        fixtureDef.density = element.density;
	                        fixtureDef.friction = element.friction;
	                        fixtureDef.restitution = element.restitution;
	                        fixtureDef.isSensor = element.isSensor;
	                        fixtureDef.shape = new	b2PolygonShape();
	                        fixtureDef.shape.SetAsArray(arr, arr.length);
	                        fixtureDefs.push(fixtureDef);
	                        arr = [];
	                }
	                arr.push(p);
	        }

	        if(arr.length > 2) {
	                fixtureDef = new b2FixtureDef();
	                fixtureDef.density = element.density;
	                fixtureDef.friction = element.friction;
	                fixtureDef.restitution = element.restitution;
	                fixtureDef.isSensor = element.isSensor;
	                fixtureDef.shape = new b2PolygonShape();
	                fixtureDef.shape.SetAsArray(arr, arr.length);
	                fixtureDefs.push(fixtureDef);
	                arr = [];
	        }

	        return fixtureDefs.length > 1 ? fixtureDefs : fixtureDefs[0];
	}
	else if(element.isUIEdge) {
	        var p0 = element.points[0];
	        var p1 = element.points[1];
	        
	        var cx = element.getCenterX();
	        var cy = element.getCenterY();
			var x0 = p0.x - cx;
			var y0 = p0.y - cy;
			var x1 = p1.x - cx;
			var y1 = p1.y - cy;
	        var v0 = new b2Vec2(Physics.toMeter(x0), Physics.toMeter(y0));
	        var v1 = new b2Vec2(Physics.toMeter(x1), Physics.toMeter(y1));
			fixtureDef.shape = new b2PolygonShape()
			fixtureDef.shape.SetAsEdge(v0, v1);
	}

	return fixtureDef;
}

Physics.createBody = function(world, element) {
	var body = null;
	var pos = element.getPositionInWindow();
	var hw = element.getWidth() >> 1;
	var hh = element.getHeight() >> 1;
	var x  = pos.x + hw;
	var y  = pos.y + hh;
	var density = element.density;
	var bodyDef = new b2BodyDef();
	var fixtureDef = Physics.createFixtureDef(world, element);

	if(density < 0) {
		bodyDef.type = b2Body.b2_kinematicBody;
	}
	else {
		bodyDef.type = density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
	}

	if(element.isUIEdge) {
		x = element.getCenterX();
		y = element.getCenterY();
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	}
	else {
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	}
	
	if(element.fixedRotation) {
		bodyDef.fixedRotation = true;
	}
	
	if(element.isBullet) {
		bodyDef.bullet = true;
	}
	
	if(element.allowSleep) {
		bodyDef.awake = true;
		bodyDef.allowSleep = true;
	}
	else {
		bodyDef.allowSleep = false;
	}
					
	bodyDef.linearDamping = element.linearDamping || 0;
	bodyDef.angularDamping = element.angularDamping || 0;

	body = world.CreateBody(bodyDef);
	if(fixtureDef.length) {
		for(var i = 0; i < fixtureDef.length; i++) {
			body.CreateFixture(fixtureDef[i]);
		}
		console.log("Create Composite Polygon: n=" + fixtureDef.length);
	}
	else {
		body.CreateFixture(fixtureDef);
	}

	body.element = element;
	body.name = element.name;
	element.body = body;

	if(element.rotation) {
		body.SetAngle(element.rotation);
	}

	if(!element.enable) {
		body.SetActive(false);
	}

	if(element.xInitVelocity || element.yInitVelocity) {
		element.setV(element.xInitVelocity, element.yInitVelocity);
	}

	element.onBodyCreated();

	return body;
}

Physics.createEmbedBody = function(world, parentElement, childElement) {
	var bodyDef = null;
	var fixtureDef = Physics.createFixtureDef(world, childElement);

	if(!bodyDef) {
		var pos = parentElement.getPositionInWindow();
		var hw = parentElement.w >> 1;
		var hh = parentElement.h >> 1;
		var x  = pos.x + hw;
		var y  = pos.y + hh;
		
		bodyDef = new b2BodyDef();
		if(fixtureDef.density < 0) {
			delete fixtureDef.density;
			b2BodyDef.type = b2Body.b2_kinematicBody;
		}
		else {
			bodyDef.type = fixtureDef.density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
		}
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	
		if(parentElement.fixedRotation || childElement.fixedRotation) {
			bodyDef.fixedRotation = true;
		}

		if(parentElement.isBullet || childElement.isBullet) {
			bodyDef.bullet = true;
		}

		if(parentElement.allowSleep || childElement.allowSleep) {
			bodyDef.awake = true;
			bodyDef.allowSleep = true;
		}
		else {
			bodyDef.allowSleep = false;
		}
		
		if(childElement.linearDamping !== undefined) {
			bodyDef.linearDamping = childElement.linearDamping;
		}
		
		if(childElement.angularDamping !== undefined) {
			bodyDef.angularDamping = childElement.angularDamping;
		}

		var body = world.CreateBody(bodyDef);
		body.element = parentElement;
		parentElement.body = body;
		
		if(!parentElement.enable || !childElement.enable) {
			body.SetActive(false);
		}
	}

	body.CreateFixture(fixtureDef);

	return body;
}

Physics.createBodyForElement = function(world, parentElement, childElement) {
	if(childElement.physicsShape) {
		Physics.createBody(world, childElement);	
	}
	else if(childElement.isUIPhysicsShape) {
		if(parentElement.isUIWindow) {
			Physics.createBody(world, childElement);
		}
		else if(parentElement.isUISprite || parentElement.isUISkeletonAnimation 
			|| parentElement.isUITransformAnimation || parentElement.isUIFrameAnimation){
			Physics.createEmbedBody(world, parentElement, childElement);
		}
		else {
			Physics.createBody(world, childElement);
		}
	} else {
		Physics.createWorldShapes(world, childElement);
	}

	return;
}

Physics.destroyBodyForElement = function(world, element) {
	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.destroyBodyForElement(world, iter);
	}
	
	if(element.body) {
		var body = element.body;
		body.SetActive(false);
		
		setTimeout(function() {			
			world.DestroyBody(body);
		}, 0);

		body.element = null;
		element.body = null;
	}

	return;
}

Physics.destroyJointForElement = function(world, element) {
	if(element.joint) {
        var joint = element.joint;
        element.joint = null;
		setTimeout(function() {
			world.DestroyJoint(joint);
            joint = null;
		}, 0);
	}

	return;
}

Physics.createWorldShapes = function(world, element) {
	var x = 0;
	var y = 0;
	var bodyDef = null;
	var fixtureDef = null;

	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.createBodyForElement(world, element, iter);
	}

	return;
}

Physics.findBodiesAtPoint = function(scene, point, index) {
	var arr = [];
	var n = scene.children.length;

	var canvas = cantkGetTempCanvas(scene.w, scene.h);
	var ctx = canvas.getContext("2d");

	for(var i = index; i >= 0; i--) {
		var iter = scene.children[i];
		if(!iter.body) {
			continue;
		}

		var rect = {x:iter.left, y:iter.top, w:iter.w, h:iter.h};
		if(iter.rotation) {
			ctx.save();
			ctx.beginPath();
			ctx.translate(rect.x, rect.y);
			if(iter.rotation) {
				ctx.translate(rect.w >> 1, rect.h >> 1);
				ctx.rotate(iter.rotation);
				ctx.translate(-(rect.w >> 1), -(rect.h >> 1));
			}
			ctx.rect(0, 0, rect.w, rect.h);
			if(ctx.isPointInPath(point.x, point.y)) {
				arr.push(iter.body);
			}
			ctx.restore();
		}
		else {
			if(isPointInRect(point, rect)) {
				arr.push(iter.body);
			}
		}
	}

	return arr;
}

Physics.createJoint = function(world, element, scene) {
	var scene = element.getWindow();
	if(!element.isUIJoint) {
		return;
	}

	if(element.isUIOneJoint) {
		var p = {};
		var arr = null;
		p.x = element.left + (element.w >> 1);
		p.y = element.top + (element.h >> 1);

		var index = element.getIndex();
		arr = Physics.findBodiesAtPoint(scene, p, index);

		if(arr.length == 1) {
			arr = [world.GetGroundBody(), arr[0]];
		}

		if(arr.length > 1) {
			var rJointDef = null;
			var anchorPoint = new b2Vec2(Physics.toMeter(p.x), Physics.toMeter(p.y));

			if(arr[0].GetType() === b2Body.b2_staticBody && arr[1].GetType() === b2Body.b2_staticBody) {
				console.log("%cWarning: it seems no meanings to pin two static body together.", 
					"color: red; font-weight: bold");
			}
			
			if(element.isUIRevoluteJoint) {
				rJointDef = new b2RevoluteJointDef();
				rJointDef.Initialize(arr[0], arr[1], anchorPoint);

				rJointDef.lowerAngle = (element.lowerAngle ? element.lowerAngle : 0)*Math.PI/180;
				rJointDef.upperAngle = (element.upperAngle ? element.upperAngle : 0)*Math.PI/180;
				rJointDef.motorSpeed = element.motorSpeed ? element.motorSpeed : 0;
				rJointDef.maxMotorTorque = element.maxMotorTorque ? element.maxMotorTorque : 0;
				rJointDef.enableLimit = element.enableLimit ? element.enableLimit : false;
				rJointDef.enableMotor = element.enableMotor ? element.enableMotor : false;
			}
			else if(element.isUIWeldJoint) {
				rJointDef = new b2WeldJointDef();
				rJointDef.Initialize(arr[0], arr[1], anchorPoint);
			}

			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}
	else if(element.isUITwoJoint) {
		var rJointDef = null;
		var p0 = element.points[0];
		var p1 = element.points[1];
		var index = element.getIndex();
		var arr0 = Physics.findBodiesAtPoint(scene, p0, index);
		var arr1 = Physics.findBodiesAtPoint(scene, p1, index);

		if(arr0.length && arr1.length) {
			var anchorPoint0 = new b2Vec2(Physics.toMeter(p0.x), Physics.toMeter(p0.y));
			var anchorPoint1 = new b2Vec2(Physics.toMeter(p1.x), Physics.toMeter(p1.y));

			if(element.isUIDistanceJoint) {
				rJointDef = new b2DistanceJointDef();
				rJointDef.Initialize(arr0[0], arr1[0], anchorPoint0, anchorPoint1);

				rJointDef.frequencyHz = element.frequencyHz || 0;
				rJointDef.dampingRatio = element.dampingRatio || 0;
				rJointDef.collideConnected = element.collideConnected;
			}
			else if(element.isUILineJoint) {
				var dx = anchorPoint1.x - anchorPoint0.x;
				var dy = anchorPoint1.y - anchorPoint0.y;
				var axis = {};

				axis.x = dx/Math.sqrt(dx*dx+dy*dy);
				axis.y = dy/Math.sqrt(dx*dx+dy*dy);

				rJointDef = new b2LineJointDef();
				rJointDef.Initialize(arr0[0], arr0[1], anchorPoint0, axis);
				rJointDef.enableLimit = true;
				rJointDef.lowerTranslation = 0;
				rJointDef.upperTranslation = 10;
				rJointDef.enableMotor = false;
				rJointDef.maxMotorForce = 300000;
				rJointDef.motorSpeed = 1;
			}

			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}
	else if(element.isUIPulleyJoint) {
		var rJointDef = null;
		var p0 = element.points[0];
		var p1 = element.points[1];
		var p2 = element.points[2];
		var p3 = element.points[3];
		var index = element.getIndex();
		var arr0 = Physics.findBodiesAtPoint(scene, p0, index);
		var arr1 = Physics.findBodiesAtPoint(scene, p3, index);

		if(arr0.length && arr1.length) {
			rJointDef = new b2PulleyJointDef();
			var ratio = 1;
			var anchorPoint0 = new b2Vec2(Physics.toMeter(p0.x), Physics.toMeter(p0.y));
			var anchorPoint1 = new b2Vec2(Physics.toMeter(p1.x), Physics.toMeter(p1.y));
			var anchorPoint2 = new b2Vec2(Physics.toMeter(p2.x), Physics.toMeter(p2.y));
			var anchorPoint3 = new b2Vec2(Physics.toMeter(p3.x), Physics.toMeter(p3.y));

			rJointDef.Initialize(arr0[0], arr1[0], anchorPoint1, anchorPoint2, anchorPoint0, anchorPoint3, ratio);
			
			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}

	return;
}

Physics.createWorldJoints = function(world, scene, element) {
	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.createWorldJoints(world, scene, iter);
	}

	Physics.createJoint(world, element, scene);
}

Physics.updateBodyElementsPosition = function(world) {
	for (var b = world.m_bodyList; b; b = b.m_next) {
		var element = b.element;

		if(element) {
			var a = b.GetAngle();
			var p = b.GetPosition();
            if(p.x !== undefined && p.y !== undefined) {
                var x = Physics.toPixel(p.x) - (element.getWidth() >> 1);
                var y = Physics.toPixel(p.y) - (element.getHeight() >> 1);


                var parent = element.getParent();
                if(!parent.isUIWindow) {
                    var pos = parent.getPositionInWindow();
                    x = x - pos.x;
                    y = y - pos.y;
                }

                var ox = element.left;
                var oy = element.top;

                element.setRotation(a);
                if(ox !== x || oy !== y) {
                    element.setPositionByBody(x, y);
                }
            }
		}
	}

	for (var joint = world.m_jointList; joint; joint = joint.m_next) {
		switch (joint.m_type) {
			case b2Joint.e_distanceJoint: {
				var p0 = joint.GetAnchorA();
				var p1 = joint.GetAnchorB();
				var element = joint.element;

				element.points[0].x = Physics.toPixel(p0.x);
				element.points[0].y = Physics.toPixel(p0.y);

				element.points[1].x = Physics.toPixel(p1.x);
				element.points[1].y = Physics.toPixel(p1.y);
				break;
			}
			case b2Joint.e_pulleyJoint: {
				var p0 = joint.GetAnchorA();
				var p1 = joint.GetGroundAnchorA();
				var p2 = joint.GetGroundAnchorB();
				var p3 = joint.GetAnchorB();

				var element = joint.element;

				element.points[0].x = Physics.toPixel(p0.x);
				element.points[0].y = Physics.toPixel(p0.y);

				element.points[1].x = Physics.toPixel(p1.x);
				element.points[1].y = Physics.toPixel(p1.y);

				element.points[2].x = Physics.toPixel(p2.x);
				element.points[2].y = Physics.toPixel(p2.y);

				element.points[3].x = Physics.toPixel(p3.x);
				element.points[3].y = Physics.toPixel(p3.y);
				break;
			}
			default: {
				var p = joint.GetAnchorA();
				var element = joint.element;
				var x = Physics.toPixel(p.x) - (element.w >> 1);
				var y = Physics.toPixel(p.y) - (element.h >> 1);
				element.setPositionByBody(x, y);

				break;
			}
		}
	}

	return;
}

Physics.destroyWorld = function(world) {
	var b = world.m_bodyList;
	do {
		if(!b) break;

		var next = b.m_next;
		if(b.element) {
			b.element.body = null;
			b.element = null;
		}
		
		world.DestroyBody(b);

		b = next;
	}while(true);

	var joint = world.m_jointList;
	do {
		if(!joint) break;
		var next = joint.m_next;

		if(joint.element) {
			joint.element = null;
		}
			
		world.DestroyJoint(joint);

		joint = next;
	}while(true);

	return;
}

Physics.reparentPhysicsToScene = function(scene) {
	var arr = [];

	function onVisit(el) {
		var parentShape = el.getParent();
		if(el.isUISkeletonAnimation || el.isUISprite || el.isUIFrameAnimation || el.isUITransformAnimation) {
			if(!parentShape.isUIWindow) {
				arr.push(el);
			}
		}
		else if(el.isUIPhysicsShape) {
			if(!parentShape.isUISkeletonAnimation && !parentShape.isUISprite 
				&& !parentShape.isUIFrameAnimation && !parentShape.isUITransformAnimation
				&& !parentShape.isUIWindow) {
					arr.push(el);
			}
		}
	}

	scene.forEach(onVisit);

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		iter.reparent(scene, true);
	}

	return;
}

Physics.createWorld = function(scene) {
	if(scene.world || !window.b2World) {
		return;
	}

	var world = null;
	var maxX = scene.w >> 1;
	var maxY = scene.h >> 1;
	var minX = -scene.w >> 1;
	var minY = -scene.h >> 1;
	var fps = scene.getFPS();
	var allowSleep = scene.allowSleep ? scene.allowSleep : true;
	var gravityX = scene.gravityX ? scene.gravityX : 0;
	var gravityY = scene.gravityY ? scene.gravityY : 0;
	var gravity = new b2Vec2(gravityX, gravityY);
	var worldAABB = new b2AABB();
	var stepSize = 1;
	Physics.pixelsPerMeter = scene.pixelsPerMeter || 100;

	worldAABB.lowerBound.Set(minX, minY);
	worldAABB.upperBound.Set(maxX, maxY);

	world = new b2World(gravity, allowSleep);

	Physics.createWorldShapes(world, scene);
	Physics.createWorldJoints(world, scene, scene);

	var listener = new b2ContactListener();
	listener.BeginContact = function (contact) {
		var body1 = contact.GetFixtureA().GetBody();
		var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			Physics.frozen = true;
			element1.callOnBeginContactHandler(body2, contact);
			element2.callOnBeginContactHandler(body1, contact);
			Physics.frozen = false;
		}
	}
	
	listener.EndContact = function (contact) {
		var body1 = contact.GetFixtureA().GetBody();
		var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;
		if(element1 && element2) {
			Physics.frozen = true;
			element1.callOnEndContactHandler(body2, contact);
			element2.callOnEndContactHandler(body1, contact);
			Physics.frozen = false;
		}
	}
	
	listener.PreSolve = function (contact, oldManifold) {
		var body1 = contact.GetFixtureA().GetBody();
		var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			Physics.frozen = true;
			element1.callOnPreSolveHandler(body2, contact, oldManifold);
			element2.callOnPreSolveHandler(body1, contact, oldManifold);
			Physics.frozen = false;
		}
	}

	listener.PostSolve = function (contact, impulse) {
		var body1 = contact.GetFixtureA().GetBody();
		var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			Physics.frozen = true;
			element1.callOnPostSolveHandler(body2, contact, impulse);
			element2.callOnPostSolveHandler(body1, contact, impulse);
			Physics.frozen = false;
		}
	}

	world.SetContactListener(listener);

	var velocityIterations = scene.velocityIterations ? scene.velocityIterations : 8;
	var positionIterations = scene.positionIterations ? scene.positionIterations : 5;

	console.log("Box2d:" + velocityIterations + ":" + positionIterations + ":" + fps);

	var timeStep = 1/fps;
	var intervalID = 0;
	function stepIt() {
		if(scene.world != world) {
			clearInterval(intervalID);
			console.log("World is recreated.");
			return false;
		}

		var realTimeStep = scene.scaleTime(timeStep);
		if(scene.timeScaleIsZero()) {
			realTimeStep = 0;
		}

		if(scene.isVisible() && scene.isTopWindow() && scene.isPlaying()) {
			Physics.pixelsPerMeter = scene.pixelsPerMeter || 100;
			world.Step(realTimeStep, velocityIterations, positionIterations);
		
			scene.postRedraw();
			if(scene.autoClearForce) {
				world.ClearForces();
			}
			Physics.updateBodyElementsPosition(world);
		}

		return true;
	}

	scene.world = world;
	intervalID = setInterval(stepIt, timeStep * 1000);

	return;
}


/*
 * File:   ui-circle.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic circle for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICircle
 * @extends UIBody
 * 圆形刚体。
 */
function UICircle() {
	return;
}

UICircle.prototype = new UIBody();
UICircle.prototype.isUICircle = true;

UICircle.prototype.initUICircle = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UICircle.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

UICircle.prototype.resizeBody = function() {
	var x = this.left;
	var y = this.top;
	var r = Physics.toMeter(Math.min(this.getWidth(true)>>1, this.getHeight(true)>>1));
	var shape = this.body.GetFixtureList().GetShape();

	shape.SetRadius(r);
	this.body.SynchronizeFixtures();
	this.setLeftTop(x, y);
}

UICircle.prototype.drawShape = function(canvas) {
	var x = this.w >> 1;
	var y = this.h >> 1;
	var r = Math.min(this.getWidth(true)>>1, this.getHeight(true)>>1);

	canvas.arc(x, y, r, 0, Math.PI * 2);

	return;
}

function UICircleCreator() {
	var args = ["ui-circle", "ui-circle", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICircle();
		return g.initUICircle(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICircleCreator());

/*
 * File:   ui-sound.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sound for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISound() {
	return;
}

UISound.prototype = new UICheckBox();
UISound.prototype.isUISound = true;

UISound.prototype.initUISound = function(type, w, h, bg) {
	this.initUICheckBox(type, w, h, null, null, null, null, null, null);	

	this.soundURL = "";
	this.loop = true;
	this.autoPlay = true;
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UISound.prototype.setSoundURL = function(soundURL) {
	this.soundURL = soundURL;

	return;
}

UISound.prototype.setAutoPlay = function(autoPlay) {
	this.value = autoPlay;
	this.autoPlay = autoPlay;

	return;
}

UISound.prototype.setLoop = function(loop) {
	this.loop = loop;

	return;
}

UISound.prototype.isPlaying = function() {
	return this.playing;
}

UISound.prototype.pause = function() {
	if(this.audio && this.playing) {
		this.audio.pause();
		this.playing = false;
	}

	return;
}

UISound.prototype.stop = function() {
	if(this.audio && this.playing) {
		this.audio.stop();
		this.playing = false;
	}

	return;
}

UISound.prototype.play = function(force) {
	if(this.audio && (!this.playing || force)) {
		this.audio.play();
		this.playing = true;
	}

	return;
}

UISound.prototype.mute = function(value) {
	this.setValue(!value);

	return;
}

UISound.prototype.setValue = function(value) {
	this.value = value;

	if(value) {
		this.play();
	}
	else {
		this.pause();
	}

	return;
}

UISound.prototype.onModeChanged = function() {
	this.stop();

	return;
}

UISound.songs = [];
UISound.addSong = function(song) {
	UISound.songs.push(song);

	return;
}

UISound.removeSong = function(url) {
	for(var i = 0; i < UISound.songs.length; i++) {
		var iter = UISound.songs[i];
		if(iter.url === url) {
			iter.stop();
			UISound.songs.remove(iter);
			
			return iter;
		}
	}

	return null;
}

UISound.prototype.onInit = function() {
	var me = this;
	if(this.soundURL) {
		var config = {
			urls: [this.soundURL],
			autoplay: this.autoPlay,
			loop: this.loop,
			volume: 0.8
		};
		
		config.onend = function() {
			me.playing = false;
			console.log("audio end.");
		}

		UISound.removeSong(this.soundURL);
		var audio = new Howl(config);
		audio.url = this.soundURL;
		UISound.addSong(audio);

		if(!this.getValue()) {
			audio.mute();
		}

		if(this.autoPlay) {
			this.playing = true;
		}

		this.audio = audio;

		return;
	}
}

UISound.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UISound.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.mode === Shape.MODE_EDITING) {
		return;
	}
	
	this.setValue(!this.value);
	this.callOnClickHandler(point);

	return;
}

UISound.prototype.onFromJsonDone = function() {
	if(this.soundURL) {
		ResLoader.loadAudio(this.soundURL, function(audio) {
			console.log("audio loaded: " + audio.src);
		});
	}

	return;
}

function UISoundCreator() {
	var args = ["ui-sound", "ui-sound", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISound();
		return g.initUISound(this.type, 100, 100, null);
	}
	
	return;
}

/*
 * File:   ui-distance-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  distance joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIDistanceJoint
 * @extends UITwoPoints
 * 把两个刚体链接在一起，保持它们的距离不变。
 *
 */
function UIDistanceJoint() {
	return;
}

UIDistanceJoint.prototype = new UITwoJoint();
UIDistanceJoint.prototype.isUIJoint = true;
UIDistanceJoint.prototype.isUIDistanceJoint = true;

UIDistanceJoint.prototype.saveProps = ["collideConnected", "frequencyHz", "dampingRatio"];
UIDistanceJoint.prototype.initUIDistanceJoint = function(type, w, h) {
	this.initUITwoJoint(type, w, h);	
	
	this.frequencyHz = 4;
	this.dampingRatio = 0.5;
	this.collideConnected = true;

	return this;
}

function UIDistanceJointCreator() {
	var args = ["ui-distance-joint", "ui-distance-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDistanceJoint();
		return g.initUIDistanceJoint(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDistanceJointCreator());

/*
 * File:   ui-particles.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  particles 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIParticlesX
 * @extends UIElement
 * 粒子产生器。
 *
 *注意：
 * 
 * 1.系统在载入粒子配置的文件的时候，默认读取配置文件内指定的图片名称，该图片必须和配置文件在同一目录下。
 *
 * 2.用我们官方指定的粒子编辑器生成的是一个json文件，该文件默认已经包含了图片资源。用其他工具生成的粒子有配置文件和图片文件。
 *
 * 3.特殊属性，选择资源的时候只需要指定plist或者json文件即可，不必指定图片文件，引擎会去读取。
 */
function UIParticlesX() {
	return;
}

UIParticlesX.prototype = new UIElement();
UIParticlesX.prototype.isUIParticlesX = true;
UIParticlesX.prototype.saveProps = ["dataURL"];

UIParticlesX.prototype.initUIParticlesX = function(type) {
	this.initUIElement(type);	
	this.name = "ui-particles";
	this.autoEmit = true;
	this.paused = false;
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UIParticlesX.prototype.setEmitterPosition = function(x, y) {
	return this;
}

UIParticlesX.prototype.onFromJsonDone = function() {

	return this;
}

/**
 * @method emit
 * 发射粒子。
 * @param {Boolean} once 是否子发射一次。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     this.win.find("ui-particles-general").emit(true);
 *
 */
UIParticlesX.prototype.emit = function(once) {
	this.particles.emit(once);
	return this;
}

/**
 * @method start
 * 启动粒子产生器，除非调用了stop，一般不需手工调用它。
 * 如果对已经启动的粒子编辑器调用该接口，系统会清空当前粒子编辑器状态，并重新生成。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.start = function() {
	this.particles.reset();
	return this;
}

/**
 * @method stop
 * 调用该接口，粒子发射器将不再发射新的粒子，已经发射的粒子会随着生命周期的结束而消失。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.stop = function() {
	this.particles.stop();
	return this;
}

/**
 * @method pause
 * 暂停。调用该接口，相当于一个时间停滞的效果，粒子发射器将暂停发射新的粒子，已经发射的粒子停留在该时刻的状态。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.pause = function() {
	this.paused = true;
	return this;
}

/**
 * @method resume 
 * 恢复。恢复粒子发射、更新粒子状态。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.resume = function() {
	this.paused = false;

	return this;
}

UIParticlesX.prototype.loadPList = function(options, texture) {
	this.particles = new ParticleEmitter();
	this.particles.init(options);
	this.particles.setTexture(texture);

	return;
}

UIParticlesX.prototype.onInit = function() {
	var me = this;
	var options = null;

	if(this.dataURL) {
		ResLoader.loadData(this.dataURL, function(data) {
			try {
                options = JSON.parse(data);
			}
			catch(err) {
				var plist = new PList();
				options = plist.parse(data);
                if(options.textureFileName) {
                    me.textureURL = me.dataURL.substring(0, me.dataURL.lastIndexOf('/')+1) + options.textureFileName;
                }
			}

			delete me.particles;
			var imageData = options.imageData;
			if(imageData) {
				var texture = new Image();
				texture.src = imageData;
				me.loadPList(options, texture);
			}
            else if(me.textureURL) {
                ResLoader.loadImage(me.textureURL, function(img) {
                    if(img.width === 0 || img.height === 0) {
                        console.debug("particlesx invalid img");    
                        return;
                    }
                    me.loadPList(options, img);
                });
			}
		});
	}

	return;
}

UIParticlesX.prototype.drawBgImage = function() {
	return;
}

UIParticlesX.prototype.setDataURL = function(url) {
	if(url === this.dataURL || !url) return;
	this.dataURL = url;
	this.textureURL = url.substring(0, url.lastIndexOf('.')+1) + 'png';
	this.onInit();
}

UIParticlesX.prototype.getDataURL = function() {
	return this.dataURL;	
}

UIParticlesX.prototype.drawParticle = function(canvas) {
	var paused = this.timeScaleIsZero() || this.paused || (this.mode === Shape.MODE_EDITING && this.disablePreview);
	if(!paused) {
		this.particles.update(canvas.timeStep/1000);
	}

	this.particles.setScaleX(this.scaleX);
	this.particles.setScaleY(this.scaleY);

	this.particles.draw(canvas);
}

UIParticlesX.prototype.paintSelfOnly = function(canvas) {
	if(this.particles) {
		canvas.needRedraw++;
		canvas.save();
		canvas.translate(this.w/2, this.h/2);
		this.drawParticle(canvas);
		canvas.restore();
	}

	return;
}

UIParticlesX.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIParticlesXCreator() {
	var args = ["ui-particles-x", "ui-particles-x", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIParticlesX();
		return g.initUIParticlesX(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIParticlesXCreator());
void function() {

function pMultIn(point, factor) {
	point.x *= factor;
	point.y *= factor;
}

function pIn(p1, p2) {
	p1.x = p2.x;
	p1.y = p2.y;
}

function pAddIn(p1, p2) {
	p1.x += p2.x;
	p1.y += p2.y;
}

function pSubIn(p1, p2) {
	p1.x -= p2.x;
	p1.y -= p2.y;
}

function pNormalizeIn(p) {
	pMultIn(p, 1.0 / Math.sqrt(p.x * p.x + p.y * p.y));
}

function pZeroIn(p) {
	p.x = 0;
	p.y = 0;
}

function Point(x, y) {
	if(!(this instanceof Point)) {
		return new Point(x, y);	
	}
	this.x = x;
	this.y = y;
}

function Color(r, g, b, a) {
	if(!(this instanceof Color)) {
		return new Color(r, g, b, a);	
	}
	this.r = r;
	this.g = g;
	this.b = b;
	this.a = a;
}

function Rect(x, y, w, h) {
	if(!(this instanceof Rect)) {
		return new Rect(x, y, w, h);
	}

	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
}

function pointInMatrix(point, transform) {
	var x = point.x,
		y = point.y,
		a = transform.a,
		b = transform.b,
		c = transform.c,
		d = transform.d,
		tx = transform.tx,
		ty = transform.ty;

	return {x: a*x + c*y + tx, y: b*x + d*y + ty};
}

var ONE_RAD = Math.PI/180;
function angleToRadians(angle) {
	return ONE_RAD*angle;	
}

function randomMinus1To1() {
	return (Math.random() - 0.5) * 2;
}

function Clampf(val, min, max) {
	if(min > max) {
		var tmp = min;
		min = max;
		max = min;
	}

	return val < min ? min : val > max ? max : val;
}

var ONE 	  = 1;
var SRC_ALPHA = 0x0302;
var BLEND_DST = 0x0303;

function Particle() {
	//粒子坐标浮动值
	this.pos = Point(0, 0);
	//粒子起始坐标
	this.startPos = Point(0, 0);
	//粒子最终绘制的坐标
	this.drawPos = Point(0, 0);
	this.color = Color(0, 0, 0, 255);
	this.deltaColor = Color(0, 0, 0, 255);
	//重力模式
	this.modeA = new Particle.ParamsGravity();
	//半径模式
	this.modeB = new Particle.ParamsRadius();
	this.size = 0;
	this.deltaSize = 0;
	this.rotation = 0;
	this.deltaRotation = 0;
	this.timeToLive = 0;
	this.isChangeColor = false;
}

Particle.TemporaryPoints = [
	Point(0, 0),
	Point(0, 0),
	Point(0, 0),
	Point(0, 0)
];

////////////////////////////////////////////////////////////////////////////////
Particle.ModeGravity = function(speed, speedVar, gravityX, gravityY, radialAccel, 
	radialAccelVar, tangentialAccel, tangentialAccelVar, rotationIsDir) {
	//粒子初速度
	this.speed = speed;
	//粒子初速度浮值
	this.speedVar = speedVar;
	this.gravity = {x: gravityX, y: gravityY};
	this.radialAccel = radialAccel;
	this.radialAccelVar = radialAccelVar;
	this.tangentialAccel = tangentialAccel;
	this.tangentialAccelVar = tangentialAccelVar;
	this.rotationIsDir = rotationIsDir;
}

Particle.ModeGravity.prototype.randomFeatures = function(randians, particle) {
	var params = particle.modeA;
	//速度
	var speed = this.speed + this.speedVar * randomMinus1To1();
	//方向
	params.dir.x = Math.cos(randians);
	params.dir.y = Math.sin(randians);
	pMultIn(params.dir, speed);
	//径向加速度
	params.radialAccel = this.radialAccel + this.radialAccelVar * randomMinus1To1();
	//切向加速度
	params.tangentialAccel = this.tangentialAccel + this.tangentialAccelVar * randomMinus1To1();
}

Particle.ParamsGravity = function(p, radialAccel, tangentialAccel) {
	this.dir = p || Point(0, 0);
	this.radialAccel = radialAccel;
	this.tangentialAccel = tangentialAccel;
}

///////////////////////////////////////////////////////////////////////////////
Particle.ModeRadius = function(startRadius, startRadiusVar, endRadius,
	endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
	this.startRadius = startRadius;
	this.startRadiusVar = startRadiusVar;
	this.endRadius = endRadius;
	this.endRadiusVar = endRadiusVar;

	this.rotatePerSecond = rotatePerSecond;
	this.rotatePerSecondVar = rotatePerSecondVar;
}

Particle.ModeRadius.prototype.randomFeatures = function(randians, particle) {
	var params = particle.modeB;
	var startRadius = this.startRadius + this.startRadiusVar * randomMinus1To1();
	var endRadius = this.endRadius + this.endRadiusVar * randomMinus1To1();

	params.angle = randians;
	params.radius = startRadius;
	params.deltaRadius = (endRadius - startRadius) / particle.timeToLive;
	params.anglePerSecond = angleToRadians(this.rotatePerSecond + this.rotatePerSecondVar * randomMinus1To1());
}

Particle.ParamsRadius = function(angle, anglePerSecond, radius, deltaRadius) {
	//粒子旋转角度
	this.angle = angle;
	//粒子运动半径
	this.radius = radius || 0; 
	//粒子运动半径增量
	this.deltaRadius = deltaRadius || 0;
	//粒子旋转角速度
	this.anglePerSecond = anglePerSecond || 0;
}

////////////////////////////////////////////////////////////////////////////////
function ParticleEmitter(opts) {
	this.emitMode = 0;
	this.duration = 0;
	this.emitRate = 0;
	this.timeCounter = 0;
	//发射器原始坐标
	this.srcPos = Point(0, 0);
	//发射器坐标浮动值
	this.srcPosVar = Point(0, 0);
	this.angle = 0;
	this.angleVar = 0;
	this.maxParticles = 0;
	this.isRemoveOnFinish = false;
	this.particles = [];
	this.particleCounter = 0;

	this.positionType = ParticleEmitter.POS_TYPE_FREE;

	this.srcBlendFunc = 0;
	this.dstBlendFunc = 0;

	this.life = 0;
	this.lifeVar = 0;

	this.startSize = 0;
	this.startSizeVar = 0;
	this.endSize = 0;
	this.endSizeVar = 0;

	this.startColor = Color(0, 0, 0, 0);
	this.startColorVar = Color(0, 0, 0, 0);
	this.endColor = Color(0, 0, 0, 0);
	this.endColorVar = Color(0, 0, 0, 0);

	this.startSpin = 0;
	this.startSpinVar = 0;

	this.endSpin = 0;
	this.endSpinVar = 0;

	this.tmpZeroPoint = Point(0, 0);

	this.elapsed = 0;
	this.timeScale = 1;
	this.active = true;
	this.texture = null;

	this.scaleX = 1;
	this.scaleY = 1;

	this.tintCache = document.createElement("canvas");

	this.transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
	this.worldTransform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};

	this.anchorPointInPoints = Point(0, 0);
}

ParticleEmitter.POS_TYPE_FREE 	 = 0;
ParticleEmitter.POS_TYPE_RELATIVE = 1;
ParticleEmitter.POS_TYPE_GROUPED  = 2;

ParticleEmitter.MODE_GRAVITY = 0;
ParticleEmitter.MODE_RADIUS  = 1;
ParticleEmitter.MODE_WIND	= 2;

function fetchProperty(opts, key, def) {
	return opts[key] != void 0 ? opts[key] : def;	
}

function renderToCache(image, cache) {
	var w = image.width;
    var h = image.height;

    cache[0].width = w;
    cache[0].height = h;
    cache[1].width = w;
    cache[1].height = h;
    cache[2].width = w;
    cache[2].height = h;
    cache[3].width = w;
    cache[3].height = h;

    var cacheCtx = cache[3].getContext("2d");
    cacheCtx.drawImage(image, 0, 0);
    var pixels = cacheCtx.getImageData(0, 0, w, h).data;

    var ctx;
    for(var rgbI = 0; rgbI < 4; rgbI++) {
        ctx = cache[rgbI].getContext("2d");

        var to = ctx.getImageData(0, 0, w, h);
        var data = to.data;
        for(var i = 0; i < pixels.length; i += 4) {
			data[i    ] = (rgbI === 0) ? pixels[i    ] : 0;
            data[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
            data[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
            data[i + 3] = pixels[i + 3];
		}
        ctx.putImageData(to, 0, 0);
	}
    image.onload = null;
}

ParticleEmitter.prototype.parseModeGravity = function(opts) {
	return new Particle.ModeGravity(
		parseFloat(fetchProperty(opts, "speed")),
		parseFloat(fetchProperty(opts, "speedVariance")),
		parseFloat(fetchProperty(opts, "gravityx")),
		parseFloat(fetchProperty(opts, "gravityy")),
		parseFloat(fetchProperty(opts, "radialAcceleration")),
		parseFloat(fetchProperty(opts, "radialAccelVariance")),
		parseFloat(fetchProperty(opts, "tangentialAcceleration")),
		parseFloat(fetchProperty(opts, "tangentialAccelVariance")),
		(fetchProperty(opts, "rotationIsDir", false))
	);
}

ParticleEmitter.prototype.parseModeRadius = function(opts) {
	return new Particle.ModeRadius(
		parseFloat(fetchProperty(opts, "maxRadius")),
		parseFloat(fetchProperty(opts, "maxRadiusVariance")),
		parseFloat(fetchProperty(opts, "minRadius")),
		0,
		parseFloat(fetchProperty(opts, "rotatePerSecond")),
		parseFloat(fetchProperty(opts, "rotatePerSecondVariance"))
	);
}

ParticleEmitter.prototype.init = function(opts) {
	this.maxParticles = parseInt(fetchProperty(opts, 'maxParticles', 0));

	for(var i = 0; i < this.maxParticles; i++) {
		this.particles.push(new Particle());
	}

	//emitter angle
	this.angle = parseInt(fetchProperty(opts, 'angle', 0));
	this.angleVar = parseInt(fetchProperty(opts, 'angleVariance', 0));

	//emitter duration
	this.duration = parseInt(fetchProperty(opts, 'duration', 0));
	this.backDuration = this.duration;

	//blend function
	this.srcBlendFunc = parseInt(fetchProperty(opts, 'blendFuncSource', 0));
	this.dstBlendFunc = parseInt(fetchProperty(opts, 'blendFuncDestination', 0));

	//particle color
    this.startColor.r = parseFloat(fetchProperty(opts, "startColorRed")) * 255;
    this.startColor.g = parseFloat(fetchProperty(opts, "startColorGreen")) * 255;
    this.startColor.b = parseFloat(fetchProperty(opts, "startColorBlue")) * 255;
    this.startColor.a = parseFloat(fetchProperty(opts, "startColorAlpha")) * 255;

    this.startColorVar.r = parseFloat(fetchProperty(opts, "startColorVarianceRed")) * 255;
    this.startColorVar.g = parseFloat(fetchProperty(opts, "startColorVarianceGreen")) * 255;
    this.startColorVar.b = parseFloat(fetchProperty(opts, "startColorVarianceBlue")) * 255;
    this.startColorVar.a = parseFloat(fetchProperty(opts, "startColorVarianceAlpha")) * 255;

    this.endColor.r = parseFloat(fetchProperty(opts, "finishColorRed")) * 255;
    this.endColor.g = parseFloat(fetchProperty(opts, "finishColorGreen")) * 255;
    this.endColor.b = parseFloat(fetchProperty(opts, "finishColorBlue")) * 255;
    this.endColor.a = parseFloat(fetchProperty(opts, "finishColorAlpha")) * 255;

    this.endColorVar.r = parseFloat(fetchProperty(opts, "finishColorVarianceRed")) * 255;
    this.endColorVar.g = parseFloat(fetchProperty(opts, "finishColorVarianceGreen")) * 255;
    this.endColorVar.b = parseFloat(fetchProperty(opts, "finishColorVarianceBlue")) * 255;
    this.endColorVar.a = parseFloat(fetchProperty(opts, "finishColorVarianceAlpha")) * 255;

    // particle size
    this.startSize = parseFloat(fetchProperty(opts, "startParticleSize"));
    this.startSizeVar = parseFloat(fetchProperty(opts, "startParticleSizeVariance"));
    this.endSize = parseFloat(fetchProperty(opts, "finishParticleSize"));
    this.endSizeVar = parseFloat(fetchProperty(opts, "finishParticleSizeVariance"));

    //emitter position
    this.srcPos.x = parseFloat(fetchProperty(opts, "sourcePositionx"));
    this.srcPos.y = parseFloat(fetchProperty(opts, "sourcePositiony"));
	this.srcPosVar.x = parseFloat(fetchProperty(opts, "sourcePositionVariancex"));
    this.srcPosVar.y = parseFloat(fetchProperty(opts, "sourcePositionVariancey"));
	
	//particle spining
	this.startSpin = parseFloat(fetchProperty(opts, "rotationStart"));
	this.startSpinVar = parseFloat(fetchProperty(opts, "rotationStartVariance"));
	this.endSpin = parseFloat(fetchProperty(opts, "rotationEnd"));
	this.endSpinVar = parseFloat(fetchProperty(opts, "rotationEndVariance"));

	//particle life span
	this.life = parseFloat(fetchProperty(opts, "particleLifespan"));
	this.lifeVar = parseFloat(fetchProperty(opts, "particleLifespanVariance"));

	//emitter rate
	this.emitRate = this.maxParticles / this.life;

	this.isRemoveOnFinish = fetchProperty(opts, "isAutoRemoveOnFinish", false);

	//emitter mode
	this.emitMode = parseFloat(fetchProperty(opts, "emitterType"));

	this.imageData = fetchProperty(opts, "imageData", null) ||
		fetchProperty(opts, "textureImageData", null);

	if(this.imageData) {
		var image = new Image();
		image.src = this.imageData;
		this.setTexture(image);
	}

	if(this.emitMode === ParticleEmitter.MODE_GRAVITY) {
		this.mode = this.parseModeGravity(opts);
	}
	else {
		this.mode = this.parseModeRadius(opts);
	}
}

ParticleEmitter.prototype.setScaleX = function(scaleX) {
	this.scaleX = scaleX;
	return this;
}

ParticleEmitter.prototype.setScaleY = function(scaleY) {
	this.scaleY = scaleY;
	return this;
}

ParticleEmitter.prototype.emit = function(once) {
	this.reset();
	if(once) {
		if("backDuration" in this) {
			this.duration = this.backDuration;
		}
		if(this.duration === -1) {
			this.duration = 1;
		}
	}
	else {
		if("backDuration" in this) {
			this.backDuration = this.duration;
		}
		this.duration = -1;
	}
}

ParticleEmitter.prototype.reset = function() {
	this.active = true;
	this.elapsed = 0;

	if("backDuration" in this) {
		this.duration = this.backDuration;
	}
	var particles = this.particles;
	for(var i = 0; i < particles.length; i++) {
		particles[i].timeToLive = 0;
	}
}

ParticleEmitter.prototype.reload = function(opts) {
	this.stop();
	this.init(opts);
	this.start();
}

ParticleEmitter.prototype.pause = function() {
	this.timeScale = 0;
	return this;
}

ParticleEmitter.prototype.resume = function() {
	this.timeScale = 1;
	return this;
}

ParticleEmitter.prototype.start = function() {
	this.reset();
	return this;
}

ParticleEmitter.prototype.stop = function() {
	if("backDuration" in this) {
		this.duration = this.backDuration;
	}
	this.active = false;
	this.elapsed = this.duration; 
	this.timeCounter = 0;

	return this;
}

ParticleEmitter.prototype.setTexture = function(texture) {
	if(texture === this.texture) return;

	this.texture = texture;
	//renderToCache(this.texture, this.tintCaches);
	this.textureRect = Rect(0, 0, texture.width, texture.height);

	return this;
}

ParticleEmitter.prototype.getWorldTransform = function() {
	var t = this.transform;	
	var a = 1, b = 0, c = 0, d = 1;

	t.tx = this.srcPos.x;
	t.ty = this.srcPos.y;

	t.a = a;
	t.b = b;
	t.c = c;
	t.d = d;

	var scaleX = this.scaleX, scaleY = this.scaleY;
	var appX = this.anchorPointInPoints.x, appY = this.anchorPointInPoints.y;

	scaleX = (scaleX < 0.000001 && scaleX > -0.000001) ? 0.000001 : scaleX;
	scaleY = (scaleY < 0.000001 && scaleY > -0.000001) ? 0.000001 : scaleY;
	
	if(scaleX !== 1 || scaleY !== 1) {
		a = t.a *= scaleX;
		b = t.b *= scaleX;
		c = t.c *= scaleY;
		d = t.d *= scaleY;
	}

	t.tx -= a * appX + c * appY;
	t.ty -= b * appX + d * appY;

	return this.transform;
}

ParticleEmitter.prototype.convertToWorldSpace = function(point) {
	return pointInMatrix(point, this.getWorldTransform());		
}

ParticleEmitter.prototype.initParticle = function(particle) {
	//timeToLive
	particle.timeToLive = this.life + this.lifeVar*randomMinus1To1();	
	particle.timeToLive = Math.max(0, particle.timeToLive);

	//position
	particle.pos.x = this.srcPosVar.x*randomMinus1To1();	
	particle.pos.y = this.srcPosVar.y*randomMinus1To1();	

	//color
	var startColor = {
		r: Clampf(this.startColor.r + this.startColorVar.r*randomMinus1To1(), 0, 255),
		g: Clampf(this.startColor.g + this.startColorVar.g*randomMinus1To1(), 0, 255),
		b: Clampf(this.startColor.b + this.startColorVar.b*randomMinus1To1(), 0, 255),
		a: Clampf(this.startColor.a + this.startColorVar.a*randomMinus1To1(), 0, 255)
	};
	var endColor = {
		r: Clampf(this.endColor.r + this.endColorVar.r*randomMinus1To1(), 0, 255),
		g: Clampf(this.endColor.g + this.endColorVar.g*randomMinus1To1(), 0, 255),
		b: Clampf(this.endColor.b + this.endColorVar.b*randomMinus1To1(), 0, 255),
		a: Clampf(this.endColor.a + this.endColorVar.a*randomMinus1To1(), 0, 255)
	};
	particle.color = startColor;	
	particle.deltaColor = {
		r: (endColor.r - startColor.r)/particle.timeToLive,
		g: (endColor.g - startColor.g)/particle.timeToLive,
		b: (endColor.b - startColor.b)/particle.timeToLive,
		a: (endColor.a - startColor.a)/particle.timeToLive
	};

	//size
	var startSize = this.startSize + this.startSizeVar * randomMinus1To1();
	var endSize = this.endSize + this.endSizeVar * randomMinus1To1();
	particle.size = Math.max(0, startSize);
	particle.deltaSize = (endSize - startSize) / particle.timeToLive;

	//rotation
	var startA = this.startSpin + this.startSpinVar * randomMinus1To1();
	var end = this.endSpin + this.endSpinVar * randomMinus1To1();
	particle.rotation = startA;
	particle.deltaRotation = (end - startA) / particle.timeToLive;

	//position
	if(this.positionType === ParticleEmitter.POS_TYPE_FREE) {
		particle.startPos = this.convertToWorldSpace(this.tmpZeroPoint);	
	}
	else if(this.positionType === ParticleEmitter.POS_TYPE_RELATIVE) {
		particle.startPos.x = this.srcPos.x;
		particle.startPos.y = this.srcPos.y;
	}

	//direction
	var randians = angleToRadians(this.angle + this.angleVar*randomMinus1To1());

	this.mode.randomFeatures(randians, particle);
}

ParticleEmitter.prototype.isFull = function() {
	return this.particleCounter >= this.maxParticles;
}

ParticleEmitter.prototype.addParticle = function() {
	if(!this.isFull()) {
		var particle = null;

		if(this.particleCounter < this.particles.length) {
			particle = this.particles[this.particleCounter];
		}
		else {
			particle = new Particle();
			this.particles.push(particle);
		}
		this.initParticle(particle);
		++this.particleCounter;	
	}
}

ParticleEmitter.prototype.updateParticles = function(dt) {
	var currentPosition = Particle.TemporaryPoints[0];
	
	if(this.positionType === ParticleEmitter.POS_TYPE_FREE) {
		pIn(currentPosition, this.convertToWorldSpace(this.tmpZeroPoint));
	}
	else if(this.positionType === ParticleEmitter.TYPE_RELATIVE) {
		currentPosition.x = this.srcPos.x;
		currentPosition.y = this.srcPos.y;
	}

	var	particle = null,
		particleIndex = 0,
		particles = this.particles,
		tpa = Particle.TemporaryPoints[1],
		tpb = Particle.TemporaryPoints[2],
		tpc = Particle.TemporaryPoints[3];

	while(particleIndex < this.particleCounter) {
		pZeroIn(tpa);
		pZeroIn(tpb);
		pZeroIn(tpc);

		particle = particles[particleIndex];
		particle.timeToLive -= dt;

		if(particle.timeToLive > 0) {
			if(this.emitMode === ParticleEmitter.MODE_GRAVITY) {
				var tmp = tpc, radial = tpa, tangential = tpb;		

				//radial acceleration
				if(particle.pos.x || particle.pos.y) {
					pIn(radial, particle.pos);
					//计算加速度
					pNormalizeIn(radial);
				}
				else {
					pZeroIn(radial);
				}
				pIn(tangential, radial);
				pMultIn(radial, particle.modeA.radialAccel);

				//tangential acceleration
				var newy = tangential.x;
				tangential.x = -tangential.y;
				tangential.y = newy;

				pMultIn(tangential, particle.modeA.tangentialAccel);

				pIn(tmp, radial);
				pAddIn(tmp, tangential);
				pAddIn(tmp, this.mode.gravity);
				pMultIn(tmp, dt);
				pAddIn(particle.modeA.dir, tmp);

				pIn(tmp, particle.modeA.dir);
				pMultIn(tmp, dt);
				pAddIn(particle.pos, tmp);
			}
			else {
				var modeB = particle.modeB;
				modeB.angle += modeB.anglePerSecond * dt;
				modeB.radius += modeB.deltaRadius * dt;

				particle.pos.x = -Math.cos(modeB.angle) * modeB.radius;
				particle.pos.y = -Math.sin(modeB.angle) * modeB.radius;
			}
			//color
			particle.color.r += particle.deltaColor.r * dt;
			particle.color.g += particle.deltaColor.g * dt;
			particle.color.b += particle.deltaColor.b * dt;
			particle.color.a += particle.deltaColor.a * dt;
			particle.isChangeColor = false;
			//size
			particle.size += (particle.deltaSize * dt);
			particle.size = Math.max(0, particle.size);
			//rotation
			particle.rotation += (particle.deltaRotation * dt);
			//position
			var newPos = tpa;
			if(this.positionType === ParticleEmitter.POS_TYPE_FREE
				|| this.positionType === ParticleEmitter.POS_TYPE_RELATIVE) {
				var diff = tpb;

				pIn(diff, currentPosition);
				pSubIn(diff, particle.startPos);

				pIn(newPos, particle.pos);
				pSubIn(newPos, diff);
			}
			else {
				pIn(newPos, particle.pos);	
			}

			pIn(particle.drawPos, newPos);
			++particleIndex;
		}
		else {
			//life < 0
			if(particleIndex !== this.particleCounter - 1) {
				var deadParticle = 	
				particles[particleIndex] = particles[this.particleCounter - 1];
				particles[this.particleCounter - 1] = particle;
			}
			--this.particleCounter;
		}
	}

	return;
}

ParticleEmitter.prototype.update = function(dt) {
	var emitLimit = 1.0/this.emitRate;

	dt*=this.timeScale;

	if(this.active) {
		if(this.particleCounter < this.maxParticles) {
			this.timeCounter += dt;	
		}

		while(this.particleCounter < this.maxParticles 
			&& this.timeCounter > emitLimit) {
			this.addParticle();
			this.timeCounter -= emitLimit;
		}
		this.elapsed += dt;
		if(this.duration !== -1 && this.duration <= this.elapsed) {
			this.stop();
		}
	}

	this.updateParticles(dt);
}

ParticleEmitter.prototype.setTransform = function(context, t) {
	//why
	context.transform(t.a, -t.b, -t.c, t.d, t.tx * this.scaleX, -(t.ty * this.scaleY));
}

ParticleEmitter.prototype.isBlendAdditive = function() {
	//why
	return ((this.srcBlendFunc === SRC_ALPHA && this.dstBlendFunc === ONE)
		|| (this.srcBlendFunc === ONE && this.dstBlendFunc === ONE));
}

ParticleEmitter.prototype.changeTextureColor = function(texture, color, rect) {
	var canvas = this.tintCache;
	var context = canvas.getContext("2d");

	canvas.width = texture.width;
	canvas.height = texture.height;
	context.globalCompositeOperation = "source-over";
	context.fillStyle = "rgb(" + (color.r|0) + "," + (color.g|0) + "," + (color.b|0) + ")";
	context.fillRect(0, 0, rect.w, rect.h);
	context.globalCompositeOperation = "multiply";
	context.drawImage(texture, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
	context.globalCompositeOperation = "destination-atop";
	context.drawImage(texture, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);

	return canvas;
}

ParticleEmitter.prototype.draw = function(context) {
	var texture = this.texture,
		particles = this.particles,
		textureRect = this.textureRect,
		particleCounter = this.particleCounter;

	context.save();	
	this.setTransform(context, this.worldTransform);
	if(this.isBlendAdditive()) {
		context.globalCompositeOperation = 'lighter';
	}
	else {
		context.globalCompositeOperation = 'source-over';
	}

	//assert texture mode
	var particle, lpx, alpha, size, 
		w = textureRect.w, h = textureRect.h;
	for (var i = 0; i < particleCounter; i++) {
		particle = particles[i];
		lpx = (0 | (particle.size * 0.5));
		alpha = particle.color.a / 255;
		if(alpha === 0) continue;

		context.globalAlpha = alpha;
		context.save();
		context.translate((0 | particle.drawPos.x), -(0 | particle.drawPos.y));

		size = Math.floor(particle.size / 4) * 4;
		context.scale(Math.max((1 / w) * size, 0.000001), Math.max((1 / h) * size, 0.000001));

		if(particle.rotation) {
			context.rotate(angleToRadians(particle.rotation));
		}

		var dstTexture = particle.isChangeColor ? 
			this.changeTextureColor(texture, particle.color, textureRect) : texture;

		context.drawImage(dstTexture, -(0 | (w / 2)), -(0 | (h / 2)));
		context.restore();
	}
	context.restore();
}

window.ParticleEmitter = ParticleEmitter;

}();
/*
 * File:   ui-bitmap-font-text.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  BitmapFontText
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

/**
 * @class UIBitmapFontText
 * @extends UIElement
 * 数字标签。把文字做成等大小的图片，然后合并到一张大图里，显示时根据文字内容取出子图组装起来。图片一般用透明背景的PNG格式。
 *
 * 注意：要求图片的高度和宽度能被行数和列数整除，否者在部分浏览器器上显示不正常。
 *
 */
function UIBitmapFontText() {
	return;
}

UIBitmapFontText.prototype = new UIElement();
UIBitmapFontText.prototype.isUIBitmapFontText = true;

UIBitmapFontText.prototype.saveProps = ["allText", "textAlignment", "imageRows", "imageColumns"];
UIBitmapFontText.prototype.initUIBitmapFontText = function(type, w, h) {
	this.initUIElement(type);	

	this.text = "";
	this.textAlignment = "center";

	this.setMargin(5, 5);
	this.setDefSize(w, h);
	this.setSizeLimit(10, 10);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIBitmapFontText.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIBitmapFontText.prototype.setImageWithRowCols = function(url, rows, columns) {
	this.imageRows = rows;
	this.imageColumns = columns;
	this.setImage(UIElement.IMAGE_NORMAL_FG, url);

	return;
}

UIBitmapFontText.prototype.getRectOfChar = function(image, imageRect, c) {
	if(this.allText) {
		var n = this.allText.length;
		var i = this.allText.indexOf(c);

		if(i >= 0) {
			var w = imageRect.trimmed ? imageRect.rw : imageRect.w;
			var h = imageRect.trimmed ? imageRect.rh : imageRect.h;
			var rows = this.imageRows ? this.imageRows : (h > w ? n : 1);
			var columns = this.imageColumns ? this.imageColumns : (w > h ? n : 1);
			var iw = Math.round(w/columns);
			var ih = Math.round(h/rows);
			var r = Math.floor(i/columns);
			var c = i%columns;

			var rect = {};
			rect.w = iw;
			rect.h = ih;
			rect.x = iw * c + imageRect.x;
			rect.y = ih * r + imageRect.y;

			if(i === 0) {
				rect.w = rect.w - (imageRect.ox || 0);
				rect.h = rect.h - (imageRect.oy || 0);
			}
			else {
				rect.x = rect.x - (imageRect.ox || 0);
				rect.y = rect.y - (imageRect.oy || 0);
			}

			return rect;
		}
	}

	return null;
}

UIBitmapFontText.prototype.setAllText = function(allText) {
	this.allText = allText;

	return this;
}

UIBitmapFontText.prototype.getAllText = function() {
	return this.allText;
}

UIBitmapFontText.prototype.getBgImage =function() {
	var image = null;
	
	if(this.pointerDown && !this.isClicked()) {
		image = this.images.active_bg;
	}
	else {
		image = this.images.normal_bg;
	}
	
	if(!image || !image.getImage()) {
		image = this.images.default_bg;
	}

	if(!image || !image.getImage()) {
		return;
	}

	return image;
}

UIBitmapFontText.prototype.drawFgImage = function(canvas) {
	var text = this.text;
	var wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG)

	if(!text || !wImage) {
		return;
	}

	var image = wImage.getImage();
	var imageRect = wImage.getImageRect();
	if(!image) {
		return;
	}

	var size = 0;
	var h = this.h;
	var maxItemHeight = 15;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var rect = this.getRectOfChar(image, imageRect, c);
		if(rect) {
			size += rect.w;
			if(rect.h > maxItemHeight) {
				maxItemHeight = rect.h;
			}
		}
	}

	var oy = 0;
	var ox = 0;
	var tx = 0;
	var hh = this.h >> 1;
	var scale = Math.min(this.h/maxItemHeight, this.w/size);

	switch(this.textAlignment) {
		case "right": {
			ox = this.w - this.hMargin - size;
			tx = ox + size;
			break;
		}
		case "center": {
			ox = (this.w - size) >> 1;
			tx = this.w >> 1;
			break;
		}
		default: {
			ox = this.hMargin;
			tx = ox;
			break;
		}
	}	
	
	if(scale != 1) {
		canvas.translate(tx, hh);
		canvas.scale(scale, scale);
		canvas.translate(-tx, -hh);
	}

	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var rect = this.getRectOfChar(image, imageRect, c);

		if(rect) {
			oy = (h - rect.h) >> 1;
			canvas.drawImage(image, rect.x, rect.y, rect.w, rect.h, ox, oy, rect.w, rect.h);
			ox += rect.w;
		}
	}

	return;
}

function UIBitmapFontTextCreator() {
	var args = ["ui-bitmap-font-text", "ui-bitmap-font-text", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBitmapFontText();
		return g.initUIBitmapFontText(this.type, 400, 100);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBitmapFontTextCreator());

/*
 * File:   ui-bitmap-font-text-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  BitmapFontTextX
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015  Holaverse Inc.
 * 
 */

/**
 * @class UIBitmapFontTextX
 * @extends UIElement
 * 图片文字。支持[bmfont](http://www.angelcode.com/products/bmfont/doc/file_format.html)和TexturePacker打包的Json Hash格式的图片集(不支持rotation和trim)。
 *
 * 参考：http://www.angelcode.com/products/bmfont/doc/file_format.html
 */
function UIBitmapFontTextX() {
	return;
}

UIBitmapFontTextX.prototype = new UIElement();
UIBitmapFontTextX.prototype.isUIBitmapFontTextX = true;

UIBitmapFontTextX.prototype.saveProps = ["spacer"];
UIBitmapFontTextX.prototype.initUIBitmapFontTextX = function(type) {
	this.spacer = 0;
	this.initUIElement(type);	
	this.textAlignment = "center";
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIBitmapFontTextX.prototype.getCharDesc = function(c) {
	if(this.bitmapFont) {
		return this.bitmapFont.getCharDesc(c);
	}
	else {
		if(!this.charsDesc) {
			this.charsDesc = {};
		}
		var charDesc = this.charsDesc[c];
		var image = this.getImageByType(c);

		if(!charDesc && image) {
			var r = image.getImageRect();
			if(r && r.w) {
				this.charsDesc[c] = {};
				charDesc = this.charsDesc[c];

				charDesc.x = r.x;
				charDesc.y = r.y;
				charDesc.w = r.w;
				charDesc.h = r.h;
				charDesc.image = image;
			}
		}

		return charDesc;
	}
}

UIBitmapFontTextX.prototype.parseFont = function(data, dataURL) {
	var path = dataURL.dirname();
	this.bitmapFont = new BitmapFont();
	this.bitmapFont.parse(data);
	
	var pages = this.bitmapFont.getPagesDesc();
	for(var key in pages) {
		var page = pages[key];
		var imageURL = path + "/" + page.file;
		this.setImage("page" + page.id, imageURL);
	}

	var chars = this.bitmapFont.getCharsDesc();
	for(var c in chars) {
		var charDesc = chars[c];
		charDesc.image = this.getImageByType("page"+charDesc.page);
	}

	return;
}

UIBitmapFontTextX.prototype.parseJson = function(data, dataURL) {
	var frames = data.frames;
	var imageURL = dataURL.dirname() + "/" + data.meta.image;

	for(var c in frames) {
		var name = c.replace(".png", "");
		if(name.length === 1) {
			this.setImage(name, dataURL + "#" + c);
		}
	}

	return;
}

UIBitmapFontTextX.prototype.setDataURL = function(dataURL) {
	this.images = {};
	this.images.display = 0;
	this.dataURL = dataURL;

	if(dataURL) {
		if(dataURL.endWith(".fnt")) {
			ResLoader.loadData(dataURL, function(data) {	
				this.parseFont(data, dataURL);
			}.bind(this));
		}
		else if(dataURL.endWith(".json")) {
			ResLoader.loadJson(dataURL, function(data) {	
				this.parseJson(data, dataURL);
			}.bind(this));
		}
		else {
			console.log("not supported:" + dataURL);
		}
	}

	return this;
}

UIBitmapFontTextX.prototype.setSpacer = function(spacer) {
	this.spacer = spacer;

	return this;
}

UIBitmapFontTextX.prototype.getDataURL = function() {
	return this.dataURL;
}

UIBitmapFontTextX.prototype.measureText = function() {
	var w = 0;
	var h = 10;
	var text = this.text;
	var spacer = this.spacer;

	for(var i = 0; i <text.length; i++) {
		var charDesc = this.getCharDesc(text[i]);
		if(charDesc) {
			var rw = charDesc.rw || charDesc.w;
			var rh = charDesc.rh || (charDesc.h + (charDesc.oy || 0));

			w += rw;
			if(h < rh) {
				h = rh;
			}

			if(i) {
				w += spacer;
			}
		}
	}

	return {w:w, h:h};
}

UIBitmapFontTextX.prototype.onFromJsonDone = function() {
	this.setDataURL(this.dataURL);
}

UIBitmapFontTextX.prototype.drawText = function(canvas) {
	var text = this.text;

	if(!text) { 
		return;
	}

	var oy = 0;
	var ox = 0;
	var tx = 0;
	var h = this.h;
	var w = this.w;
	var hh = h >> 1;
	var spacer = this.spacer;
	var hMargin = this.hMargin;
	var size = this.measureText();
	
	if(size.w < 1 || size.h < 1) {
		return;
	}

	var scale = Math.min(h/size.h, w/size.w);

	switch(this.textAlignment) {
		case "right": {
			ox = w - hMargin - size.w;
			tx = ox + size.w;
			break;
		}
		case "center": {
			ox = (w - size.w) >> 1;
			tx = w >> 1;
			break;
		}
		default: {
			ox = hMargin;
			tx = ox;
			break;
		}
	}	

	canvas.save();
	if(scale !== 1) {
		canvas.translate(tx, hh);
		canvas.scale(scale, scale);
		canvas.translate(-tx, -hh);
	}

	var x = 0;
	var y = 0;
	var baseY = (h - size.h) >> 1;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var charDesc = this.getCharDesc(c);
		if(charDesc && charDesc.image) {
			var rect = charDesc;
			var img = charDesc.image.getImage();

			if(img) {
				x = ox + (rect.ox || 0);
				y = baseY + (rect.oy || 0);

				canvas.drawImage(img, rect.x, rect.y, rect.w, rect.h, x, y, rect.w, rect.h);
				ox += (rect.rw || rect.w);
				ox += spacer;
			}
		}
	}
	canvas.restore();

	return;
}

function UIBitmapFontTextXCreator() {
	var args = ["ui-bitmap-font-text-x", "ui-bitmap-font-text-x", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBitmapFontTextX();
		return g.initUIBitmapFontTextX(this.type, 400, 100);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBitmapFontTextXCreator());

UIElement.prototype.getScence= function() {
	return this.getWindow();
}

UIElement.prototype.getFootprints = function(name) {
	var x = 0;
	var y = 0;
	var footPrints = [];
	var arr = this.isUIWindow ? this : this.getParent().children;

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(!iter.isUIFootprint) {
			continue;
		}

		if(name && name != iter.name) {
			continue;
		}

		x = iter.left + (iter.w >> 1);
		y = iter.top + (iter.h >> 1);

		footPrints.push({x:x, y:y});
	}

	return footPrints;
}

UIElement.prototype.moveAlongPath = function(name, duration, enableRotation, onDone) {
	var footPrints = this.getFootprints(name);

	return this.moveAlongPoints(footPrints, duration, enableRotation, onDone);
}

UIElement.prototype.moveAlongPoints = function(points, duration, enableRotation, onDone) {
	var d = 0;
	var dx = 0;
	var dy = 0;
	var moveInfo = {};
	var distances = [];
	var totalDistance = 0;

	if(!points.length) {
		console.log("no footprint found.");
	}

	for(var i = 0; i < points.length; i++) {
		var iter = points[i];
		if(i) {
			dx = points[i].x - points[i-1].x;
			dy = points[i].y - points[i-1].y;

			d = Math.sqrt(dx*dx+dy*dy);
			distances.push(d);
			totalDistance += d;
		}
	}

	moveInfo.onDone = onDone;
	moveInfo.duration = duration;
	moveInfo.distances = distances;
	moveInfo.points = points;
	moveInfo.totalDistance = totalDistance;
	moveInfo.enableRotation = enableRotation;

	this.startMove(moveInfo);

	return;
}

UIElement.prototype.startMove = function(moveInfo) {
	var x = 0;
	var y = 0;
	var index = 0;
	var me = this;
	var hw = this.w >> 1;
	var hh = this.h >> 1;

	var duration = moveInfo.duration;
	var distances = moveInfo.distances;
	var points = moveInfo.points;
	var totalDistance = moveInfo.totalDistance;
	var enableRotation = moveInfo.enableRotation;

	function moveToNext() {
		if((index+1) >= points.length) {
			if(moveInfo.onDone) {
				moveInfo.onDone();
			}

			return;
		}

		var start = Date.now();
		var endPoint = points[index+1];
		var startPoint = points[index];
		var dt = duration * (distances[index]/totalDistance);
		var dx = endPoint.x - startPoint.x;
		var dy = endPoint.y - startPoint.y;

		var angle = Math.asin(Math.abs(dy)/Math.sqrt(dx * dx + dy * dy));

		if(dy <= 0 && dx < 0 ) {
			angle = Math.PI - angle;
		}
		
		if(dy > 0 && dx < 0 ) {
			angle = Math.PI + angle;
		}
		
		if(dy > 0 && dx >= 0 ) {
			angle = 2 * Math.PI - angle;
		}

		angle = -angle;
		function step() {
			var percent = (Date.now() - start)/dt;
			if(percent < 1) {
				x = startPoint.x + dx * percent - hw;
				y = startPoint.y + dy * percent - hh;

				me.setPosition(x, y);
				if(enableRotation) {
					me.setRotation(angle);
				}
				me.postRedraw();
				
				return true;
			}
			else {
				index++;
				x = endPoint.x - hw;
				y = endPoint.y - hh;

				me.setPosition(x, y);
				me.postRedraw();
				moveToNext();

				return false;
			}
		}

		UIElement.setAnimTimer(step);
	}

	moveToNext();

	return;
}

UIElement.prototype.setPositionWithSticky = function(x, y) {
	this.setPosition(x, y);

	if(this.sticky) {
		this.orgX = this.x;		
		this.orgY = this.y;	
	}

	return this;
}

UIElement.prototype.setAngle = UIElement.prototype.setRotation;

UIElement.prototype.setPositionByBody = function(left, top) {
    if(this.anchor) {
        this._x = left + this.w * this.anchor.x;
        this._y = top + this.h * this.anchor.y;
        this.setLeftTop(left, top);
    }
    else {
        this._x = left;
        this._y = top;
        this.setLeftTop(this._x, this._y);
    }

	this.callOnMovedHandler();

	return this;
}

UIElement.prototype.setSoundMusicVolume = function(volume) {
	this.getWindowManager().setSoundMusicVolume(volume);

	return this;
}

UIElement.prototype.setSoundEffectVolume = function(volume) {
	this.getWindowManager().setSoundEffectVolume(volume);

	return this;
}

UIElement.prototype.playSoundEffect = function(name, onDone) {
	this.getWindowManager().playSoundEffect(name, onDone);

	return this;
}

UIElement.prototype.playSoundMusic = function(name, onDone) {
	this.getWindowManager().playSoundMusic(name, onDone);

	return this;
}

UIElement.prototype.stopSoundMusic = function(name) {
	this.getWindowManager().stopSoundMusic(name);

	return this;
}

UIElement.prototype.stopSoundEffect = function(name) {
	this.getWindowManager().stopSoundEffect(name);

	return this;
}

UIElement.prototype.setSoundEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundEnable(enable);

	return this;
}

UIElement.prototype.isSoundEnable = UIElement.prototype.getSoundEnable = function() {
	var wm = this.getWindowManager();

	return wm.getSoundEnable();
}

UIElement.prototype.setSoundEffectEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundEffectsEnable(enable);

	return this;
}

UIElement.prototype.isSoundEffectEnable = UIElement.prototype.getSoundEffectEnable = function() {
	var wm = this.getWindowManager();

	return wm.soundEffectsEnalbe;
}

UIElement.prototype.setSoundMusicEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundMusicsEnable(enable);

	return this;
}

UIElement.prototype.isSoundMusicEnable = UIElement.prototype.getSoundMusicEnable = function() {
	var wm = this.getWindowManager();

	return wm.soundMusicsEnalbe;
}

UIElement.prototype.setVOf = function(name, x, y) {
	var el = this.getWindow().findChildByName(name, true);
	if(el) {
		el.setV(x, y);
	}
	else {
		console.log("not found " + name);
	}

	return this;
}

UIElement.prototype.setV = function(x, y) {
	var body = this.body;
	if(body) {
		this.setVisible(true);

		if(!body.IsActive()) {
			body.SetActive(true);
		}

		if(!body.IsAwake()) {
			body.SetAwake(true);
		}

		var v = body.GetLinearVelocity();
		if(x !== null && x !== undefined) {
			v.x = x;
		}

		if(y !== null && y !== undefined) {
			v.y = y;
		}

		body.SetLinearVelocity(v);
	}

	return this;
}

UIElement.prototype.onRemoved = function(parent) {
	if(!parent) {
		return;
	}

	var win = parent.getWindow();
	if(!win) {
		return;
	}

	var world = win.world;

	if(this.body) {
		Physics.destroyBodyForElement(world, this);
		this.body = null;
	}

	if(this.joint) {
		Physics.destroyJointForElement(world, this);
		this.joint = null;
	}

	return this;
}

/*
 * File:   ui-frame-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Frame Animation.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIFrameAnimation
 * @extends UIImage
 * 帧动画。通过连续播放多张图片形成动画效果。可以对图片进行分组，播放时指定分组的名称。
 *
 */
function UIFrameAnimation() {
	return;
}

UIFrameAnimation.prototype = new UIElement();
UIFrameAnimation.prototype.isUIFrameAnimation = true;

UIFrameAnimation.prototype.saveProps = ["autoPlay", "frameRate", "autoPlayDelay", "defaultGroupName"];
UIFrameAnimation.prototype.initUIFrameAnimation = function(type, w, h) {
	this.initUIElement(type);	
	
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.current = 0;
	this.frameRate = 10;
	this.playing = false;
	this.autoPlay = true;
	this.repeatTimes = 0xFFFFFFFF;
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	this.frames = [];
	this.addEventNames(["onDoubleClick", "onUpdateTransform"]);

	return this;
}

UIFrameAnimation.prototype.syncImageFrames = function() {
	this.frames = [];
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter) {
			this.frames.push(iter);
		}
	}

	return;
}

UIFrameAnimation.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	if(this.groups) {
		o.groups = JSON.parse(JSON.stringify(this.groups));
	}

	return o;
}

UIFrameAnimation.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);
	
	this.playing = false;
	this.syncImageFrames();

	if(js.groups) {
		this.groups = js.groups;
	}
	else if(js.groupsData) {
		this.groups = this.parseGroupsData(js.groupsData);
		this.groupsData = null;
	}

	return js;
}

UIFrameAnimation.prototype.afterChildAppended = function(shape) {
	shape.xAttr = UIElement.X_CENTER_IN_PARENT;
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return;
}

UIFrameAnimation.prototype.setAutoPlay = function(autoPlay) {
	this.autoPlay = autoPlay;

	return this;
}

/**
 * @method resume 
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.resume = function() {
	this.playing = true;

	return this;
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.pause = function() {
	this.playing = false;

	return this;
}

/**
 * @method stop 
 * 停止动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.stop = function() {
	this.playing = false;

	return this;
}

UIFrameAnimation.prototype.playSequence = function(sequence, repeatTimes, onDone, onOneCycle) {
	this.deferred = Deferred();

	var n = this.frames.length;
	if(!n || !sequence || !sequence.length) {
		return;
	}

	this.current = 0;
	this.playing = true;
	this.onDone = onDone;
	this.onOneCycle = onOneCycle;
	this.runningSequence = sequence;
	this.nextUpdateTime = Date.now() + this.getDuration();
	this.repeatTimes = repeatTimes ? repeatTimes : 0xFFFFFFFF;

	return this.deferred.promise;
}

UIFrameAnimation.prototype.playRange = function(startFrame, endFrame, repeatTimes, onDone, onOneCycle) {
	var n = this.frames.length;
	if(startFrame > endFrame) {
		var t = startFrame;
		startFrame = endFrame;
		endFrame = t;
	}

	var sequence = [];
	for(var i = startFrame; i <= endFrame; i++) {
		sequence.push(i);
	}

	return this.playSequence(sequence, repeatTimes, onDone, onOneCycle);
}

/**
 * @method play
 * 播放动画。
 * @param {String} name 分组名称。
 * @param {Number} repeatTimes 播放次数。 
 * @param {Function} onDone (可选) 播放指定次数后的回调函数。
 * @param {Function} onOneCycle (可选) 每播放一次的回调函数。
 *
 */
UIFrameAnimation.prototype.gotoAndPlayByName = function(name, repeatTimes, onDone, onOneCycle) {
	var range = this.getGroupRange(name);

	if(range.start !== undefined && range.end !== undefined) { 
		return this.gotoAndPlay(range.start, range.end, repeatTimes, onDone, onOneCycle);
	}
	else if(range && range.length){
		return this.playSequence(range, repeatTimes, onDone, onOneCycle);
	}
	else if(this.animations && name) {
		return this.animate(name);
	}
}

UIFrameAnimation.prototype.play = UIFrameAnimation.prototype.gotoAndPlayByName;
UIFrameAnimation.prototype.gotoAndPlay = UIFrameAnimation.prototype.playRange;

UIFrameAnimation.prototype.nextFrame = function() {
	if(!this.frames || !this.frames.length || !this.runningSequence || !this.runningSequence.length) {
		return;
	}

	var current = this.current + 1;
	var n = this.runningSequence.length;

	if(current === n) {
		if(this.onOneCycle) {
			try {
				this.onOneCycle(this);
			} catch(e) {
				console.log("onOneCycle: " + e.message);
			}
		}

		this.repeatTimes--;
		if(this.repeatTimes <= 0) {
			this.playing = false;
			if(this.onDone) {
				try{
					this.onDone(this);
				}catch(e) {
					console.log("onDone: " + e.message);
				}
			}

			if(this.deferred) {
				this.deferred.resolve();
			}

			return;
		}
	}

	this.current = current % n;

	return;
}

UIFrameAnimation.prototype.getCurrentImage = function() {
	if(!this.frames || !this.frames.length) {
		return null;
	}

	if(!this.runningSequence || !this.runningSequence.length) {
		return this.frames[0];
	}

	if(this.current >= this.runningSequence.length) {
		this.current = 0;
	}

	var index =  this.runningSequence[this.current];

	return this.frames[index];
}

UIFrameAnimation.prototype.getGroupRange = function(name) {
	var range = null;

	if(this.groups && name) {
		range = this.groups[name];
	}
	
	if(!range) {
		range = {start:0, end:this.frames.length-1};
	}

	return range;
}

UIFrameAnimation.prototype.getImages = function() {
	var str = "";
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter && iter.src) {
			str += iter.src + "\n";
		}
	}

	return str;
}

UIFrameAnimation.prototype.setImages = function(value) {
	var display = this.images.display;
	this.images = {};
	this.images.display = display;

	if(value) {
		var i = 0;
		var k = 0;
		var arr = value.split("\n");

		for(var i = 0; i < arr.length; i++) {
			var iter = arr[i];
			if(!iter) continue;

			if(iter.indexOf("/") === 0) {
				iter = iter.substr(1);
			}

			var name = "option_image_" + (k++);
			this.setImage(name, iter);
		}
	}
	this.syncImageFrames();
	
	return this;
}

UIFrameAnimation.prototype.getValue = function() {
	return this.current;
}

UIFrameAnimation.prototype.setValue = function(value) {
	this.current = Math.min(value, this.frames.length);

	return this;
}

UIFrameAnimation.prototype.startAutoPlay = function() {
	if(this.defaultGroupName) {
		this.play(this.defaultGroupName, 0xFFFFFFF); 
	}
	else {
		this.gotoAndPlay(0, this.frames.length-1, 0xFFFFFFF);	
	}

	return;
}

UIFrameAnimation.prototype.onInit = function() {
	this.syncImageFrames();

	if(this.autoPlay && this.frames && this.frames.length) {
		this.startAutoPlay();
		if(this.autoPlayDelay) {
			this.nextUpdateTime += this.autoPlayDelay;
		}
	}

	return;
}

UIFrameAnimation.prototype.paintSelf = function(canvas) {
	
	if(this.playing && this.isVisible()) {
		var duration = this.getDuration();
		var nextUpdateTime = canvas.now + duration;

		if(canvas.now > this.nextUpdateTime) {
			this.nextFrame();
			this.nextUpdateTime = nextUpdateTime;
		}
		else {
			this.nextUpdateTime = Math.min(this.nextUpdateTime, nextUpdateTime);
		}

		canvas.needRedraw++;
	}
	
	return UIElement.prototype.paintSelf.call(this, canvas);
}

/**
 * @method getFrameRate 
 * 获取帧率。
 * @return {Number} 返回帧率。
 *
 */
UIFrameAnimation.prototype.getFrameRate = function() {
	return this.frameRate ? this.frameRate : 5;
}

/**
 * @method setFrameRate 
 * 设置帧率。
 * @param {Number} frameRate 帧率。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.setFrameRate = function(frameRate) {
	this.frameRate = Math.max(1, Math.min(frameRate, 30));

	return this;
}

UIFrameAnimation.prototype.getDuration = function() {
	if(this.mode === Shape.MODE_EDITING && this.disablePreview) {
		return 0xffffff;
	}

	if(this.timeScaleIsZero()) {
		return 0xffffff;
	}
	else {
		return (1000/this.frameRate)/this.getTimeScale();
	}
}

UIFrameAnimation.prototype.shapeCanBeChild = UISprite.prototype.shapeCanBeChild;

UIFrameAnimation.prototype.drawImage = function(canvas) {
	var image = this.getCurrentImage();

	if(image) {
		var srcRect = image.getImageRect();
		var htmlImage = image.getImage();
		if(htmlImage) {
			this.drawImageAt(canvas, htmlImage, this.images.display, 0, 0, this.w, this.h, srcRect);
		}	
	}

	return;
}

function UIFrameAnimationCreator() {
	var args = [ "ui-frame-animation", "ui-frame-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFrameAnimation();
		return g.initUIFrameAnimation(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIFrameAnimationCreator());

/*
 * File:   ui-weld-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIWeldJoint() {
	return;
}

UIWeldJoint.prototype = new UIOneJoint();
UIWeldJoint.prototype.isUIJoint = true;
UIWeldJoint.prototype.isUIWeldJoint = true;

UIWeldJoint.prototype.initUIWeldJoint = function(type) {
	this.initUIOneJoint(type);	
	
	return this;
}

function UIWeldJointCreator() {
	var args = ["ui-weld-joint", "ui-weld-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWeldJoint();
		return g.initUIWeldJoint(this.type);
	}
	
	return;
}
/*
 * File:   ui-mouse-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  mouse joint, react with pointer event.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIMouseJoint
 * @extends UIElement
 * 鼠标关节。通过指针事件控制刚体的速度。
 *
 */
function UIMouseJoint() {
	return;
}

UIMouseJoint.prototype = new UIOneJoint();
UIMouseJoint.prototype.isUIMouseJoint = true;

UIMouseJoint.prototype.saveProps = ["speedScale", "enableTop", "enableLeft", "enableRight", "enableBottom"];
UIMouseJoint.prototype.initUIMouseJoint = function(type) {
	this.initUIOneJoint(type);	
	this.speedScale = 1;
	this.enableTop = true;
	this.enableLeft = true;
	this.enableRight = true;
	this.enableBottom = true;

	return this;
}

UIMouseJoint.prototype.onInit = function() {
	var sprite = this.getParent();
	var speedScale = this.speedScale;
	var enableLeft = this.enableLeft;
	var enableRight = this.enableRight;
	var enableTop = this.enableTop;
	var enableBottom = this.enableBottom;

	if(sprite.physicsShape || sprite.isUIPhysicsShape) {
		sprite.handlePointerDown = function(point) {
			return UIMouseJoint.handleSpritePointerDown(sprite, point);	
		}

		sprite.handlePointerMove = function(point) {
			return UIMouseJoint.handleSpritePointerMove(sprite, point);	
		}

		sprite.handlePointerUp = function(point) {
			return UIMouseJoint.handleSpritePointerUp(sprite, point, speedScale, enableLeft, enableRight, enableTop, enableBottom);	
		}
	}
}

UIMouseJoint.handleSpritePointerDown = function(sprite, point) {
	sprite.body.SetLinearVelocity({x:0, y:0});

	return;
}

UIMouseJoint.handleSpritePointerMove = function(sprite, point) {
	sprite.body.SetLinearVelocity({x:0, y:0});

	return;
}

UIMouseJoint.prototype.setSpeedLimit = function(xMinV, xMaxV, yMinV, yMaxV) { 
	var sprite = this.getParent();

	sprite.xMinV = xMinV;
	sprite.yMinV = yMinV;
	sprite.xMaxV = xMaxV;
	sprite.yMaxV = yMaxV;

	return;
}

UIMouseJoint.handleSpritePointerUp = function(sprite, point, speedScale, enableLeft, enableRight, enableTop, enableBottom) {
	var dt = (Date.now() - sprite.pointerDownTime)/1000;
	var dx = sprite.getMoveAbsDeltaX();
	var dy = sprite.getMoveAbsDeltaY();
	var vx = speedScale * Physics.toMeter(dx)/dt;
	var vy = speedScale * Physics.toMeter(dy)/dt;

	if(!enableLeft && vx < 0) {
		vx = 0;
	}

	if(!enableTop && vy < 0) {
		vy = 0;
	}

	if(!enableRight && vx > 0) {
		vx = 0;
	}

	if(!enableBottom && vy > 0) {
		vy = 0;
	}

	var xMaxV = sprite.xMaxV;
	if(xMaxV && Math.abs(vx) > xMaxV) {
		vx = vx > 0 ? xMaxV : -xMaxV;
	}
	
	var yMaxV = sprite.yMaxV;
	if(yMaxV && Math.abs(vy) > yMaxV) {
		vy = vy > 0 ? yMaxV : -yMaxV;
	}
	
	var xMinV = sprite.xMinV;
	if(xMinV && Math.abs(vx) < xMinV) {
		vx = vx > 0 ? xMinV : -xMinV;
	}
	
	var yMinV = sprite.yMinV;
	if(yMinV && Math.abs(vy) < yMinV) {
		vy = vy > 0 ? yMinV : -yMinV;
	}

	sprite.body.SetLinearVelocity({x:vx, y:vy});

	return;
}

function UIMouseJointCreator() {
	var args = ["ui-mouse-joint", "ui-mouse-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMouseJoint();
		return g.initUIMouseJoint(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMouseJointCreator());

/*
 * File:   ui-sound.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sound for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISoundEffects
 * @extends UICheckBox
 * 音效。在运行时它是控制音效的开关，在设计时它是添加音效文件的接口。
 *
 * 添加的音效文件是全局的，删除音效控件并不会删除音效文件。
 *
 * 可以通过任何一个控件调用playSoundEffect播放音效。
 *
 */
function UISoundEffects() {
	return;
}

UISoundEffects.prototype = new UICheckBox();
UISoundEffects.prototype.isUISoundEffects = true;

UISoundEffects.prototype.initUISoundEffects = function(type) {
	this.initUICheckBox(type);	

	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UISoundEffects.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UISoundEffects.prototype.setValue = function(value) {
	var wm = this.getWindowManager();
	
	if(this.mode === Shape.MODE_EDITING) {
		return this;
	}

	if(wm) {
		wm.setSoundEffectsEnable(value);
	}

	return this;
}

UISoundEffects.prototype.getValue = function(value) {
	var wm = this.getWindowManager();
	if(wm) {
		return wm.soundEffectsEnalbe;
	}
	else {
		return true;
	}
}

UISoundEffects.prototype.isPlaying = UISoundEffects.prototype.getValue;

function UISoundEffectsCreator() {
	var args = ["ui-sound-effects", "ui-sound-effects", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISoundEffects();
		return g.initUISoundEffects(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISoundEffectsCreator());

/*
 * File:   ui-shaker.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  shaker 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 Holaverse Inc.
 * 
 */

/**
 * @class UIShaker
 * @extends UIElement
 * 振动器。在启用时(setEnable(true))让所在的父控件(通常是场景)按指定参数振动，振动完成后自动进入禁用状态。
 *
 */
function UIShaker() {
	return;
}

UIShaker.prototype = new UIImage();
UIShaker.prototype.isUIShaker = true;

UIShaker.prototype.saveProps = ["amplitudeX", "amplitudeY", "times", "duration", "amplitudeModifier"];
UIShaker.prototype.initUIShaker = function(type, w, h) {
	this.initUIImage(type, w ,h);	

	return this;
}

/**
 * @method setAmplitudeX
 * 设置水平方向上的振幅。
 * @param {Number} value value为正向先向右动，为负向先向左动。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setAmplitudeX = function(value) {
	this.amplitudeX = value;

	return this;
}

/**
 * @method setAmplitudeY
 * 设置垂直方向上的振幅。
 * @param {Number} value 为正向先向下动，为负向先向上动。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setAmplitudeY = function(value) {
	this.amplitudeY = value;

	return this;
}

/**
 * @method setDuration
 * 设置振动持续的时间。
 * @param {Number} value 振动持续的时间。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setDuration = function(value) {
	this.duration = value;

	return this;
}

/**
 * @method setTimes
 * 设置振动的次数。
 * @param {Number} value 次数。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setTimes = function(value) {
	this.times = value;

	return this;
}

UIShaker.prototype.setAmplitudeModifier = function(value) {
	this.amplitudeModifier = value;

	return this;
}

UIShaker.prototype.getAmplitudeX = function() {
	return this.amplitudeX;
}

UIShaker.prototype.getAmplitudeY = function() {
	return this.amplitudeY;
}

UIShaker.prototype.getDuration = function() {
	return this.duration;
}

UIShaker.prototype.getTimes = function() {
	return this.times;
}

UIShaker.prototype.getAmplitudeModifier = function() {
	return this.amplitudeModifier;
}

UIShaker.prototype.setEnable = function(enable) {
	var parent = this.getParent();

	if(!parent || this.enable == enable) {
		return this;
	}

	if(!enable) {
		this.enable = enable;
		return this;
	}
	
	var me = this;
	var aX = this.amplitudeX ? this.amplitudeX : 0;
	var aY = this.amplitudeY ? this.amplitudeY : 0;
	var n = this.times ? this.times : 1;
	var duration = this.duration ? this.duration : 200;
	
	var startTime = Date.now();
	var oldPaintSelf = parent.paintSelf;
	var range = n * 2 * Math.PI;
	var am = this.amplitudeModifier;

	parent.paintSelf = function(canvas) {
		var dt = (Date.now() - startTime);

		if(dt < duration) {
			var factor = 1;
			var percent = dt/duration;
			var angle = range *  percent;
			var xo = aX * Math.cos(angle);
			var yo = aY * Math.sin(angle);

			if(am === "i") {
				factor = percent;
			}
			else if(am === "d") {
				factor = (1-percent);
			}
			else if(am === "i->d") {
				factor = 2 * (percent < 0.5 ? percent : (1-percent));
			}

			xo *= factor;
			yo *= factor;

			canvas.translate(xo, yo);
		}
		else {
			 parent.paintSelf = oldPaintSelf;
			 me.enable = false;
		}

		oldPaintSelf.call(parent, canvas);
	}
	
	return this;
}

function UIShakerCreator() {
	var args = ["ui-shaker", "ui-shaker", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIShaker();
		return g.initUIShaker(this.type, 80, 80);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIShakerCreator());

/*
 * File:   ui-settings.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  settings shape
 * 
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

/**
 * @class UISettings
 * @extends UIElement
 * 将游戏的设置独立出来，在IDE中提供一个可视化的界面，让游戏策划不需要程序配合，就可以修改这些数值来调节游戏的效果（使用时先用管理设置对话框中增加设置)。
 *
 *     @example small frame
 *     var settings = this.win.find("settings");
 *
 *     var speed = settings.getSetting("speed");
 *     console.log(speed);
 *
 */
function UISettings() {
	return;
}

UISettings.prototype = new UIElement();
UISettings.prototype.isUISettings = true;

UISettings.prototype.initUISettings = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.settingsDef = {};

	return this;
}

UISettings.prototype.getSettingObj = function(name) {
	var def = this.settingsDef[name];

	if(def && def.isGlobal) {
		return this.getWindowManager();
	}
	else {
		return this.getWindow();
	}
}

/**
 * @method getSetting
 * 获取name设置对应的值。
 * @param {String} name 
 * @return {Number} 返回对应的值。
 *
 */
UISettings.prototype.getSetting = function(name) {
	var obj = this.getSettingObj(name);

	var value = obj.settings[name];
	if(value === undefined) {
		var def = this.settingsDef[name];
		if(def) {
			value = def.defVal;
		}
	}

	return value;
}

/**
 * @method setSetting
 * 设置name设置对应的值。
 * @param {String} name 
 * @param {Number} value
 * @return {UIElement} 返回控件本身。
 *
 */
UISettings.prototype.setSetting = function(name, value) {
	var obj = this.getSettingObj(name);

	obj.settings[name] = value;

	return this;
}

UISettings.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.settingsDef = js.settingsDef;

	return this;
}

UISettings.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.settingsDef = this.settingsDef;

	return o;
}

function UISettingsCreator() {
	var args = ["ui-settings", "ui-settings", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISettings();
		return g.initUISettings(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISettingsCreator());

/*
 * File:   ui-assets.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  assets manager
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIAssets
 * @extends UIElement
 * 资源管理控件，可以添加一组资源(如图片、JSON和其它数据)，导出时自动导出这些资源，运行时可以用loadImage/loadData/loadJSON来获取相应的资源。
 *
 * 资源管理控件主要用于管理普通控件没有引用到的资源，比如游戏需要的关卡数据，动态创建的控件需要的图片和JSON等等。
 *
 */
function UIAssets() {
	return;
}

UIAssets.prototype = new UIElement();
UIAssets.prototype.isUIAssets = true;

UIAssets.prototype.initUIAssets = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.assets = {};

	return this;
}

UIAssets.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);
	
	this.assets = js.assets;

	return this;
}

UIAssets.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.assets = JSON.parse(JSON.stringify(this.assets || {}));

	return o;
}

/**
 * @method getAssetInfo
 * 获取指定名称的资源的相关信息。
 * @param {String} name 资源的名称。
 * @return {Object} 返回资源的信息。.name表示资源的名称, .url资源的URL,  .type资源的类型。
 *
 */
UIAssets.prototype.getAssetInfo = function(name) {
	var info = this.assets[name];

	if(!info) {
		console.log("not found asset:" + name);
	}

	return info;
}

/**
 * @method getAssetURL
 * 获取指定名称的资源的URL。
 * @param {String} name 资源的名称。
 * @return {Object} 返回资源的URL。
 *
 *     @example small frame
 *
 *     var win = this.win;
 *     var url = win.find("assets").getAssetURL("t.jpg");
 *     win.find("image").setValue(url);
 */
UIAssets.prototype.getAssetURL = function(name) {
	var info = this.getAssetInfo(name);

	return info ? info.url : null;
}

/**
 * @method loadJSON 
 * 加载指定名称的JSON数据。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(json) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *
 *     function onJsonLoad(json) {
 *          console.log("onJsonLoad:" + JSON.stringify(json, null, "\t"));
 *     }
 *     this.win.find("assets").loadJSON("test.json", onJsonLoad.bind(this));
 */
UIAssets.prototype.loadJSON = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "json") {
		console.log("asset is not json:" + name);
		return false;
	}

	return ResLoader.loadJson(info.url, onDone, onDone);
}

/**
 * @method loadImage
 * 加载指定名称的图片。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(img) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *
 *     function onImageLoad(img) {
 *          this.win.find("image").setValue(img);
 *     }
 *     this.win.find("assets").loadImage("t.jpg", onImageLoad.bind(this));
 */
UIAssets.prototype.loadImage = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "image") {
		console.log("asset is not image:" + name);
		return false;
	}

	return ResLoader.loadImage(info.url, onDone, onDone);
}

/**
 * @method loadData
 * 加载指定名称的文本数据。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(str) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *     
 *     function onDataLoad(data) {
 *          console.log("onDataLoad:" + data);
 *     }
 *     this.win.find("assets").loadData("test.txt", onDataLoad.bind(this));
 */
UIAssets.prototype.loadData = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "data") {
		console.log("asset is not data:" + name);
		return false;
	}

	return ResLoader.loadData(info.url, onDone, onDone);
}

function UIAssetsCreator() {
	var args = ["ui-assets", "ui-assets", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIAssets();
		return g.initUIAssets(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIAssetsCreator());

/*
 * File:   ui-tile.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  tile shape
 * 
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */


/**
 * @class UITile
 * @extends UIElement
 * 是瓦片游戏地图控件，只需要放一个UITile到场景中，地图自动与场景关联。UITile支持由Map Editor Tiled制作的地图。场景中有多个地图时，可以通过UITile的setEnable函数，或用场景的setMap来设置场景当前的地图。
 *
 * 注意：
 *
 * 1.在新建地图时请选择CSV格式作为tile layer format，保存时使用JSON格式保存，图片与数据放在同一目录下。
 *
 * 2.JSON数据中的图片名不能带路径。
 *
 * 3.启用物理引擎的方法：在tiled中新建立一个图层，给图层加几个自定义的属性。physics为true表示启用物理引擎，friction表示刚体的摩擦力系数，restitution表示刚体的弹力系数。
 *
 * 参考：http://www.mapeditor.org
 *
 */
function UITile() {
	return;
}

UITile.prototype = new UIElement();
UITile.prototype.isUITile = true;

UITile.prototype.saveProps = ["dataURL"];
UITile.prototype.initUITile = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);

	return this;
}

UITile.Layer = function() {
}

UITile.Layer.prototype.init = function(tile, info) {
	this.tile = tile;
	this.info = info;

	return this;
}

UITile.Layer.prototype.drawOrthogonal = function(canvas, rect) {
	var info = this.info;
	var ox = info.x || 0;
	var oy = info.y || 0;
	var data = info.data;
	var rows = info.height;
	var cols = info.width;
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;
	
	var w = tileW * cols;
	var top = Math.max(Math.floor(rect.y/tileH), 0);
	var left = Math.max(Math.floor(rect.x/tileW), 0);
	var right = Math.min(Math.ceil((rect.x + rect.w)/tileW), cols);
	var bottom = Math.min(Math.ceil((rect.y + rect.h)/tileH), rows);

	var x = left * tileW + ox;
	var y = top * tileH + oy;
	var rect = {x:x, y:y, w:tileW, h:tileH};

	ox = x;
	canvas.globalAlpha = info.opacity;
	for(var r = top; r <= bottom; r++) {
		for(var c = left; c <= right; c++) {
			var i = r * cols + c;
			var imgIndex = data[i]

			if(imgIndex) {
				rect.x = x;
				rect.y = y;
				tile.drawTile(canvas, rect, imgIndex);
			}

			x += tileW;
		}
		x = ox;
		y += tileH;
	}

	return;
}

UITile.Layer.prototype.drawIsometric = function(canvas, rect) {
	var top = rect.y;
	var left = rect.x;
	var right = left + rect.w;
	var bottom = top + rect.h;

	var i = 0;
	var info = this.info;
	var x = info.x || 0;
	var y = info.y || 0;
	var data = info.data;
	var rows = info.height;
	var cols = info.width;
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;

	canvas.globalAlpha = info.opacity;

	var originY = y;
	var originX = x + (this.info.width*tileW)/2 - tileW/2;
	var rect = {x:x, y:y, w:tileW, h:tileH};

	for(var r = 0; r < rows; r++) {
		for(var c = 0; c < cols; c++, i++) {
			var imgIndex = data[i]
			x = (c - r)*tileH + originX;
			y = (c + r)*tileW/4 + originY;
			if(!imgIndex || x > right || y > bottom || (x + tileW) < left || (y + tileH) < top) {
				continue;
			}
			rect.x = x;
			rect.y = y;
			tile.drawTile(canvas, rect, imgIndex);
		}
	}

	return;
}

UITile.Layer.prototype.draw = function(canvas, rect) {
	var info = this.info;

	if(!info.visible) return;

	switch(this.tile.orientation) {
		case 'orthogonal': {
			this.drawOrthogonal(canvas, rect);
			break;
		}
		case 'isometric': {
			this.drawIsometric(canvas, rect);
			break;
		}
		default: {
			throw new Error('unknow orientation: ', this.tile.orientation);
		}
	}

	return;
}

UITile.Layer.prototype.getTileByPoint = function(x, y) {
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;
	var row = Math.floor(y/tileH);
	var col = Math.floor(x/tileW);
	var index = row * this.info.width + col;
	var imageIndex = this.info.data[index];

	return {row:row, col:col, index:index, imageIndex:imageIndex};
}

UITile.TileSet = function() {
}

UITile.TileSet.prototype.init = function(tile, rootURL, info) {
	this.tile = tile;
	this.info = info;
	this.imageURL = rootURL + "/" + info.image.basename();
	this.image = WImage.create(this.imageURL);
	this.tileWidth = info.tilewidth+info.spacing;
	this.tileHeight = info.tileheight+info.spacing;
	this.cols = Math.floor((info.imagewidth-2*info.margin)/this.tileWidth);
	this.rows = Math.floor((info.imageheight-2*info.margin)/this.tileHeight);
	this.tileNr = this.cols * this.rows;
	this.startIndex = info.firstgid;

	return this;
}

UITile.TileSet.prototype.testImageIndex = function(imageIndex) {
	return imageIndex >= this.startIndex && imageIndex < (this.startIndex + this.tileNr);
}

UITile.TileSet.prototype.drawTile = function(canvas, x, y, imageIndex) {
	var image = this.image.getImage();
	var index = imageIndex - this.startIndex;

	if(index < 0 || index >= this.tileNr || !image || !image.width) {
		return;
	}

	var info = this.info;
	var c = index%this.cols;
	var r = Math.floor(index/this.cols);
	var sx = c * this.tileWidth + info.margin;
	var sy = r * this.tileHeight + info.margin;
	var w = info.tilewidth;
	var h = info.tileheight;

	if(this.tileHeight !== this.tile.tileHeight) {
		y = y - (this.tileHeight - this.tile.tileHeight);
	}

	canvas.drawImage(image,sx, sy, w, h, x, y, w, h);

	return;
}

UITile.prototype.loadTileSets = function(url, tilesets) {
	this.tilesets = [];
	var n = tilesets.length;
	var rootURL = url.dirname();

	this.images = {};
	for(var i = 0; i < n; i++) {
		var tileSet = new UITile.TileSet();
		tileSet.init(this, rootURL, tilesets[i]);

		this.setImage("option_image_"+i, tileSet.imageURL);
		this.tilesets.push(tileSet);
	}

	return this;
}

UITile.prototype.loadLayers = function(layers) {
	this.layers = [];
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		this.layers.push((new UITile.Layer()).init(this, layers[i]));
	}

	return this;
}

/**
 * @method getMapWidth
 * 获取地图的宽度。
 * @return {Number} 返回地图的宽度。
 *
 */
UITile.prototype.getMapWidth = function() {
	return this.mapWidth;
}

/**
 * @method getMapHeight
 * 获取地图的高度。
 * @return {Number} 返回地图的高度。
 *
 */
UITile.prototype.getMapHeight = function() {
	return this.mapHeight;
}

/**
 * @method getLayerNr
 * 获取地图的层数。
 * @return {Number} 返回地图的层数。
 *
 */
UITile.prototype.getLayerNr = function() {
	return this.layers ? this.layers.length : 0;
}

/**
 * @method getLayerByIndex
 * 获取地图某层的数据。
 * @param {Number} index 层数索引。
 * @return {Object} 返回地图某层的数据。layer.info里是tiled生成的原始数据。
 *
 */
UITile.prototype.getLayerByIndex = function(index) {
	if(this.layers && index < this.layers.length) {
		return this.layers[index];
	}

	return null;
}

UITile.prototype.loadJSON = function(url, json) {
	if(this.isIcon) return;

	if(!json || !json.width || !json.height) {
		console.log("invalid tiled json");
		return;
	}

	this.tileRows = json.height;
	this.tileCols = json.width;
	this.tileWidth = json.tilewidth;
	this.tileHeight = json.tileheight;
	this.orientation = json.orientation;
	this.renderorder = json.renderorder;
	this.properties = json.properties;
	this.mapWidth = this.tileWidth * this.tileCols;
	this.mapHeight = this.tileHeight * this.tileRows;

	this.loadTileSets(url, json.tilesets);
	this.loadLayers(json.layers);

	if(this.enable) {
		var win = this.getWindow();
		if(win && win.isUIScene) {
			win.setMap(this);
		}
	}

	return;
}

UITile.prototype.loadURL = function(url) {
	var me = this;
   
    ResLoader.loadJson(url, function(json) {
	    me.loadJSON(url, json);
    });

	return;
}

UITile.prototype.load = function() {
	var dataURL = this.dataURL || this.tiledJsonURL;
	if(dataURL) {
		this.dataURL = dataURL;
		this.loadURL(dataURL);
	}

	return;
}

/**
 * @method setClipRegion
 * 只显示指定区域的地图。有的游戏中只显示玩家视力范围类的地图，这时可以用本函数实现。
 * @param {Array} rects
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     var tile = this.win.find("tile");
 *     tile.setClipRegion([{x:40, y:50, w:100, h:200},{x:200, y:200, w:100, h:200}]);
 */
UITile.prototype.setClipRegion = function(rects) {
	this.clipRegion = rects;

	return this;
}

UITile.prototype.isInClipRegion = function(r) {
	if(!this.clipRegion) return true;

	var rects = this.clipRegion;
	var n = rects.length;

	for(var i = 0; i < n; i++) {
		var rect = rects[i];
		if(Rect.hasIntersection(rect, r)) {
			return true;
		}
	}

	return false;
}

UITile.prototype.drawTile = function(canvas, rect, imageIndex) {
	if(!this.isInClipRegion(rect)) {
		return;
	}

	var n = this.tilesets.length;
	for(var i = 0; i < n; i++) {
		var iter = this.tilesets[i];
		if(iter.testImageIndex(imageIndex)) {
			iter.drawTile(canvas, rect.x, rect.y, imageIndex);
			break;
		}
	}

	return;
}

UITile.prototype.draw = function(canvas, rect) {
	if(!this.layers) {
		return;
	}

	var layers = this.layers;
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		layers[i].draw(canvas, rect);	
	}

	return;
}

UITile.prototype.onAppendedInParent = function() {
	this.load();
}

UITile.prototype.createBody = function(world, name, x, y, w, h, prop) {
	var hw = w >> 1;
	var hh = h >> 1;
	var cx = x + hw;
	var cy = y + hh;
	var fixtureDef = new b2FixtureDef();
	fixtureDef.density = prop.density;
	fixtureDef.friction = prop.friction;
	fixtureDef.restitution = prop.restitution;

	if(prop.groupIndex) {
		fixtureDef.filter.groupIndex = prop.groupIndex;
	}

	if(prop.isSensor) {
		fixtureDef.isSensor = true;
	}
		
	fixtureDef.shape = new b2PolygonShape();
	fixtureDef.shape.SetAsBox(Physics.toMeter(hw), Physics.toMeter(hh));

	var bodyDef = new b2BodyDef();
	bodyDef.type = prop.density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
	bodyDef.position.Set(Physics.toMeter(cx), Physics.toMeter(cy));
	bodyDef.allowSleep = true;
	body = world.CreateBody(bodyDef);
	body.CreateFixture(fixtureDef);
	body.name = name;

	return;
}

UITile.prototype.createLayerBodies = function(world, layerIndex, info) {
	var data = info.data;
	var n = data.length;
	var prop = info.properties || {};
	var rows = info.height;
	var cols = info.width;
	var tileW = this.tileWidth;
	var tileH = this.tileHeight;
	var ox = info.x ? info.x : 0;
	var oy = info.y ? info.y : 0;

	prop.density = 0;
	prop.restitution = prop.restitution ? parseFloat(prop.restitution) : 0.5;
	prop.friction    = prop.friction ? parseFloat(prop.friction) : 0.5;

	for(var i = 0; i < n; i++) {
		var imageIndex = data[i];
		if(!imageIndex) continue;
		var r = Math.floor(i/cols);
		var c = i%cols;
		var x = ox + c * tileW;
		var y = oy + r * tileH;
		this.createBody(world, layerIndex+"-"+i, x, y, tileW, tileH, prop);
	}

	return;
}

UITile.prototype.createBodies = function(world) {
	var layers = this.layers;
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		var layer = layers[i];
		var prop = layer.info.properties;
		if(prop && prop.physics) {
			this.createLayerBodies(world, i, layer.info);	
		}
	}

	return;
}

UITile.prototype.onFromJsonDone = function(js) {
	this.load();
}

UITile.prototype.setTiledJsonURL = function(url) {
	this.dataURL = url;
	this.load();
}

UITile.prototype.getTiledJsonURL = function() {
	return this.dataURL || this.tiledJsonURL;	
}

UITile.prototype.setEnable = function(enable) {
	var parent = this.getParent();

	if(!parent || this.enable == enable) {
		return this;
	}

	var win = this.getWindow();
	if(win && win.isUIScene) {
		if(enable) {
			win.setMap(this);
		}
		else {
			if(win.getMap() === this) {
				win.setMap(null);
			}
		}
	}
	this.enable = enable;

	return;
}

function UITileCreator() {
	var args = ["ui-tile", "ui-tile", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITile();
		return g.initUITile(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITileCreator());

/*
 * File:   ui-gsensor.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  gsensor event 
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIGSensor
 * @extends UIElement
 * 用于监听设备方向变化。
 *
 * 调用setEnable启用/关闭onDeviceOrientation事件。
 *
 */

/**
 * @event onDeviceOrientation
 * 重力感应事件。
 * @param {Number} x X方向重力。
 * @param {Number} y Y方向重力。
 * @param {Number} z Z方向重力。
 * @param {Object} event 原始事件。 
 */
function UIGSensor() {
	return;
}

UIGSensor.prototype = new UIElement();
UIGSensor.prototype.isUIGSensor = true;

UIGSensor.prototype.initUIGSensor = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.addEventNames(["onDeviceOrientation"]);

	return this;
}

UIGSensor.prototype.onInit = function() {
	if(this.enable) {
		this.setEnable(true);
	}
}

UIGSensor.prototype.setEnable = function(enable) {
	var me = this;
	if(this.mode === Shape.MODE_EDITING) return this;

	function onDeviceOrientation(e) {
		var current = e.accelerationIncludingGravity;
		if(!current) {
			console.log("accelerationIncludingGravity not available.");
			return;
		}
		
		var x = current.x || 0;
		var y = current.y || 0;
		var z = current.z || -9.8;

		if(isAndroid()) {
			x = -x;
		}
		else if(isIPhone()) {
			y = -y;
		}

		me.callOnDeviceOrientation(x, y, z, e);

		return;
	}

	this.enable = enable;
	if(enable) {
		window.removeEventListener('devicemotion', onDeviceOrientation, false);		   
		window.addEventListener('devicemotion', onDeviceOrientation, false);	
	}
	else {
		window.removeEventListener('devicemotion', onDeviceOrientation, false);		   
	}

	return this;
}

function UIGSensorCreator() {
	var args = ["ui-gsensor", "ui-gsensor", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGSensor();
		return g.initUIGSensor(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGSensorCreator());

function UIMarquee() {
	return;
}

UIMarquee.prototype = new UILabel();
UIMarquee.isUIMarquee = true;

UIMarquee.prototype.saveProps = ["direction", "behavior", "scrollamount", "scrolldelay", "loop", "autoPlay"];
//direction
UIMarquee.DIR_UP   = 'up';
UIMarquee.DIR_DOWN = 'down';
UIMarquee.DIR_LEFT = 'left';
UIMarquee.DIR_RIGHT= 'right';

//behavior
UIMarquee.BEHAVIOR_SCROLL = 'scroll';
UIMarquee.BEHAVIOR_SLIDE  = 'slide';
UIMarquee.BEHAVIOR_ALTERNATE = 'alternate';

//loop
UIMarquee.LOOP_INFINITE = 'infinite';

//scrollamount
UIMarquee.DEFAULT_SCROLL_AMOUNT = 1;//px

//scrolldelay
UIMarquee.DEFAULT_SCROLL_DELAY  = 20;//ms

UIMarquee.prototype.initUIMarquee = function(type, initText, bg) {
	this.initUIElement(type);	

	this.setText(initText);
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.running = false;
	this.scrollCounter = 0;
	this.timeScale = 1;
	this.autoPlay = false;
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.addEventNames(["onChanged", "onUpdateTransform", "onPlayStepDone", "onPlayDone"]);

	return this;
}

var configLeftResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis = scrollDis%(w+textLen);
		if(scrollDis <= textLen) {
			canvas.rect(w - textLen, 0, textLen, h);	
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= w) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(w - scrollDis, 0);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {	
		if(this.done) return;
		scrollDis%=w;
		if(scrollDis <= textLen) {
			canvas.rect(w-textLen, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(w - scrollDis, 0);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(w-textLen, 0);
			return;
		}
		var odd = parseInt(scrollDis/(w-textLen), 10)%2 > 0;
		var dis = parseInt(scrollDis%(w-textLen), 10);
			dis = odd ? w-textLen-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(!odd && this.needStep){
			this.callOnStep();
		}

		canvas.translate(w - textLen - dis, 0);
	}
};

var configUpResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis = scrollDis%(h+textHeight);
		if(scrollDis <= textHeight) {
			canvas.rect(0, h - textHeight, w, textHeight);	
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= h) {
			canvas.rect(0, 0, w, h);
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(0, h - scrollDis);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		scrollDis%=h;
		if(scrollDis <= textHeight) {
			canvas.rect(0, h-textHeight, w, textHeight);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(0, h - scrollDis);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(0, h - textHeight);
			return;
		}
		var odd = parseInt(scrollDis/(h-textHeight), 10)%2 > 0;
		var dis = parseInt(scrollDis%(h-textHeight), 10);
			dis = odd ? h-textHeight-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(!odd && this.needStep) {
			this.callOnStep();
		}

		canvas.translate(0, h - textHeight - dis);
	}
};

var configRightResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis%=(w+textLen);
		if(scrollDis >= w) {
			this.needStep = true;
			canvas.rect(w-textLen, 0, textLen, h);
			canvas.clip();
		}
		else if(scrollDis <= textLen) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		canvas.translate(scrollDis - textLen, 0);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(w - textLen, 0);	
			return;
		}
		scrollDis%=w;
		if(scrollDis <= textLen) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(scrollDis - textLen, 0);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		var odd = parseInt(scrollDis/(w-textLen), 10)%2 > 0;
		var dis = parseInt(scrollDis%(w-textLen), 10);
			dis = odd ? w-textLen-dis : dis;

		if(odd) {
			this.needStep = true;
		}
		if(!odd && this.needStep) {
			this.callOnStep();
		}

		canvas.translate(dis, 0);
	}
};

var configDownResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);	
			canvas.clip();
			return;
		}
		scrollDis%=(h+textHeight);
		if(scrollDis <= textHeight) {
			canvas.rect(0, 0, w, textHeight + scrollDis);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= h) {
			canvas.rect(0, h - textHeight, w, textHeight);	
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(0, scrollDis - textHeight);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(0, h - textHeight);	
			return;
		}
		scrollDis%=h;
		if(scrollDis <= textHeight) {
			canvas.rect(0, 0, w, textHeight);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(0, scrollDis - textHeight);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		var odd = parseInt(scrollDis/(h-textHeight), 10)%2 > 0;
		var dis = parseInt(scrollDis%(h-textHeight), 10);
			dis = odd ? h-textHeight-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(this.needStep && !odd) {
			this.callOnStep();
		}
		canvas.translate(0, dis);
	}
};


UIMarquee.makeResolve = function(hAlign, vAlign, handlers) {
	return function(canvas) {
		var w = this.getWidth(true),
			h = this.getHeight(true),
			timeStep = canvas.timeStep;

		var scrollDis = parseInt(this.scrollCounter*this.scrollamount/this.scrolldelay, 10);

		canvas.font = this.style.getFont();
		var text = this.getLocaleText(this.text);
		var textLen = canvas.measureText(text).width;
		var textHeight = parseInt(canvas.font);

		this.hTextAlign = hAlign;
		this.vTextAlign = vAlign;

		var args = [canvas, scrollDis, textLen, textHeight, w, h];
		switch(this.behavior) {
			case UIMarquee.BEHAVIOR_SCROLL: {
				handlers.onScroll.apply(this, args);
				break;
			}
			case UIMarquee.BEHAVIOR_SLIDE: {
				handlers.onSlide.apply(this, args);
				break;
			}
			case UIMarquee.BEHAVIOR_ALTERNATE: {
				handlers.onAlternate.apply(this, args);
				break;
			}
			default: {
				throw new Error('unknow behavior');
			}
		}
	};
}

UIMarquee.prototype.leftResolve = UIMarquee.makeResolve('left', 'middle', configLeftResolve); 
UIMarquee.prototype.rightResolve = UIMarquee.makeResolve('left', 'middle', configRightResolve); 
UIMarquee.prototype.upResolve = UIMarquee.makeResolve('center', 'up', configUpResolve); 
UIMarquee.prototype.downResolve = UIMarquee.makeResolve('center', 'up', configDownResolve); 

UIMarquee.prototype.update = function(canvas) {
	var timeStep = canvas.timeStep;

	if(timeStep < this.scrolldelay) timeStep = this.scrolldelay;

	this.scrollCounter += (this.timeScale*timeStep);

	switch(this.direction) {
		case UIMarquee.DIR_RIGHT: {
			this.rightResolve(canvas);
			break;
		}
		case UIMarquee.DIR_LEFT: {
			this.leftResolve(canvas);
			break;
		}
		case UIMarquee.DIR_UP: {
			this.upResolve(canvas);
			break;
		}
		case UIMarquee.DIR_DOWN: {
			this.downResolve(canvas);
			break;
		}
		default: {
			throw new Error("unknow UIMarquee.direction:" + this.direction);
		}
	}
}

UIMarquee.prototype.onInit = function() {
	if(this.autoPlay) {
		this.play();
	}

	return;
}

UIMarquee.prototype.drawText = function(canvas) {
	this.layoutText(canvas);
	if((this.running || this.done) && this.mode !== Shape.MODE_EDITING) {
		this.update(canvas);
		this.defaultDrawText(canvas);
	}

	if(this.mode === Shape.MODE_EDITING) {
		this.defaultDrawText(canvas);
	}

	return;
}

UIMarquee.prototype.initOpts = function(config, onDone, onStep) {
	if(typeof config === 'function') {
		onStep = onDone;
		onDone = config;
		config = {};
	}

	this.onStep = onStep || config.onStep;
	this.onDone = onDone || config.onDone;
	this.direction = config.direction || this.direction || UIMarquee.DIR_RIGHT;
	this.behavior = config.behavior || this.behavior || UIMarquee.BEHAVIOR_SCROLL;
	this.loop = config.loop > 0 ? config.loop : (this.loop ? this.loop : UIMarquee.LOOP_INFINITE);
	this.backloop = this.loop;
	this.scrolldelay = config.scrolldelay || this.scrolldelay || UIMarquee.DEFAULT_SCROLL_DELAY;
	this.scrollamount = config.scrollamount || this.scrollamount || UIMarquee.DEFAULT_SCROLL_AMOUNT;

	return this;
}

UIMarquee.prototype.play = function(config, onStep, onDone) {
	config = config || {};
	this.initOpts(config, onStep, onDone);
	this.reset();
	this.started = true;
	this.running = true;
	this.done = false;
	this.text = this.backText ? this.backText : this.text;

	return this;
}

UIMarquee.prototype.reset = function() {
	this.timeScale = 1;
	this.scrollCounter = 0;
	this.needStep = false;
	this.loop = this.backloop;
}

UIMarquee.prototype.restart = function() {
	if(!this.started) return;
	this.running = true;
	this.done = false;
	this.text = this.backText ? this.backText : this.text;
	this.reset();
	return this;
}

UIMarquee.prototype.stop = function() {
	this.reset();
	this.running = false;
	return this;
}

UIMarquee.prototype.pause = function() {
	if(!this.running) return;

	this.timeScale = 0;
	return this;
}

UIMarquee.prototype.resume = function() {
	if(!this.running) return;

	this.timeScale = 1;
	return this;
}

UIMarquee.prototype.callOnStep = function() {
	this.needStep = false;
	if(this.loop !== UIMarquee.LOOP_INFINITE) {
		--this.loop;
		if(this.loop === 0) {
			this.callOnDone();
			return;
		}
	}

	if(typeof this.onStep === 'function') {
		if(!this.onStep()) {
			this.callOnDone();
			return;
		}
	}

	return this;
}

UIMarquee.prototype.callOnDone = function() {
	if(typeof this.onDone === 'function') {
		this.onDone();
	}

	this.done = true;
	this.stop();

	return this;
}

function UIMarqueeCreator() {
	var args = ["ui-marquee", "ui-marquee", null, 1];	

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMarquee();
		return g.initUIMarquee(this.type, dappGetText("Text"), null);
	}
}

ShapeFactoryGet().addShapeCreator(new UIMarqueeCreator());
/*
 * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * 
 * Sean Lin 2012-5-8,
 *
 * The library is box2dweb, http://code.google.com/p/box2dweb/
 *
 * It is a port of Box2DFlash 2.1a to JavaScript.
 * You can read the documentation for Box2dFlash, since nearly everything is
 * organized the same way. http://www.box2dflash.org/docs/2.1a/reference/
 *
 */

var Box2D = {};

Box2D.MIN_VALUE = Number.MIN_VALUE;
if(Box2D.MIN_VALUE === 0) {
	var d = 2;
	while (Box2D.MIN_VALUE === 0) {
	  Box2D.MIN_VALUE = 1/(Number.MAX_VALUE/d);
	  d *= 2;
	}
}

(function (a2j, undefined) {

    if(!(Object.defineProperty instanceof Function)
        && Object.prototype.__defineGetter__ instanceof Function
        && Object.prototype.__defineSetter__ instanceof Function)
    {
        Object.defineProperty = function(obj, p, cfg) {
            if(cfg.get instanceof Function)
                obj.__defineGetter__(p, cfg.get);
            if(cfg.set instanceof Function)
                obj.__defineSetter__(p, cfg.set);
        }
    }

    function emptyFn() {};
    a2j.inherit = function(cls, base) {
        var tmpCtr = cls;
        emptyFn.prototype = base.prototype;
        cls.prototype = new emptyFn;
        cls.prototype.constructor = tmpCtr;
    };

    a2j.generateCallback = function generateCallback(context, cb) {
        return function () {
            cb.apply(context, arguments);
        };
    };

    a2j.NVector = function NVector(length) {
        if (length === undefined) length = 0;
        var tmp = new Array(length || 0);
        for (var i = 0; i < length; ++i)
            tmp[i] = 0;
        return tmp;
    };

    a2j.is = function is(o1, o2) {
        if (o1 === null) return false;
        if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
        if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
        return false;
    };

    a2j.parseUInt = function(v) {
        return Math.abs(parseInt(v));
    }

})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
    Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

    function b2AABB() {
        b2AABB.b2AABB.apply(this, arguments);
    };
    Box2D.Collision.b2AABB = b2AABB;

    function b2Bound() {
        b2Bound.b2Bound.apply(this, arguments);
    };
    Box2D.Collision.b2Bound = b2Bound;

    function b2BoundValues() {
        b2BoundValues.b2BoundValues.apply(this, arguments);
        if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
    };
    Box2D.Collision.b2BoundValues = b2BoundValues;

    function b2Collision() {
        b2Collision.b2Collision.apply(this, arguments);
    };
    Box2D.Collision.b2Collision = b2Collision;

    function b2ContactID() {
        b2ContactID.b2ContactID.apply(this, arguments);
        if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
    };
    Box2D.Collision.b2ContactID = b2ContactID;

    function b2ContactPoint() {
        b2ContactPoint.b2ContactPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ContactPoint = b2ContactPoint;

    function b2Distance() {
        b2Distance.b2Distance.apply(this, arguments);
    };
    Box2D.Collision.b2Distance = b2Distance;

    function b2DistanceInput() {
        b2DistanceInput.b2DistanceInput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceInput = b2DistanceInput;

    function b2DistanceOutput() {
        b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

    function b2DistanceProxy() {
        b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

    function b2DynamicTree() {
        b2DynamicTree.b2DynamicTree.apply(this, arguments);
        if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTree = b2DynamicTree;

    function b2DynamicTreeBroadPhase() {
        b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

    function b2DynamicTreeNode() {
        b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

    function b2DynamicTreePair() {
        b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

    function b2Manifold() {
        b2Manifold.b2Manifold.apply(this, arguments);
        if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
    };
    Box2D.Collision.b2Manifold = b2Manifold;

    function b2ManifoldPoint() {
        b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
        if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

    function b2Point() {
        b2Point.b2Point.apply(this, arguments);
    };
    Box2D.Collision.b2Point = b2Point;

    function b2RayCastInput() {
        b2RayCastInput.b2RayCastInput.apply(this, arguments);
        if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastInput = b2RayCastInput;

    function b2RayCastOutput() {
        b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

    function b2Segment() {
        b2Segment.b2Segment.apply(this, arguments);
    };
    Box2D.Collision.b2Segment = b2Segment;

    function b2SeparationFunction() {
        b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
    };
    Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

    function b2Simplex() {
        b2Simplex.b2Simplex.apply(this, arguments);
        if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
    };
    Box2D.Collision.b2Simplex = b2Simplex;

    function b2SimplexCache() {
        b2SimplexCache.b2SimplexCache.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexCache = b2SimplexCache;

    function b2SimplexVertex() {
        b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

    function b2TimeOfImpact() {
        b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
    };
    Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

    function b2TOIInput() {
        b2TOIInput.b2TOIInput.apply(this, arguments);
    };
    Box2D.Collision.b2TOIInput = b2TOIInput;

    function b2WorldManifold() {
        b2WorldManifold.b2WorldManifold.apply(this, arguments);
        if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
    };
    Box2D.Collision.b2WorldManifold = b2WorldManifold;

    function ClipVertex() {
        ClipVertex.ClipVertex.apply(this, arguments);
    };
    Box2D.Collision.ClipVertex = ClipVertex;

    function Features() {
        Features.Features.apply(this, arguments);
    };
    Box2D.Collision.Features = Features;

    function b2CircleShape() {
        b2CircleShape.b2CircleShape.apply(this, arguments);
        if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

    function b2EdgeChainDef() {
        b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
        if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

    function b2EdgeShape() {
        b2EdgeShape.b2EdgeShape.apply(this, arguments);
        if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

    function b2MassData() {
        b2MassData.b2MassData.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2MassData = b2MassData;

    function b2PolygonShape() {
        b2PolygonShape.b2PolygonShape.apply(this, arguments);
        if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

    function b2Shape() {
        b2Shape.b2Shape.apply(this, arguments);
        if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2Shape = b2Shape;
    Box2D.Common.b2internal = 'Box2D.Common.b2internal';

    function b2Color() {
        b2Color.b2Color.apply(this, arguments);
        if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
    };
    Box2D.Common.b2Color = b2Color;

    function b2Settings() {
        b2Settings.b2Settings.apply(this, arguments);
    };
    Box2D.Common.b2Settings = b2Settings;

    function b2Mat22() {
        b2Mat22.b2Mat22.apply(this, arguments);
        if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat22 = b2Mat22;

    function b2Mat33() {
        b2Mat33.b2Mat33.apply(this, arguments);
        if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat33 = b2Mat33;

    function b2Math() {
        b2Math.b2Math.apply(this, arguments);
    };
    Box2D.Common.Math.b2Math = b2Math;

    function b2Sweep() {
        b2Sweep.b2Sweep.apply(this, arguments);
    };
    Box2D.Common.Math.b2Sweep = b2Sweep;

    function b2Transform() {
        b2Transform.b2Transform.apply(this, arguments);
        if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
    };
    Box2D.Common.Math.b2Transform = b2Transform;

    function b2Vec2() {
        b2Vec2.b2Vec2.apply(this, arguments);
        if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec2 = b2Vec2;

    function b2Vec3() {
        b2Vec3.b2Vec3.apply(this, arguments);
        if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec3 = b2Vec3;

    function b2Body() {
        b2Body.b2Body.apply(this, arguments);
        if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
    };
    Box2D.Dynamics.b2Body = b2Body;

    function b2BodyDef() {
        b2BodyDef.b2BodyDef.apply(this, arguments);
        if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2BodyDef = b2BodyDef;

    function b2ContactFilter() {
        b2ContactFilter.b2ContactFilter.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

    function b2ContactImpulse() {
        b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

    function b2ContactListener() {
        b2ContactListener.b2ContactListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactListener = b2ContactListener;

    function b2ContactManager() {
        b2ContactManager.b2ContactManager.apply(this, arguments);
        if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactManager = b2ContactManager;

    function b2DebugDraw() {
        b2DebugDraw.b2DebugDraw.apply(this, arguments);
        if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
    };
    Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

    function b2DestructionListener() {
        b2DestructionListener.b2DestructionListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

    function b2FilterData() {
        b2FilterData.b2FilterData.apply(this, arguments);
    };
    Box2D.Dynamics.b2FilterData = b2FilterData;

    function b2Fixture() {
        b2Fixture.b2Fixture.apply(this, arguments);
        if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
    };
    Box2D.Dynamics.b2Fixture = b2Fixture;

    function b2FixtureDef() {
        b2FixtureDef.b2FixtureDef.apply(this, arguments);
        if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

    function b2Island() {
        b2Island.b2Island.apply(this, arguments);
        if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
    };
    Box2D.Dynamics.b2Island = b2Island;

    function b2TimeStep() {
        b2TimeStep.b2TimeStep.apply(this, arguments);
    };
    Box2D.Dynamics.b2TimeStep = b2TimeStep;

    function b2World() {
        b2World.b2World.apply(this, arguments);
        if (this.constructor === b2World) this.b2World.apply(this, arguments);
    };
    Box2D.Dynamics.b2World = b2World;

    function b2CircleContact() {
        b2CircleContact.b2CircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

    function b2Contact() {
        b2Contact.b2Contact.apply(this, arguments);
        if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2Contact = b2Contact;

    function b2ContactConstraint() {
        b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
        if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

    function b2ContactConstraintPoint() {
        b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

    function b2ContactEdge() {
        b2ContactEdge.b2ContactEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

    function b2ContactFactory() {
        b2ContactFactory.b2ContactFactory.apply(this, arguments);
        if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

    function b2ContactRegister() {
        b2ContactRegister.b2ContactRegister.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

    function b2ContactResult() {
        b2ContactResult.b2ContactResult.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

    function b2ContactSolver() {
        b2ContactSolver.b2ContactSolver.apply(this, arguments);
        if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

    function b2EdgeAndCircleContact() {
        b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

    function b2NullContact() {
        b2NullContact.b2NullContact.apply(this, arguments);
        if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

    function b2PolyAndCircleContact() {
        b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

    function b2PolyAndEdgeContact() {
        b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

    function b2PolygonContact() {
        b2PolygonContact.b2PolygonContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

    function b2PositionSolverManifold() {
        b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
        if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

    function b2BuoyancyController() {
        b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

    function b2ConstantAccelController() {
        b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

    function b2ConstantForceController() {
        b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

    function b2Controller() {
        b2Controller.b2Controller.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2Controller = b2Controller;

    function b2ControllerEdge() {
        b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

    function b2GravityController() {
        b2GravityController.b2GravityController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

    function b2TensorDampingController() {
        b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

    function b2DistanceJoint() {
        b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
        if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

    function b2DistanceJointDef() {
        b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
        if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

    function b2FrictionJoint() {
        b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
        if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

    function b2FrictionJointDef() {
        b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
        if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

    function b2GearJoint() {
        b2GearJoint.b2GearJoint.apply(this, arguments);
        if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

    function b2GearJointDef() {
        b2GearJointDef.b2GearJointDef.apply(this, arguments);
        if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

    function b2Jacobian() {
        b2Jacobian.b2Jacobian.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

    function b2Joint() {
        b2Joint.b2Joint.apply(this, arguments);
        if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Joint = b2Joint;

    function b2JointDef() {
        b2JointDef.b2JointDef.apply(this, arguments);
        if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

    function b2JointEdge() {
        b2JointEdge.b2JointEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

    function b2LineJoint() {
        b2LineJoint.b2LineJoint.apply(this, arguments);
        if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

    function b2LineJointDef() {
        b2LineJointDef.b2LineJointDef.apply(this, arguments);
        if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

    function b2MouseJoint() {
        b2MouseJoint.b2MouseJoint.apply(this, arguments);
        if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

    function b2MouseJointDef() {
        b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
        if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

    function b2PrismaticJoint() {
        b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
        if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

    function b2PrismaticJointDef() {
        b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
        if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

    function b2PulleyJoint() {
        b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
        if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

    function b2PulleyJointDef() {
        b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
        if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

    function b2RevoluteJoint() {
        b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
        if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

    function b2RevoluteJointDef() {
        b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
        if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

    function b2WeldJoint() {
        b2WeldJoint.b2WeldJoint.apply(this, arguments);
        if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

    function b2WeldJointDef() {
        b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
        if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    b2AABB.b2AABB = function () {
        this.lowerBound = new b2Vec2();
        this.upperBound = new b2Vec2();
    };
    b2AABB.prototype.IsValid = function () {
        var dX = this.upperBound.x - this.lowerBound.x;
        var dY = this.upperBound.y - this.lowerBound.y;
        var valid = dX >= 0.0 && dY >= 0.0;
        valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
        return valid;
    }
    b2AABB.prototype.GetCenter = function () {
        return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
    }
    b2AABB.prototype.GetExtents = function () {
        return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
    }
    b2AABB.prototype.Contains = function (aabb) {
        var result = true;
        result = result && this.lowerBound.x <= aabb.lowerBound.x;
        result = result && this.lowerBound.y <= aabb.lowerBound.y;
        result = result && aabb.upperBound.x <= this.upperBound.x;
        result = result && aabb.upperBound.y <= this.upperBound.y;
        return result;
    }
    b2AABB.prototype.RayCast = function (output, input) {
        var tmin = (-Number.MAX_VALUE);
        var tmax = Number.MAX_VALUE;
        var pX = input.p1.x;
        var pY = input.p1.y;
        var dX = input.p2.x - input.p1.x;
        var dY = input.p2.y - input.p1.y;
        var absDX = Math.abs(dX);
        var absDY = Math.abs(dY);
        var normal = output.normal;
        var inv_d = 0;
        var t1 = 0;
        var t2 = 0;
        var t3 = 0;
        var s = 0; {
            if (absDX < Box2D.MIN_VALUE) {
                if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
            }
            else {
                inv_d = 1.0 / dX;
                t1 = (this.lowerBound.x - pX) * inv_d;
                t2 = (this.upperBound.x - pX) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.x = s;
                    normal.y = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        } {
            if (absDY < Box2D.MIN_VALUE) {
                if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
            }
            else {
                inv_d = 1.0 / dY;
                t1 = (this.lowerBound.y - pY) * inv_d;
                t2 = (this.upperBound.y - pY) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.y = s;
                    normal.x = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        }
        output.fraction = tmin;
        return true;
    }
    b2AABB.prototype.TestOverlap = function (other) {
        var d1X = other.lowerBound.x - this.upperBound.x;
        var d1Y = other.lowerBound.y - this.upperBound.y;
        var d2X = this.lowerBound.x - other.upperBound.x;
        var d2Y = this.lowerBound.y - other.upperBound.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    b2AABB.Combine = function (aabb1, aabb2) {
        var aabb = new b2AABB();
        aabb.Combine(aabb1, aabb2);
        return aabb;
    }
    b2AABB.prototype.Combine = function (aabb1, aabb2) {
        this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
        this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
        this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
        this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
    }
    b2Bound.b2Bound = function () {};
    b2Bound.prototype.IsLower = function () {
        return (this.value & 1) == 0;
    }
    b2Bound.prototype.IsUpper = function () {
        return (this.value & 1) == 1;
    }
    b2Bound.prototype.Swap = function (b) {
        var tempValue = this.value;
        var tempProxy = this.proxy;
        var tempStabbingCount = this.stabbingCount;
        this.value = b.value;
        this.proxy = b.proxy;
        this.stabbingCount = b.stabbingCount;
        b.value = tempValue;
        b.proxy = tempProxy;
        b.stabbingCount = tempStabbingCount;
    }
    b2BoundValues.b2BoundValues = function () {};
    b2BoundValues.prototype.b2BoundValues = function () {
        this.lowerValues = new Vector_a2j_Number();
        this.lowerValues[0] = 0.0;
        this.lowerValues[1] = 0.0;
        this.upperValues = new Vector_a2j_Number();
        this.upperValues[0] = 0.0;
        this.upperValues[1] = 0.0;
    }
    b2Collision.b2Collision = function () {};
    b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
        if (offset === undefined) offset = 0;
        var cv;
        var numOut = 0;
        cv = vIn[0];
        var vIn0 = cv.v;
        cv = vIn[1];
        var vIn1 = cv.v;
        var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
        var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
        if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
        if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
        if (distance0 * distance1 < 0.0) {
            var interp = distance0 / (distance0 - distance1);
            cv = vOut[numOut];
            var tVec = cv.v;
            tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
            tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
            cv = vOut[numOut];
            var cv2;
            if (distance0 > 0.0) {
                cv2 = vIn[0];
                cv.id = cv2.id;
            }
            else {
                cv2 = vIn[1];
                cv.id = cv2.id;
            }++numOut;
        }
        return numOut;
    }
    b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
        var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = vertices2[i];
            var dot = tVec.x * normal1X + tVec.y * normal1Y;
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        tVec = vertices1[edge1];
        tMat = xf1.R;
        var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = vertices2[index];
        tMat = xf2.R;
        var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        v2X -= v1X;
        v2Y -= v1Y;
        var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
        return separation;
    }
    b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = poly2.m_centroid;
        var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf1.R;
        tVec = poly1.m_centroid;
        dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
        var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
        var edge = 0;
        var maxDot = (-Number.MAX_VALUE);
        for (var i = 0; i < count1; ++i) {
            tVec = normals1[i];
            var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
            if (dot > maxDot) {
                maxDot = dot;
                edge = i;
            }
        }
        var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
        var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
        var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
        var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
        var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
        var bestEdge = 0;
        var bestSeparation = 0;
        var increment = 0;
        if (sPrev > s && sPrev > sNext) {
            increment = (-1);
            bestEdge = prevEdge;
            bestSeparation = sPrev;
        }
        else if (sNext > s) {
            increment = 1;
            bestEdge = nextEdge;
            bestSeparation = sNext;
        }
        else {
            edgeIndex[0] = edge;
            return s;
        }
        while (true) {
            if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
            else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
            if (s > bestSeparation) {
                bestEdge = edge;
                bestSeparation = s;
            }
            else {
                break;
            }
        }
        edgeIndex[0] = bestEdge;
        return bestSeparation;
    }
    b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
        normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
        normal1X = tX;
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = normals2[i];
            var dot = (normal1X * tVec.x + normal1Y * tVec.y);
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        var tClip;
        var i1 = parseInt(index);
        var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
        tClip = c[0];
        tVec = vertices2[i1];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i1;
        tClip.id.features.incidentVertex = 0;
        tClip = c[1];
        tVec = vertices2[i2];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i2;
        tClip.id.features.incidentVertex = 1;
    }
    b2Collision.MakeClipPointVector = function () {
        var r = new Vector(2);
        r[0] = new ClipVertex();
        r[1] = new ClipVertex();
        return r;
    }
    b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
        var cv;
        manifold.m_pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = 0;
        b2Collision.s_edgeAO[0] = edgeA;
        var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
        edgeA = b2Collision.s_edgeAO[0];
        if (separationA > totalRadius) return;
        var edgeB = 0;
        b2Collision.s_edgeBO[0] = edgeB;
        var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
        edgeB = b2Collision.s_edgeBO[0];
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1;
        var xf2;
        var edge1 = 0;
        var flip = 0;
        var k_relativeTol = 0.98;
        var k_absoluteTol = 0.001;
        var tMat;
        if (separationB > k_relativeTol * separationA + k_absoluteTol) {
            poly1 = polyB;
            poly2 = polyA;
            xf1 = xfB;
            xf2 = xfA;
            edge1 = edgeB;
            manifold.m_type = b2Manifold.e_faceB;
            flip = 1;
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            xf1 = xfA;
            xf2 = xfB;
            edge1 = edgeA;
            manifold.m_type = b2Manifold.e_faceA;
            flip = 0;
        }
        var incidentEdge = b2Collision.s_incidentEdge;
        b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var local_v11 = vertices1[edge1];
        var local_v12;
        if (edge1 + 1 < count1) {
            local_v12 = vertices1[parseInt(edge1 + 1)];
        }
        else {
            local_v12 = vertices1[0];
        }
        var localTangent = b2Collision.s_localTangent;
        localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
        localTangent.Normalize();
        var localNormal = b2Collision.s_localNormal;
        localNormal.x = localTangent.y;
        localNormal.y = (-localTangent.x);
        var planePoint = b2Collision.s_planePoint;
        planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
        var tangent = b2Collision.s_tangent;
        tMat = xf1.R;
        tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
        tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
        var tangent2 = b2Collision.s_tangent2;
        tangent2.x = (-tangent.x);
        tangent2.y = (-tangent.y);
        var normal = b2Collision.s_normal;
        normal.x = tangent.y;
        normal.y = (-tangent.x);
        var v11 = b2Collision.s_v11;
        var v12 = b2Collision.s_v12;
        v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
        v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
        v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
        v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
        var frontOffset = normal.x * v11.x + normal.y * v11.y;
        var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
        var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
        var clipPoints1 = b2Collision.s_clipPoints1;
        var clipPoints2 = b2Collision.s_clipPoints2;
        var np = 0;
        np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
        if (np < 2) return;
        np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
        if (np < 2) return;
        manifold.m_localPlaneNormal.SetV(localNormal);
        manifold.m_localPoint.SetV(planePoint);
        var pointCount = 0;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
            cv = clipPoints2[i];
            var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
            if (separation <= totalRadius) {
                var cp = manifold.m_points[pointCount];
                tMat = xf2.R;
                var tX = cv.v.x - xf2.position.x;
                var tY = cv.v.y - xf2.position.y;
                cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
                cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
                cp.m_id.Set(cv.id);
                cp.m_id.features.flip = flip;
                ++pointCount;
            }
        }
        manifold.m_pointCount = pointCount;
    }
    b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
        manifold.m_pointCount = 0;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = circle1.m_p;
        var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        tVec = circle2.m_p;
        var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var distSqr = dX * dX + dY * dY;
        var radius = circle1.m_radius + circle2.m_radius;
        if (distSqr > radius * radius) {
            return;
        }
        manifold.m_type = b2Manifold.e_circles;
        manifold.m_localPoint.SetV(circle1.m_p);
        manifold.m_localPlaneNormal.SetZero();
        manifold.m_pointCount = 1;
        manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
        manifold.m_points[0].m_id.key = 0;
    }
    b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX = 0;
        var dY = 0;
        var positionX = 0;
        var positionY = 0;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
        var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
        var dist = 0;
        var normalIndex = 0;
        var separation = (-Number.MAX_VALUE);
        var radius = polygon.m_radius + circle.m_radius;
        var vertexCount = parseInt(polygon.m_vertexCount);
        var vertices = polygon.m_vertices;
        var normals = polygon.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
            tVec = vertices[i];
            dX = cLocalX - tVec.x;
            dY = cLocalY - tVec.y;
            tVec = normals[i];
            var s = tVec.x * dX + tVec.y * dY;
            if (s > radius) {
                return;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        var vertIndex1 = parseInt(normalIndex);
        var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < Box2D.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
            manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
            manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return;
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0.0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else {
            var faceCenterX = 0.5 * (v1.x + v2.x);
            var faceCenterY = 0.5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
            manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
    }
    b2Collision.TestOverlap = function (a, b) {
        var t1 = b.lowerBound;
        var t2 = a.upperBound;
        var d1X = t1.x - t2.x;
        var d1Y = t1.y - t2.y;
        t1 = a.lowerBound;
        t2 = b.upperBound;
        var d2X = t1.x - t2.x;
        var d2Y = t1.y - t2.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
        Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
        Box2D.Collision.b2Collision.s_normal = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
        Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
        Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
    });
    b2ContactID.b2ContactID = function () {
        this.features = new Features();
    };
    b2ContactID.prototype.b2ContactID = function () {
        this.features._m_id = this;
    }
    b2ContactID.prototype.Set = function (id) {
        this.key = id._key;
    }
    b2ContactID.prototype.Copy = function () {
        var id = new b2ContactID();
        id.key = this.key;
        return id;
    }
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._key;
        }
    });
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._key = value;
            this.features._referenceEdge = this._key & 0x000000ff;
            this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
            this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
            this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
        }
    });
    b2ContactPoint.b2ContactPoint = function () {
        this.position = new b2Vec2();
        this.velocity = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2Distance.b2Distance = function () {};
    b2Distance.Distance = function (output, cache, input) {
        ++b2Distance.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        var simplex = b2Distance.s_simplex;
        simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = simplex.m_vertices;
        var k_maxIters = 20;
        var saveA = b2Distance.s_saveA;
        var saveB = b2Distance.s_saveB;
        var saveCount = 0;
        var closestPoint = simplex.GetClosestPoint();
        var distanceSqr1 = closestPoint.LengthSquared();
        var distanceSqr2 = distanceSqr1;
        var i = 0;
        var p;
        var iter = 0;
        while (iter < k_maxIters) {
            saveCount = simplex.m_count;
            for (i = 0;
                 i < saveCount; i++) {
                saveA[i] = vertices[i].indexA;
                saveB[i] = vertices[i].indexB;
            }
            switch (simplex.m_count) {
                case 1:
                    break;
                case 2:
                    simplex.Solve2();
                    break;
                case 3:
                    simplex.Solve3();
                    break;
                default:
                    b2Settings.b2Assert(false);
            }
            if (simplex.m_count == 3) {
                break;
            }
            p = simplex.GetClosestPoint();
            distanceSqr2 = p.LengthSquared();
            if (distanceSqr2 > distanceSqr1) {}
            distanceSqr1 = distanceSqr2;
            var d = simplex.GetSearchDirection();
            if (d.LengthSquared() < Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                break;
            }
            var vertex = vertices[simplex.m_count];
            vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
            vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
            vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
            vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
            vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
            ++iter;
            ++b2Distance.b2_gjkIters;
            var duplicate = false;
            for (i = 0;
                 i < saveCount; i++) {
                if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                    duplicate = true;
                    break;
                }
            }
            if (duplicate) {
                break;
            }++simplex.m_count;
        }
        b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
        simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
        output.iterations = iter;
        simplex.WriteCache(cache);
        if (input.useRadii) {
            var rA = proxyA.m_radius;
            var rB = proxyB.m_radius;
            if (output.distance > rA + rB && output.distance > Box2D.MIN_VALUE) {
                output.distance -= rA + rB;
                var normal = b2Math.SubtractVV(output.pointB, output.pointA);
                normal.Normalize();
                output.pointA.x += rA * normal.x;
                output.pointA.y += rA * normal.y;
                output.pointB.x -= rB * normal.x;
                output.pointB.y -= rB * normal.y;
            }
            else {
                p = new b2Vec2();
                p.x = .5 * (output.pointA.x + output.pointB.x);
                p.y = .5 * (output.pointA.y + output.pointB.y);
                output.pointA.x = output.pointB.x = p.x;
                output.pointA.y = output.pointB.y = p.y;
                output.distance = 0.0;
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
        Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
        Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
    });
    b2DistanceInput.b2DistanceInput = function () {};
    b2DistanceOutput.b2DistanceOutput = function () {
        this.pointA = new b2Vec2();
        this.pointB = new b2Vec2();
    };
    b2DistanceProxy.b2DistanceProxy = function () {};
    b2DistanceProxy.prototype.Set = function (shape) {
        switch (shape.GetType()) {
            case b2Shape.e_circleShape:
            {
                var circle = (shape instanceof b2CircleShape ? shape : null);
                this.m_vertices = new Vector(1, true);
                this.m_vertices[0] = circle.m_p;
                this.m_count = 1;
                this.m_radius = circle.m_radius;
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var polygon = (shape instanceof b2PolygonShape ? shape : null);
                this.m_vertices = polygon.m_vertices;
                this.m_count = polygon.m_vertexCount;
                this.m_radius = polygon.m_radius;
            }
                break;
            case b2Shape.e_edgeShape:
            {
                var edge = (shape instanceof b2EdgeShape ? shape : null);
                this.m_vertices = new Vector(2, true);
                this.m_vertices[0] = edge.m_v1;
                this.m_vertices[1] = edge.m_v2;
                this.m_count = 2;
                this.m_radius = edge.m_radius;
            }
                break;
            default:
                b2Settings.b2Assert(false);
        }
    }
    b2DistanceProxy.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2DistanceProxy.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2DistanceProxy.prototype.GetVertexCount = function () {
        return this.m_count;
    }
    b2DistanceProxy.prototype.GetVertex = function (index) {
        if (index === undefined) index = 0;
        b2Settings.b2Assert(0 <= index && index < this.m_count);
        return this.m_vertices[index];
    }
    b2DynamicTree.b2DynamicTree = function () {};
    b2DynamicTree.prototype.b2DynamicTree = function () {
        this.m_root = null;
        this.m_freeList = null;
        this.m_path = 0;
        this.m_insertionCount = 0;
    }
    b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
        var node = this.AllocateNode();
        var extendX = b2Settings.b2_aabbExtension;
        var extendY = b2Settings.b2_aabbExtension;
        node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        node.aabb.upperBound.x = aabb.upperBound.x + extendX;
        node.aabb.upperBound.y = aabb.upperBound.y + extendY;
        node.userData = userData;
        this.InsertLeaf(node);
        return node;
    }
    b2DynamicTree.prototype.DestroyProxy = function (proxy) {
        this.RemoveLeaf(proxy);
        this.FreeNode(proxy);
    }
    b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
        b2Settings.b2Assert(proxy.IsLeaf());
        if (proxy.aabb.Contains(aabb)) {
            return false;
        }
        this.RemoveLeaf(proxy);
        var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
        var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
        proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
        proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
        this.InsertLeaf(proxy);
        return true;
    }
    b2DynamicTree.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        if (this.m_root == null) return;
        for (var i = 0; i < iterations; i++) {
            var node = this.m_root;
            var bit = 0;
            while (node.IsLeaf() == false) {
                node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
                bit = (bit + 1) & 31;
            }++this.m_path;
            this.RemoveLeaf(node);
            this.InsertLeaf(node);
        }
    }
    b2DynamicTree.prototype.GetFatAABB = function (proxy) {
        return proxy.aabb;
    }
    b2DynamicTree.prototype.GetUserData = function (proxy) {
        return proxy.userData;
    }
    b2DynamicTree.prototype.Query = function (callback, aabb) {
        if (this.m_root == null) return;
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(aabb)) {
                if (node.IsLeaf()) {
                    var proceed = callback(node);
                    if (!proceed) return;
                }
                else {
                    stack[count++] = node.child1;
                    stack[count++] = node.child2;
                }
            }
        }
    }
    b2DynamicTree.prototype.RayCast = function (callback, input) {
        if (this.m_root == null) return;
        var p1 = input.p1;
        var p2 = input.p2;
        var r = b2Math.SubtractVV(p1, p2);
        r.Normalize();
        var v = b2Math.CrossFV(1.0, r);
        var abs_v = b2Math.AbsV(v);
        var maxFraction = input.maxFraction;
        var segmentAABB = new b2AABB();
        var tX = 0;
        var tY = 0; {
            tX = p1.x + maxFraction * (p2.x - p1.x);
            tY = p1.y + maxFraction * (p2.y - p1.y);
            segmentAABB.lowerBound.x = Math.min(p1.x, tX);
            segmentAABB.lowerBound.y = Math.min(p1.y, tY);
            segmentAABB.upperBound.x = Math.max(p1.x, tX);
            segmentAABB.upperBound.y = Math.max(p1.y, tY);
        }
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(segmentAABB) == false) {
                continue;
            }
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
            if (separation > 0.0) continue;
            if (node.IsLeaf()) {
                var subInput = new b2RayCastInput();
                subInput.p1 = input.p1;
                subInput.p2 = input.p2;
                subInput.maxFraction = input.maxFraction;
                maxFraction = callback(subInput, node);
                if (maxFraction == 0.0) return;
                if (maxFraction > 0.0) {
                    tX = p1.x + maxFraction * (p2.x - p1.x);
                    tY = p1.y + maxFraction * (p2.y - p1.y);
                    segmentAABB.lowerBound.x = Math.min(p1.x, tX);
                    segmentAABB.lowerBound.y = Math.min(p1.y, tY);
                    segmentAABB.upperBound.x = Math.max(p1.x, tX);
                    segmentAABB.upperBound.y = Math.max(p1.y, tY);
                }
            }
            else {
                stack[count++] = node.child1;
                stack[count++] = node.child2;
            }
        }
    }
    b2DynamicTree.prototype.AllocateNode = function () {
        if (this.m_freeList) {
            var node = this.m_freeList;
            this.m_freeList = node.parent;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            return node;
        }
        return new b2DynamicTreeNode();
    }
    b2DynamicTree.prototype.FreeNode = function (node) {
        node.parent = this.m_freeList;
        this.m_freeList = node;
    }
    b2DynamicTree.prototype.InsertLeaf = function (leaf) {
        ++this.m_insertionCount;
        if (this.m_root == null) {
            this.m_root = leaf;
            this.m_root.parent = null;
            return;
        }
        var center = leaf.aabb.GetCenter();
        var sibling = this.m_root;
        if (sibling.IsLeaf() == false) {
            do {
                var child1 = sibling.child1;
                var child2 = sibling.child2;
                var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
                var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
                if (norm1 < norm2) {
                    sibling = child1;
                }
                else {
                    sibling = child2;
                }
            }
            while (sibling.IsLeaf() == false)
        }
        var node1 = sibling.parent;
        var node2 = this.AllocateNode();
        node2.parent = node1;
        node2.userData = null;
        node2.aabb.Combine(leaf.aabb, sibling.aabb);
        if (node1) {
            if (sibling.parent.child1 == sibling) {
                node1.child1 = node2;
            }
            else {
                node1.child2 = node2;
            }
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            do {
                if (node1.aabb.Contains(node2.aabb)) break;
                node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
                node2 = node1;
                node1 = node1.parent;
            }
            while (node1)
        }
        else {
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            this.m_root = node2;
        }
    }
    b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
        if (leaf == this.m_root) {
            this.m_root = null;
            return;
        }
        var node2 = leaf.parent;
        var node1 = node2.parent;
        var sibling;
        if (node2.child1 == leaf) {
            sibling = node2.child2;
        }
        else {
            sibling = node2.child1;
        }
        if (node1) {
            if (node1.child1 == node2) {
                node1.child1 = sibling;
            }
            else {
                node1.child2 = sibling;
            }
            sibling.parent = node1;
            this.FreeNode(node2);
            while (node1) {
                var oldAABB = node1.aabb;
                node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
                if (oldAABB.Contains(node1.aabb)) break;
                node1 = node1.parent;
            }
        }
        else {
            this.m_root = sibling;
            sibling.parent = null;
            this.FreeNode(node2);
        }
    }
    b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
        this.m_tree = new b2DynamicTree();
        this.m_moveBuffer = new Vector();
        this.m_pairBuffer = new Vector();
        this.m_pairCount = 0;
    };
    b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
        var proxy = this.m_tree.CreateProxy(aabb, userData);
        ++this.m_proxyCount;
        this.BufferMove(proxy);
        return proxy;
    }
    b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
        this.UnBufferMove(proxy);
        --this.m_proxyCount;
        this.m_tree.DestroyProxy(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
        var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
        if (buffer) {
            this.BufferMove(proxy);
        }
    }
    b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
        var aabbA = this.m_tree.GetFatAABB(proxyA);
        var aabbB = this.m_tree.GetFatAABB(proxyB);
        return aabbA.TestOverlap(aabbB);
    }
    b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
        return this.m_tree.GetUserData(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
        return this.m_tree.GetFatAABB(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
        return this.m_proxyCount;
    }
    b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
        var __this = this;
        __this.m_pairCount = 0;
        var i = 0,
            queryProxy;
        for (i = 0;
             i < __this.m_moveBuffer.length; ++i) {
            queryProxy = __this.m_moveBuffer[i];

            function QueryCallback(proxy) {
                if (proxy == queryProxy) return true;
                if (__this.m_pairCount == __this.m_pairBuffer.length) {
                    __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
                }
                var pair = __this.m_pairBuffer[__this.m_pairCount];
                pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
                pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
                return true;
            };
            var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
            __this.m_tree.Query(QueryCallback, fatAABB);
        }
        __this.m_moveBuffer.length = 0;
        for (var i = 0; i < __this.m_pairCount;) {
            var primaryPair = __this.m_pairBuffer[i];
            var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
            var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
            callback(userDataA, userDataB);
            ++i;
            while (i < __this.m_pairCount) {
                var pair = __this.m_pairBuffer[i];
                if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
                    break;
                }++i;
            }
        }
    }
    b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
        this.m_tree.Query(callback, aabb);
    }
    b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
        this.m_tree.RayCast(callback, input);
    }
    b2DynamicTreeBroadPhase.prototype.Validate = function () {}
    b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        this.m_tree.Rebalance(iterations);
    }
    b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
        this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
    }
    b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
        var i = parseInt(this.m_moveBuffer.indexOf(proxy));
        this.m_moveBuffer.splice(i, 1);
    }
    b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
        return 0;
    }
    b2DynamicTreeBroadPhase.__implements = {};
    b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
    b2DynamicTreeNode.b2DynamicTreeNode = function () {
        this.aabb = new b2AABB();
    };
    b2DynamicTreeNode.prototype.IsLeaf = function () {
        return this.child1 == null;
    }
    b2DynamicTreePair.b2DynamicTreePair = function () {};
    b2Manifold.b2Manifold = function () {
        this.m_pointCount = 0;
    };
    b2Manifold.prototype.b2Manifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2ManifoldPoint();
        }
        this.m_localPlaneNormal = new b2Vec2();
        this.m_localPoint = new b2Vec2();
    }
    b2Manifold.prototype.Reset = function () {
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
        }
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_type = 0;
        this.m_pointCount = 0;
    }
    b2Manifold.prototype.Set = function (m) {
        this.m_pointCount = m.m_pointCount;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
        }
        this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_type = m.m_type;
    }
    b2Manifold.prototype.Copy = function () {
        var copy = new b2Manifold();
        copy.Set(this);
        return copy;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Manifold.e_circles = 0x0001;
        Box2D.Collision.b2Manifold.e_faceA = 0x0002;
        Box2D.Collision.b2Manifold.e_faceB = 0x0004;
    });
    b2ManifoldPoint.b2ManifoldPoint = function () {
        this.m_localPoint = new b2Vec2();
        this.m_id = new b2ContactID();
    };
    b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
        this.Reset();
    }
    b2ManifoldPoint.prototype.Reset = function () {
        this.m_localPoint.SetZero();
        this.m_normalImpulse = 0.0;
        this.m_tangentImpulse = 0.0;
        this.m_id.key = 0;
    }
    b2ManifoldPoint.prototype.Set = function (m) {
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_normalImpulse = m.m_normalImpulse;
        this.m_tangentImpulse = m.m_tangentImpulse;
        this.m_id.Set(m.m_id);
    }
    b2Point.b2Point = function () {
        this.p = new b2Vec2();
    };
    b2Point.prototype.Support = function (xf, vX, vY) {
        if (vX === undefined) vX = 0;
        if (vY === undefined) vY = 0;
        return this.p;
    }
    b2Point.prototype.GetFirstVertex = function (xf) {
        return this.p;
    }
    b2RayCastInput.b2RayCastInput = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
        if (p1 === undefined) p1 = null;
        if (p2 === undefined) p2 = null;
        if (maxFraction === undefined) maxFraction = 1;
        if (p1) this.p1.SetV(p1);
        if (p2) this.p2.SetV(p2);
        this.maxFraction = maxFraction;
    }
    b2RayCastOutput.b2RayCastOutput = function () {
        this.normal = new b2Vec2();
    };
    b2Segment.b2Segment = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
        if (maxLambda === undefined) maxLambda = 0;
        var s = segment.p1;
        var rX = segment.p2.x - s.x;
        var rY = segment.p2.y - s.y;
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var nX = dY;
        var nY = (-dX);
        var k_slop = 100.0 * Box2D.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = s.x - this.p1.x;
            var bY = s.y - this.p1.y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= maxLambda * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    nX /= nLen;
                    nY /= nLen;
                    lambda[0] = a;
                    normal.Set(nX, nY);
                    return true;
                }
            }
        }
        return false;
    }
    b2Segment.prototype.Extend = function (aabb) {
        this.ExtendForward(aabb);
        this.ExtendBackward(aabb);
    }
    b2Segment.prototype.ExtendForward = function (aabb) {
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x + dX * lambda;
        this.p2.y = this.p1.y + dY * lambda;
    }
    b2Segment.prototype.ExtendBackward = function (aabb) {
        var dX = (-this.p2.x) + this.p1.x;
        var dY = (-this.p2.y) + this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + dX * lambda;
        this.p1.y = this.p2.y + dY * lambda;
    }
    b2SeparationFunction.b2SeparationFunction = function () {
        this.m_localPoint = new b2Vec2();
        this.m_axis = new b2Vec2();
    };
    b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
        this.m_proxyA = proxyA;
        this.m_proxyB = proxyB;
        var count = parseInt(cache.count);
        b2Settings.b2Assert(0 < count && count < 3);
        var localPointA;
        var localPointA1;
        var localPointA2;
        var localPointB;
        var localPointB1;
        var localPointB2;
        var pointAX = 0;
        var pointAY = 0;
        var pointBX = 0;
        var pointBY = 0;
        var normalX = 0;
        var normalY = 0;
        var tMat;
        var tVec;
        var s = 0;
        var sgn = 0;
        if (count == 1) {
            this.m_type = b2SeparationFunction.e_points;
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_axis.x = pointBX - pointAX;
            this.m_axis.y = pointBY - pointAY;
            this.m_axis.Normalize();
        }
        else if (cache.indexB[0] == cache.indexB[1]) {
            this.m_type = b2SeparationFunction.e_faceA;
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
            this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else if (cache.indexA[0] == cache.indexA[0]) {
            this.m_type = b2SeparationFunction.e_faceB;
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
            this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else {
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            var pA = b2Math.MulX(transformA, localPointA);
            var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
            var pB = b2Math.MulX(transformB, localPointB);
            var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
            var a = dA.x * dA.x + dA.y * dA.y;
            var e = dB.x * dB.x + dB.y * dB.y;
            var r = b2Math.SubtractVV(dB, dA);
            var c = dA.x * r.x + dA.y * r.y;
            var f = dB.x * r.x + dB.y * r.y;
            var b = dA.x * dB.x + dA.y * dB.y;
            var denom = a * e - b * b;
            s = 0.0;
            if (denom != 0.0) {
                s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
            }
            var t = (b * s + f) / e;
            if (t < 0.0) {
                t = 0.0;
                s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
            }
            localPointA = new b2Vec2();
            localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
            localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
            localPointB = new b2Vec2();
            localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
            localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
            if (s == 0.0 || s == 1.0) {
                this.m_type = b2SeparationFunction.e_faceB;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
                this.m_axis.Normalize();
                this.m_localPoint = localPointB;
                tVec = this.m_axis;
                tMat = transformB.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointA;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
            else {
                this.m_type = b2SeparationFunction.e_faceA;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
                this.m_localPoint = localPointA;
                tVec = this.m_axis;
                tMat = transformA.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointB;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
        }
    }
    b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
        var axisA;
        var axisB;
        var localPointA;
        var localPointB;
        var pointA;
        var pointB;
        var seperation = 0;
        var normal;
        switch (this.m_type) {
            case b2SeparationFunction.e_points:
            {
                axisA = b2Math.MulTMV(transformA.R, this.m_axis);
                axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointA = b2Math.MulX(transformA, localPointA);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceA:
            {
                normal = b2Math.MulMV(transformA.R, this.m_axis);
                pointA = b2Math.MulX(transformA, this.m_localPoint);
                axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceB:
            {
                normal = b2Math.MulMV(transformB.R, this.m_axis);
                pointB = b2Math.MulX(transformB, this.m_localPoint);
                axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                pointA = b2Math.MulX(transformA, localPointA);
                seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
                return seperation;
            }
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2SeparationFunction.e_points = 0x01;
        Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
        Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
    });
    b2Simplex.b2Simplex = function () {
        this.m_v1 = new b2SimplexVertex();
        this.m_v2 = new b2SimplexVertex();
        this.m_v3 = new b2SimplexVertex();
        this.m_vertices = new Vector(3);
    };
    b2Simplex.prototype.b2Simplex = function () {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3;
    }
    b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
        b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
        var wALocal;
        var wBLocal;
        this.m_count = cache.count;
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            wALocal = proxyA.GetVertex(v.indexA);
            wBLocal = proxyB.GetVertex(v.indexB);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            v.a = 0;
        }
        if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Box2D.MIN_VALUE) {
                this.m_count = 0;
            }
        }
        if (this.m_count == 0) {
            v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            wALocal = proxyA.GetVertex(0);
            wBLocal = proxyB.GetVertex(0);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            this.m_count = 1;
        }
    }
    b2Simplex.prototype.WriteCache = function (cache) {
        cache.metric = this.GetMetric();
        cache.count = Box2D.parseUInt(this.m_count);
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
            cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
        }
    }
    b2Simplex.prototype.GetSearchDirection = function () {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
            {
                var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
                var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
                if (sgn > 0.0) {
                    return b2Math.CrossFV(1.0, e12);
                }
                else {
                    return b2Math.CrossVF(e12, 1.0);
                }
            }
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetClosestPoint = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return new b2Vec2();
            case 1:
                return this.m_v1.w;
            case 2:
                return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                break;
            case 1:
                pA.SetV(this.m_v1.wA);
                pB.SetV(this.m_v1.wB);
                break;
            case 2:
                pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                b2Settings.b2Assert(false);
                break;
        }
    }
    b2Simplex.prototype.GetMetric = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return 0.0;
            case 1:
                return 0.0;
            case 2:
                return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    b2Simplex.prototype.Solve2 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
        if (d12_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        var d12_1 = (w2.x * e12.x + w2.y * e12.y);
        if (d12_1 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        var inv_d12 = 1.0 / (d12_1 + d12_2);
        this.m_v1.a = d12_1 * inv_d12;
        this.m_v2.a = d12_2 * inv_d12;
        this.m_count = 2;
    }
    b2Simplex.prototype.Solve3 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var w3 = this.m_v3.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var w1e12 = b2Math.Dot(w1, e12);
        var w2e12 = b2Math.Dot(w2, e12);
        var d12_1 = w2e12;
        var d12_2 = (-w1e12);
        var e13 = b2Math.SubtractVV(w3, w1);
        var w1e13 = b2Math.Dot(w1, e13);
        var w3e13 = b2Math.Dot(w3, e13);
        var d13_1 = w3e13;
        var d13_2 = (-w1e13);
        var e23 = b2Math.SubtractVV(w3, w2);
        var w2e23 = b2Math.Dot(w2, e23);
        var w3e23 = b2Math.Dot(w3, e23);
        var d23_1 = w3e23;
        var d23_2 = (-w2e23);
        var n123 = b2Math.CrossVV(e12, e13);
        var d123_1 = n123 * b2Math.CrossVV(w2, w3);
        var d123_2 = n123 * b2Math.CrossVV(w3, w1);
        var d123_3 = n123 * b2Math.CrossVV(w1, w2);
        if (d12_2 <= 0.0 && d13_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
            var inv_d12 = 1.0 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
            return;
        }
        if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
            var inv_d13 = 1.0 / (d13_1 + d13_2);
            this.m_v1.a = d13_1 * inv_d13;
            this.m_v3.a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v2.Set(this.m_v3);
            return;
        }
        if (d12_1 <= 0.0 && d23_2 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        if (d13_1 <= 0.0 && d23_1 <= 0.0) {
            this.m_v3.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v3);
            return;
        }
        if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
            var inv_d23 = 1.0 / (d23_1 + d23_2);
            this.m_v2.a = d23_1 * inv_d23;
            this.m_v3.a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v1.Set(this.m_v3);
            return;
        }
        var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
        this.m_v1.a = d123_1 * inv_d123;
        this.m_v2.a = d123_2 * inv_d123;
        this.m_v3.a = d123_3 * inv_d123;
        this.m_count = 3;
    }
    b2SimplexCache.b2SimplexCache = function () {
        this.indexA = new Vector_a2j_Number(3);
        this.indexB = new Vector_a2j_Number(3);
    };
    b2SimplexVertex.b2SimplexVertex = function () {};
    b2SimplexVertex.prototype.Set = function (other) {
        this.wA.SetV(other.wA);
        this.wB.SetV(other.wB);
        this.w.SetV(other.w);
        this.a = other.a;
        this.indexA = other.indexA;
        this.indexB = other.indexB;
    }
    b2TimeOfImpact.b2TimeOfImpact = function () {};
    b2TimeOfImpact.TimeOfImpact = function (input) {
        ++b2TimeOfImpact.b2_toiCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var sweepA = input.sweepA;
        var sweepB = input.sweepB;
        b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
        b2Settings.b2Assert(1.0 - sweepA.t0 > Box2D.MIN_VALUE);
        var radius = proxyA.m_radius + proxyB.m_radius;
        var tolerance = input.tolerance;
        var alpha = 0.0;
        var k_maxIterations = 1000;
        var iter = 0;
        var target = 0.0;
        b2TimeOfImpact.s_cache.count = 0;
        b2TimeOfImpact.s_distanceInput.useRadii = false;
        for (;;) {
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
            b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
            b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
            b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
            b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
            b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
            if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
                alpha = 1.0;
                break;
            }
            b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
            var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (separation <= 0.0) {
                alpha = 1.0;
                break;
            }
            if (iter == 0) {
                if (separation > radius) {
                    target = b2Math.Max(radius - tolerance, 0.75 * radius);
                }
                else {
                    target = b2Math.Max(separation - tolerance, 0.02 * radius);
                }
            }
            if (separation - target < 0.5 * tolerance) {
                if (iter == 0) {
                    alpha = 1.0;
                    break;
                }
                break;
            }
            var newAlpha = alpha; {
                var x1 = alpha;
                var x2 = 1.0;
                var f1 = separation;
                sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
                sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
                var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                if (f2 >= target) {
                    alpha = 1.0;
                    break;
                }
                var rootIterCount = 0;
                for (;;) {
                    var x = 0;
                    if (rootIterCount & 1) {
                        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
                    }
                    else {
                        x = 0.5 * (x1 + x2);
                    }
                    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
                    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
                    var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                    if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                        newAlpha = x;
                        break;
                    }
                    if (f > target) {
                        x1 = x;
                        f1 = f;
                    }
                    else {
                        x2 = x;
                        f2 = f;
                    }++rootIterCount;
                    ++b2TimeOfImpact.b2_toiRootIters;
                    if (rootIterCount == 50) {
                        break;
                    }
                }
                b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
            }
            if (newAlpha < (1.0 + 100.0 * Box2D.MIN_VALUE) * alpha) {
                break;
            }
            alpha = newAlpha;
            iter++;
            ++b2TimeOfImpact.b2_toiIters;
            if (iter == k_maxIterations) {
                break;
            }
        }
        b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
        return alpha;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
        Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
        Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
        Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
    });
    b2TOIInput.b2TOIInput = function () {
        this.proxyA = new b2DistanceProxy();
        this.proxyB = new b2DistanceProxy();
        this.sweepA = new b2Sweep();
        this.sweepB = new b2Sweep();
    };
    b2WorldManifold.b2WorldManifold = function () {
        this.m_normal = new b2Vec2();
    };
    b2WorldManifold.prototype.b2WorldManifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
        if (radiusA === undefined) radiusA = 0;
        if (radiusB === undefined) radiusB = 0;
        if (manifold.m_pointCount == 0) {
            return;
        }
        var i = 0;
        var tVec;
        var tMat;
        var normalX = 0;
        var normalY = 0;
        var planePointX = 0;
        var planePointY = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        switch (manifold.m_type) {
            case b2Manifold.e_circles:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_points[0].m_localPoint;
                var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1;
                    this.m_normal.y = 0;
                }
                var cAX = pointAX + radiusA * this.m_normal.x;
                var cAY = pointAY + radiusA * this.m_normal.y;
                var cBX = pointBX - radiusB * this.m_normal.x;
                var cBY = pointBY - radiusB * this.m_normal.y;
                this.m_points[0].x = 0.5 * (cAX + cBX);
                this.m_points[0].y = 0.5 * (cAY + cBY);
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = normalX;
                this.m_normal.y = normalY;
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfB.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = xfB.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_localPoint;
                planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = (-normalX);
                this.m_normal.y = (-normalY);
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfA.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
                }
            }
                break;
        }
    }
    ClipVertex.ClipVertex = function () {
        this.v = new b2Vec2();
        this.id = new b2ContactID();
    };
    ClipVertex.prototype.Set = function (other) {
        this.v.SetV(other.v);
        this.id.Set(other.id);
    }
    Features.Features = function () {};
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._referenceEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._referenceEdge = value;
            this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentEdge = value;
            this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentVertex;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentVertex = value;
            this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._flip;
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._flip = value;
            this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
        }
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
    b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2CircleShape.b2CircleShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.m_p = new b2Vec2();
    };
    b2CircleShape.prototype.Copy = function () {
        var s = new b2CircleShape();
        s.Set(this);
        return s;
    }
    b2CircleShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2CircleShape)) {
            var other2 = (other instanceof b2CircleShape ? other : null);
            this.m_p.SetV(other2.m_p);
        }
    }
    b2CircleShape.prototype.TestPoint = function (transform, p) {
        var tMat = transform.R;
        var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        dX = p.x - dX;
        dY = p.y - dY;
        return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
    }
    b2CircleShape.prototype.RayCast = function (output, input, transform) {
        var tMat = transform.R;
        var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        var sX = input.p1.x - positionX;
        var sY = input.p1.y - positionY;
        var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        var c = (sX * rX + sY * rY);
        var rr = (rX * rX + rY * rY);
        var sigma = c * c - rr * b;
        if (sigma < 0.0 || rr < Box2D.MIN_VALUE) {
            return false;
        }
        var a = (-(c + Math.sqrt(sigma)));
        if (0.0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            output.normal.x = sX + a * rX;
            output.normal.y = sY + a * rY;
            output.normal.Normalize();
            return true;
        }
        return false;
    }
    b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
        aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
    }
    b2CircleShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
        massData.center.SetV(this.m_p);
        massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
    }
    b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var p = b2Math.MulX(xf, this.m_p);
        var l = (-(b2Math.Dot(normal, p) - offset));
        if (l < (-this.m_radius) + Box2D.MIN_VALUE) {
            return 0;
        }
        if (l > this.m_radius) {
            c.SetV(p);
            return Math.PI * this.m_radius * this.m_radius;
        }
        var r2 = this.m_radius * this.m_radius;
        var l2 = l * l;
        var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
        var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
        c.x = p.x + normal.x * com;
        c.y = p.y + normal.y * com;
        return area;
    }
    b2CircleShape.prototype.GetLocalPosition = function () {
        return this.m_p;
    }
    b2CircleShape.prototype.SetLocalPosition = function (position) {
        this.m_p.SetV(position);
    }
    b2CircleShape.prototype.GetRadius = function () {
        return this.m_radius;
    }
    b2CircleShape.prototype.SetRadius = function (radius) {
        if (radius === undefined) radius = 0;
        this.m_radius = radius;
    }
    b2CircleShape.prototype.b2CircleShape = function (radius) {
        if (radius === undefined) radius = 0;
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_circleShape;
        this.m_radius = radius;
    }
    b2EdgeChainDef.b2EdgeChainDef = function () {};
    b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0;
        this.isALoop = true;
        this.vertices = [];
    }
    Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
    b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2EdgeShape.b2EdgeShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.s_supportVec = new b2Vec2();
        this.m_v1 = new b2Vec2();
        this.m_v2 = new b2Vec2();
        this.m_coreV1 = new b2Vec2();
        this.m_coreV2 = new b2Vec2();
        this.m_normal = new b2Vec2();
        this.m_direction = new b2Vec2();
        this.m_cornerDir1 = new b2Vec2();
        this.m_cornerDir2 = new b2Vec2();
    };
    b2EdgeShape.prototype.TestPoint = function (transform, p) {
        return false;
    }

    b2EdgeShape.prototype.Copy = function () {
        var s = new b2EdgeShape(this.m_v1, this.m_v2);
        s.Set(this);
        return s;
    }

    b2EdgeShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2EdgeShape)) {
            var other2 = (other instanceof b2EdgeShape ? other : null);
            this.s_supportVec.SetV(other2.s_supportVec);
            this.m_v1.SetV(other2.m_v1);
            this.m_v2.SetV(other2.m_v2);
            this.m_coreV1.SetV(other2.m_coreV1);
            this.m_coreV2.SetV(other2.m_coreV2);
            this.m_normal.SetV(other2.m_normal);
            this.m_direction.SetV(other2.m_direction);
            this.m_cornerDir1.SetV(other2.m_cornerDir1);
            this.m_cornerDir2.SetV(other2.m_cornerDir2);
        }
    }
    b2EdgeShape.prototype.RayCast = function (output, input, transform) {
        var tMat;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
        var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
        var k_slop = 100.0 * Box2D.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = input.p1.x - v1X;
            var bY = input.p1.y - v1Y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= input.maxFraction * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    output.fraction = a;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    output.normal.x = nX / nLen;
                    output.normal.y = nY / nLen;
                    return true;
                }
            }
        }
        return false;
    }
    b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
        var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
        if (v1X < v2X) {
            aabb.lowerBound.x = v1X;
            aabb.upperBound.x = v2X;
        }
        else {
            aabb.lowerBound.x = v2X;
            aabb.upperBound.x = v1X;
        }
        if (v1Y < v2Y) {
            aabb.lowerBound.y = v1Y;
            aabb.upperBound.y = v2Y;
        }
        else {
            aabb.lowerBound.y = v2Y;
            aabb.upperBound.y = v1Y;
        }
    }
    b2EdgeShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = 0;
        massData.center.SetV(this.m_v1);
        massData.I = 0;
    }
    b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
        var v1 = b2Math.MulX(xf, this.m_v1);
        var v2 = b2Math.MulX(xf, this.m_v2);
        var d1 = b2Math.Dot(normal, v1) - offset;
        var d2 = b2Math.Dot(normal, v2) - offset;
        if (d1 > 0) {
            if (d2 > 0) {
                return 0;
            }
            else {
                v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
        }
        else {
            if (d2 > 0) {
                v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
            else {}
        }
        c.x = (v0.x + v1.x + v2.x) / 3;
        c.y = (v0.y + v1.y + v2.y) / 3;
        return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
    }
    b2EdgeShape.prototype.GetLength = function () {
        return this.m_length;
    }
    b2EdgeShape.prototype.GetVertex1 = function () {
        return this.m_v1;
    }
    b2EdgeShape.prototype.GetVertex2 = function () {
        return this.m_v2;
    }
    b2EdgeShape.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1;
    }
    b2EdgeShape.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2;
    }
    b2EdgeShape.prototype.GetNormalVector = function () {
        return this.m_normal;
    }
    b2EdgeShape.prototype.GetDirectionVector = function () {
        return this.m_direction;
    }
    b2EdgeShape.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1;
    }
    b2EdgeShape.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2;
    }
    b2EdgeShape.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1;
    }
    b2EdgeShape.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2;
    }
    b2EdgeShape.prototype.GetFirstVertex = function (xf) {
        var tMat = xf.R;
        return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
    }
    b2EdgeShape.prototype.GetNextEdge = function () {
        return this.m_nextEdge;
    }
    b2EdgeShape.prototype.GetPrevEdge = function () {
        return this.m_prevEdge;
    }
    b2EdgeShape.prototype.Support = function (xf, dX, dY) {
        if (dX === undefined) dX = 0;
        if (dY === undefined) dY = 0;
        var tMat = xf.R;
        var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
        var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
        var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
        var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
        if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
            this.s_supportVec.x = v1X;
            this.s_supportVec.y = v1Y;
        }
        else {
            this.s_supportVec.x = v2X;
            this.s_supportVec.y = v2Y;
        }
        return this.s_supportVec;
    }
    b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_edgeShape;
        this.m_prevEdge = null;
        this.m_nextEdge = null;
        this.m_v1 = v1;
        this.m_v2 = v2;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
        this.m_length = this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
        this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
        this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
    }
    b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
        this.m_prevEdge = edge;
        this.m_coreV1 = core;
        this.m_cornerDir1 = cornerDir;
        this.m_cornerConvex1 = convex;
    }
    b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
        this.m_nextEdge = edge;
        this.m_coreV2 = core;
        this.m_cornerDir2 = cornerDir;
        this.m_cornerConvex2 = convex;
    }
    b2EdgeShape.prototype.Copy = function () {
        var s = new b2EdgeShape(this.m_v1, this.m_v2);

        return s;
    }
    b2MassData.b2MassData = function () {
        this.mass = 0.0;
        this.center = new b2Vec2(0, 0);
        this.I = 0.0;
    };
    Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
    b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2PolygonShape.b2PolygonShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
    };
    b2PolygonShape.prototype.Copy = function () {
        var s = new b2PolygonShape();
        s.Set(this);
        return s;
    }
    b2PolygonShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2PolygonShape)) {
            var other2 = (other instanceof b2PolygonShape ? other : null);
            this.m_centroid.SetV(other2.m_centroid);
            this.m_vertexCount = other2.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var i = 0; i < this.m_vertexCount; i++) {
                this.m_vertices[i].SetV(other2.m_vertices[i]);
                this.m_normals[i].SetV(other2.m_normals[i]);
            }
        }
    }
    b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var v = new Vector();
        var i = 0,
            tVec;
        for (i = 0;
             i < vertices.length; ++i) {
            tVec = vertices[i];
            v.push(tVec);
        }
        this.SetAsVector(v, vertexCount);
    }
    b2PolygonShape.AsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsArray(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        if (vertexCount == 0) vertexCount = vertices.length;
        b2Settings.b2Assert(2 <= vertexCount);
        this.m_vertexCount = vertexCount;
        this.Reserve(vertexCount);
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(vertices[i]);
        }
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            var i1 = parseInt(i);
            var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
            var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
            b2Settings.b2Assert(edge.LengthSquared() > Box2D.MIN_VALUE);
            this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
            this.m_normals[i].Normalize();
        }
        this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
    }
    b2PolygonShape.AsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsVector(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid.SetZero();
    }
    b2PolygonShape.AsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsBox(hx, hy);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid = center;
        var xf = new b2Transform();
        xf.position = center;
        xf.R.Set(angle);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
            this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
        }
    }
    b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsOrientedBox(hx, hy, center, angle);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(v1);
        this.m_vertices[1].SetV(v2);
        this.m_centroid.x = 0.5 * (v1.x + v2.x);
        this.m_centroid.y = 0.5 * (v1.y + v2.y);
        this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = (-this.m_normals[0].x);
        this.m_normals[1].y = (-this.m_normals[0].y);
    }
    b2PolygonShape.AsEdge = function (v1, v2) {
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsEdge(v1, v2);
        return polygonShape;
    }
    b2PolygonShape.prototype.TestPoint = function (xf, p) {
        var tVec;
        var tMat = xf.R;
        var tX = p.x - xf.position.x;
        var tY = p.y - xf.position.y;
        var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
        var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = pLocalX - tVec.x;
            tY = pLocalY - tVec.y;
            tVec = this.m_normals[i];
            var dot = (tVec.x * tX + tVec.y * tY);
            if (dot > 0.0) {
                return false;
            }
        }
        return true;
    }
    b2PolygonShape.prototype.RayCast = function (output, input, transform) {
        var lower = 0.0;
        var upper = input.maxFraction;
        var tX = 0;
        var tY = 0;
        var tMat;
        var tVec;
        tX = input.p1.x - transform.position.x;
        tY = input.p1.y - transform.position.y;
        tMat = transform.R;
        var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        tX = input.p2.x - transform.position.x;
        tY = input.p2.y - transform.position.y;
        tMat = transform.R;
        var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var index = parseInt((-1));
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = tVec.x - p1X;
            tY = tVec.y - p1Y;
            tVec = this.m_normals[i];
            var numerator = (tVec.x * tX + tVec.y * tY);
            var denominator = (tVec.x * dX + tVec.y * dY);
            if (denominator == 0.0) {
                if (numerator < 0.0) {
                    return false;
                }
            }
            else {
                if (denominator < 0.0 && numerator < lower * denominator) {
                    lower = numerator / denominator;
                    index = i;
                }
                else if (denominator > 0.0 && numerator < upper * denominator) {
                    upper = numerator / denominator;
                }
            }
            if (upper < lower - Box2D.MIN_VALUE) {
                return false;
            }
        }
        if (index >= 0) {
            output.fraction = lower;
            tMat = transform.R;
            tVec = this.m_normals[index];
            output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            return true;
        }
        return false;
    }
    b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
        var tMat = xf.R;
        var tVec = this.m_vertices[0];
        var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var upperX = lowerX;
        var upperY = lowerY;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            lowerX = lowerX < vX ? lowerX : vX;
            lowerY = lowerY < vY ? lowerY : vY;
            upperX = upperX > vX ? upperX : vX;
            upperY = upperY > vY ? upperY : vY;
        }
        aabb.lowerBound.x = lowerX - this.m_radius;
        aabb.lowerBound.y = lowerY - this.m_radius;
        aabb.upperBound.x = upperX + this.m_radius;
        aabb.upperBound.y = upperY + this.m_radius;
    }
    b2PolygonShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        if (this.m_vertexCount == 2) {
            massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
            massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
            massData.mass = 0.0;
            massData.I = 0.0;
            return;
        }
        var centerX = 0.0;
        var centerY = 0.0;
        var area = 0.0;
        var I = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var k_inv3 = 1.0 / 3.0;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            var p2 = this.m_vertices[i];
            var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = e1X * e2Y - e1Y * e2X;
            var triangleArea = 0.5 * D;area += triangleArea;
            centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
            centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
            var px = p1X;
            var py = p1Y;
            var ex1 = e1X;
            var ey1 = e1Y;
            var ex2 = e2X;
            var ey2 = e2Y;
            var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
            var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
        }
        massData.mass = density * area;
        centerX *= 1.0 / area;
        centerY *= 1.0 / area;
        massData.center.Set(centerX, centerY);
        massData.I = density * I;
    }
    b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var normalL = b2Math.MulTMV(xf.R, normal);
        var offsetL = offset - b2Math.Dot(normal, xf.position);
        var depths = new Vector_a2j_Number();
        var diveCount = 0;
        var intoIndex = parseInt((-1));
        var outoIndex = parseInt((-1));
        var lastSubmerged = false;
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
            var isSubmerged = depths[i] < (-Box2D.MIN_VALUE);
            if (i > 0) {
                if (isSubmerged) {
                    if (!lastSubmerged) {
                        intoIndex = i - 1;
                        diveCount++;
                    }
                }
                else {
                    if (lastSubmerged) {
                        outoIndex = i - 1;
                        diveCount++;
                    }
                }
            }
            lastSubmerged = isSubmerged;
        }
        switch (diveCount) {
            case 0:
                if (lastSubmerged) {
                    var md = new b2MassData();
                    this.ComputeMass(md, 1);
                    c.SetV(b2Math.MulX(xf, md.center));
                    return md.mass;
                }
                else {
                    return 0;
                }
                break;
            case 1:
                if (intoIndex == (-1)) {
                    intoIndex = this.m_vertexCount - 1;
                }
                else {
                    outoIndex = this.m_vertexCount - 1;
                }
                break;
        }
        var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
        var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
        var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
        var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
        var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
        var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
        var area = 0;
        var center = new b2Vec2();
        var p2 = this.m_vertices[intoIndex2];
        var p3;
        i = intoIndex2;
        while (i != outoIndex2) {
            i = (i + 1) % this.m_vertexCount;
            if (i == outoIndex2) p3 = outoVec;
            else p3 = this.m_vertices[i];
            var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
            area += triangleArea;
            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
            p2 = p3;
        }
        center.Multiply(1 / area);
        c.SetV(b2Math.MulX(xf, center));
        return area;
    }
    b2PolygonShape.prototype.GetVertexCount = function () {
        return this.m_vertexCount;
    }
    b2PolygonShape.prototype.GetVertices = function () {
        return this.m_vertices;
    }
    b2PolygonShape.prototype.GetNormals = function () {
        return this.m_normals;
    }
    b2PolygonShape.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2PolygonShape.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2PolygonShape.prototype.Validate = function () {
        return false;
    }
    b2PolygonShape.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_polygonShape;
        this.m_centroid = new b2Vec2();
        this.m_vertices = new Vector();
        this.m_normals = new Vector();
    }
    b2PolygonShape.prototype.Reserve = function (count) {
        if (count === undefined) count = 0;
        for (var i = parseInt(this.m_vertices.length); i < count; i++) {
            this.m_vertices[i] = new b2Vec2();
            this.m_normals[i] = new b2Vec2();
        }
    }
    b2PolygonShape.ComputeCentroid = function (vs, count) {
        if (count === undefined) count = 0;
        var c = new b2Vec2();
        var area = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var inv3 = 1.0 / 3.0;
        for (var i = 0; i < count; ++i) {
            var p2 = vs[i];
            var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = (e1X * e2Y - e1Y * e2X);
            var triangleArea = 0.5 * D;area += triangleArea;
            c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
            c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
        }
        c.x *= 1.0 / area;
        c.y *= 1.0 / area;
        return c;
    }
    b2PolygonShape.ComputeOBB = function (obb, vs, count) {
        if (count === undefined) count = 0;
        var i = 0;
        var p = new Vector(count + 1);
        for (i = 0;
             i < count; ++i) {
            p[i] = vs[i];
        }
        p[count] = p[0];
        var minArea = Number.MAX_VALUE;
        for (i = 1;
             i <= count; ++i) {
            var root = p[parseInt(i - 1)];
            var uxX = p[i].x - root.x;
            var uxY = p[i].y - root.y;
            var length = Math.sqrt(uxX * uxX + uxY * uxY);
            uxX /= length;
            uxY /= length;
            var uyX = (-uxY);
            var uyY = uxX;
            var lowerX = Number.MAX_VALUE;
            var lowerY = Number.MAX_VALUE;
            var upperX = (-Number.MAX_VALUE);
            var upperY = (-Number.MAX_VALUE);
            for (var j = 0; j < count; ++j) {
                var dX = p[j].x - root.x;
                var dY = p[j].y - root.y;
                var rX = (uxX * dX + uxY * dY);
                var rY = (uyX * dX + uyY * dY);
                if (rX < lowerX) lowerX = rX;
                if (rY < lowerY) lowerY = rY;
                if (rX > upperX) upperX = rX;
                if (rY > upperY) upperY = rY;
            }
            var area = (upperX - lowerX) * (upperY - lowerY);
            if (area < 0.95 * minArea) {
                minArea = area;
                obb.R.col1.x = uxX;
                obb.R.col1.y = uxY;
                obb.R.col2.x = uyX;
                obb.R.col2.y = uyY;
                var centerX = 0.5 * (lowerX + upperX);
                var centerY = 0.5 * (lowerY + upperY);
                var tMat = obb.R;
                obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
                obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
                obb.extents.x = 0.5 * (upperX - lowerX);
                obb.extents.y = 0.5 * (upperY - lowerY);
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
    });
    b2Shape.b2Shape = function () {};
    b2Shape.prototype.Copy = function () {
        return null;
    }
    b2Shape.prototype.Set = function (other) {
        this.m_radius = other.m_radius;
    }
    b2Shape.prototype.GetType = function () {
        return this.m_type;
    }
    b2Shape.prototype.TestPoint = function (xf, p) {
        return false;
    }
    b2Shape.prototype.RayCast = function (output, input, transform) {
        return false;
    }
    b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
    b2Shape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
    }
    b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        return 0;
    }
    b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
        var input = new b2DistanceInput();
        input.proxyA = new b2DistanceProxy();
        input.proxyA.Set(shape1);
        input.proxyB = new b2DistanceProxy();
        input.proxyB.Set(shape2);
        input.transformA = transform1;
        input.transformB = transform2;
        input.useRadii = true;
        var simplexCache = new b2SimplexCache();
        simplexCache.count = 0;
        var output = new b2DistanceOutput();
        b2Distance.Distance(output, simplexCache, input);
        return output.distance < 10.0 * Box2D.MIN_VALUE;
    }
    b2Shape.prototype.b2Shape = function () {
        this.m_type = b2Shape.e_unknownShape;
        this.m_radius = b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
        Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
        Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
        Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
        Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
        Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
        Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
        Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Color.b2Color = function () {
        this._r = 0;
        this._g = 0;
        this._b = 0;
    };
    b2Color.prototype.b2Color = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    b2Color.prototype.Set = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    Object.defineProperty(b2Color.prototype, 'r', {
        enumerable: false,
        configurable: true,
        set: function (rr) {
            if (rr === undefined) rr = 0;
            this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'g', {
        enumerable: false,
        configurable: true,
        set: function (gg) {
            if (gg === undefined) gg = 0;
            this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'b', {
        enumerable: false,
        configurable: true,
        set: function (bb) {
            if (bb === undefined) bb = 0;
            this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'color', {
        enumerable: false,
        configurable: true,
        get: function () {
            return (this._r << 16) | (this._g << 8) | (this._b);
        }
    });
    b2Settings.b2Settings = function () {};
    b2Settings.b2MixFriction = function (friction1, friction2) {
        if (friction1 === undefined) friction1 = 0;
        if (friction2 === undefined) friction2 = 0;
        return Math.sqrt(friction1 * friction2);
    }
    b2Settings.b2MixRestitution = function (restitution1, restitution2) {
        if (restitution1 === undefined) restitution1 = 0;
        if (restitution2 === undefined) restitution2 = 0;
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
    b2Settings.b2Assert = function (a) {
        if (!a) {
            throw "Assertion Failed";
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.b2Settings.VERSION = "2.1alpha";
        Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
        Box2D.Common.b2Settings.b2_pi = Math.PI;
        Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
        Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
        Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
        Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_linearSlop = 0.005;
        Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
        Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
        Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
        Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
        Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
        Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
        Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
        Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
        Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
        Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
        Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
    });
})();
(function () {
    var b2AABB = Box2D.Collision.b2AABB,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Mat22.b2Mat22 = function () {
        this.col1 = new b2Vec2();
        this.col2 = new b2Vec2();
    };
    b2Mat22.prototype.b2Mat22 = function () {
        this.SetIdentity();
    }
    b2Mat22.FromAngle = function (angle) {
        if (angle === undefined) angle = 0;
        var mat = new b2Mat22();
        mat.Set(angle);
        return mat;
    }
    b2Mat22.FromVV = function (c1, c2) {
        var mat = new b2Mat22();
        mat.SetVV(c1, c2);
        return mat;
    }
    b2Mat22.prototype.Set = function (angle) {
        if (angle === undefined) angle = 0;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.col1.x = c;
        this.col2.x = (-s);
        this.col1.y = s;
        this.col2.y = c;
    }
    b2Mat22.prototype.SetVV = function (c1, c2) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
    }
    b2Mat22.prototype.Copy = function () {
        var mat = new b2Mat22();
        mat.SetM(this);
        return mat;
    }
    b2Mat22.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
    }
    b2Mat22.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
    }
    b2Mat22.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
    }
    b2Mat22.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
    }
    b2Mat22.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x);
    }
    b2Mat22.prototype.GetInverse = function (out) {
        var a = this.col1.x;
        var b = this.col2.x;
        var c = this.col1.y;
        var d = this.col2.y;
        var det = a * d - b * c;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.col1.x = det * d;
        out.col2.x = (-det * b);
        out.col1.y = (-det * c);
        out.col2.y = det * a;
        return out;
    }
    b2Mat22.prototype.Solve = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat22.prototype.Abs = function () {
        this.col1.Abs();
        this.col2.Abs();
    }
    b2Mat33.b2Mat33 = function () {
        this.col1 = new b2Vec3();
        this.col2 = new b2Vec3();
        this.col3 = new b2Vec3();
    };
    b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
        if (c1 === undefined) c1 = null;
        if (c2 === undefined) c2 = null;
        if (c3 === undefined) c3 = null;
        if (!c1 && !c2 && !c3) {
            this.col1.SetZero();
            this.col2.SetZero();
            this.col3.SetZero();
        }
        else {
            this.col1.SetV(c1);
            this.col2.SetV(c2);
            this.col3.SetV(c3);
        }
    }
    b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
        this.col3.SetV(c3);
    }
    b2Mat33.prototype.Copy = function () {
        return new b2Mat33(this.col1, this.col2, this.col3);
    }
    b2Mat33.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
        this.col3.SetV(m.col3);
    }
    b2Mat33.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col1.z += m.col1.z;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
        this.col2.z += m.col2.z;
        this.col3.x += m.col3.x;
        this.col3.y += m.col3.y;
        this.col3.z += m.col3.z;
    }
    b2Mat33.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 1.0;
    }
    b2Mat33.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 0.0;
    }
    b2Mat33.prototype.Solve22 = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        if (bZ === undefined) bZ = 0;
        var a11 = this.col1.x;
        var a21 = this.col1.y;
        var a31 = this.col1.z;
        var a12 = this.col2.x;
        var a22 = this.col2.y;
        var a32 = this.col2.z;
        var a13 = this.col3.x;
        var a23 = this.col3.y;
        var a33 = this.col3.z;
        var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
        out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
        out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
        return out;
    }
    b2Math.b2Math = function () {};
    b2Math.IsValid = function (x) {
        if (x === undefined) x = 0;
        return isFinite(x);
    }
    b2Math.Dot = function (a, b) {
        return a.x * b.x + a.y * b.y;
    }
    b2Math.CrossVV = function (a, b) {
        return a.x * b.y - a.y * b.x;
    }
    b2Math.CrossVF = function (a, s) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.y, (-s * a.x));
        return v;
    }
    b2Math.CrossFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2((-s * a.y), s * a.x);
        return v;
    }
    b2Math.MulMV = function (A, v) {
        var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
        return u;
    }
    b2Math.MulTMV = function (A, v) {
        var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
        return u;
    }
    b2Math.MulX = function (T, v) {
        var a = b2Math.MulMV(T.R, v);
        a.x += T.position.x;
        a.y += T.position.y;
        return a;
    }
    b2Math.MulXT = function (T, v) {
        var a = b2Math.SubtractVV(v, T.position);
        var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
        a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
        a.x = tX;
        return a;
    }
    b2Math.AddVV = function (a, b) {
        var v = new b2Vec2(a.x + b.x, a.y + b.y);
        return v;
    }
    b2Math.SubtractVV = function (a, b) {
        var v = new b2Vec2(a.x - b.x, a.y - b.y);
        return v;
    }
    b2Math.Distance = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return Math.sqrt(cX * cX + cY * cY);
    }
    b2Math.DistanceSquared = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return (cX * cX + cY * cY);
    }
    b2Math.MulFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.x, s * a.y);
        return v;
    }
    b2Math.AddMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
        return C;
    }
    b2Math.MulMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
        return C;
    }
    b2Math.MulTMM = function (A, B) {
        var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
        var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
        var C = b2Mat22.FromVV(c1, c2);
        return C;
    }
    b2Math.Abs = function (a) {
        if (a === undefined) a = 0;
        return a > 0.0 ? a : (-a);
    }
    b2Math.AbsV = function (a) {
        var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
        return b;
    }
    b2Math.AbsM = function (A) {
        var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
        return B;
    }
    b2Math.Min = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a < b ? a : b;
    }
    b2Math.MinV = function (a, b) {
        var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
        return c;
    }
    b2Math.Max = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a > b ? a : b;
    }
    b2Math.MaxV = function (a, b) {
        var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
        return c;
    }
    b2Math.Clamp = function (a, low, high) {
        if (a === undefined) a = 0;
        if (low === undefined) low = 0;
        if (high === undefined) high = 0;
        return a < low ? low : a > high ? high : a;
    }
    b2Math.ClampV = function (a, low, high) {
        return b2Math.MaxV(low, b2Math.MinV(a, high));
    }
    b2Math.Swap = function (a, b) {
        var tmp = a[0];
        a[0] = b[0];
        b[0] = tmp;
    }
    b2Math.Random = function () {
        return Math.random() * 2 - 1;
    }
    b2Math.RandomRange = function (lo, hi) {
        if (lo === undefined) lo = 0;
        if (hi === undefined) hi = 0;
        var r = Math.random();
        r = (hi - lo) * r + lo;
        return r;
    }
    b2Math.NextPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        x |= (x >> 1) & 0x7FFFFFFF;
        x |= (x >> 2) & 0x3FFFFFFF;
        x |= (x >> 4) & 0x0FFFFFFF;
        x |= (x >> 8) & 0x00FFFFFF;
        x |= (x >> 16) & 0x0000FFFF;
        return x + 1;
    }
    b2Math.IsPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        var result = x > 0 && (x & (x - 1)) == 0;
        return result;
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
        Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
        Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
    });
    b2Sweep.b2Sweep = function () {
        this.localCenter = new b2Vec2();
        this.c0 = new b2Vec2;
        this.c = new b2Vec2();
    };
    b2Sweep.prototype.Set = function (other) {
        this.localCenter.SetV(other.localCenter);
        this.c0.SetV(other.c0);
        this.c.SetV(other.c);
        this.a0 = other.a0;
        this.a = other.a;
        this.t0 = other.t0;
    }
    b2Sweep.prototype.Copy = function () {
        var copy = new b2Sweep();
        copy.localCenter.SetV(this.localCenter);
        copy.c0.SetV(this.c0);
        copy.c.SetV(this.c);
        copy.a0 = this.a0;
        copy.a = this.a;
        copy.t0 = this.t0;
        return copy;
    }
    b2Sweep.prototype.GetTransform = function (xf, alpha) {
        if (alpha === undefined) alpha = 0;
        xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
        xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
        var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
        xf.R.Set(angle);
        var tMat = xf.R;
        xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
        xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
    }
    b2Sweep.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        if (this.t0 < t && 1.0 - this.t0 > Box2D.MIN_VALUE) {
            var alpha = (t - this.t0) / (1.0 - this.t0);
            this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
            this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
            this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
            this.t0 = t;
        }
    }
    b2Transform.b2Transform = function () {
        this.position = new b2Vec2;
        this.R = new b2Mat22();
    };
    b2Transform.prototype.b2Transform = function (pos, r) {
        if (pos === undefined) pos = null;
        if (r === undefined) r = null;
        if (pos) {
            this.position.SetV(pos);
            this.R.SetM(r);
        }
    }
    b2Transform.prototype.Initialize = function (pos, r) {
        this.position.SetV(pos);
        this.R.SetM(r);
    }
    b2Transform.prototype.SetIdentity = function () {
        this.position.SetZero();
        this.R.SetIdentity();
    }
    b2Transform.prototype.Set = function (x) {
        this.position.SetV(x.position);
        this.R.SetM(x.R);
    }
    b2Transform.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x);
    }
    b2Vec2.b2Vec2 = function () {};
    b2Vec2.prototype.b2Vec2 = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetZero = function () {
        this.x = 0.0;
        this.y = 0.0;
    }
    b2Vec2.prototype.Set = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
    }
    b2Vec2.prototype.GetNegative = function () {
        return new b2Vec2((-this.x), (-this.y));
    }
    b2Vec2.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
    }
    b2Vec2.Make = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        return new b2Vec2(x_, y_);
    }
    b2Vec2.prototype.Copy = function () {
        return new b2Vec2(this.x, this.y);
    }
    b2Vec2.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
    }
    b2Vec2.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
    }
    b2Vec2.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
    }
    b2Vec2.prototype.MulM = function (A) {
        var tX = this.x;
        this.x = A.col1.x * tX + A.col2.x * this.y;
        this.y = A.col1.y * tX + A.col2.y * this.y;
    }
    b2Vec2.prototype.MulTM = function (A) {
        var tX = b2Math.Dot(this, A.col1);
        this.y = b2Math.Dot(this, A.col2);
        this.x = tX;
    }
    b2Vec2.prototype.CrossVF = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = s * this.y;
        this.y = (-s * tX);
    }
    b2Vec2.prototype.CrossFV = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = (-s * this.y);
        this.y = s * tX;
    }
    b2Vec2.prototype.MinV = function (b) {
        this.x = this.x < b.x ? this.x : b.x;
        this.y = this.y < b.y ? this.y : b.y;
    }
    b2Vec2.prototype.MaxV = function (b) {
        this.x = this.x > b.x ? this.x : b.x;
        this.y = this.y > b.y ? this.y : b.y;
    }
    b2Vec2.prototype.Abs = function () {
        if (this.x < 0) this.x = (-this.x);
        if (this.y < 0) this.y = (-this.y);
    }
    b2Vec2.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.LengthSquared = function () {
        return (this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.Normalize = function () {
        var length = Math.sqrt(this.x * this.x + this.y * this.y);
        if (length < Box2D.MIN_VALUE) {
            return 0.0;
        }
        var invLength = 1.0 / length;
        this.x *= invLength;
        this.y *= invLength;
        return length;
    }
    b2Vec2.prototype.IsValid = function () {
        return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
    }
    b2Vec3.b2Vec3 = function () {};
    b2Vec3.prototype.b2Vec3 = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetZero = function () {
        this.x = this.y = this.z = 0.0;
    }
    b2Vec3.prototype.Set = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
    }
    b2Vec3.prototype.GetNegative = function () {
        return new b2Vec3((-this.x), (-this.y), (-this.z));
    }
    b2Vec3.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
        this.z = (-this.z);
    }
    b2Vec3.prototype.Copy = function () {
        return new b2Vec3(this.x, this.y, this.z);
    }
    b2Vec3.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
    }
    b2Vec3.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
    }
    b2Vec3.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
        this.z *= a;
    }
})();
(function () {
    var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

    b2Body.b2Body = function () {
        this.m_xf = new b2Transform();
        this.m_sweep = new b2Sweep();
        this.m_linearVelocity = new b2Vec2();
        this.m_force = new b2Vec2();
    };
    
    b2Body.prototype.modifyGravity = function (gravity) {
    	return gravity;
    }

    b2Body.prototype.connectEdges = function (s1, s2, angle1) {
        if (angle1 === undefined) angle1 = 0;
        var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
        var coreOffset = Math.tan((angle2 - angle1) * 0.5);
        var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
        core = b2Math.SubtractVV(core, s2.GetNormalVector());
        core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
        core = b2Math.AddVV(core, s2.GetVertex1());
        var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
        cornerDir.Normalize();
        var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
        s1.SetNextEdge(s2, core, cornerDir, convex);
        s2.SetPrevEdge(s1, core, cornerDir, convex);
        return angle2;
    }
    b2Body.prototype.CreateFixture = function (def) {
        if (this.m_world.IsLocked() == true) {
            return null;
        }
        var fixture = new b2Fixture();
        fixture.Create(this, this.m_xf, def);
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.CreateProxy(broadPhase, this.m_xf);
        }
        fixture.m_next = this.m_fixtureList;
        this.m_fixtureList = fixture;
        ++this.m_fixtureCount;
        fixture.m_body = this;
        if (fixture.m_density > 0.0) {
            this.ResetMassData();
        }
        this.m_world.m_flags |= b2World.e_newFixture;
        return fixture;
    }
    b2Body.prototype.CreateFixture2 = function (shape, density) {
        if (density === undefined) density = 0.0;
        var def = new b2FixtureDef();
        def.shape = shape;
        def.density = density;
        return this.CreateFixture(def);
    }
    b2Body.prototype.DestroyFixture = function (fixture) {
        if (this.m_world.IsLocked() == true) {
            return;
        }
        var node = this.m_fixtureList;
        var ppF = null;
        var found = false;
        while (node != null) {
            if (node == fixture) {
                if (ppF) ppF.m_next = fixture.m_next;
                else this.m_fixtureList = fixture.m_next;
                found = true;
                break;
            }
            ppF = node;
            node = node.m_next;
        }
        var edge = this.m_contactList;
        while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            if (fixture == fixtureA || fixture == fixtureB) {
                this.m_world.m_contactManager.Destroy(c);
            }
        }
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.DestroyProxy(broadPhase);
        }
        else {}
        fixture.Destroy();
        fixture.m_body = null;
        fixture.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData();
    }
    b2Body.prototype.SetPositionAndAngle = function (position, angle) {
        if (angle === undefined) angle = 0;
        var f;
        if (this.m_world.IsLocked() == true) {
            return;
        }
        this.m_xf.R.Set(angle);
        this.m_xf.position.SetV(position);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_sweep.a0 = this.m_sweep.a = angle;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, this.m_xf, this.m_xf);
        }
        this.m_world.m_contactManager.FindNewContacts();
    }
    b2Body.prototype.SetTransform = function (xf) {
        this.SetPositionAndAngle(xf.position, xf.GetAngle());
    }
    b2Body.prototype.GetTransform = function () {
        return this.m_xf;
    }
    b2Body.prototype.GetPosition = function () {
        return this.m_xf.position;
    }
    b2Body.prototype.SetPosition = function (position) {
        this.SetPositionAndAngle(position, this.GetAngle());
    }
    b2Body.prototype.GetAngle = function () {
        return this.m_sweep.a;
    }
    b2Body.prototype.SetAngle = function (angle) {
        if (angle === undefined) angle = 0;
        this.SetPositionAndAngle(this.GetPosition(), angle);
    }
    b2Body.prototype.GetWorldCenter = function () {
        return this.m_sweep.c;
    }
    b2Body.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter;
    }
    b2Body.prototype.SetLinearVelocity = function (v) {
        if (this.m_type == b2Body.b2_staticBody) {
        	alert("Static body not support SetLinearVelocity");
            return;
        }
        this.m_linearVelocity.SetV(v);
    }
    b2Body.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity;
    }
    b2Body.prototype.SetAngularVelocity = function (omega) {
        if (omega === undefined) omega = 0;
        if (this.m_type == b2Body.b2_staticBody) {
        	alert("Static body not support SetAngularVelocity");
            return;
        }
        this.m_angularVelocity = omega;
    }
    b2Body.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity;
    }
    b2Body.prototype.GetDefinition = function () {
        var bd = new b2BodyDef();
        bd.type = this.GetType();
        bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
        bd.angle = this.GetAngle();
        bd.angularDamping = this.m_angularDamping;
        bd.angularVelocity = this.m_angularVelocity;
        bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
        bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
        bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
        bd.linearDamping = this.m_linearDamping;
        bd.linearVelocity.SetV(this.GetLinearVelocity());
        bd.position = this.GetPosition();
        bd.userData = this.GetUserData();
        return bd;
    }
    b2Body.prototype.ApplyForce = function (force, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_force.x += force.x;
        this.m_force.y += force.y;
        this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
    }
    b2Body.prototype.ApplyTorque = function (torque) {
        if (torque === undefined) torque = 0;
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_torque += torque;
    }
    b2Body.prototype.ApplyImpulse = function (impulse, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_linearVelocity.x += this.m_invMass * impulse.x;
        this.m_linearVelocity.y += this.m_invMass * impulse.y;
        this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
    }
    b2Body.prototype.Split = function (callback) {
        var linearVelocity = this.GetLinearVelocity().Copy();
        var angularVelocity = this.GetAngularVelocity();
        var center = this.GetWorldCenter();
        var body1 = this;
        var body2 = this.m_world.CreateBody(this.GetDefinition());
        var prev;
        for (var f = body1.m_fixtureList; f;) {
            if (callback(f)) {
                var next = f.m_next;
                if (prev) {
                    prev.m_next = next;
                }
                else {
                    body1.m_fixtureList = next;
                }
                body1.m_fixtureCount--;
                f.m_next = body2.m_fixtureList;
                body2.m_fixtureList = f;
                body2.m_fixtureCount++;
                f.m_body = body2;
                f = next;
            }
            else {
                prev = f;
                f = f.m_next;
            }
        }
        body1.ResetMassData();
        body2.ResetMassData();
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
        var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
        body1.SetLinearVelocity(velocity1);
        body2.SetLinearVelocity(velocity2);
        body1.SetAngularVelocity(angularVelocity);
        body2.SetAngularVelocity(angularVelocity);
        body1.SynchronizeFixtures();
        body2.SynchronizeFixtures();
        return body2;
    }
    b2Body.prototype.Merge = function (other) {
        var f;
        for (f = other.m_fixtureList;
             f;) {
            var next = f.m_next;
            other.m_fixtureCount--;
            f.m_next = this.m_fixtureList;
            this.m_fixtureList = f;
            this.m_fixtureCount++;
            f.m_body = body2;
            f = next;
        }
        body1.m_fixtureCount = 0;
        var body1 = this;
        var body2 = other;
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = body1.GetLinearVelocity().Copy();
        var velocity2 = body2.GetLinearVelocity().Copy();
        var angular1 = body1.GetAngularVelocity();
        var angular = body2.GetAngularVelocity();
        body1.ResetMassData();
        this.SynchronizeFixtures();
    }
    b2Body.prototype.GetMass = function () {
        return this.m_mass;
    }
    b2Body.prototype.GetInertia = function () {
        return this.m_I;
    }
    b2Body.prototype.GetMassData = function (data) {
        data.mass = this.m_mass;
        data.I = this.m_I;
        data.center.SetV(this.m_sweep.localCenter);
    }
    b2Body.prototype.SetMassData = function (massData) {
        b2Settings.b2Assert(this.m_world.IsLocked() == false);
        if (this.m_world.IsLocked() == true) {
            return;
        }
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_mass = massData.mass;
        if (this.m_mass <= 0.0) {
            this.m_mass = 1.0;
        }
        this.m_invMass = 1.0 / this.m_mass;
        if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
            this.m_invI = 1.0 / this.m_I;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(massData.center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.ResetMassData = function () {
        this.m_mass = 0.0;
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
            return;
        }
        var center = b2Vec2.Make(0, 0);
        for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (f.m_density == 0.0) {
                continue;
            }
            var massData = f.GetMassData();
            this.m_mass += massData.mass;
            center.x += massData.center.x * massData.mass;
            center.y += massData.center.y * massData.mass;
            this.m_I += massData.I;
        }
        if (this.m_mass > 0.0) {
            this.m_invMass = 1.0 / this.m_mass;
            center.x *= this.m_invMass;
            center.y *= this.m_invMass;
        }
        else {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
            this.m_I *= this.m_inertiaScale;
            b2Settings.b2Assert(this.m_I > 0);
            this.m_invI = 1.0 / this.m_I;
        }
        else {
            this.m_I = 0.0;
            this.m_invI = 0.0;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.GetWorldPoint = function (localPoint) {
        var A = this.m_xf.R;
        var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        u.x += this.m_xf.position.x;
        u.y += this.m_xf.position.y;
        return u;
    }
    b2Body.prototype.GetWorldVector = function (localVector) {
        return b2Math.MulMV(this.m_xf.R, localVector);
    }
    b2Body.prototype.GetLocalPoint = function (worldPoint) {
        return b2Math.MulXT(this.m_xf, worldPoint);
    }
    b2Body.prototype.GetLocalVector = function (worldVector) {
        return b2Math.MulTMV(this.m_xf.R, worldVector);
    }
    b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
        var A = this.m_xf.R;
        var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        worldPoint.x += this.m_xf.position.x;
        worldPoint.y += this.m_xf.position.y;
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearDamping = function () {
        return this.m_linearDamping;
    }
    b2Body.prototype.SetLinearDamping = function (linearDamping) {
        if (linearDamping === undefined) linearDamping = 0;
        this.m_linearDamping = linearDamping;
    }
    b2Body.prototype.GetAngularDamping = function () {
        return this.m_angularDamping;
    }
    b2Body.prototype.SetAngularDamping = function (angularDamping) {
        if (angularDamping === undefined) angularDamping = 0;
        this.m_angularDamping = angularDamping;
    }
    b2Body.prototype.SetType = function (type) {
        if (type === undefined) type = 0;
        if (this.m_type == type) {
            return;
        }
        this.m_type = type;
        this.ResetMassData();
        if (this.m_type == b2Body.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
        }
        this.SetAwake(true);
        this.m_force.SetZero();
        this.m_torque = 0.0;
        for (var ce = this.m_contactList; ce; ce = ce.next) {
            ce.contact.FlagForFiltering();
        }
    }
    b2Body.prototype.GetType = function () {
        return this.m_type;
    }
    b2Body.prototype.SetBullet = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_bulletFlag;
        }
    }
    b2Body.prototype.IsBullet = function () {
        return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
    }
    b2Body.prototype.SetSleepingAllowed = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_allowSleepFlag;
            this.SetAwake(true);
        }
    }
    b2Body.prototype.SetAwake = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
        }
        else {
            this.m_flags &= ~b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
            this.m_force.SetZero();
            this.m_torque = 0.0;
        }
    }
    b2Body.prototype.IsAwake = function () {
        return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
    }
    b2Body.prototype.SetFixedRotation = function (fixed) {
        if (fixed) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_fixedRotationFlag;
        }
        this.ResetMassData();
    }
    b2Body.prototype.IsFixedRotation = function () {
        return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
    }
    b2Body.prototype.SetActive = function (flag) {
        if (flag == this.IsActive()) {
            return;
        }
        var broadPhase;
        var f;
        if (flag) {
            this.m_flags |= b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.CreateProxy(broadPhase, this.m_xf);
            }
        }
        else {
            this.m_flags &= ~b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.DestroyProxy(broadPhase);
            }
            var ce = this.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.m_world.m_contactManager.Destroy(ce0.contact);
            }
            this.m_contactList = null;
        }
    }
    b2Body.prototype.IsActive = function () {
        return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
    }
    b2Body.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
    }
    b2Body.prototype.GetFixtureList = function () {
        return this.m_fixtureList;
    }
    b2Body.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2Body.prototype.GetControllerList = function () {
        return this.m_controllerList;
    }
    b2Body.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2Body.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Body.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Body.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Body.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Body.prototype.b2Body = function (bd, world) {
        this.m_flags = 0;
        if (bd.bullet) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        if (bd.fixedRotation) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        if (bd.allowSleep) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        if (bd.awake) {
            this.m_flags |= b2Body.e_awakeFlag;
        }
        if (bd.active) {
            this.m_flags |= b2Body.e_activeFlag;
        }
        this.m_world = world;
        this.m_xf.position.SetV(bd.position);
        this.m_xf.R.Set(bd.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1.0;
        this.m_sweep.a0 = this.m_sweep.a = bd.angle;
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_contactList = null;
        this.m_controllerCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_linearVelocity.SetV(bd.linearVelocity);
        this.m_angularVelocity = bd.angularVelocity;
        this.m_linearDamping = bd.linearDamping;
        this.m_angularDamping = bd.angularDamping;
        this.m_force.Set(0.0, 0.0);
        this.m_torque = 0.0;
        this.m_sleepTime = 0.0;
        this.m_type = bd.type;
        if (this.m_type == b2Body.b2_dynamicBody) {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        else {
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
        }
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_inertiaScale = bd.inertiaScale;
        this.m_userData = bd.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0;
    }
    b2Body.prototype.SynchronizeFixtures = function () {
        var xf1 = b2Body.s_xf1;
        xf1.R.Set(this.m_sweep.a0);
        var tMat = xf1.R;
        var tVec = this.m_sweep.localCenter;
        xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var f;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, xf1, this.m_xf);
        }
    }
    b2Body.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    }
    b2Body.prototype.ShouldCollide = function (other) {
        if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
            return false;
        }
        for (var jn = this.m_jointList; jn; jn = jn.next) {
            if (jn.other == other) if (jn.joint.m_collideConnected == false) {
                return false;
            }
        }
        return true;
    }
    b2Body.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        this.m_sweep.Advance(t);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a = this.m_sweep.a0;
        this.SynchronizeTransform();
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
        Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
        Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
        Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
        Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
        Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
        Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
        Box2D.Dynamics.b2Body.b2_staticBody = 0;
        Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
        Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
    });
    b2BodyDef.b2BodyDef = function () {
        this.position = new b2Vec2();
        this.linearVelocity = new b2Vec2();
    };
    b2BodyDef.prototype.b2BodyDef = function () {
        this.userData = null;
        this.position.Set(0.0, 0.0);
        this.angle = 0.0;
        this.linearVelocity.Set(0, 0);
        this.angularVelocity = 0.0;
        this.linearDamping = 0.0;
        this.angularDamping = 0.0;
        this.allowSleep = true;
        this.awake = true;
        this.fixedRotation = false;
        this.bullet = false;
        this.type = b2Body.b2_staticBody;
        this.active = true;
        this.inertiaScale = 1.0;
    }
    b2ContactFilter.b2ContactFilter = function () {};
    b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
        var filter1 = fixtureA.GetFilterData();
        var filter2 = fixtureB.GetFilterData();
        if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
            return filter1.groupIndex > 0;
        }
        var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
        return collide;
    }
    b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
        if (!userData) return true;
        return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
    });
    b2ContactImpulse.b2ContactImpulse = function () {
        this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
    };
    b2ContactListener.b2ContactListener = function () {};
    b2ContactListener.prototype.BeginContact = function (contact) {}
    b2ContactListener.prototype.EndContact = function (contact) {}
    b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
    b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
    });
    b2ContactManager.b2ContactManager = function () {};
    b2ContactManager.prototype.b2ContactManager = function () {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
        this.m_contactListener = b2ContactListener.b2_defaultListener;
        this.m_contactFactory = new b2ContactFactory(this.m_allocator);
        this.m_broadPhase = new b2DynamicTreeBroadPhase();
    }
    b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
        var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
        var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA == bodyB) return;
        var edge = bodyB.GetContactList();
        while (edge) {
            if (edge.other == bodyA) {
                var fA = edge.contact.GetFixtureA();
                var fB = edge.contact.GetFixtureB();
                if (fA == fixtureA && fB == fixtureB) return;
                if (fA == fixtureB && fB == fixtureA) return;
            }
            edge = edge.next;
        }
        if (bodyB.ShouldCollide(bodyA) == false) {
            return;
        }
        if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
            return;
        }
        var c = this.m_contactFactory.Create(fixtureA, fixtureB);
        fixtureA = c.GetFixtureA();
        fixtureB = c.GetFixtureB();
        bodyA = fixtureA.m_body;
        bodyB = fixtureB.m_body;
        c.m_prev = null;
        c.m_next = this.m_world.m_contactList;
        if (this.m_world.m_contactList != null) {
            this.m_world.m_contactList.m_prev = c;
        }
        this.m_world.m_contactList = c;
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA;
        }
        bodyA.m_contactList = c.m_nodeA;
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB;
        }
        bodyB.m_contactList = c.m_nodeB;
        ++this.m_world.m_contactCount;
        return;
    }
    b2ContactManager.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
    }
    b2ContactManager.prototype.Destroy = function (c) {
        var fixtureA = c.GetFixtureA();
        var fixtureB = c.GetFixtureB();
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (c.IsTouching()) {
            this.m_contactListener.EndContact(c);
        }
        if (c.m_prev) {
            c.m_prev.m_next = c.m_next;
        }
        if (c.m_next) {
            c.m_next.m_prev = c.m_prev;
        }
        if (c == this.m_world.m_contactList) {
            this.m_world.m_contactList = c.m_next;
        }
        if (c.m_nodeA.prev) {
            c.m_nodeA.prev.next = c.m_nodeA.next;
        }
        if (c.m_nodeA.next) {
            c.m_nodeA.next.prev = c.m_nodeA.prev;
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next;
        }
        if (c.m_nodeB.prev) {
            c.m_nodeB.prev.next = c.m_nodeB.next;
        }
        if (c.m_nodeB.next) {
            c.m_nodeB.next.prev = c.m_nodeB.prev;
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next;
        }
        this.m_contactFactory.Destroy(c);
        --this.m_contactCount;
    }
    b2ContactManager.prototype.Collide = function () {
        var c = this.m_world.m_contactList;
        while (c) {
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
                c = c.GetNext();
                continue;
            }

			//Jim: If body is not active, skip it
            if (!bodyA.IsActive() || !bodyB.IsActive()){
                c = c.GetNext();
                continue;
            }

            if (c.m_flags & b2Contact.e_filterFlag) {
                if (bodyB.ShouldCollide(bodyA) == false) {
                    var cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
                    cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                c.m_flags &= ~b2Contact.e_filterFlag;
            }
            var proxyA = fixtureA.m_proxy;
            var proxyB = fixtureB.m_proxy;
            var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
            if (overlap == false) {
                cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue;
            }
            c.Update(this.m_contactListener);
            c = c.GetNext();
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
    });
    b2DebugDraw.b2DebugDraw = function () {};
    b2DebugDraw.prototype.b2DebugDraw = function () {}
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.GetFlags = function () {}
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.SetSprite = function (sprite) {}
    b2DebugDraw.prototype.GetSprite = function () {}
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
    }
    b2DebugDraw.prototype.GetDrawScale = function () {}
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
    }
    b2DebugDraw.prototype.GetLineThickness = function () {}
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetAlpha = function () {}
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetFillAlpha = function () {}
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
    }
    b2DebugDraw.prototype.GetXFormScale = function () {}
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
    b2DebugDraw.prototype.DrawTransform = function (xf) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
        Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
        Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
        Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
        Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
        Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
    });
    b2DestructionListener.b2DestructionListener = function () {};
    b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
    b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
    b2FilterData.b2FilterData = function () {
        this.categoryBits = 0x0001;
        this.maskBits = 0xFFFF;
        this.groupIndex = 0;
    };
    b2FilterData.prototype.Copy = function () {
        var copy = new b2FilterData();
        copy.categoryBits = this.categoryBits;
        copy.maskBits = this.maskBits;
        copy.groupIndex = this.groupIndex;
        return copy;
    }
    b2Fixture.b2Fixture = function () {
        this.m_filter = new b2FilterData();
    };
    b2Fixture.prototype.GetType = function () {
        return this.m_shape.GetType();
    }
    b2Fixture.prototype.GetShape = function () {
        return this.m_shape;
    }
    b2Fixture.prototype.SetSensor = function (sensor) {
        if (this.m_isSensor == sensor) return;
        this.m_isSensor = sensor;
        if (this.m_body == null) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
            edge = edge.next;
        }
    }
    b2Fixture.prototype.IsSensor = function () {
        return this.m_isSensor;
    }
    b2Fixture.prototype.SetFilterData = function (filter) {
        this.m_filter = filter.Copy();
        if (this.m_body) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
            edge = edge.next;
        }
    }
    b2Fixture.prototype.GetFilterData = function () {
        return this.m_filter.Copy();
    }
    b2Fixture.prototype.GetBody = function () {
        return this.m_body;
    }
    b2Fixture.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Fixture.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Fixture.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Fixture.prototype.TestPoint = function (p) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
    }
    b2Fixture.prototype.RayCast = function (output, input) {
        return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
    }
    b2Fixture.prototype.GetMassData = function (massData) {
        if (massData === undefined) massData = null;
        if (massData == null) {
            massData = new b2MassData();
        }
        this.m_shape.ComputeMass(massData, this.m_density);
        return massData;
    }
    b2Fixture.prototype.SetDensity = function (density) {
        if (density === undefined) density = 0;
        this.m_density = density;
    }
    b2Fixture.prototype.GetDensity = function () {
        return this.m_density;
    }
    b2Fixture.prototype.GetFriction = function () {
        return this.m_friction;
    }
    b2Fixture.prototype.SetFriction = function (friction) {
        if (friction === undefined) friction = 0;
        this.m_friction = friction;
    }
    b2Fixture.prototype.GetRestitution = function () {
        return this.m_restitution;
    }
    b2Fixture.prototype.SetRestitution = function (restitution) {
        if (restitution === undefined) restitution = 0;
        this.m_restitution = restitution;
    }
    b2Fixture.prototype.GetAABB = function () {
        return this.m_aabb;
    }
    b2Fixture.prototype.b2Fixture = function () {
        this.m_aabb = new b2AABB();
        this.m_userData = null;
        this.m_body = null;
        this.m_next = null;
        this.m_shape = null;
        this.m_density = 0.0;
        this.m_friction = 0.0;
        this.m_restitution = 0.0;
    }
    b2Fixture.prototype.Create = function (body, xf, def) {
        this.m_userData = def.userData;
        this.m_friction = def.friction;
        this.m_restitution = def.restitution;
        this.m_body = body;
        this.m_next = null;
        this.m_filter = def.filter.Copy();
        this.m_isSensor = def.isSensor;
        this.m_shape = def.shape.Copy();
        this.m_density = def.density;
    }
    b2Fixture.prototype.Destroy = function () {
        this.m_shape = null;
    }
    b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
        this.m_shape.ComputeAABB(this.m_aabb, xf);
        this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
    }
    b2Fixture.prototype.DestroyProxy = function (broadPhase) {
        if (this.m_proxy == null) {
            return;
        }
        broadPhase.DestroyProxy(this.m_proxy);
        this.m_proxy = null;
    }
    b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
        if (!this.m_proxy) return;
        var aabb1 = new b2AABB();
        var aabb2 = new b2AABB();
        this.m_shape.ComputeAABB(aabb1, transform1);
        this.m_shape.ComputeAABB(aabb2, transform2);
        this.m_aabb.Combine(aabb1, aabb2);
        var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
        broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
    }
    b2FixtureDef.b2FixtureDef = function () {
        this.filter = new b2FilterData();
    };
    b2FixtureDef.prototype.b2FixtureDef = function () {
        this.shape = null;
        this.userData = null;
        this.friction = 0.2;
        this.restitution = 0.0;
        this.density = 0.0;
        this.filter.categoryBits = 0x0001;
        this.filter.maskBits = 0xFFFF;
        this.filter.groupIndex = 0;
        this.isSensor = false;
    }
    b2Island.b2Island = function () {};
    b2Island.prototype.b2Island = function () {
        this.m_bodies = new Vector();
        this.m_contacts = new Vector();
        this.m_joints = new Vector();
    }
    b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
        if (bodyCapacity === undefined) bodyCapacity = 0;
        if (contactCapacity === undefined) contactCapacity = 0;
        if (jointCapacity === undefined) jointCapacity = 0;
        var i = 0;
        this.m_bodyCapacity = bodyCapacity;
        this.m_contactCapacity = contactCapacity;
        this.m_jointCapacity = jointCapacity;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_allocator = allocator;
        this.m_listener = listener;
        this.m_contactSolver = contactSolver;
        for (i = this.m_bodies.length;
             i < bodyCapacity; i++)
            this.m_bodies[i] = null;
        for (i = this.m_contacts.length;
             i < contactCapacity; i++)
            this.m_contacts[i] = null;
        for (i = this.m_joints.length;
             i < jointCapacity; i++)
            this.m_joints[i] = null;
    }
    b2Island.prototype.Clear = function () {
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
    }
    b2Island.prototype.Solve = function (step, gravity, allowSleep) {
        var i = 0;
        var j = 0;
        var b;
        var joint;
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() != b2Body.b2_dynamicBody) continue;
            var g = b.modifyGravity(gravity);
            b.m_linearVelocity.x += step.dt * (g.x + b.m_invMass * b.m_force.x);
            b.m_linearVelocity.y += step.dt * (g.y + b.m_invMass * b.m_force.y);
            b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
            b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
            b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
        }
        this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        contactSolver.InitVelocityConstraints(step);
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.InitVelocityConstraints(step);
        }
        for (i = 0;
             i < step.velocityIterations; ++i) {
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                joint.SolveVelocityConstraints(step);
            }
            contactSolver.SolveVelocityConstraints();
        }
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.FinalizeVelocityConstraints();
        }
        contactSolver.FinalizeVelocityConstraints();
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = step.dt * b.m_linearVelocity.x;
            var translationY = step.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
            }
            var rotation = step.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
            b.m_sweep.a += step.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        for (i = 0;
             i < step.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
        if (allowSleep) {
            var minSleepTime = Number.MAX_VALUE;
            var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
            var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
            for (i = 0;
                 i < this.m_bodyCount; ++i) {
                b = this.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                else {
                    b.m_sleepTime += step.dt;
                    minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
                }
            }
            if (minSleepTime >= b2Settings.b2_timeToSleep) {
                for (i = 0;
                     i < this.m_bodyCount; ++i) {
                    b = this.m_bodies[i];
                    b.SetAwake(false);
                }
            }
        }
    }
    b2Island.prototype.SolveTOI = function (subStep) {
        var i = 0;
        var j = 0;
        this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        for (i = 0;
             i < this.m_jointCount; ++i) {
            this.m_joints[i].InitVelocityConstraints(subStep);
        }
        for (i = 0;
             i < subStep.velocityIterations; ++i) {
            contactSolver.SolveVelocityConstraints();
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                this.m_joints[j].SolveVelocityConstraints(subStep);
            }
        }
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = subStep.dt * b.m_linearVelocity.x;
            var translationY = subStep.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            }
            var rotation = subStep.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
            b.m_sweep.a += subStep.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        var k_toiBaumgarte = 0.75;
        for (i = 0;
             i < subStep.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
    }
    b2Island.prototype.Report = function (constraints) {
        if (this.m_listener == null) {
            return;
        }
        for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            var cc = constraints[i];
            for (var j = 0; j < cc.pointCount; ++j) {
                b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
                b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
            }
            this.m_listener.PostSolve(c, b2Island.s_impulse);
        }
    }
    b2Island.prototype.AddBody = function (body) {
        body.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = body;
    }
    b2Island.prototype.AddContact = function (contact) {
        this.m_contacts[this.m_contactCount++] = contact;
    }
    b2Island.prototype.AddJoint = function (joint) {
        this.m_joints[this.m_jointCount++] = joint;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
    });
    b2TimeStep.b2TimeStep = function () {};
    b2TimeStep.prototype.Set = function (step) {
        this.dt = step.dt;
        this.inv_dt = step.inv_dt;
        this.positionIterations = step.positionIterations;
        this.velocityIterations = step.velocityIterations;
        this.warmStarting = step.warmStarting;
    }
    b2World.b2World = function () {
        this.s_stack = new Vector();
        this.m_contactManager = new b2ContactManager();
        this.m_contactSolver = new b2ContactSolver();
        this.m_island = new b2Island();
    };
    b2World.prototype.b2World = function (gravity, doSleep) {
        this.m_destructionListener = null;
        this.m_debugDraw = null;
        this.m_bodyList = null;
        this.m_contactList = null;
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_controllerCount = 0;
        b2World.m_warmStarting = true;
        b2World.m_continuousPhysics = true;
        this.m_allowSleep = doSleep;
        gravity.y = gravity.y;
        this.m_gravity = gravity;
        this.m_inv_dt0 = 0.0;
        this.m_contactManager.m_world = this;
        var bd = new b2BodyDef();
        this.m_groundBody = this.CreateBody(bd);
    }
    b2World.prototype.SetDestructionListener = function (listener) {
        this.m_destructionListener = listener;
    }
    b2World.prototype.SetContactFilter = function (filter) {
        this.m_contactManager.m_contactFilter = filter;
    }
    b2World.prototype.SetContactListener = function (listener) {
        this.m_contactManager.m_contactListener = listener;
    }
    b2World.prototype.SetDebugDraw = function (debugDraw) {
        this.m_debugDraw = debugDraw;
    }
    b2World.prototype.SetBroadPhase = function (broadPhase) {
        var oldBroadPhase = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = broadPhase;
        for (var b = this.m_bodyList; b; b = b.m_next) {
            for (var f = b.m_fixtureList; f; f = f.m_next) {
                f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
            }
        }
    }
    b2World.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate();
    }
    b2World.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount();
    }
    b2World.prototype.CreateBody = function (def) {
        if (this.IsLocked() == true) {
            return null;
        }
        var b = new b2Body(def, this);
        b.m_prev = null;
        b.m_next = this.m_bodyList;
        if (this.m_bodyList) {
            this.m_bodyList.m_prev = b;
        }
        this.m_bodyList = b;
        ++this.m_bodyCount;
        return b;
    }
    b2World.prototype.DestroyBody = function (b) {
        if (this.IsLocked() == true) {
            return;
        }
        var jn = b.m_jointList;
        while (jn) {
            var jn0 = jn;
            jn = jn.next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
            }
            this.DestroyJoint(jn0.joint);
        }
        var coe = b.m_controllerList;
        while (coe) {
            var coe0 = coe;
            coe = coe.nextController;
            coe0.controller.RemoveBody(b);
        }
        var ce = b.m_contactList;
        while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact);
        }
        b.m_contactList = null;
        var f = b.m_fixtureList;
        while (f) {
            var f0 = f;
            f = f.m_next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeFixture(f0);
            }
            f0.DestroyProxy(this.m_contactManager.m_broadPhase);
            f0.Destroy();
        }
        b.m_fixtureList = null;
        b.m_fixtureCount = 0;
        if (b.m_prev) {
            b.m_prev.m_next = b.m_next;
        }
        if (b.m_next) {
            b.m_next.m_prev = b.m_prev;
        }
        if (b == this.m_bodyList) {
            this.m_bodyList = b.m_next;
        }--this.m_bodyCount;
    }
    b2World.prototype.CreateJoint = function (def) {
        var j = b2Joint.Create(def, null);
        j.m_prev = null;
        j.m_next = this.m_jointList;
        if (this.m_jointList) {
            this.m_jointList.m_prev = j;
        }
        this.m_jointList = j;
        ++this.m_jointCount;
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.m_bodyB;
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.m_bodyA.m_jointList;
        if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
        j.m_bodyA.m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.m_bodyA;
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.m_bodyB.m_jointList;
        if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
        j.m_bodyB.m_jointList = j.m_edgeB;
        var bodyA = def.bodyA;
        var bodyB = def.bodyB;
        if (def.collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
        return j;
    }
    b2World.prototype.DestroyJoint = function (j) {
        var collideConnected = j.m_collideConnected;
        if (j.m_prev) {
            j.m_prev.m_next = j.m_next;
        }
        if (j.m_next) {
            j.m_next.m_prev = j.m_prev;
        }
        if (j == this.m_jointList) {
            this.m_jointList = j.m_next;
        }
        var bodyA = j.m_bodyA;
        var bodyB = j.m_bodyB;
        bodyA.SetAwake(true);
        bodyB.SetAwake(true);
        if (j.m_edgeA.prev) {
            j.m_edgeA.prev.next = j.m_edgeA.next;
        }
        if (j.m_edgeA.next) {
            j.m_edgeA.next.prev = j.m_edgeA.prev;
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next;
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        if (j.m_edgeB.prev) {
            j.m_edgeB.prev.next = j.m_edgeB.next;
        }
        if (j.m_edgeB.next) {
            j.m_edgeB.next.prev = j.m_edgeB.prev;
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next;
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        b2Joint.Destroy(j, null);
        --this.m_jointCount;
        if (collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
    }
    b2World.prototype.AddController = function (c) {
        c.m_next = this.m_controllerList;
        c.m_prev = null;
        this.m_controllerList = c;
        c.m_world = this;
        this.m_controllerCount++;
        return c;
    }
    b2World.prototype.RemoveController = function (c) {
        if (c.m_prev) c.m_prev.m_next = c.m_next;
        if (c.m_next) c.m_next.m_prev = c.m_prev;
        if (this.m_controllerList == c) this.m_controllerList = c.m_next;
        this.m_controllerCount--;
    }
    b2World.prototype.CreateController = function (controller) {
        if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
        controller.m_next = this.m_controllerList;
        controller.m_prev = null;
        if (this.m_controllerList) this.m_controllerList.m_prev = controller;
        this.m_controllerList = controller;
        ++this.m_controllerCount;
        controller.m_world = this;
        return controller;
    }
    b2World.prototype.DestroyController = function (controller) {
        controller.Clear();
        if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
        if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
        if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
        --this.m_controllerCount;
    }
    b2World.prototype.SetWarmStarting = function (flag) {
        b2World.m_warmStarting = flag;
    }
    b2World.prototype.SetContinuousPhysics = function (flag) {
        b2World.m_continuousPhysics = flag;
    }
    b2World.prototype.GetBodyCount = function () {
        return this.m_bodyCount;
    }
    b2World.prototype.GetJointCount = function () {
        return this.m_jointCount;
    }
    b2World.prototype.GetContactCount = function () {
        return this.m_contactCount;
    }
    b2World.prototype.SetGravity = function (gravity) {
        this.m_gravity = gravity;
    }
    b2World.prototype.GetGravity = function () {
        return this.m_gravity;
    }
    b2World.prototype.GetGroundBody = function () {
        return this.m_groundBody;
    }
    b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
        if (dt === undefined) dt = 0;
        if (velocityIterations === undefined) velocityIterations = 0;
        if (positionIterations === undefined) positionIterations = 0;
        if (this.m_flags & b2World.e_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_flags &= ~b2World.e_newFixture;
        }
        this.m_flags |= b2World.e_locked;
        var step = b2World.s_timestep2;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0.0) {
            step.inv_dt = 1.0 / dt;
        }
        else {
            step.inv_dt = 0.0;
        }
        step.dtRatio = this.m_inv_dt0 * dt;
        step.warmStarting = b2World.m_warmStarting;
        this.m_contactManager.Collide();
        if (step.dt > 0.0) {
            this.Solve(step);
        }
        if (b2World.m_continuousPhysics && step.dt > 0.0) {
            this.SolveTOI(step);
        }
        if (step.dt > 0.0) {
            this.m_inv_dt0 = step.inv_dt;
        }
        this.m_flags &= ~b2World.e_locked;
    }
    b2World.prototype.ClearForces = function () {
        for (var body = this.m_bodyList; body; body = body.m_next) {
            body.m_force.SetZero();
            body.m_torque = 0.0;
        }
    }
    b2World.prototype.DrawDebugData = function () {
        if (this.m_debugDraw == null) {
            return;
        }
        this.m_debugDraw.m_sprite.graphics.clear();
        var flags = this.m_debugDraw.GetFlags();
        var i = 0;
        var b;
        var f;
        var s;
        var j;
        var bp;
        var invQ = new b2Vec2;
        var x1 = new b2Vec2;
        var x2 = new b2Vec2;
        var xf;
        var b1 = new b2AABB();
        var b2 = new b2AABB();
        var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
        var color = new b2Color(0, 0, 0);
        if (flags & b2DebugDraw.e_shapeBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b.m_xf;
                for (f = b.GetFixtureList();
                     f; f = f.m_next) {
                    s = f.GetShape();
                    if (b.IsActive() == false) {
                        color.Set(0.5, 0.5, 0.3);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_staticBody) {
                        color.Set(0.5, 0.9, 0.5);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_kinematicBody) {
                        color.Set(0.5, 0.5, 0.9);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.IsAwake() == false) {
                        color.Set(0.6, 0.6, 0.6);
                        this.DrawShape(s, xf, color);
                    }
                    else {
                        color.Set(0.9, 0.7, 0.7);
                        this.DrawShape(s, xf, color);
                    }
                }
            }
        }
        if (flags & b2DebugDraw.e_jointBit) {
            for (j = this.m_jointList;
                 j; j = j.m_next) {
                this.DrawJoint(j);
            }
        }
        if (flags & b2DebugDraw.e_controllerBit) {
            for (var c = this.m_controllerList; c; c = c.m_next) {
                c.Draw(this.m_debugDraw);
            }
        }
        if (flags & b2DebugDraw.e_pairBit) {
            color.Set(0.3, 0.9, 0.9);
            for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
                var fixtureA = contact.GetFixtureA();
                var fixtureB = contact.GetFixtureB();
                var cA = fixtureA.GetAABB().GetCenter();
                var cB = fixtureB.GetAABB().GetCenter();
                this.m_debugDraw.DrawSegment(cA, cB, color);
            }
        }
        if (flags & b2DebugDraw.e_aabbBit) {
            bp = this.m_contactManager.m_broadPhase;
            vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
            for (b = this.m_bodyList;
                 b; b = b.GetNext()) {
                if (b.IsActive() == false) {
                    continue;
                }
                for (f = b.GetFixtureList();
                     f; f = f.GetNext()) {
                    var aabb = bp.GetFatAABB(f.m_proxy);
                    vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                    vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                    vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                    vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                    this.m_debugDraw.DrawPolygon(vs, 4, color);
                }
            }
        }
        if (flags & b2DebugDraw.e_centerOfMassBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b2World.s_xf;
                xf.R = b.m_xf.R;
                xf.position = b.GetWorldCenter();
                this.m_debugDraw.DrawTransform(xf);
            }
        }
    }
    b2World.prototype.QueryAABB = function (callback, aabb) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            return callback(broadPhase.GetUserData(proxy));
        };
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryShape = function (callback, shape, transform) {
        var __this = this;
        if (transform === undefined) transform = null;
        if (transform == null) {
            transform = new b2Transform();
            transform.SetIdentity();
        }
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        shape.ComputeAABB(aabb, transform);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryPoint = function (callback, p) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (fixture.TestPoint(p)) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
        aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.RayCast = function (callback, point1, point2) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;
        var output = new b2RayCastOutput;

        function RayCastWrapper(input, proxy) {
            var userData = broadPhase.GetUserData(proxy);
            var fixture = (userData instanceof b2Fixture ? userData : null);
            var hit = fixture.RayCast(output, input);
            if (hit) {
                var fraction = output.fraction;
                var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
                return callback(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
        };
        var input = new b2RayCastInput(point1, point2);
        broadPhase.RayCast(RayCastWrapper, input);
    }
    b2World.prototype.RayCastOne = function (point1, point2) {
        var __this = this;
        var result;

        function RayCastOneWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result = fixture;
            return fraction;
        };
        __this.RayCast(RayCastOneWrapper, point1, point2);
        return result;
    }
    b2World.prototype.RayCastAll = function (point1, point2) {
        var __this = this;
        var result = new Vector();

        function RayCastAllWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result[result.length] = fixture;
            return 1;
        };
        __this.RayCast(RayCastAllWrapper, point1, point2);
        return result;
    }
    b2World.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2World.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2World.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2World.prototype.IsLocked = function () {
        return (this.m_flags & b2World.e_locked) > 0;
    }
    b2World.prototype.Solve = function (step) {
        var b;
        for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
            controller.Step(step);
        }
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
        }
        for (var c = this.m_contactList; c; c = c.m_next) {
            c.m_flags &= ~b2Contact.e_islandFlag;
        }
        for (var j = this.m_jointList; j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        var stackSize = parseInt(this.m_bodyCount);
        var stack = this.s_stack;
        for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
            if (seed.m_flags & b2Body.e_islandFlag) {
                continue;
            }
            if (seed.IsAwake() == false || seed.IsActive() == false) {
                continue;
            }
            if (seed.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (stackCount > 0) {
                b = stack[--stackCount];
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                var other;
                for (var ce = b.m_contactList; ce; ce = ce.next) {
                    if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(ce.contact);
                    ce.contact.m_flags |= b2Contact.e_islandFlag;
                    other = ce.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jn = b.m_jointList; jn; jn = jn.next) {
                    if (jn.joint.m_islandFlag == true) {
                        continue;
                    }
                    other = jn.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jn.joint);
                    jn.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            island.Solve(step, this.m_gravity, this.m_allowSleep);
            for (var i = 0; i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    b.m_flags &= ~b2Body.e_islandFlag;
                }
            }
        }
        for (i = 0;
             i < stack.length; ++i) {
            if (!stack[i]) break;
            stack[i] = null;
        }
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            if (b.IsAwake() == false || b.IsActive() == false) {
                continue;
            }
            if (b.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            b.SynchronizeFixtures();
        }
        this.m_contactManager.FindNewContacts();
    }
    b2World.prototype.SolveTOI = function (step) {
        var b;
        var fA;
        var fB;
        var bA;
        var bB;
        var cEdge;
        var j;
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var queue = b2World.s_queue;
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
            b.m_sweep.t0 = 0.0;
        }
        var c;
        for (c = this.m_contactList;
             c; c = c.m_next) {
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
        }
        for (j = this.m_jointList;
             j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        for (;;) {
            var minContact = null;
            var minTOI = 1.0;
            for (c = this.m_contactList;
                 c; c = c.m_next) {
                if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
                    continue;
                }
                var toi = 1.0;
                if (c.m_flags & b2Contact.e_toiFlag) {
                    toi = c.m_toi;
                }
                else {
                    fA = c.m_fixtureA;
                    fB = c.m_fixtureB;
                    bA = fA.m_body;
                    bB = fB.m_body;
                    if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                        continue;
                    }
                    var t0 = bA.m_sweep.t0;
                    if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                        t0 = bB.m_sweep.t0;
                        bA.m_sweep.Advance(t0);
                    }
                    else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                        t0 = bA.m_sweep.t0;
                        bB.m_sweep.Advance(t0);
                    }
                    toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
                    b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
                    if (toi > 0.0 && toi < 1.0) {
                        toi = (1.0 - toi) * t0 + toi;
                        if (toi > 1) toi = 1;
                    }
                    c.m_toi = toi;
                    c.m_flags |= b2Contact.e_toiFlag;
                }
                if (Box2D.MIN_VALUE < toi && toi < minTOI) {
                    minContact = c;
                    minTOI = toi;
                }
            }
            if (minContact == null || 1.0 - 100.0 * Box2D.MIN_VALUE < minTOI) {
                break;
            }
            fA = minContact.m_fixtureA;
            fB = minContact.m_fixtureB;
            bA = fA.m_body;
            bB = fB.m_body;
            b2World.s_backupA.Set(bA.m_sweep);
            b2World.s_backupB.Set(bB.m_sweep);
            bA.Advance(minTOI);
            bB.Advance(minTOI);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_flags &= ~b2Contact.e_toiFlag;
            if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
                bA.m_sweep.Set(b2World.s_backupA);
                bB.m_sweep.Set(b2World.s_backupB);
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();
                continue;
            }
            if (minContact.IsTouching() == false) {
                continue;
            }
            var seed = bA;
            if (seed.GetType() != b2Body.b2_dynamicBody) {
                seed = bB;
            }
            island.Clear();
            var queueStart = 0;
            var queueSize = 0;
            queue[queueStart + queueSize++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (queueSize > 0) {
                b = queue[queueStart++];
                --queueSize;
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    if (island.m_contactCount == island.m_contactCapacity) {
                        break;
                    }
                    if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(cEdge.contact);
                    cEdge.contact.m_flags |= b2Contact.e_islandFlag;
                    var other = cEdge.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
                    if (island.m_jointCount == island.m_jointCapacity) continue;
                    if (jEdge.joint.m_islandFlag == true) continue;
                    other = jEdge.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jEdge.joint);
                    jEdge.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) continue;
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            var subStep = b2World.s_timestep;
            subStep.warmStarting = false;
            subStep.dt = (1.0 - minTOI) * step.dt;
            subStep.inv_dt = 1.0 / subStep.dt;
            subStep.dtRatio = 0.0;
            subStep.velocityIterations = step.velocityIterations;
            subStep.positionIterations = step.positionIterations;
            island.SolveTOI(subStep);
            var i = 0;
            for (i = 0;
                 i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                b.m_flags &= ~b2Body.e_islandFlag;
                if (b.IsAwake() == false) {
                    continue;
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                b.SynchronizeFixtures();
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
                }
            }
            for (i = 0;
                 i < island.m_contactCount; ++i) {
                c = island.m_contacts[i];
                c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
            }
            for (i = 0;
                 i < island.m_jointCount; ++i) {
                j = island.m_joints[i];
                j.m_islandFlag = false;
            }
            this.m_contactManager.FindNewContacts();
        }
    }
    b2World.prototype.DrawJoint = function (joint) {
        var b1 = joint.GetBodyA();
        var b2 = joint.GetBodyB();
        var xf1 = b1.m_xf;
        var xf2 = b2.m_xf;
        var x1 = xf1.position;
        var x2 = xf2.position;
        var p1 = joint.GetAnchorA();
        var p2 = joint.GetAnchorB();
        var color = b2World.s_jointColor;
        switch (joint.m_type) {
            case b2Joint.e_distanceJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            case b2Joint.e_pulleyJoint:
            {
                var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
                var s1 = pulley.GetGroundAnchorA();
                var s2 = pulley.GetGroundAnchorB();
                this.m_debugDraw.DrawSegment(s1, p1, color);
                this.m_debugDraw.DrawSegment(s2, p2, color);
                this.m_debugDraw.DrawSegment(s1, s2, color);
            }
                break;
            case b2Joint.e_mouseJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            default:
                if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
                this.m_debugDraw.DrawSegment(p1, p2, color);
                if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
        }
    }
    b2World.prototype.DrawShape = function (shape, xf, color) {
        switch (shape.m_type) {
            case b2Shape.e_circleShape:
            {
                var circle = ((shape instanceof b2CircleShape ? shape : null));
                var center = b2Math.MulX(xf, circle.m_p);
                var radius = circle.m_radius;
                var axis = xf.R.col1;
                this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var i = 0;
                var poly = ((shape instanceof b2PolygonShape ? shape : null));
                var vertexCount = parseInt(poly.GetVertexCount());
                var localVertices = poly.GetVertices();
                var vertices = new Vector(vertexCount);
                for (i = 0;
                     i < vertexCount; ++i) {
                    vertices[i] = b2Math.MulX(xf, localVertices[i]);
                }
                this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
            }
                break;
            case b2Shape.e_edgeShape:
            {
                var edge = (shape instanceof b2EdgeShape ? shape : null);
                this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
        Box2D.Dynamics.b2World.s_xf = new b2Transform();
        Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
        Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
        Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
        Box2D.Dynamics.b2World.s_queue = new Vector();
        Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
        Box2D.Dynamics.b2World.e_newFixture = 0x0001;
        Box2D.Dynamics.b2World.e_locked = 0x0002;
    });
})();
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2CircleContact.b2CircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2CircleContact.Create = function (allocator) {
        return new b2CircleContact();
    }
    b2CircleContact.Destroy = function (contact, allocator) {}
    b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
//        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_edgeShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
    }
    b2CircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2Contact.b2Contact = function () {
        this.m_nodeA = new b2ContactEdge();
        this.m_nodeB = new b2ContactEdge();
        this.m_manifold = new b2Manifold();
        this.m_oldManifold = new b2Manifold();
    };
    b2Contact.prototype.GetManifold = function () {
        return this.m_manifold;
    }
    b2Contact.prototype.GetWorldManifold = function (worldManifold) {
        var bodyA = this.m_fixtureA.GetBody();
        var bodyB = this.m_fixtureB.GetBody();
        var shapeA = this.m_fixtureA.GetShape();
        var shapeB = this.m_fixtureB.GetShape();
        worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
    }
    b2Contact.prototype.IsTouching = function () {
        return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
    }
    b2Contact.prototype.IsContinuous = function () {
        return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
    }
    b2Contact.prototype.SetSensor = function (sensor) {
        if (sensor) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_sensorFlag;
        }
    }
    b2Contact.prototype.IsSensor = function () {
        return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
    }
    b2Contact.prototype.SetEnabled = function (flag) {
        if (flag) {
            this.m_flags |= b2Contact.e_enabledFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_enabledFlag;
        }
    }
    b2Contact.prototype.IsEnabled = function () {
        return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
    }
    b2Contact.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Contact.prototype.GetFixtureA = function () {
        return this.m_fixtureA;
    }
    b2Contact.prototype.GetFixtureB = function () {
        return this.m_fixtureB;
    }
    b2Contact.prototype.FlagForFiltering = function () {
        this.m_flags |= b2Contact.e_filterFlag;
    }
    b2Contact.prototype.b2Contact = function () {}
    b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
        if (fixtureA === undefined) fixtureA = null;
        if (fixtureB === undefined) fixtureB = null;
        this.m_flags = b2Contact.e_enabledFlag;
        if (!fixtureA || !fixtureB) {
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            return;
        }
        if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
        }
        this.m_fixtureA = fixtureA;
        this.m_fixtureB = fixtureB;
        this.m_manifold.m_pointCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_nodeA.contact = null;
        this.m_nodeA.prev = null;
        this.m_nodeA.next = null;
        this.m_nodeA.other = null;
        this.m_nodeB.contact = null;
        this.m_nodeB.prev = null;
        this.m_nodeB.next = null;
        this.m_nodeB.other = null;
    }
    b2Contact.prototype.Update = function (listener) {
        var tManifold = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = tManifold;
        this.m_flags |= b2Contact.e_enabledFlag;
        var touching = false;
        var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
        var bodyA = this.m_fixtureA.m_body;
        var bodyB = this.m_fixtureB.m_body;
        var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & b2Contact.e_sensorFlag) {
            if (aabbOverlap) {
                var shapeA = this.m_fixtureA.GetShape();
                var shapeB = this.m_fixtureB.GetShape();
                var xfA = bodyA.GetTransform();
                var xfB = bodyB.GetTransform();
                touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
            }
            this.m_manifold.m_pointCount = 0;
        }
        else {
            if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
                this.m_flags |= b2Contact.e_continuousFlag;
            }
            else {
                this.m_flags &= ~b2Contact.e_continuousFlag;
            }
            if (aabbOverlap) {
                this.Evaluate();
                touching = this.m_manifold.m_pointCount > 0;
                for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
                    var mp2 = this.m_manifold.m_points[i];
                    mp2.m_normalImpulse = 0.0;
                    mp2.m_tangentImpulse = 0.0;
                    var id2 = mp2.m_id;
                    for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                        var mp1 = this.m_oldManifold.m_points[j];
                        if (mp1.m_id.key == id2.key) {
                            mp2.m_normalImpulse = mp1.m_normalImpulse;
                            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                            break;
                        }
                    }
                }
            }
            else {
                this.m_manifold.m_pointCount = 0;
            }
            if (touching != wasTouching) {
                bodyA.SetAwake(true);
                bodyB.SetAwake(true);
            }
        }
        if (touching) {
            this.m_flags |= b2Contact.e_touchingFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_touchingFlag;
        }
        if (wasTouching == false && touching == true) {
            listener.BeginContact(this);
        }
        if (wasTouching == true && touching == false) {
            listener.EndContact(this);
        }
        if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
            listener.PreSolve(this, this.m_oldManifold);
        }
    }
    b2Contact.prototype.Evaluate = function () {}
    b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
        b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        b2Contact.s_input.sweepA = sweepA;
        b2Contact.s_input.sweepB = sweepB;
        b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
        return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
        Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
        Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
        Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
        Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
        Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
        Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
        Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
    });
    b2ContactConstraint.b2ContactConstraint = function () {
        this.localPlaneNormal = new b2Vec2();
        this.localPoint = new b2Vec2();
        this.normal = new b2Vec2();
        this.normalMass = new b2Mat22();
        this.K = new b2Mat22();
    };
    b2ContactConstraint.prototype.b2ContactConstraint = function () {
        this.points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.points[i] = new b2ContactConstraintPoint();
        }
    }
    b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
        this.localPoint = new b2Vec2();
        this.rA = new b2Vec2();
        this.rB = new b2Vec2();
    };
    b2ContactEdge.b2ContactEdge = function () {};
    b2ContactFactory.b2ContactFactory = function () {};
    b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
        this.m_allocator = allocator;
        this.InitializeRegisters();
    }
    b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
        if (type1 === undefined) type1 = 0;
        if (type2 === undefined) type2 = 0;
        this.m_registers[type1][type2].createFcn = createFcn;
        this.m_registers[type1][type2].destroyFcn = destroyFcn;
        this.m_registers[type1][type2].primary = true;
        if (type1 != type2) {
            this.m_registers[type2][type1].createFcn = createFcn;
            this.m_registers[type2][type1].destroyFcn = destroyFcn;
            this.m_registers[type2][type1].primary = false;
        }
    }
    b2ContactFactory.prototype.InitializeRegisters = function () {
        this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
        for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
            this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
            for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
                this.m_registers[i][j] = new b2ContactRegister();
            }
        }
        this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
        this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
        this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
    }
    b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
        var type1 = parseInt(fixtureA.GetType());
        var type2 = parseInt(fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        var c;
        if (reg.pool) {
            c = reg.pool;
            reg.pool = c.m_next;
            reg.poolCount--;
            c.Reset(fixtureA, fixtureB);
            return c;
        }
        var createFcn = reg.createFcn;
        if (createFcn != null) {
            if (reg.primary) {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureA, fixtureB);
                return c;
            }
            else {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureB, fixtureA);
                return c;
            }
        }
        else {
            return null;
        }
    }
    b2ContactFactory.prototype.Destroy = function (contact) {
        if (contact.m_manifold.m_pointCount > 0) {
            contact.m_fixtureA.m_body.SetAwake(true);
            contact.m_fixtureB.m_body.SetAwake(true);
        }
        var type1 = parseInt(contact.m_fixtureA.GetType());
        var type2 = parseInt(contact.m_fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        if (true) {
            reg.poolCount++;
            contact.m_next = reg.pool;
            reg.pool = contact;
        }
        var destroyFcn = reg.destroyFcn;
        destroyFcn(contact, this.m_allocator);
    }
    b2ContactRegister.b2ContactRegister = function () {};
    b2ContactResult.b2ContactResult = function () {
        this.position = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2ContactSolver.b2ContactSolver = function () {
        this.m_step = new b2TimeStep();
        this.m_constraints = new Vector();
    };
    b2ContactSolver.prototype.b2ContactSolver = function () {}
    b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
        if (contactCount === undefined) contactCount = 0;
        var contact;
        this.m_step.Set(step);
        this.m_allocator = allocator;
        var i = 0;
        var tVec;
        var tMat;
        this.m_constraintCount = contactCount;
        while (this.m_constraints.length < this.m_constraintCount) {
            this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
        }
        for (i = 0;
             i < contactCount; ++i) {
            contact = contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            var manifold = contact.GetManifold();
            var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
            var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
            var vAX = bodyA.m_linearVelocity.x;
            var vAY = bodyA.m_linearVelocity.y;
            var vBX = bodyB.m_linearVelocity.x;
            var vBY = bodyB.m_linearVelocity.y;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            b2Settings.b2Assert(manifold.m_pointCount > 0);
            b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
            var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
            var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
            var cc = this.m_constraints[i];
            cc.bodyA = bodyA;
            cc.bodyB = bodyB;
            cc.manifold = manifold;
            cc.normal.x = normalX;
            cc.normal.y = normalY;
            cc.pointCount = manifold.m_pointCount;
            cc.friction = friction;
            cc.restitution = restitution;
            cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
            cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
            cc.localPoint.x = manifold.m_localPoint.x;
            cc.localPoint.y = manifold.m_localPoint.y;
            cc.radius = radiusA + radiusB;
            cc.type = manifold.m_type;
            for (var k = 0; k < cc.pointCount; ++k) {
                var cp = manifold.m_points[k];
                var ccp = cc.points[k];
                ccp.normalImpulse = cp.m_normalImpulse;
                ccp.tangentImpulse = cp.m_tangentImpulse;
                ccp.localPoint.SetV(cp.m_localPoint);
                var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
                var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
                var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
                var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
                var rnA = rAX * normalY - rAY * normalX;
                var rnB = rBX * normalY - rBY * normalX;
                rnA *= rnA;
                rnB *= rnB;
                var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
                ccp.normalMass = 1.0 / kNormal;
                var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
                kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
                ccp.equalizedMass = 1.0 / kEqualized;
                var tangentX = normalY;
                var tangentY = (-normalX);
                var rtA = rAX * tangentY - rAY * tangentX;
                var rtB = rBX * tangentY - rBY * tangentX;
                rtA *= rtA;
                rtB *= rtB;
                var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
                ccp.tangentMass = 1.0 / kTangent;
                ccp.velocityBias = 0.0;
                var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
                var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
                var vRel = cc.normal.x * tX + cc.normal.y * tY;
                if (vRel < (-b2Settings.b2_velocityThreshold)) {
                    ccp.velocityBias += (-cc.restitution * vRel);
                }
            }
            if (cc.pointCount == 2) {
                var ccp1 = cc.points[0];
                var ccp2 = cc.points[1];
                var invMassA = bodyA.m_invMass;
                var invIA = bodyA.m_invI;
                var invMassB = bodyB.m_invMass;
                var invIB = bodyB.m_invI;
                var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
                var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
                var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
                var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
                var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
                var k_maxConditionNumber = 100.0;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    cc.K.col1.Set(k11, k12);
                    cc.K.col2.Set(k12, k22);
                    cc.K.GetInverse(cc.normalMass);
                }
                else {
                    cc.pointCount = 1;
                }
            }
        }
    }
    b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
        var tVec;
        var tVec2;
        var tMat;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var tX = 0;
            var j = 0;
            var tCount = 0;
            if (step.warmStarting) {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp = c.points[j];
                    ccp.normalImpulse *= step.dtRatio;
                    ccp.tangentImpulse *= step.dtRatio;
                    var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
                    var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
                    bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                    bodyA.m_linearVelocity.x -= invMassA * PX;
                    bodyA.m_linearVelocity.y -= invMassA * PY;
                    bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                    bodyB.m_linearVelocity.x += invMassB * PX;
                    bodyB.m_linearVelocity.y += invMassB * PY;
                }
            }
            else {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp2 = c.points[j];
                    ccp2.normalImpulse = 0.0;
                    ccp2.tangentImpulse = 0.0;
                }
            }
        }
    }
    b2ContactSolver.prototype.SolveVelocityConstraints = function () {
        var j = 0;
        var ccp;
        var rAX = 0;
        var rAY = 0;
        var rBX = 0;
        var rBY = 0;
        var dvX = 0;
        var dvY = 0;
        var vn = 0;
        var vt = 0;
        var lambda = 0;
        var maxFriction = 0;
        var newImpulse = 0;
        var PX = 0;
        var PY = 0;
        var dX = 0;
        var dY = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var tMat;
        var tVec;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            var vA = bodyA.m_linearVelocity;
            var vB = bodyB.m_linearVelocity;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var friction = c.friction;
            var tX = 0;
            for (j = 0;
                 j < c.pointCount; j++) {
                ccp = c.points[j];
                dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
                dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
                vt = dvX * tangentX + dvY * tangentY;
                lambda = ccp.tangentMass * (-vt);
                maxFriction = friction * ccp.normalImpulse;
                newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
                lambda = newImpulse - ccp.tangentImpulse;
                PX = lambda * tangentX;
                PY = lambda * tangentY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.tangentImpulse = newImpulse;
            }
            var tCount = parseInt(c.pointCount);
            if (c.pointCount == 1) {
                ccp = c.points[0];
                dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
                dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
                vn = dvX * normalX + dvY * normalY;
                lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
                newImpulse = ccp.normalImpulse + lambda;
                newImpulse = newImpulse > 0 ? newImpulse : 0.0;
                lambda = newImpulse - ccp.normalImpulse;
                PX = lambda * normalX;
                PY = lambda * normalY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.normalImpulse = newImpulse;
            }
            else {
                var cp1 = c.points[0];
                var cp2 = c.points[1];
                var aX = cp1.normalImpulse;
                var aY = cp2.normalImpulse;
                var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
                var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
                var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
                var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
                var vn1 = dv1X * normalX + dv1Y * normalY;
                var vn2 = dv2X * normalX + dv2Y * normalY;
                var bX = vn1 - cp1.velocityBias;
                var bY = vn2 - cp2.velocityBias;
                tMat = c.K;
                bX -= tMat.col1.x * aX + tMat.col2.x * aY;
                bY -= tMat.col1.y * aX + tMat.col2.y * aY;
                var k_errorTol = 0.001;
                for (;;) {
                    tMat = c.normalMass;
                    var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
                    var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
                    if (xX >= 0.0 && xY >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = (-cp1.normalMass * bX);
                    xY = 0.0;
                    vn1 = 0.0;
                    vn2 = c.K.col1.y * xX + bY;
                    if (xX >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = (-cp2.normalMass * bY);
                    vn1 = c.K.col2.x * xY + bX;
                    vn2 = 0.0;
                    if (xY >= 0.0 && vn1 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = 0.0;
                    vn1 = bX;
                    vn2 = bY;
                    if (vn1 >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    break;
                }
            }
            bodyA.m_angularVelocity = wA;
            bodyB.m_angularVelocity = wB;
        }
    }
    b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var m = c.manifold;
            for (var j = 0; j < c.pointCount; ++j) {
                var point1 = m.m_points[j];
                var point2 = c.points[j];
                point1.m_normalImpulse = point2.normalImpulse;
                point1.m_tangentImpulse = point2.tangentImpulse;
            }
        }
    }
    b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var minSeparation = 0.0;
        for (var i = 0; i < this.m_constraintCount; i++) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_mass * bodyA.m_invMass;
            var invIA = bodyA.m_mass * bodyA.m_invI;
            var invMassB = bodyB.m_mass * bodyB.m_invMass;
            var invIB = bodyB.m_mass * bodyB.m_invI;
            b2ContactSolver.s_psm.Initialize(c);
            var normal = b2ContactSolver.s_psm.m_normal;
            for (var j = 0; j < c.pointCount; j++) {
                var ccp = c.points[j];
                var point = b2ContactSolver.s_psm.m_points[j];
                var separation = b2ContactSolver.s_psm.m_separations[j];
                var rAX = point.x - bodyA.m_sweep.c.x;
                var rAY = point.y - bodyA.m_sweep.c.y;
                var rBX = point.x - bodyB.m_sweep.c.x;
                var rBY = point.y - bodyB.m_sweep.c.y;
                minSeparation = minSeparation < separation ? minSeparation : separation;
                var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
                var impulse = (-ccp.equalizedMass * C);
                var PX = impulse * normal.x;
                var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
                bodyA.m_sweep.c.y -= invMassA * PY;
                bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
                bodyA.SynchronizeTransform();
                bodyB.m_sweep.c.x += invMassB * PX;
                bodyB.m_sweep.c.y += invMassB * PY;
                bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
                bodyB.SynchronizeTransform();
            }
        }
        return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
    });
    Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2EdgeAndCircleContact.Create = function (allocator) {
        return new b2EdgeAndCircleContact();
    }
    b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
    b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2EdgeAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX = 0;
        var dY = 0;
        var positionX = 0;
        var positionY = 0;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
        var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
        var dist = 0;
        var radius = edge.m_radius + circle.m_radius;
        tVec = edge.m_normal;
        var separation = tVec.x * dX + tVec.y * dY;
        var v1 = edge.m_v1;
        var v2 = edge.m_v2;
        if (separation < Number.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(edge.m_normal);
            manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
            manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return;
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0.0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else {
            var faceCenterX = 0.5 * (v1.x + v2.x);
            var faceCenterY = 0.5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * tVec.x + (cLocalY - faceCenterY) * tVec.y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = tVec.x;
            manifold.m_localPlaneNormal.y = tVec.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
    }
    Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
    b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2NullContact.b2NullContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2NullContact.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this);
    }
    b2NullContact.prototype.Evaluate = function () {}
    Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndCircleContact.Create = function (allocator) {
        return new b2PolyAndCircleContact();
    }
    b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
    b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
    }
    b2PolyAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.m_body;
        var bB = this.m_fixtureB.m_body;
        b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndEdgeContact.Create = function (allocator) {
        return new b2PolyAndEdgeContact();
    }
    b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
    b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
    }
    b2PolyAndEdgeContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
    Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolygonContact.b2PolygonContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolygonContact.Create = function (allocator) {
        return new b2PolygonContact();
    }
    b2PolygonContact.Destroy = function (contact, allocator) {}
    b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2PolygonContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PositionSolverManifold.b2PositionSolverManifold = function () {};
    b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new b2Vec2();
        this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2PositionSolverManifold.prototype.Initialize = function (cc) {
        b2Settings.b2Assert(cc.pointCount > 0);
        var i = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        var tMat;
        var tVec;
        var planePointX = 0;
        var planePointY = 0;
        switch (cc.type) {
            case b2Manifold.e_circles:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.points[0].localPoint;
                var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1.0;
                    this.m_normal.y = 0.0;
                }
                this.m_points[0].x = 0.5 * (pointAX + pointBX);
                this.m_points[0].y = 0.5 * (pointAY + pointBY);
                this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].x = clipPointX;
                    this.m_points[i].y = clipPointY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyA.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].Set(clipPointX, clipPointY);
                }
                this.m_normal.x *= (-1);
                this.m_normal.y *= (-1);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
    });
})();
(function () {
    var b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
        b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
        b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
        b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

    Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
    b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2BuoyancyController.b2BuoyancyController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.normal = new b2Vec2(0, (-1));
        this.offset = 0;
        this.density = 0;
        this.velocity = new b2Vec2(0, 0);
        this.linearDrag = 2;
        this.angularDrag = 1;
        this.useDensity = false;
        this.useWorldGravity = true;
        this.gravity = null;
    };
    b2BuoyancyController.prototype.Step = function (step) {
        if (!this.m_bodyList) return;
        if (this.useWorldGravity) {
            this.gravity = this.GetWorld().GetGravity().Copy();
        }
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (body.IsAwake() == false) {
                continue;
            }
            var areac = new b2Vec2();
            var massc = new b2Vec2();
            var area = 0.0;
            var mass = 0.0;
            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
                var sc = new b2Vec2();
                var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
                area += sarea;
                areac.x += sarea * sc.x;
                areac.y += sarea * sc.y;
                var shapeDensity = 0;
                if (this.useDensity) {
                    shapeDensity = 1;
                }
                else {
                    shapeDensity = 1;
                }
                mass += sarea * shapeDensity;
                massc.x += sarea * sc.x * shapeDensity;
                massc.y += sarea * sc.y * shapeDensity;
            }
            areac.x /= area;
            areac.y /= area;
            massc.x /= mass;
            massc.y /= mass;
            if (area < Box2D.MIN_VALUE) continue;
            var buoyancyForce = this.gravity.GetNegative();
            buoyancyForce.Multiply(this.density * area);
            body.ApplyForce(buoyancyForce, massc);
            var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
            dragForce.Subtract(this.velocity);
            dragForce.Multiply((-this.linearDrag * area));
            body.ApplyForce(dragForce, areac);
            body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
        }
    }
    b2BuoyancyController.prototype.Draw = function (debugDraw) {
        var r = 1000;
        var p1 = new b2Vec2();
        var p2 = new b2Vec2();
        p1.x = this.normal.x * this.offset + this.normal.y * r;
        p1.y = this.normal.y * this.offset - this.normal.x * r;
        p2.x = this.normal.x * this.offset - this.normal.y * r;
        p2.y = this.normal.y * this.offset + this.normal.x * r;
        var color = new b2Color(0, 0, 1);
        debugDraw.DrawSegment(p1, p2, color);
    }
    Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantAccelController.b2ConstantAccelController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.A = new b2Vec2(0, 0);
    };
    b2ConstantAccelController.prototype.Step = function (step) {
        var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
        }
    }
    Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantForceController.b2ConstantForceController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.F = new b2Vec2(0, 0);
    };
    b2ConstantForceController.prototype.Step = function (step) {
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.ApplyForce(this.F, body.GetWorldCenter());
        }
    }
    b2Controller.b2Controller = function () {};
    b2Controller.prototype.Step = function (step) {}
    b2Controller.prototype.Draw = function (debugDraw) {}
    b2Controller.prototype.AddBody = function (body) {
        var edge = new b2ControllerEdge();
        edge.controller = this;
        edge.body = body;
        edge.nextBody = this.m_bodyList;
        edge.prevBody = null;
        this.m_bodyList = edge;
        if (edge.nextBody) edge.nextBody.prevBody = edge;
        this.m_bodyCount++;
        edge.nextController = body.m_controllerList;
        edge.prevController = null;
        body.m_controllerList = edge;
        if (edge.nextController) edge.nextController.prevController = edge;
        body.m_controllerCount++;
    }
    b2Controller.prototype.RemoveBody = function (body) {
        var edge = body.m_controllerList;
        while (edge && edge.controller != this)
            edge = edge.nextController;
        if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
        if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
        if (edge.nextController) edge.nextController.prevController = edge.prevController;
        if (edge.prevController) edge.prevController.nextController = edge.nextController;
        if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
        if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
        body.m_controllerCount--;
        this.m_bodyCount--;
    }
    b2Controller.prototype.Clear = function () {
        while (this.m_bodyList)
            this.RemoveBody(this.m_bodyList.body);
    }
    b2Controller.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Controller.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Controller.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2ControllerEdge.b2ControllerEdge = function () {};
    Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
    b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2GravityController.b2GravityController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.G = 1;
        this.invSqr = true;
    };
    b2GravityController.prototype.Step = function (step) {
        var i = null;
        var body1 = null;
        var p1 = null;
        var mass1 = 0;
        var j = null;
        var body2 = null;
        var p2 = null;
        var dx = 0;
        var dy = 0;
        var r2 = 0;
        var f = null;
        if (this.invSqr) {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Box2D.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
        else {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Box2D.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
    }
    Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
    b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2TensorDampingController.b2TensorDampingController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.T = new b2Mat22();
        this.maxTimestep = 0;
    };
    b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
        if (xDamping === undefined) xDamping = 0;
        if (yDamping === undefined) yDamping = 0;
        this.T.col1.x = (-xDamping);
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = (-yDamping);
        if (xDamping > 0 || yDamping > 0) {
            this.maxTimestep = 1 / Math.max(xDamping, yDamping);
        }
        else {
            this.maxTimestep = 0;
        }
    }
    b2TensorDampingController.prototype.Step = function (step) {
        var timestep = step.dt;
        if (timestep <= Box2D.MIN_VALUE) return;
        if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) {
                continue;
            }
            var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
        }
    }
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World;

    Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
    b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2DistanceJoint.b2DistanceJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u = new b2Vec2();
    };
    b2DistanceJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2DistanceJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
    }
    b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2DistanceJoint.prototype.GetLength = function () {
        return this.m_length;
    }
    b2DistanceJoint.prototype.SetLength = function (length) {
        if (length === undefined) length = 0;
        this.m_length = length;
    }
    b2DistanceJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2DistanceJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2DistanceJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_length = def.length;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = 0.0;
        this.m_gamma = 0.0;
        this.m_bias = 0.0;
    }
    b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        if (length > b2Settings.b2_linearSlop) {
            this.m_u.Multiply(1.0 / length);
        }
        else {
            this.m_u.SetZero();
        }
        var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
        var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
        var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
        this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
        if (this.m_frequencyHz > 0.0) {
            var C = length - this.m_length;
            var omega = 2.0 * Math.PI * this.m_frequencyHz;
            var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            this.m_gamma = step.dt * (d + step.dt * k);
            this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
            this.m_bias = C * step.dt * k * this.m_gamma;
            this.m_mass = invMass + this.m_gamma;
            this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            var PX = this.m_impulse * this.m_u.x;
            var PY = this.m_impulse * this.m_u.y;
            bA.m_linearVelocity.x -= bA.m_invMass * PX;
            bA.m_linearVelocity.y -= bA.m_invMass * PY;
            bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
            bB.m_linearVelocity.x += bB.m_invMass * PX;
            bB.m_linearVelocity.y += bB.m_invMass * PY;
            bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
        var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
        var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
        var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
        var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
        var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
        this.m_impulse += impulse;
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_linearVelocity.x -= bA.m_invMass * PX;
        bA.m_linearVelocity.y -= bA.m_invMass * PY;
        bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_linearVelocity.x += bB.m_invMass * PX;
        bB.m_linearVelocity.y += bB.m_invMass * PY;
        bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
    }
    b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        if (this.m_frequencyHz > 0.0) {
            return true;
        }
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(dX * dX + dY * dY);
        dX /= length;
        dY /= length;
        var C = length - this.m_length;
        C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
        var impulse = (-this.m_mass * C);
        this.m_u.Set(dX, dY);
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_sweep.c.x -= bA.m_invMass * PX;
        bA.m_sweep.c.y -= bA.m_invMass * PY;
        bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_sweep.c.x += bB.m_invMass * PX;
        bB.m_sweep.c.y += bB.m_invMass * PY;
        bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return b2Math.Abs(C) < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2DistanceJointDef.b2DistanceJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_distanceJoint;
        this.length = 1.0;
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
        var dX = anchorB.x - anchorA.x;
        var dY = anchorB.y - anchorA.y;
        this.length = Math.sqrt(dX * dX + dY * dY);
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
    b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2FrictionJoint.b2FrictionJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_linearMass = new b2Mat22();
        this.m_linearImpulse = new b2Vec2();
    };
    b2FrictionJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2FrictionJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
    }
    b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_angularImpulse;
    }
    b2FrictionJoint.prototype.SetMaxForce = function (force) {
        if (force === undefined) force = 0;
        this.m_maxForce = force;
    }
    b2FrictionJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxTorque = torque;
    }
    b2FrictionJoint.prototype.GetMaxTorque = function () {
        return this.m_maxTorque;
    }
    b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0.0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0.0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque;
    }
    b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var K = new b2Mat22();
        K.col1.x = mA + mB;
        K.col2.x = 0.0;
        K.col1.y = 0.0;
        K.col2.y = mA + mB;
        K.col1.x += iA * rAY * rAY;
        K.col2.x += (-iA * rAX * rAY);
        K.col1.y += (-iA * rAX * rAY);
        K.col2.y += iA * rAX * rAX;
        K.col1.x += iB * rBY * rBY;
        K.col2.x += (-iB * rBX * rBY);
        K.col1.y += (-iB * rBX * rBY);
        K.col2.y += iB * rBX * rBX;
        K.GetInverse(this.m_linearMass);
        this.m_angularMass = iA + iB;
        if (this.m_angularMass > 0.0) {
            this.m_angularMass = 1.0 / this.m_angularMass;
        }
        if (step.warmStarting) {
            this.m_linearImpulse.x *= step.dtRatio;
            this.m_linearImpulse.y *= step.dtRatio;
            this.m_angularImpulse *= step.dtRatio;
            var P = this.m_linearImpulse;
            bA.m_linearVelocity.x -= mA * P.x;
            bA.m_linearVelocity.y -= mA * P.y;
            bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
            bB.m_linearVelocity.x += mB * P.x;
            bB.m_linearVelocity.y += mB * P.y;
            bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
        }
        else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0.0;
        }
    }
    b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var maxImpulse = 0; {
            var Cdot = wB - wA;
            var impulse = (-this.m_angularMass * Cdot);
            var oldImpulse = this.m_angularImpulse;
            maxImpulse = step.dt * this.m_maxTorque;
            this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_angularImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse;
        } {
            var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
            var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
            var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
            var oldImpulseV = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(impulseV);
            maxImpulse = step.dt * this.m_maxForce;
            if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                this.m_linearImpulse.Normalize();
                this.m_linearImpulse.Multiply(maxImpulse);
            }
            impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
            vA.x -= mA * impulseV.x;
            vA.y -= mA * impulseV.y;
            wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
            vB.x += mB * impulseV.x;
            vB.y += mB * impulseV.y;
            wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
        }
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2FrictionJointDef.b2FrictionJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_frictionJoint;
        this.maxForce = 0.0;
        this.maxTorque = 0.0;
    }
    b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
    }
    Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
    b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2GearJoint.b2GearJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_J = new b2Jacobian();
    };
    b2GearJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2GearJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
    }
    b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        var tMat = this.m_bodyB.m_xf.R;
        var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
        var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
        var tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var PX = this.m_impulse * this.m_J.linearB.x;
        var PY = this.m_impulse * this.m_J.linearB.y;
        return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
    }
    b2GearJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2GearJoint.prototype.SetRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_ratio = ratio;
    }
    b2GearJoint.prototype.b2GearJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var type1 = parseInt(def.joint1.m_type);
        var type2 = parseInt(def.joint2.m_type);
        this.m_revolute1 = null;
        this.m_prismatic1 = null;
        this.m_revolute2 = null;
        this.m_prismatic2 = null;
        var coordinate1 = 0;
        var coordinate2 = 0;
        this.m_ground1 = def.joint1.GetBodyA();
        this.m_bodyA = def.joint1.GetBodyB();
        if (type1 == b2Joint.e_revoluteJoint) {
            this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        this.m_ground2 = def.joint2.GetBodyA();
        this.m_bodyB = def.joint2.GetBodyB();
        if (type2 == b2Joint.e_revoluteJoint) {
            this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        this.m_ratio = def.ratio;
        this.m_constant = coordinate1 + this.m_ratio * coordinate2;
        this.m_impulse = 0.0;
    }
    b2GearJoint.prototype.InitVelocityConstraints = function (step) {
        var g1 = this.m_ground1;
        var g2 = this.m_ground2;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var ugX = 0;
        var ugY = 0;
        var rX = 0;
        var rY = 0;
        var tMat;
        var tVec;
        var crug = 0;
        var tX = 0;
        var K = 0.0;
        this.m_J.SetZero();
        if (this.m_revolute1) {
            this.m_J.angularA = (-1.0);
            K += bA.m_invI;
        }
        else {
            tMat = g1.m_xf.R;
            tVec = this.m_prismatic1.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bA.m_xf.R;
            rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearA.Set((-ugX), (-ugY));
            this.m_J.angularA = (-crug);
            K += bA.m_invMass + bA.m_invI * crug * crug;
        }
        if (this.m_revolute2) {
            this.m_J.angularB = (-this.m_ratio);
            K += this.m_ratio * this.m_ratio * bB.m_invI;
        }
        else {
            tMat = g2.m_xf.R;
            tVec = this.m_prismatic2.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bB.m_xf.R;
            rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
            this.m_J.angularB = (-this.m_ratio * crug);
            K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
        }
        this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
        if (step.warmStarting) {
            bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
            bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
            bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
            bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
            bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
            bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
        var impulse = (-this.m_mass * Cdot);
        this.m_impulse += impulse;
        bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
    }
    b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var linearError = 0.0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var coordinate1 = 0;
        var coordinate2 = 0;
        if (this.m_revolute1) {
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        if (this.m_revolute2) {
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
        var impulse = (-this.m_mass * C);
        bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2GearJointDef.b2GearJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    };
    b2GearJointDef.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_gearJoint;
        this.joint1 = null;
        this.joint2 = null;
        this.ratio = 1.0;
    }
    b2Jacobian.b2Jacobian = function () {
        this.linearA = new b2Vec2();
        this.linearB = new b2Vec2();
    };
    b2Jacobian.prototype.SetZero = function () {
        this.linearA.SetZero();
        this.angularA = 0.0;
        this.linearB.SetZero();
        this.angularB = 0.0;
    }
    b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        this.linearA.SetV(x1);
        this.angularA = a1;
        this.linearB.SetV(x2);
        this.angularB = a2;
    }
    b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
    }
    b2Joint.b2Joint = function () {
        this.m_edgeA = new b2JointEdge();
        this.m_edgeB = new b2JointEdge();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
    };
    b2Joint.prototype.GetType = function () {
        return this.m_type;
    }
    b2Joint.prototype.GetAnchorA = function () {
        return null;
    }
    b2Joint.prototype.GetAnchorB = function () {
        return null;
    }
    b2Joint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return null;
    }
    b2Joint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2Joint.prototype.GetBodyA = function () {
        return this.m_bodyA;
    }
    b2Joint.prototype.GetBodyB = function () {
        return this.m_bodyB;
    }
    b2Joint.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Joint.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Joint.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Joint.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
    }
    b2Joint.Create = function (def, allocator) {
        var joint = null;
        switch (def.type) {
            case b2Joint.e_distanceJoint:
            {
                joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
            }
                break;
            case b2Joint.e_mouseJoint:
            {
                joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
            }
                break;
            case b2Joint.e_prismaticJoint:
            {
                joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
            }
                break;
            case b2Joint.e_revoluteJoint:
            {
                joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
            }
                break;
            case b2Joint.e_pulleyJoint:
            {
                joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
            }
                break;
            case b2Joint.e_gearJoint:
            {
                joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
            }
                break;
            case b2Joint.e_lineJoint:
            {
                joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
            }
                break;
            case b2Joint.e_weldJoint:
            {
                joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
            }
                break;
            case b2Joint.e_frictionJoint:
            {
                joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
            }
                break;
            default:
                break;
        }
        return joint;
    }
    b2Joint.Destroy = function (joint, allocator) {}
    b2Joint.prototype.b2Joint = function (def) {
        b2Settings.b2Assert(def.bodyA != def.bodyB);
        this.m_type = def.type;
        this.m_prev = null;
        this.m_next = null;
        this.m_bodyA = def.bodyA;
        this.m_bodyB = def.bodyB;
        this.m_collideConnected = def.collideConnected;
        this.m_islandFlag = false;
        this.m_userData = def.userData;
    }
    b2Joint.prototype.InitVelocityConstraints = function (step) {}
    b2Joint.prototype.SolveVelocityConstraints = function (step) {}
    b2Joint.prototype.FinalizeVelocityConstraints = function () {}
    b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return false;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
        Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
        Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
        Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
        Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
        Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
        Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
        Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
        Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
        Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
        Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
        Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
        Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
        Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
    });
    b2JointDef.b2JointDef = function () {};
    b2JointDef.prototype.b2JointDef = function () {
        this.type = b2Joint.e_unknownJoint;
        this.userData = null;
        this.bodyA = null;
        this.bodyB = null;
        this.collideConnected = false;
    }
    b2JointEdge.b2JointEdge = function () {};
    Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
    b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2LineJoint.b2LineJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat22();
        this.m_impulse = new b2Vec2();
    };
    b2LineJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2LineJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
    }
    b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2LineJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2LineJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2LineJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2LineJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2LineJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2LineJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2LineJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2LineJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2LineJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2LineJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2LineJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2LineJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2LineJoint.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce;
    }
    b2LineJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2LineJoint.prototype.b2LineJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2LineJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            this.m_motorMass = this.m_motorMass > Box2D.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.y = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
            }
            var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
            var f2r = 0;
            if (this.m_K.col1.x != 0.0) {
                f2r = b / this.m_K.col1.x + f1.x;
            }
            else {
                f2r = f1.x;
            }
            this.m_impulse.x = f2r;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y * this.m_a1;
            L2 = df.x * this.m_s2 + df.y * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = 0;
            if (this.m_K.col1.x != 0.0) {
                df2 = ((-Cdot1)) / this.m_K.col1.x;
            }
            else {
                df2 = 0.0;
            }
            this.m_impulse.x += df2;
            PX = df2 * this.m_perp.x;
            PY = df2 * this.m_perp.y;
            L1 = df2 * this.m_s1;
            L2 = df2 * this.m_s2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec2();
        var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1));
        angularError = 0.0;
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve(impulse, (-C1), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var impulse1 = 0;
            if (k11 != 0.0) {
                impulse1 = ((-C1)) / k11;
            }
            else {
                impulse1 = 0.0;
            }
            impulse.x = impulse1;
            impulse.y = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2LineJointDef.b2LineJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2LineJointDef.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_lineJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
    }
    Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
    b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2MouseJoint.b2MouseJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.m_localAnchor = new b2Vec2();
        this.m_target = new b2Vec2();
        this.m_impulse = new b2Vec2();
        this.m_mass = new b2Mat22();
        this.m_C = new b2Vec2();
    };
    b2MouseJoint.prototype.GetAnchorA = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
    }
    b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2MouseJoint.prototype.GetTarget = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.SetTarget = function (target) {
        if (this.m_bodyB.IsAwake() == false) {
            this.m_bodyB.SetAwake(true);
        }
        this.m_target = target;
    }
    b2MouseJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
        if (maxForce === undefined) maxForce = 0;
        this.m_maxForce = maxForce;
    }
    b2MouseJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2MouseJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2MouseJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2MouseJoint.prototype.b2MouseJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_target.SetV(def.target);
        var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
        var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
        var tMat = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
        this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
        this.m_maxForce = def.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_beta = 0.0;
        this.m_gamma = 0.0;
    }
    b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var mass = b.GetMass();
        var omega = 2.0 * Math.PI * this.m_frequencyHz;
        var d = 2.0 * mass * this.m_dampingRatio * omega;
        var k = mass * omega * omega;
        this.m_gamma = step.dt * (d + step.dt * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
        this.m_beta = step.dt * k * this.m_gamma;
        var tMat;tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var invMass = b.m_invMass;
        var invI = b.m_invI;this.K1.col1.x = invMass;
        this.K1.col2.x = 0.0;
        this.K1.col1.y = 0.0;
        this.K1.col2.y = invMass;
        this.K2.col1.x = invI * rY * rY;
        this.K2.col2.x = (-invI * rX * rY);
        this.K2.col1.y = (-invI * rX * rY);
        this.K2.col2.y = invI * rX * rX;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
        b.m_angularVelocity *= 0.98;
        this.m_impulse.x *= step.dtRatio;
        this.m_impulse.y *= step.dtRatio;
        b.m_linearVelocity.x += invMass * this.m_impulse.x;
        b.m_linearVelocity.y += invMass * this.m_impulse.y;
        b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
    }
    b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var tMat;
        var tX = 0;
        var tY = 0;
        tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rX + tMat.col2.x * rY);
        rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
        var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
        tMat = this.m_mass;
        tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
        var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
        var oldImpulseX = this.m_impulse.x;
        var oldImpulseY = this.m_impulse.y;
        this.m_impulse.x += impulseX;
        this.m_impulse.y += impulseY;
        var maxImpulse = step.dt * this.m_maxForce;
        if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
        }
        impulseX = this.m_impulse.x - oldImpulseX;
        impulseY = this.m_impulse.y - oldImpulseY;
        b.m_linearVelocity.x += b.m_invMass * impulseX;
        b.m_linearVelocity.y += b.m_invMass * impulseY;
        b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
    }
    b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2MouseJointDef.b2MouseJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.target = new b2Vec2();
    };
    b2MouseJointDef.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_mouseJoint;
        this.maxForce = 0.0;
        this.frequencyHz = 5.0;
        this.dampingRatio = 0.7;
    }
    Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PrismaticJoint.b2PrismaticJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat33();
        this.m_impulse = new b2Vec3();
    };
    b2PrismaticJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PrismaticJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
    }
    b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2PrismaticJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2PrismaticJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2PrismaticJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2PrismaticJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2PrismaticJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2PrismaticJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2PrismaticJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2PrismaticJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2PrismaticJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2PrismaticJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            if (this.m_motorMass > Box2D.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        var Cdot1Y = w2 - w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
            }
            var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
            var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
            var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
            f2r.x += f1.x;
            f2r.y += f1.y;
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            df.z = this.m_impulse.z - f1.z;
            PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
            L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
            this.m_impulse.x += df2.x;
            this.m_impulse.y += df2.y;
            PX = df2.x * this.m_perp.x;
            PY = df2.x * this.m_perp.y;
            L1 = df2.x * this.m_s1 + df2.y;
            L2 = df2.x * this.m_s2 + df2.y;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec3();
        var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
        var C1Y = a2 - a1 - this.m_refAngle;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
        angularError = b2Math.Abs(C1Y);
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var k12 = i1 * this.m_s1 + i2 * this.m_s2;
            var k22 = i1 + i2;
            this.m_K.col1.Set(k11, k12, 0.0);
            this.m_K.col2.Set(k12, k22, 0.0);
            var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PrismaticJointDef.b2PrismaticJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_prismaticJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.referenceAngle = 0.0;
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PulleyJoint.b2PulleyJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u1 = new b2Vec2();
        this.m_u2 = new b2Vec2();
    };
    b2PulleyJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PulleyJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
    }
    b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2PulleyJoint.prototype.GetGroundAnchorA = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a;
    }
    b2PulleyJoint.prototype.GetGroundAnchorB = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a;
    }
    b2PulleyJoint.prototype.GetLength1 = function () {
        var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetLength2 = function () {
        var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_ratio = def.ratio;
        this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
        this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
        this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
        this.m_impulse = 0.0;
        this.m_limitImpulse1 = 0.0;
        this.m_limitImpulse2 = 0.0;
    }
    b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(p1X - s1X, p1Y - s1Y);
        this.m_u2.Set(p2X - s2X, p2Y - s2Y);
        var length1 = this.m_u1.Length();
        var length2 = this.m_u2.Length();
        if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
        }
        else {
            this.m_u1.SetZero();
        }
        if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
        }
        else {
            this.m_u2.SetZero();
        }
        var C = this.m_constant - length1 - this.m_ratio * length2;
        if (C > 0.0) {
            this.m_state = b2Joint.e_inactiveLimit;
            this.m_impulse = 0.0;
        }
        else {
            this.m_state = b2Joint.e_atUpperLimit;
        }
        if (length1 < this.m_maxLength1) {
            this.m_limitState1 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse1 = 0.0;
        }
        else {
            this.m_limitState1 = b2Joint.e_atUpperLimit;
        }
        if (length2 < this.m_maxLength2) {
            this.m_limitState2 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse2 = 0.0;
        }
        else {
            this.m_limitState2 = b2Joint.e_atUpperLimit;
        }
        var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
        var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
        this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
        this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1.0 / this.m_limitMass1;
        this.m_limitMass2 = 1.0 / this.m_limitMass2;
        this.m_pulleyMass = 1.0 / this.m_pulleyMass;
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            this.m_limitImpulse1 *= step.dtRatio;
            this.m_limitImpulse2 *= step.dtRatio;
            var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
            var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
            var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
            var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        else {
            this.m_impulse = 0.0;
            this.m_limitImpulse1 = 0.0;
            this.m_limitImpulse2 = 0.0;
        }
    }
    b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = 0;
        var v1Y = 0;
        var v2X = 0;
        var v2Y = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var Cdot = 0;
        var impulse = 0;
        var oldImpulse = 0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
            impulse = this.m_pulleyMass * ((-Cdot));
            oldImpulse = this.m_impulse;
            this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
            impulse = this.m_impulse - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            P2X = (-this.m_ratio * impulse * this.m_u2.x);
            P2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
            impulse = (-this.m_limitMass1 * Cdot);
            oldImpulse = this.m_limitImpulse1;
            this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
            impulse = this.m_limitImpulse1 - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
            impulse = (-this.m_limitMass2 * Cdot);
            oldImpulse = this.m_limitImpulse2;
            this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
            impulse = this.m_limitImpulse2 - oldImpulse;
            P2X = (-impulse * this.m_u2.x);
            P2Y = (-impulse * this.m_u2.y);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
    }
    b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var p1X = 0;
        var p1Y = 0;
        var p2X = 0;
        var p2Y = 0;
        var length1 = 0;
        var length2 = 0;
        var C = 0;
        var impulse = 0;
        var oldImpulse = 0;
        var oldLimitPositionImpulse = 0;
        var tX = 0;
        var linearError = 0.0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length1 = this.m_u1.Length();
            length2 = this.m_u2.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.Multiply(1.0 / length1);
            }
            else {
                this.m_u1.SetZero();
            }
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.Multiply(1.0 / length2);
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_constant - length1 - this.m_ratio * length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_pulleyMass * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            p2X = (-this.m_ratio * impulse * this.m_u2.x);
            p2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            length1 = this.m_u1.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.x *= 1.0 / length1;
                this.m_u1.y *= 1.0 / length1;
            }
            else {
                this.m_u1.SetZero();
            }
            C = this.m_maxLength1 - length1;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass1 * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bA.SynchronizeTransform();
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length2 = this.m_u2.Length();
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.x *= 1.0 / length2;
                this.m_u2.y *= 1.0 / length2;
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_maxLength2 - length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass2 * C);
            p2X = (-impulse * this.m_u2.x);
            p2Y = (-impulse * this.m_u2.y);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bB.SynchronizeTransform();
        }
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
    });
    Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PulleyJointDef.b2PulleyJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.groundAnchorA = new b2Vec2();
        this.groundAnchorB = new b2Vec2();
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_pulleyJoint;
        this.groundAnchorA.Set((-1.0), 1.0);
        this.groundAnchorB.Set(1.0, 1.0);
        this.localAnchorA.Set((-1.0), 0.0);
        this.localAnchorB.Set(1.0, 0.0);
        this.lengthA = 0.0;
        this.maxLengthA = 0.0;
        this.lengthB = 0.0;
        this.maxLengthB = 0.0;
        this.ratio = 1.0;
        this.collideConnected = true;
    }
    b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
        if (r === undefined) r = 0;
        this.bodyA = bA;
        this.bodyB = bB;
        this.groundAnchorA.SetV(gaA);
        this.groundAnchorB.SetV(gaB);
        this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
        var d1X = anchorA.x - gaA.x;
        var d1Y = anchorA.y - gaA.y;
        this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
        var d2X = anchorB.x - gaB.x;
        var d2Y = anchorB.y - gaB.y;
        this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
        this.ratio = r;
        var C = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
        this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
    }
    Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
    b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2RevoluteJoint.b2RevoluteJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.K3 = new b2Mat22();
        this.impulse3 = new b2Vec3();
        this.impulse2 = new b2Vec2();
        this.reduced = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2RevoluteJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2RevoluteJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2RevoluteJoint.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
    }
    b2RevoluteJoint.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
    }
    b2RevoluteJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2RevoluteJoint.prototype.EnableLimit = function (flag) {
        this.m_enableLimit = flag;
    }
    b2RevoluteJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle;
    }
    b2RevoluteJoint.prototype.GetUpperLimit = function () {
        return this.m_upperAngle;
    }
    b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_lowerAngle = lower;
        this.m_upperAngle = upper;
    }
    b2RevoluteJoint.prototype.IsMotorEnabled = function () {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        return this.m_enableMotor;
    }
    b2RevoluteJoint.prototype.EnableMotor = function (flag) {
        this.m_enableMotor = flag;
    }
    b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2RevoluteJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxMotorTorque = torque;
    }
    b2RevoluteJoint.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque;
    }
    b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = 0.0;
        this.m_lowerAngle = def.lowerAngle;
        this.m_upperAngle = def.upperAngle;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
    }
    b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        if (this.m_enableMotor || this.m_enableLimit) {}
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
        this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
        this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
        this.m_mass.col3.y = r1X * i1 + r2X * i2;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = i1 + i2;
        this.m_motorMass = 1.0 / (i1 + i2);
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (this.m_enableLimit) {
            var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointAngle <= this.m_lowerAngle) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atLowerLimit;
            }
            else if (jointAngle >= this.m_upperAngle) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atUpperLimit;
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x;
            var PY = this.m_impulse.y;
            bA.m_linearVelocity.x -= m1 * PX;
            bA.m_linearVelocity.y -= m1 * PY;
            bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
            bB.m_linearVelocity.x += m2 * PX;
            bB.m_linearVelocity.y += m2 * PY;
            bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        var newImpulse = 0;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = w2 - w1 - this.m_motorSpeed;
            var impulse = this.m_motorMass * ((-Cdot));
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            w1 -= i1 * impulse;
            w2 += i2 * impulse;
        }
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            var Cdot2 = w2 - w1;
            this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
            if (this.m_limitState == b2Joint.e_equalLimits) {
                this.m_impulse.Add(this.impulse3);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse < 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse > 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            v1.x -= m1 * this.impulse3.x;
            v1.y -= m1 * this.impulse3.y;
            w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
            v2.x += m2 * this.impulse3.x;
            v2.y += m2 * this.impulse3.y;
            w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
        }
        else {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
            this.m_impulse.x += this.impulse2.x;
            this.m_impulse.y += this.impulse2.y;
            v1.x -= m1 * this.impulse2.x;
            v1.y -= m1 * this.impulse2.y;
            w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
            v2.x += m2 * this.impulse2.x;
            v2.y += m2 * this.impulse2.y;
            w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var oldLimitImpulse = 0;
        var C = 0;
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var angularError = 0.0;
        var positionError = 0.0;
        var tX = 0;
        var impulseX = 0;
        var impulseY = 0;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            var limitImpulse = 0.0;
            if (this.m_limitState == b2Joint.e_equalLimits) {
                C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
                angularError = b2Math.Abs(C);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                C = angle - this.m_lowerAngle;
                angularError = (-C);
                C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
                limitImpulse = (-this.m_motorMass * C);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                C = angle - this.m_upperAngle;
                angularError = C;
                C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
            }
            bA.m_sweep.a -= bA.m_invI * limitImpulse;
            bB.m_sweep.a += bB.m_invI * limitImpulse;
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        } {
            tMat = bA.m_xf.R;
            var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            var CLengthSquared = CX * CX + CY * CY;
            var CLength = Math.sqrt(CLengthSquared);
            positionError = CLength;
            var invMass1 = bA.m_invMass;
            var invMass2 = bB.m_invMass;
            var invI1 = bA.m_invI;
            var invI2 = bB.m_invI;
            var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
            if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
                var uX = CX / CLength;
                var uY = CY / CLength;
                var k = invMass1 + invMass2;
                var m = 1.0 / k;
                impulseX = m * ((-CX));
                impulseY = m * ((-CY));
                var k_beta = 0.5;
                bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
                bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
                bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
                bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
                CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
                CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            }
            this.K1.col1.x = invMass1 + invMass2;
            this.K1.col2.x = 0.0;
            this.K1.col1.y = 0.0;
            this.K1.col2.y = invMass1 + invMass2;
            this.K2.col1.x = invI1 * r1Y * r1Y;
            this.K2.col2.x = (-invI1 * r1X * r1Y);
            this.K2.col1.y = (-invI1 * r1X * r1Y);
            this.K2.col2.y = invI1 * r1X * r1X;
            this.K3.col1.x = invI2 * r2Y * r2Y;
            this.K3.col2.x = (-invI2 * r2X * r2Y);
            this.K3.col1.y = (-invI2 * r2X * r2Y);
            this.K3.col2.y = invI2 * r2X * r2X;
            this.K.SetM(this.K1);
            this.K.AddM(this.K2);
            this.K.AddM(this.K3);
            this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
            impulseX = b2RevoluteJoint.tImpulse.x;
            impulseY = b2RevoluteJoint.tImpulse.y;
            bA.m_sweep.c.x -= bA.m_invMass * impulseX;
            bA.m_sweep.c.y -= bA.m_invMass * impulseY;
            bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
            bB.m_sweep.c.x += bB.m_invMass * impulseX;
            bB.m_sweep.c.y += bB.m_invMass * impulseY;
            bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
    });
    Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2RevoluteJointDef.b2RevoluteJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_revoluteJoint;
        this.localAnchorA.Set(0.0, 0.0);
        this.localAnchorB.Set(0.0, 0.0);
        this.referenceAngle = 0.0;
        this.lowerAngle = 0.0;
        this.upperAngle = 0.0;
        this.maxMotorTorque = 0.0;
        this.motorSpeed = 0.0;
        this.enableLimit = false;
        this.enableMotor = false;
    }
    b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
    b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2WeldJoint.b2WeldJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2WeldJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2WeldJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2WeldJoint.prototype.b2WeldJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new b2Mat33();
    }
    b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_impulse.z *= step.dtRatio;
            bA.m_linearVelocity.x -= mA * this.m_impulse.x;
            bA.m_linearVelocity.y -= mA * this.m_impulse.y;
            bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
            bB.m_linearVelocity.x += mB * this.m_impulse.x;
            bB.m_linearVelocity.y += mB * this.m_impulse.y;
            bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
        }
    }
    b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
        var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
        var Cdot2 = wB - wA;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
        this.m_impulse.Add(impulse);
        vA.x -= mA * impulse.x;
        vA.y -= mA * impulse.y;
        wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        vB.x += mB * impulse.x;
        vB.y += mB * impulse.y;
        wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
        var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
        var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
        var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
        var angularError = b2Math.Abs(C2);
        if (positionError > k_allowedStretch) {
            iA *= 1.0;
            iB *= 1.0;
        }
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        bA.m_sweep.c.x -= mA * impulse.x;
        bA.m_sweep.c.y -= mA * impulse.y;
        bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        bB.m_sweep.c.x += mB * impulse.x;
        bB.m_sweep.c.y += mB * impulse.y;
        bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2WeldJointDef.b2WeldJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2WeldJointDef.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_weldJoint;
        this.referenceAngle = 0.0;
    }
    b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
})();
(function () {
    var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
    b2DebugDraw.b2DebugDraw = function () {
        this.m_drawScale = 1.0;
        this.m_lineThickness = 1.0;
        this.m_alpha = 1.0;
        this.m_fillAlpha = 1.0;
        this.m_xformScale = 1.0;
        var __this = this;
        //#WORKAROUND
        this.m_sprite = {
            graphics: {
                clear: function () {
                    __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
                }
            }
        };
    };
    b2DebugDraw.prototype._color = function (color, alpha) {
        return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
    };
    b2DebugDraw.prototype.b2DebugDraw = function () {
        this.m_drawFlags = 0;
    };
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags = flags;
    };
    b2DebugDraw.prototype.GetFlags = function () {
        return this.m_drawFlags;
    };
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags |= flags;
    };
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags &= ~flags;
    };
    b2DebugDraw.prototype.SetSprite = function (sprite) {
        this.m_ctx = sprite;
    };
    b2DebugDraw.prototype.GetSprite = function () {
        return this.m_ctx;
    };
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
        this.m_drawScale = drawScale;
    };
    b2DebugDraw.prototype.GetDrawScale = function () {
        return this.m_drawScale;
    };
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
        this.m_lineThickness = lineThickness;
        this.m_ctx.strokeWidth = lineThickness;
    };
    b2DebugDraw.prototype.GetLineThickness = function () {
        return this.m_lineThickness;
    };
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_alpha = alpha;
    };
    b2DebugDraw.prototype.GetAlpha = function () {
        return this.m_alpha;
    };
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_fillAlpha = alpha;
    };
    b2DebugDraw.prototype.GetFillAlpha = function () {
        return this.m_fillAlpha;
    };
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
        this.m_xformScale = xformScale;
    };
    b2DebugDraw.prototype.GetXFormScale = function () {
        return this.m_xformScale;
    };
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (!radius) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (!radius) return;
        var s = this.m_ctx,
            drawScale = this.m_drawScale,
            cx = center.x * drawScale,
            cy = center.y * drawScale;
        s.moveTo(0, 0);
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
        s.moveTo(cx, cy);
        s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.beginPath();
        s.moveTo(p1.x * drawScale, p1.y * drawScale);
        s.lineTo(p2.x * drawScale, p2.y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawTransform = function (xf) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(0xff0000, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

        s.strokeStyle = this._color(0xff00, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
        s.closePath();
        s.stroke();
    };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;

if (typeof require !== 'undefined' && typeof module !== 'undefined') {
    module.exports = Box2D;
}
    
window.b2Color = Box2D.Common.b2Color,
window.b2internal = Box2D.Common.b2internal,
window.b2Settings = Box2D.Common.b2Settings,
window.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
window.b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
window.b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
window.b2MassData = Box2D.Collision.Shapes.b2MassData,
window.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
window.b2Shape = Box2D.Collision.Shapes.b2Shape,
window.b2Mat22 = Box2D.Common.Math.b2Mat22,
window.b2Mat33 = Box2D.Common.Math.b2Mat33,
window.b2Math = Box2D.Common.Math.b2Math,
window.b2Sweep = Box2D.Common.Math.b2Sweep,
window.b2Transform = Box2D.Common.Math.b2Transform,
window.b2Vec2 = Box2D.Common.Math.b2Vec2,
window.b2Vec3 = Box2D.Common.Math.b2Vec3,
window.b2Body = Box2D.Dynamics.b2Body,
window.b2BodyDef = Box2D.Dynamics.b2BodyDef,
window.b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
window.b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
window.b2ContactListener = Box2D.Dynamics.b2ContactListener,
window.b2ContactManager = Box2D.Dynamics.b2ContactManager,
window.b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
window.b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
window.b2FilterData = Box2D.Dynamics.b2FilterData,
window.b2Fixture = Box2D.Dynamics.b2Fixture,
window.b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
window.b2Island = Box2D.Dynamics.b2Island,
window.b2TimeStep = Box2D.Dynamics.b2TimeStep,
window.b2World = Box2D.Dynamics.b2World,
window.b2AABB = Box2D.Collision.b2AABB,
window.b2Bound = Box2D.Collision.b2Bound,
window.b2BoundValues = Box2D.Collision.b2BoundValues,
window.b2Collision = Box2D.Collision.b2Collision,
window.b2ContactID = Box2D.Collision.b2ContactID,
window.b2ContactPoint = Box2D.Collision.b2ContactPoint,
window.b2Distance = Box2D.Collision.b2Distance,
window.b2DistanceInput = Box2D.Collision.b2DistanceInput,
window.b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
window.b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
window.b2DynamicTree = Box2D.Collision.b2DynamicTree,
window.b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
window.b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
window.b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
window.b2Manifold = Box2D.Collision.b2Manifold,
window.b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
window.b2Point = Box2D.Collision.b2Point,
window.b2RayCastInput = Box2D.Collision.b2RayCastInput,
window.b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
window.b2Segment = Box2D.Collision.b2Segment,
window.b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
window.b2Simplex = Box2D.Collision.b2Simplex,
window.b2SimplexCache = Box2D.Collision.b2SimplexCache,
window.b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
window.b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
window.b2TOIInput = Box2D.Collision.b2TOIInput,
window.b2WorldManifold = Box2D.Collision.b2WorldManifold,
window.b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
window.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
window.b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
window.b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
window.b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
window.b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
window.b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
window.b2Joint = Box2D.Dynamics.Joints.b2Joint,
window.b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
window.b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
window.b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
window.b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
window.b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
window.b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
window.b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
window.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
window.b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
window.b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
window.b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
window.b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
window.b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
window.b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

/*
 * File:   ui-weixin.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  WeiXin Settings/Events
 * 
 * Copyright (c) 2015 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWeixin 
 * @extends UIElement 
 * 微信设置控件。配置成功后可以调用微信JSAPI。导出游戏到自己的服务器上运行，需要提供自己的配置文件URL。
 * 
 * 使用自己的配置文件URL请参考：https://github.com/drawapp8/GameWiki/wiki/Wechat-JSSDK-wiki
 *
 * 微信JSAPI: http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html
 *
 */
function UIWeixin() {
	return;
}

UIWeixin.prototype = new UIElement();
UIWeixin.prototype.isUIWeixin = true;
UIWeixin.prototype.saveProps = ["configURL", "shareTitle", "shareDesc", "shareLink", "shareImage", 
		"apiList", "debug"];

UIWeixin.prototype.initUIWeixin = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setCanRectSelectable(false, true);

	return this;
}

UIWeixin.prototype.onAppendedInParent = function() {
	TangideApp.addUserScript("http://res.wx.qq.com/open/js/jweixin-1.0.0.js");

	return;
}

UIWeixin.jsApiList = [
        'checkJsApi',
        'onMenuShareTimeline',
        'onMenuShareAppMessage',
        'onMenuShareQQ',
        'onMenuShareWeibo',
        'hideMenuItems',
        'showMenuItems',
        'hideAllNonBaseMenuItem',
        'showAllNonBaseMenuItem',
        'translateVoice',
        'startRecord',
        'stopRecord',
        'onRecordEnd',
        'playVoice',
        'pauseVoice',
        'stopVoice',
        'uploadVoice',
        'downloadVoice',
        'chooseImage',
        'previewImage',
        'uploadImage',
        'downloadImage',
        'getNetworkType',
        'openLocation',
        'getLocation',
        'hideOptionMenu',
        'showOptionMenu',
        'closeWindow',
        'scanQRCode',
        'chooseWXPay',
        'openProductSpecificView',
        'addCard',
        'chooseCard',
        'openCard'
      ];

UIWeixin.prototype.getConfig = function(configURL, jsApiList, debug) {
	if(UIWeixin.config) {
		return;
	}
	else {
		UIWeixin.config = {};
	}

	httpGetJSON(configURL, function onDone(data) {
		UIWeixin.config = data;

		if(UIWeixin.config) {
			UIWeixin.config.jsApiList = jsApiList;
			UIWeixin.config.debug = debug;
			console.log("Fetch UIWeixin.config success:");
		}
		else {
			console.log("Fetch weixin config failed.");
			return;
		}

		function callWeiXinConfig() {
			try {
				wx.config(UIWeixin.config);
				UIWeixin.configDone = true;
				console.log(JSON.stringify(UIWeixin.config, null, "\t"));
				console.log("Call wx.config done:");
			}
			catch(e) {
				console.log("wx script is not load yet, try to config lator:");
				setTimeout(callWeiXinConfig, 100);
			}
		}

		if(isWeiXin()) {
			console.log("Is WeiXin, try to config it.");
			callWeiXinConfig();
		}
		else {
			console.log("It is not weixin browser");
		}
	});
}

UIWeixin.prototype.onFromJsonDone = function() {
	var url = window.btoa(location.href);
	var configURL = null;

	if(location.href.indexOf('i5r.com.cn') >= 0) {
		configURL = this.configURL ? this.configURL : "/weixin/php/json_config.php";
	}
	else {
		configURL = this.configURL ? this.configURL : "/wechat/config";
	}

	if(configURL.indexOf("?") > 0) {
		configURL = configURL + "&url=" + url;
	}
	else {
		configURL = configURL + "?url=" + url;
	}

	var jsApiList = UIWeixin.jsApiList;
	if(this.apiList) {
		jsApiList = this.apiList.split("\n");
	}

	this.getConfig(configURL, jsApiList, this.debug);

	return;
}

UIWeixin.prototype.onInit = function() {
	var me = this;
	if(!window.wx) {
		console.log("UIWeixin.prototype.onInit wx not defined.");
		return;
	}

	wx.ready(function () {
		UIWeixin.ready = true;
		me.updateShareInfo();
		console.log("wx.ready");
	});

	wx.error(function (res) {
	});

	console.log("UIWeixin.prototype.onInit end");

	return;
}

UIWeixin.prototype.onDeinit = function() {

	return;
}

UIWeixin.prototype.shapeCanBeChild = function(shape) {
	return false;
}

/**
 * @method setShareTitle
 * 设置分享标题。
 * @param {String} shareTitle 分享标题。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareTitle = function(shareTitle) {
	this.shareTitle = shareTitle;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareDesc
 * 设置分享描述。
 * @param {String} shareDesc 分享描述。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareDesc = function(shareDesc) {
	this.shareDesc = shareDesc;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareLink
 * 设置分享链接。
 * @param {String} shareLink 分享链接。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareLink = function(shareLink) {
	this.shareLink = shareLink;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareImage
 * 设置分享图片。
 * @param {String} shareImage 分享图片。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareImage = function(shareImage) {
	this.shareImage = shareImage;
	this.updateShareInfo();

	return this;
}

UIWeixin.prototype.updateShareInfo = function() { 
	if(!window.wx) {
		return;
	}

	var view = this.view;
	var title = this.shareTitle ? this.shareTitle : view.getAppName();
	var desc = this.shareDesc ? this.shareDesc : view.getAppDesc();
	var link = this.shareLink ? this.shareLink : location.href;
	var imgUrl = ResLoader.toAbsURL(this.shareImage ? this.shareImage : view.getAppIcon());

	var info = {
		title: title,
		desc: desc,
		link: link,
		imgUrl: imgUrl,
		trigger: function (res) {
			console.log("weixin operation trigger:" + JSON.stringify(res));
		},
		success: function (res) {
			console.log("weixin operation success:" + JSON.stringify(res));
		},
		cancel: function (res) {
			console.log("weixin operation cancel:" + JSON.stringify(res));
		},
		fail: function (res) {
			console.log("weixin operation fail:" + JSON.stringify(res));
		}
	};

    wx.onMenuShareAppMessage(info);
    wx.onMenuShareTimeline(info);
    wx.onMenuShareQQ(info);
    wx.onMenuShareWeibo(info);

	return;
}

function UIWeixinCreator() {
	var args = ["ui-weixin", "ui-weixin", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWeixin();
		return g.initUIWeixin(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIWeixinCreator());

if(!window.CanTK) {
	window.CanTK = {};
}

CanTK.isOldIE = isOldIE;
CanTK.isTizen = isTizen;
CanTK.isMobile = isMobile;
CanTK.isAndroid = isAndroid;
CanTK.isFirefoxOS = isFirefoxOS;
CanTK.delayLoadScripts = delayLoadScripts;
CanTK.initViewPort = cantkInitViewPort;
CanTK.restoreViewPort = cantkRestoreViewPort;
CanTK.httpGetURL = httpGetURL;	
CanTK.httpGetJSON = httpGetJSON;	
CanTK.httpDoRequest = httpDoRequest;	

CanTK.LinearInterpolator = LinearInterpolator;
CanTK.BounceInterpolator = BounceInterpolator;
CanTK.AccelerateInterpolator = AccelerateInterpolator;
CanTK.AccDecelerateInterpolator = AccDecelerateInterpolator;
CanTK.DecelerateInterpolator = DecelerateInterpolator;
CanTK.detectDeviceConfig = cantkDetectDeviceConfig;
CanTK.regShapeCreator = cantkRegShapeCreator;
CanTK.ShapeCreator = ShapeCreator;

window.isOldIE = isOldIE;
window.isTizen = isTizen;
window.isMobile = isMobile;
window.isAndroid = isAndroid;
window.isFirefoxOS = isFirefoxOS;
window.httpGetURL = httpGetURL;	
window.httpGetJSON = httpGetJSON;	
window.httpDoRequest = httpDoRequest;	
window.cantkInitViewPort = cantkInitViewPort;
window.cantkRestoreViewPort = cantkRestoreViewPort;
window.cantkRegisterUIElements = cantkRegisterUIElements;	
window.cantkGetViewPort = cantkGetViewPort;

window.Shape = Shape;
window.UIElement = UIElement;
window.UIWindowManager = UIWindowManager;
window.ShapeFactory = ShapeFactory;

CanTK.UIImage = UIImage;
CanTK.Physics = Physics;

CanTK.Shape = Shape;
CanTK.UIElement = UIElement;

CanTK.init = function () {
	return cantkRegisterUIElements();
}

CanTK.createElement = function(type) {
	return ShapeFactoryGet().createShape(type, C_CREATE_FOR_PROGRAM);
}

CanTK.createElementWithJson = function(data) {
	var type = data.type;
	var el = ShapeFactoryGet().createShape(type, C_CREATE_FOR_PROGRAM);

	if(el) {
		el.fromJson(data);
		el.setMode(Shape.MODE_RUNNING, true);
	}

	return el;
}

CanTK.UIElement.RUNNING = Shape.MODE_RUNNING;
CanTK.UIElement.DEFAULT_IMAGE = UIElement.IMAGE_DEFAULT;

CanTK.setResRoot = function(resRoot) {
	return ResLoader.setResRoot(resRoot);
}


/**
 * @class HolaSDK
 * HolaSDK。广告，分享和统计等API。
 *
 * 所有函数通过HolaSDK直接调用。示例：
 * 
 *     @example small frame
 *     HolaSDK.exit()
 *
 */
function HolaSDK() {
}

HolaSDK.exec = function(action, options) {
	if(window.HolaF) {
		window.HolaF(action, options);
		console.log("HolaSDK.exec:" + action + ":" + (options ? JSON.stringify(options) : "{}"));
	}
	else {
		console.log("HolaSDK.exec(e):" + action + ":" + (options ? JSON.stringify(options) : "{}"));
	}
}

HolaSDK.init = function(appID, debug) {
	if(HolaSDK.initialized) {
		return;
	}

	var options = {};
	options.app_id = appID;
	options.debug = debug;

	HolaSDK.appID = appID;
	HolaSDK.initialized = true;
	HolaSDK.startTime = Date.now();
	HolaSDK.exec('GameJsAdSdk.init', options);
	console.log("HolaSDK.init done");
}

/**
 * @method showAd
 * 显示广告(一般不需要直接调用)。
 * @param {String} placementID 位置ID。
 * @param {Number} placementType 类型。 
 * @param {Number} impressionTime 显示时间。
 * @param {Boolean} closable 是否可关闭。
 *
 */
HolaSDK.showAd = function(placementID, placementType, impressionTime, closable) {
	var options = {};
	options.placement_id = HolaSDK.appID + '_' + placementID;
	options.placement_type = placementType;
	options.impression_time = impressionTime;
	options.closable = closable;

	HolaSDK.exec('GameJsAdSdk.showAd', options);
}

/**
 * @method closeAd
 * 关闭广告(一般不需要直接调用)。
 */
HolaSDK.closeAd = function() {
    if(!HolaSDK.initialized) return;
	HolaSDK.exec('GameJsAdSdk.closeAd');
}

/**
 * @method share
 * 分享(在分享按钮的Click事件中填写相应参数即可)。
 * @param {String} title 标题。
 * @param {String} description 描述。
 * @param {String} link 链接。
 * @param {String} icon 图标。
 *
 */
HolaSDK.share = function(title, description, link, icon) {
	var options = {};
	options.title = title;
	options.description = description;

	HolaSDK.exec('share', options);
}

HolaSDK.fixTime = function(duration) {
	if(duration > 1000) {
		duration = duration/1000;
	}

	return duration;
}

/**
 * @method sendBarrage
 * 发送弹幕。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.sendBarrage = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Barrage.send', options);
}

/**
 * @method ping
 * 更新游戏状态。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.ping = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Barrage.ping', options);
}

HolaSDK.onPaused = function() {
	if(HolaSDK.onPausedCallback) {
		HolaSDK.onPausedCallback();
	}
}

/**
 * @method whenPaused
 * 注册暂停事件的回调函数。
 * @param {Function} callback 
 *
 */
HolaSDK.whenPaused = function(callback) {
	HolaSDK.onPausedCallback = callback;

	HolaSDK.exec('Game.Event.onPause', HolaSDK.onPaused);
}

HolaSDK.onResumed = function() {
	if(HolaSDK.onResumedCallback) {
		HolaSDK.onResumedCallback();
	}
}

/**
 * @method whenResumed
 * 注册恢复事件的回调函数。
 * @param {Function} callback 
 *
 */
HolaSDK.whenResumed = function(callback) {
	HolaSDK.onResumedCallback = callback;

	HolaSDK.exec('Game.Event.onResume', HolaSDK.onResumed);
}

HolaSDK.onRestarted = function() {
	if(HolaSDK.onRestartedCallback) {
		HolaSDK.onRestartedCallback();
	}
}

/**
 * @method whenRestarted
 * 注册重玩事件的回调函数。游戏盒子上的Replay按钮被按下时触发本事件。
 * @param {Function} callback 
 *
 */
HolaSDK.whenRestarted = function(callback) {
	HolaSDK.onRestartedCallback = callback;

	HolaSDK.exec('Game.Event.onRestart', HolaSDK.onRestarted);
}

/**
 * @method gameStarted
 * 游戏开始时调用(用于更新统计信息)。
 * @param {Number} level 当前关数。
 *
 */
HolaSDK.gameStarted = function(level) {
	var options = {};
	options.level = level;

	HolaSDK.exec('Game.Status.start', options);
}

/**
 * @method gamePaused
 * 游戏暂停时调用(用于更新统计信息)。
 *
 */
HolaSDK.gamePaused = function() {
	HolaSDK.exec('Game.Status.pause');
}

/**
 * @method gameResumed
 * 游戏恢复时调用(用于更新统计信息)。
 *
 */
HolaSDK.gameResumed = function() {
	HolaSDK.exec('Game.Status.resume');
}

/**
 * @method gameOver
 * 游戏结束时调用(用于更新统计信息)。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.gameOver = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Game.Status.over', options);
}

HolaSDK.gameRestarted = function() {
	console.log("HolaSDK.gameRestarted is not supported now!!!");
}

HolaSDK.gameExited = function() {
	HolaSDK.exec('Game.Status.exit');
}

/**
 * @method exit
 * 退出游戏，返回游戏大厅。
 *
 */
HolaSDK.exit = function() {
	HolaSDK.exec('Game.exit');
}


HolaSDK.getSDKURL = function() {
    return "http://game-ad-sdk.haloapps.com/static/abyhola/sdk/js_ad_sdk_loader.js?v=034";
}

window.HolaSDK = HolaSDK;

/*
 * File: view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief: view
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TView() {
}

TView.prototype = new WWidget();

TView.prototype.init = function(parent, x, y, w, h) {
	WWidget.prototype.init.call(this, parent, x, y, w, h);

	this.scale = 1;
	this.wmRect = {};
	this.lastPointerPosition = {x:0, y:0};
	this.pointerDownPosition = {x:0, y:0};

	return this;
}

TView.prototype.setDoc = function(doc) {
	this.doc = doc;

	return this;
}

TView.prototype.loadJson = function(json) {
	return this.doc.loadJson(json);
}

TView.prototype.loadString = function(str) {
	return this.doc.loadString(str);
}

TView.prototype.loadURL = function(url) {
	return this.doc.loadURL(url);
}

TView.prototype.getDeviceConfig = function() {
	return this.doc.getDeviceConfig();
}

TView.prototype.getWindowManager = function() {
	return this.doc.getWindowManager();
}

TView.prototype.getCurrentWindow = function() {
	return this.doc.getCurrentWindow();
}

TView.prototype.getMetaInfo = TView.prototype.getMeta = function() {
	return this.doc.getMeta();
}

TView.prototype.getMoveDeltaX = function() {
	return this.moveDeltaX;
}

TView.prototype.getMoveDeltaY = function() {
	return this.moveDeltaY;
}

TView.prototype.getMoveAbsDeltaX = function() {
	return this.moveAbsDeltaX;
}

TView.prototype.getMoveAbsDeltaY = function() {
	return this.moveAbsDeltaY;
}

TView.prototype.updateLastPointerPoint = function(point, pointerDown) {
	if(pointerDown) {
		this.pointerDownPosition.x = point.x;
		this.pointerDownPosition.y = point.y;
	}

	this.moveDeltaX = point.x - this.lastPointerPosition.x;
	this.moveDeltaY = point.y - this.lastPointerPosition.y;
	this.moveAbsDeltaX = point.x - this.pointerDownPosition.x;
	this.moveAbsDeltaY = point.y - this.pointerDownPosition.y;
	this.lastPointerPosition.x = point.x;
	this.lastPointerPosition.y = point.y;

	return;
}

TView.prototype.autoScale = function() {
	var wm = this.getWindowManager();

	if(!wm) return;
	
	var scale = 1;
	var w = this.getWidth();
	var h = this.getHeight();
	
	if(wm.w < wm.h) {
		scale = h/(wm.h+100);
	}
	else {
		scale = w/(wm.w+100);
	}

	if(scale > 1) {
		scale = 1;
	}

	this.zoomTo(scale);

	return;
}

TView.prototype.getScale = function() {
	return this.scale;
}

TView.prototype.onScaled = function(scale) {
	return;
}

TView.prototype.zoomTo = TView.prototype.setScale = function(scale) {

	this.scale = Math.min(2, Math.max(0.5, Math.round(scale * 10)/10));
	this.onScaled(this.scale);

	return this;
}

TView.prototype.zoomIn = function() {
	return this.zoomTo(this.scale * 1.2);
}

TView.prototype.zoomOut = function() {
	return this.zoomTo(this.scale * 0.8);
}

TView.prototype.getWmRect = function() {
	var r = this.wmRect;
	var wm = this.getWindowManager();
	if(wm) {
		var w = this.getWidth();
		var h = this.getHeight();
		r.w = wm.w * this.scale;
		r.h = wm.h * this.scale;
		r.x = (w - r.w) >> 1;
		r.y = (h - r.h) >> 1;
	}
	else {
		r.x = 0;
		r.y = 0;
		r.w = 0;
		r.h = 0;
	}

	return r;
}

TView.prototype.paintSelf = function(canvas) {
	var w = this.getWidth();
	var h = this.getHeight();

	canvas.save();
	canvas.beginPath();
	canvas.rect(0, 0, w, h);
	canvas.clip();
	canvas.beginPath();	

	var wm = this.getWindowManager();
	if(wm) {
		var r = this.getWmRect();	
		canvas.translate(r.x, r.y);
		canvas.scale(this.scale, this.scale);
		wm.setLeftTop(0, 0);
		wm.paintSelf(canvas);
	}
	canvas.restore();

	return;
}

TView.prototype.translatePointToWm = function(point) {
	var r = this.getWmRect();
	var pos = this.translatePoint(point);
	var p = {x:pos.x-r.x, y:pos.y-r.y};
			
	p.x = p.x/this.scale;
	p.y = p.y/this.scale;

	return p;
}

TView.prototype.onDoubleClick = function(point) {
	this.updateLastPointerPoint(point, true);

	WWidget.prototype.onDoubleClick.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);

			wm.onDoubleClick(p);
		}
	}

	return;
}

TView.prototype.onPointerDown = function(point) {
	this.updateLastPointerPoint(point, true);

	WWidget.prototype.onPointerDown.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);

			wm.onPointerDown(p);
		}
	}

	return;
}

TView.prototype.onPointerMove = function(point) {
	this.updateLastPointerPoint(point);
	WWidget.prototype.onPointerMove.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);
			wm.onPointerMove(p);
		}
	}

	return;
}

TView.prototype.onPointerUp = function(point) {
	WWidget.prototype.onPointerUp.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);
			wm.onPointerUp(p);
		}
	}

	return;
}

TView.prototype.onKeyDown = function(code) {
	WWidget.prototype.onKeyDown.call(this, code);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			wm.onKeyDown(code);
		}
	}

	return;
}

TView.prototype.onKeyUp = function(code) {
	WWidget.prototype.onKeyUp.call(this, code);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			wm.onKeyUp(code);
		}
	}

	return;
}

TView.prototype.detectDeviceConfig = function() {
	return this.doc.detectDeviceConfig();
}
/*
 * File: document.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: document
 *
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 *
 */

function TDocument() {
}

TDocument.magic = "cantk";
TDocument.prototype.loadURL = function(url) {
	httpGetJSON(url, this.loadJson.bind(this));

	return this;
}

TDocument.prototype.loadString = function(str) {
	try {
		var json = JSON.parse(str);
		this.loadJson(json);
	}catch(e) {
		console.log("loadString:" + e.message);
	}

	return this;
}

TDocument.prototype.getEmptyDoc = function() {
	var doc = {};
	doc.version = 2;
	doc.magic = TDocument.magic;

	return doc;
}

TDocument.prototype.getLocales = function() {
	if(!this.doc.locales) {
		this.doc.locales = {
			"default":{},
			"en":{},
			"zh": {}
		};
	}

	return this.doc.locales;
}

TDocument.prototype.getAssetsConfig = function() {
	var meta = this.getMeta();

	return meta.assetsConfig || TDocument.getDefaultAssetsConfig();
}

TDocument.prototype.getAssetsConfigStr = function() {
	var config = this.getAssetsConfig();

	return JSON.stringify(config, null, "\t");
}

TDocument.prototype.setAssetsConfigStr = function(str) {
	try {
		var config = JSON.parse(str);
		this.setAssetsConfig(config);
	}catch(e) {
		console.log("setAssetsConfigStr:" + e.message);
	}

	return this;
}

TDocument.prototype.setAssetsConfig = function(config) {
	var meta = this.getMeta();
	meta.assetsConfig = config;

	return this;
}

TDocument.getDefaultAssetsConfig = function() {
	if(!TDocument.defaultAssetsConfig) {
		var c = {};
		c.assets = {};
		c.assets.sizes = ["1280x800", "480x800"];
		c.assets.densities = ["hdpi", "xhdpi"];
		c.assets.languages = ["en", "zh"]

		c.design = {};
		c.design.size = "480x800";
		c.design.density = "hdpi";
		c.design.language = "en";

		c.map = {}
		c.map.size = {
			"1280x720":"480x800",
			"480x800":"480x800"
		};
		c.map.density = {
			"ldpi":"hdpi",
			"mdpi":"hdpi",
			"xhdpi":"hdpi",
			"xxhdpi":"hdpi"
		};
		c.map.language = {
			"en":"en",
			"zh":"en"
		}

		TDocument.defaultAssetsConfig = c;
	}

	return TDocument.defaultAssetsConfig;
}

TDocument.prototype.setLocales = function(locales) {
	this.doc.locales = locales;

	return this;
}

TDocument.prototype.getMetaInfo = TDocument.prototype.getMeta = function() {
	return this.doc.meta;
}

TDocument.prototype.getDocID = function() {
	return this.doc.docid;
}

TDocument.prototype.getDeviceConfig = function() {
	return this.wm.deviceConfig;
}

TDocument.prototype.loadV1 = function(json) {
	if(!json.pages || !json.pages[0].shapes || !json.pages[0].shapes[0].children) {
		return this;
	}

	var doc = this.getEmptyDoc();
	doc.meta = json.meta;
	doc.docid = json.docid;

	var device = json.pages[0].shapes[0];
	function forEach(shape) {

		if(shape.type === "ui-window-manager") {
			doc.wm = shape;

			return;
		}

		if(shape.children) {
			var n = shape.children.length;
			for(var i = 0; i < n; i++) {
				var iter = shape.children[i];
				forEach(iter);
			}
		}
	}

	forEach(device);

	doc.deviceConfig = device.config;
	this.loadV2(doc);

	return ;
}

TDocument.prototype.createWindowManager = function(json) {
	var factory = ShapeFactory.getInstance();
	var wm = factory.createShapeByProgram(json.wm.type);

	wm.fromJson(json.wm);
	wm.deviceConfig = json.deviceConfig;

	return wm;
}

TDocument.prototype.onBeforeLoad = function(json) {
}

TDocument.prototype.loadV2 = function(json) {
	this.doc = json;

	this.onBeforeLoad(json);
	this.wm = this.createWindowManager(json);

	var meta = this.getMeta();
    if(meta && meta.general) {
        document.title = meta.general.appname;
    }
	if(meta && meta.extfonts) {
		ResLoader.loadFonts(meta.extfonts);
	}


    var keys = ["soundMusicAutoPlay", "soundMusicLoop", "soundMusicVolume",
        "soundMusicURLs", "soundEffectsEnalbe", "soundEffectVolume", "soundEffectURLs"];
    keys.forEach(function(it) {
        if(it in json.wm) {
            this.wm[it] = json.wm[it];
        }
    }, this);

    var wm = this.wm;
    if(meta && meta.soundConfig) {
        var keys = ["soundMusicAutoPlay", "soundMusicLoop", "soundMusicVolume", "soundMusicURLs", "soundEffectsEnalbe", "soundEffectVolume", "soundEffectURLs"];
        keys.forEach(function(key) {
            wm[key] = meta.soundConfig[key];
        })

        wm.setSoundMusicVolume(wm.soundMusicVolume);
        wm.setSoundEffectVolume(wm.soundEffectVolume);
    }

	this.onLoad();

	return;
}

TDocument.prototype.loadJson = function(json) {
	if(!json) return this;

	if(json.magic === "drawapps") {
		this.loadV1(json);
	}
	else if(json.magic === TDocument.magic) {
		this.loadV2(json);
	}
    else if(json.code === 302) {
        window.location.href = json.data;
    }
	else {
		console.log("invalid json");
	}

	return this;
}

TDocument.prototype.getWindowManager = function() {
	return this.wm;
}

TDocument.prototype.getCurrentWindow = function() {
	return this.wm ? this.wm.getCurrentWindow() : null;
}

TDocument.prototype.detectDeviceConfig = function() {
	if(this.detectedDeviceConfig) {
		return this.detectedDeviceConfig;
	}

	var deviceConfig = {version:4};

	if(isAndroid()) {
		deviceConfig.platform = "android";
	}
	else if(isIPhone () || isIPad()) {
		deviceConfig.platform = "iphone";
	}
	else if(isFirefoxOS()) {
		deviceConfig.platform = "firefox";
	}
	else if(isWinPhone()) {
		deviceConfig.platform = "winphone";
	}
	else if(isTizen()) {
		deviceConfig.platform = "tizen";
	}
	else {
		deviceConfig.platform = "android";
	}

	if(window.devicePixelRatio > 2.2) {
		deviceConfig.lcdDensity = "xxhdpi";
	}
	else if(window.devicePixelRatio > 1.5) {
		deviceConfig.lcdDensity = "xhdpi";
	}
	else if(window.devicePixelRatio > 1.1) {
		deviceConfig.lcdDensity = "hdpi";
	}
	else if(window.devicePixelRatio > 0.8) {
		deviceConfig.lcdDensity = "mdpi";
	}
	else if(!window.devicePixelRatio) {
		var minSize = Math.min(window.orgViewPort.width, window.orgViewPort.height);
		if(minSize > 600) {
			deviceConfig.lcdDensity = "xhdpi";
		}
		else {
			deviceConfig.lcdDensity = "hdpi";
		}
	}
	else {
		deviceConfig.lcdDensity = "ldpi";
	}

	if(isFirefoxOS()) {
		deviceConfig.lcdDensity = "mdpi";
	}

	if(!isMobile()) {
		deviceConfig.lcdDensity = "hdpi";
	}

	this.detectedDeviceConfig = deviceConfig;
	console.log("deviceConfig.lcdDensity:" + deviceConfig.lcdDensity);
	console.log("deviceConfig.platform:" + deviceConfig.platform);

	return deviceConfig;
}

/*
 * File: runtime_view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  runtime view 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TRuntimeView() {
}

TRuntimeView.prototype = new TView();
TRuntimeView.prototype.init = function(parent, x, y, w, h, app) {
	this.app = app;
	this.type = "app-view";
	TView.prototype.init.call(this, parent, x, y, w, h);
	
	this.preview = app.preview;
	this.setDoc(new TRuntimeDocument());

	this.doc.onLoad = this.onLoad.bind(this);
	WWindowManager.onMultiTouch = this.onMultiTouch.bind(this);

	return this;
}

TRuntimeView.prototype.onMultiTouch = function(action, points, event) {
	var wm = this.getWindowManager();
	if(wm) {
		wm.onMultiTouch(action, points, event);
	}
}

TRuntimeView.prototype.resizeForFixWidth = function(wm) {
	var vp = cantkGetViewPort();
	var scale = wm.w/vp.width;
	var w = wm.w;
	var h = vp.height * scale;

	var styleW = vp.width;
	var styleH = vp.height;

	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.setSize(w, h);
	wm.relayout();
}

TRuntimeView.prototype.resizeForFixHeight = function(wm) {
	var vp = cantkGetViewPort();
	var scale = wm.h/vp.height;
	var h = wm.h;
	var w = vp.width * scale;

	var styleW = vp.width;
	var styleH = vp.height;

	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.setSize(w, h);
	wm.relayout();
}

TRuntimeView.prototype.resizeForFixResolution = function(wm) {
	var vp = cantkGetViewPort();
	var scalex = wm.w/vp.width;
	var scaley = wm.h/vp.height;
	var scale = Math.max(scalex, scaley);
	var w = scale * vp.width;
	var h = scale * vp.height;
	var styleW = vp.width;
	var styleH = vp.height;
	var x = (w - wm.w) >> 1;
	var y = (h - wm.h) >> 1;

	wm.setLeftTop(x, y);
	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.relayout();
}

TRuntimeView.prototype.translatePointToWm = function(point) {
	return point;
}

TRuntimeView.prototype.resizeForAuto = function(wm) {
	var vp = cantkGetViewPort();
	wm.setSize(vp.width, vp.height);
	wm.relayout();
}

TRuntimeView.prototype.adjustWMSizePositionPreview = function(wm) {
	wm.setLeftTop(0, 0);
	this.resizeForFixResolution(wm);
}

TRuntimeView.prototype.adjustWMSizePositionRun = function(wm) {
	var meta = this.getMeta();
	var general = meta.general;
	var orientation = general.orientation;

	wm.forcePortrait = false;
	wm.forceLandscape = false;
	var designWidth = this.designWidth;
	var designHeight = this.designHeight;

	if(orientation === "landscape" && designWidth > designHeight) {
		wm.forceLandscape = true;
	}
	else if(orientation === "portrait" && designHeight > designWidth) {
		wm.forcePortrait = true;
	}
	wm.screenScaleMode = general.screenscale; 
	
	wm.setLeftTop(0, 0);
	switch(wm.screenScaleMode) {
		case "fix-width": {
			this.resizeForFixWidth(wm);
			break;
		}
		case "fix-height": {
			this.resizeForFixHeight(wm);
			break;
		}
		case "fix-resolution": {
			this.resizeForFixResolution(wm);
			break;
		}
		default: {
			this.resizeForAuto(wm);
			break;
		}
	}

	return;
}

TRuntimeView.prototype.adjustWMSizePosition = function() {
	var wm = this.getWindowManager();

	if(this.preview) {
		return this.adjustWMSizePositionPreview(wm);
	}
	else {
		return this.adjustWMSizePositionRun(wm);
	}
}

TRuntimeView.prototype.onLoad = function() {
	var wm = this.getWindowManager();
	
	//for preview current window
	if(window.cantkInitWindow !== undefined) {
		wm.setInitWindow(window.cantkInitWindow);
		console.log("window.cantkInitWindow:" + window.cantkInitWindow);
	}

    wm.setView(this);
    wm.setApp(this.app);
	wm.setMode(Shape.MODE_RUNNING, true);

	this.designWidth = wm.w;
	this.designHeight = wm.h;
	this.adjustWMSizePosition();
	this.run();
}

TRuntimeView.prototype.paintLoading = function(canvas) {
}

TRuntimeView.prototype.getViewScale = function() {
	return 1;
}

TRuntimeView.prototype.paintSelf = function(canvas) {
	var wm = this.getWindowManager();
	if(!wm) {
		this.paintLoading(canvas);

		return;
	}

	canvas.save();
	wm.paint(canvas);
	canvas.restore();

	var sx = wm.x;
	var sy = wm.y;
	var sw = wm.w;
	var sh = wm.h;
	var w = this.rect.w;
	var h = this.rect.h;

	canvas.beginPath();
	if(sy > 0) {
		canvas.rect(0, 0, w, sy);
	}
	if(sx > 0) {
		canvas.rect(0, 0, sx, h);
	}
	var r = sx + sw;
	var rw = w - r;
	if(rw > 0) {
		canvas.rect(r, 0, rw, h);
	}
	var b = sy + sh;
	var bh = h - b;
	if(bh > 0) {
		canvas.rect(0, b, w, bh);
	}

	if(sy > 0 || sx > 0 || rw > 0 || bh > 0) {
		canvas.fillStyle = wm.style.fillColor;
		canvas.fill();
	}

	return;
}

TRuntimeView.prototype.onGesture = function(gesture) {
	var curWin = wm.getCurrentWindow();

	curWin.onGesture(gesture);

	return;
}

TRuntimeView.prototype.getAppInfo = function() {
	var metaInfo = this.getMetaInfo();

	return metaInfo.general;
}

TRuntimeView.prototype.onLoadUserScriptsDone = function() {
	var appInfo = this.getAppInfo();
	HolaSDK.init(appInfo.appid, false);
	console.log("TRuntimeView.prototype.onLoadUserScriptsDone.");
}

TRuntimeView.prototype.loadUserScripts = function(meta) {
	if(meta) {
		var scripts = meta.extlibs;
		var force = window.location.href.indexOf("appid=preview") > 0;
		
		if(!scripts) {
			scripts = [];
		}

//		scripts.push(HolaSDK.getSDKURL());

        if(scripts.length > 0) {
            //make a sort
            var userLibs = [];
            var extLibs = [];
            scripts.forEach(function(script) {
                if(script.indexOf("read.php?") > 0 && script.indexOf("/libs/") > 0) {
                    userLibs.push(script);
                } else {
                    extLibs.push(script);
                }
            });
            userLibs.sort();
            scripts = extLibs.concat(userLibs);
        }
		
        if(scripts) {
			var arr = [];
			for(var i = 0; i < scripts.length; i++) {
				var iter = scripts[i];
				if(iter.indexOf("res.wx.qq.com") >= 0 && !isWeiXin()) {
					console.log("not weixin browser skip weixin jssdk");
					continue;
				}
				arr.push(iter);
			}

			if(arr.length) {
				ResLoader.loadScriptsSync(arr, this.onLoadUserScriptsDone.bind(this));
			}
		}
	}

	return;
}

TRuntimeView.prototype.paintBackground = function(canvas) {
}

TRuntimeView.prototype.startRedrawTimer = function(fps) {
	var fps = fps || 60;
	var dt = 1000/fps;
	var wm = WWindowManager.getInstance();

	setInterval(wm.postRedraw.bind(wm), dt);

	return;
}

TRuntimeView.prototype.run = function() {
	var meta = this.getMeta();
	var wm = this.getWindowManager();
	var runtimeConfig = this.detectDeviceConfig();

	if(this.preview) {
		runtimeConfig.lcdDensity = wm.deviceConfig.lcdDensity;
	}

	wm.setDeviceConfig(runtimeConfig);

	this.modifyTitle(meta);
	this.loadUserScripts(meta);
	if(meta && meta.extfonts) {
		ResLoader.loadFonts(meta.extfonts);
	}
	this.startRedrawTimer(meta.general.fps);

	wm.systemInit();
	wm.postRedraw();

	return;
}

TRuntimeView.prototype.modifyTitle = function(meta) {
	if(meta && meta.general) {
		var appname = meta.general.appname;

		document.title = appname;
		if(isIPhone() || isIPad()) {
			var tags = document.getElementsByTagName("title");
			if(tags && tags.length) {
				var title = tags[0];
				title.innerHTML = appname;
            }
		}
	}
}

TRuntimeView.create = function(parent, x, y, w, h, app) {
	var view = new TRuntimeView();
	return view.init(parent, x, y, w, h, app);
}

function dappGetText(text) {
	return text;
}

function dappIsEditorApp() {
	return false;
}

/*
 * File: runtime_document.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: runtime document 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TRuntimeDocument() {
}

TRuntimeDocument.prototype = new TDocument();

TRuntimeDocument.prototype.updateAssetsMapRule = function(assetsConfig) {
	var key = null;
	var mapped = assetsConfig.mapped;
	var runtime = assetsConfig.runtime;
	var design = assetsConfig.design;

	var mapLanguage = assetsConfig.map.language;
	for(key in mapLanguage) {
		if(runtime.language.indexOf(key) >= 0) {
			mapped.language = mapLanguage[key];
			break;
		}
	}
	if(!mapped.language) {
		mapped.language = design.language;
	}

	var mapSize = assetsConfig.map.size;
	for(key  in mapSize) {
		if(key === runtime.size) {
			mapped.size = mapSize[key];
		}
	}
	if(!mapped.size) {
		mapped.size = design.size;
	}

	var mapDensity = assetsConfig.map.density;
	for(key  in mapDensity) {
		if(key === runtime.density) {
			mapped.density = mapDensity[key];
		}
	}
	if(!mapped.density) {
		mapped.density = design.density;
	}

	return this;
}

TRuntimeDocument.prototype.fixAssetsConfig = function(assetsConfig) {
	var runtime = {};
	var vp = cantkGetViewPort();
	var config = this.detectDeviceConfig();

	runtime.width = vp.width;
	runtime.height = vp.height;
	runtime.density = config.lcdDensity;
	runtime.language = Locales.getLang();
	runtime.size = runtime.width+"x"+runtime.height;

	assetsConfig.mapped = {};
	assetsConfig.runtime = runtime;

	this.updateAssetsMapRule(assetsConfig);

	return this;
}

TRuntimeDocument.prototype.createWindowManager = function(json) {
	var assetsConfig = this.getAssetsConfig();
	if(assetsConfig) {
		this.fixAssetsConfig(assetsConfig);
		ResLoader.setAssetsConfig(assetsConfig);
		ResLoader.mapImageURL = this.mapAssetURL.bind(this);
	}

	return TDocument.prototype.createWindowManager.call(this, json);
}

TRuntimeDocument.prototype.applyLocales = function(json) {
	var stringTable = null;
	var locales = json.locales;
	var name = Locales.getLang();

	if(!locales) return;

	for(var key in locales) {
		var keys = key.toLowerCase().split(";");
		for(var i = 0; i < keys.length; i++) {
			var iter = keys[i];
			if(iter === name || name.startWith(iter)) {
				stringTable = locales[key];
				console.log("Matched locale:" + name + " ==> " + key);
				break;
			}
		}
		if(stringTable) break;
	}

	if(!stringTable) {
		stringTable = locales["default"];
		if(stringTable) {
			console.log("Matched locale:" + name + " ==> default");
		}
	}

	if(stringTable) {
		webappSetLocaleStrings(stringTable);
	}

	return;
}

TRuntimeDocument.prototype.onBeforeLoad = function(json) {
	this.applyLocales(json);
}

TRuntimeDocument.prototype.mapAssetURL = function(url, assetsConfig) {
	if(!assetsConfig || !url || url.length > 1024) {
		return url;
	}

	var design = assetsConfig.design;
	var mapped = assetsConfig.mapped;
	
	if(design.language !== mapped.language && url.indexOf(design.language) >= 0) {
		url = url.replace(new RegExp(design.language, "g"), mapped.language);
	}

	if(design.density !== mapped.density && url.indexOf(design.density) >= 0) {
		url = url.replace(new RegExp(design.density, "g"), mapped.density);
	}

	if(design.size !== mapped.size && url.indexOf(design.size) >= 0) {
		url = url.replace(new RegExp(design.size, "g"), mapped.size);
	}

	return url;
}

/*
 * File: webapp.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  web app.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TWebApp(preview) {
	document.body.style.overflow = "hidden";
	this.viewPort = cantkGetViewPort();

	this.preview = !!preview; 
	this.init(preview);

	return this;
}

TWebApp.prototype.prepareCanvas = function() {
	this.canvas	 = CantkRT.getMainCanvas();

	var canvas = this.canvas;
	var vp = cantkGetViewPort();
	var w = vp.width;
	var h = vp.height;

	canvas.width = w;
	canvas.height = h;
	canvas.style.width = w + "px";
	canvas.style.height = h + "px";

	this.manager = WWindowManager.create(this, this.canvas, this.canvas);

	return;
}

TWebApp.prototype.init = function() {
	this.prepareCanvas();
	var w = this.canvas.width;
	var h = this.canvas.height;

	var app = this;
	this.win = WWindow.create(this.manager, 0, 0, w, h);
	this.view = TRuntimeView.create(this.win, 0, 0, w, h, this);
	
	var view = this.view;
	this.win.paintBackground = function(canvas) {
	};
	
	this.win.onGesture = function(gesture) {
		return view.onGesture(gesture);
	};

	window.onresize = function() {
		setTimeout(app.onSizeChanged.bind(app), 50);
	}

	return;
}


TWebApp.prototype.resizeWin = function(w, h) {
	this.win.resize(w, h);
	this.view.resize(w, h);
}

TWebApp.prototype.resizeCanvas = function(w, h, x, y, styleW, styleH) {
	var canvas = this.canvas;

	canvas.style.position = "absolute";
	canvas.width = w;
	canvas.height = h;
	canvas.style.top = y + "px";
	canvas.style.left = x + "px";
	canvas.style.width = styleW + "px";
	canvas.style.height = styleH + "px";

	return;
}

TWebApp.prototype.onSizeChanged = function() {
	var viewPort = cantkGetViewPort();

	if(EditorElement.imeOpen) {
		console.log("EditorElement.imeOpen is true.");
		return;
	}

	if(viewPort.width === this.viewPort.width && viewPort.height === this.viewPort.height) {
		console.log("onSizeChanged: size is not changed.");
		return;
	}

	var w = viewPort.width;
	var h = viewPort.height;
	this.viewPort = viewPort;
	this.manager.resize(w, h);
	this.view.adjustWMSizePosition();
}

TWebApp.prototype.exitApp = function() {
	if(isTizen()) {
		tizen.application.getCurrentApplication().exit();
	}
	else if(navigator.app) {
		navigator.app.exitApp();
	}
	console.log("exitApp");
	return;
}

TWebApp.prototype.runWithURL = function(url) {
	this.view.loadURL(url);
	return this;
}

TWebApp.prototype.runWithData = function(json) {
	if(typeof json === "string") {
		this.view.loadString(json);
	}
	else {
		this.view.loadJson(json);
	}
	return this;
}

window.webappRunWithURL = function(url) {
	var app = new TWebApp();
	
	return app.runWithURL(url);
}

window.webappRunWithData = function(json) {
	var app = new TWebApp();
	
	return app.runWithData(json);
}

window.webappPreviewWithURL = function(url) {
	var app = new TWebApp(true);
	
	return app.runWithURL(url);
}

window.webappPreviewWithData = function(json) {
	var app = new TWebApp(true);
	
	return app.runWithData(json);
}

window.webappGetText = webappGetText;
window.webappSetLocaleStrings = webappSetLocaleStrings;

window.webappSnapshot = function() {
	var canvas = CantkRT.getMainCanvas();
	var dataURL = canvas.toDataURL();
	
	var image = {};
	image.src = dataURL;
	image.width = canvas.width;
	image.height = canvas.height;

	return image;
}


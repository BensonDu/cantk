
/*
 * File:    browser.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief:   detect browser
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function browser() {
}

browser.init = function() {
	var u = navigator.userAgent, app = navigator.appVersion;

	browser.ie9 = u.indexOf('MSIE 9.0') >=0;
	browser.ie10 = u.indexOf('MSIE 10.0') >=0;
	browser.ie = u.indexOf('MSIE') >=0 || u.indexOf('Trident') >=0;
	browser.oldIE = u.indexOf('MSIE 8.0') >=0||u.indexOf('MSIE 7.0') >=0 || u.indexOf('MSIE 6.0') >=0;
	browser.android = u.indexOf('Android') >=0 && u.indexOf('Linux') >=0;
	browser.iPhone = u.indexOf('iPhone') >=0;
	browser.iPad = u.indexOf('iPad') >=0;
	browser.blackberry = u.indexOf('BlackBerry') >=0;
	browser.firefoxMobile = u.indexOf('Mobile') >=0 && u.indexOf('Firefox') >=0;
	browser.firefoxOS = u.indexOf('Mobile') >=0 && u.indexOf('Firefox') >=0 && u.indexOf('Android') < 0;
	browser.windowPhone = u.indexOf('Windows Phone') >=0;
	browser.webkit = u.indexOf("WebKit") >=0;
	browser.weixin = u.indexOf("MicroMessenger") >= 0;
	browser.weibo = u.indexOf("weibo") >= 0;
	browser.qq = u.indexOf("QQ") >= 0;
	browser.linux = u.indexOf("Linux") >= 0;
	browser.windows = u.indexOf("Windows") >= 0;
	browser.macosx = u.indexOf("Mac OS X") >= 0;

	if(browser.iPhone) {
		var a = u.match(/iPhone; CPU iPhone OS \d+/g);
		if(a && a.length) {
			browser.iOSVersion = parseInt(a[0].match(/\d+/g)[0]);
		}
	}

	function getBrowserVersionNumber() {
		var ua = navigator.userAgent;
		var keys = ["AppleWebKit/", "AppleWebKit ", "AppleWebKit", "MSIE ", "Firefox/", 
			"Safari/", "Opera ", "Opera/"];

		for(var i = 0; i < keys.length; i++) {
			var iter = keys[i];
			var offset = ua.indexOf(iter);
			if(offset >= 0) {
				var str = ua.substr(offset + iter.length);
				var version = parseFloat(str);

				return version;
			}
		}

		return 1.0;
	}

	browser.number = getBrowserVersionNumber();

	browser.isAudioSupportLoop = true;
	if(browser.isIPhone && browser.iOSVersion < 6) {
		browser.isAudioSupportLoop = false;
	}

	if(browser.oldIE || browser.ie9) {
		window.console = {};
		window.console.log = function(str) {};
	}
	
	browser.isMobile = browser.android || browser.iPhone || browser.blackberry
		|| browser.windowPhone || browser.firefoxMobile || browser.iPad;

	if(browser.isMobile) {
		window.console.logStr = "";
		window.console.logR = window.console.log;

		window.console.getLog = function() {
			return window.console.logStr;
		}

		window.console.log = function(str) {
			window.console.logStr += str + "\n";
			window.console.logR(str);

			return;
		}
	}

	console.log(navigator.userAgent); 
	window.isSpecialBrowser = browser.qq || browser.weibo || browser.weixin;

	return;
}

function isQQ() {
	return browser.qq;
}

function isWeiBo() {
	return browser.weibo;
}

function isWeiXin() {
	return browser.weixin;
}

function isWebkit() {
	return browser.webkit;
}

function isOldIE() {
	return browser.oldIE;
}

function isIE() {
	return browser.ie;
}

if(browser.oldIE) {
	console.log("oldIE "+browser.oldIE);
}

function isMobile() {
	return browser.isMobile;
}

browser.isWindows = function() {
	return !browser.isMobile && browser.windows;
}

browser.isLinux = function() {
	return !browser.isMobile && browser.linux;
}

browser.isMacOSX = function() {
	return !browser.isMobile && browser.macosx;
}

function isAndroid() {
	return browser.android;
}

function isIPhone() {
	return browser.iPhone;
}

function isIPad() {
	return browser.iPad;
}

function isWinPhone() {
	return browser.windowPhone;
}

function isBlackBerry() {
	return browser.blackberry;
}

function isFirefoxMobile() {
	return browser.firefoxMobile;
}

function isFirefoxOS () {
	return browser.firefoxOS;
}

function isHolaPlay() {
	return window.cantkRTV8;
}

function isPhoneGap() {
	return (window.cordova || window.Cordova || window.PhoneGap || window.phonegap) 
		&& /^file:\/{3}[^\/]/i.test(window.location.href) 
		&& /ios|iphone|ipod|ipad|android/i.test(navigator.userAgent);
}

function isTizen() {
	return window.tizen;
}

function browserVersion() {
	return browser.number;
}

if (typeof KeyEvent === "undefined") {
    var KeyEvent = {
        DOM_VK_CANCEL: 3,
        DOM_VK_HELP: 6,
        DOM_VK_BACK_SPACE: 8,
        DOM_VK_TAB: 9,
        DOM_VK_CLEAR: 12,
        DOM_VK_RETURN: 13,
        DOM_VK_ENTER: 14,
        DOM_VK_SHIFT: 16,
        DOM_VK_CONTROL: 17,
        DOM_VK_ALT: 18,
        DOM_VK_PAUSE: 19,
        DOM_VK_CAPS_LOCK: 20,
        DOM_VK_ESCAPE: 27,
        DOM_VK_SPACE: 32,
        DOM_VK_PAGE_UP: 33,
        DOM_VK_PAGE_DOWN: 34,
        DOM_VK_END: 35,
        DOM_VK_HOME: 36,
        DOM_VK_LEFT: 37,
        DOM_VK_UP: 38,
        DOM_VK_RIGHT: 39,
        DOM_VK_DOWN: 40,
        DOM_VK_PRINTSCREEN: 44,
        DOM_VK_INSERT: 45,
        DOM_VK_DELETE: 46,
        DOM_VK_0: 48,
        DOM_VK_1: 49,
        DOM_VK_2: 50,
        DOM_VK_3: 51,
        DOM_VK_4: 52,
        DOM_VK_5: 53,
        DOM_VK_6: 54,
        DOM_VK_7: 55,
        DOM_VK_8: 56,
        DOM_VK_9: 57,
        DOM_VK_SEMICOLON: 59,
        DOM_VK_EQUALS: 61,
        DOM_VK_A: 65,
        DOM_VK_B: 66,
        DOM_VK_C: 67,
        DOM_VK_D: 68,
        DOM_VK_E: 69,
        DOM_VK_F: 70,
        DOM_VK_G: 71,
        DOM_VK_H: 72,
        DOM_VK_I: 73,
        DOM_VK_J: 74,
        DOM_VK_K: 75,
        DOM_VK_L: 76,
        DOM_VK_M: 77,
        DOM_VK_N: 78,
        DOM_VK_O: 79,
        DOM_VK_P: 80,
        DOM_VK_Q: 81,
        DOM_VK_R: 82,
        DOM_VK_S: 83,
        DOM_VK_T: 84,
        DOM_VK_U: 85,
        DOM_VK_V: 86,
        DOM_VK_W: 87,
        DOM_VK_X: 88,
        DOM_VK_Y: 89,
        DOM_VK_Z: 90,
        DOM_VK_CONTEXT_MENU: 93,
        DOM_VK_NUMPAD0: 96,
        DOM_VK_NUMPAD1: 97,
        DOM_VK_NUMPAD2: 98,
        DOM_VK_NUMPAD3: 99,
        DOM_VK_NUMPAD4: 100,
        DOM_VK_NUMPAD5: 101,
        DOM_VK_NUMPAD6: 102,
        DOM_VK_NUMPAD7: 103,
        DOM_VK_NUMPAD8: 104,
        DOM_VK_NUMPAD9: 105,
        DOM_VK_MULTIPLY: 106,
        DOM_VK_ADD: 107,
        DOM_VK_SEPARATOR: 108,
        DOM_VK_SUBTRACT: 109,
        DOM_VK_DECIMAL: 110,
        DOM_VK_DIVIDE: 111,
        DOM_VK_BACK_BUTTON: 115, /*F4*/
        DOM_VK_MENU_BUTTON: 118, /*F7*/
        DOM_VK_SEARCH_BUTTON: 120, /*F9*/
        DOM_VK_F1: 112,
        DOM_VK_F2: 113,
        DOM_VK_F3: 114,
        DOM_VK_F4: 115,
        DOM_VK_F5: 116,
        DOM_VK_F6: 117,
        DOM_VK_F7: 118,
        DOM_VK_F8: 119,
        DOM_VK_F9: 120,
        DOM_VK_F10: 121,
        DOM_VK_F11: 122,
        DOM_VK_F12: 123,
        DOM_VK_F13: 124,
        DOM_VK_F14: 125,
        DOM_VK_F15: 126,
        DOM_VK_F16: 127,
        DOM_VK_F17: 128,
        DOM_VK_F18: 129,
        DOM_VK_F19: 130,
        DOM_VK_F20: 131,
        DOM_VK_F21: 132,
        DOM_VK_F22: 133,
        DOM_VK_F23: 134,
        DOM_VK_F24: 135,
        DOM_VK_NUM_LOCK: 144,
        DOM_VK_SCROLL_LOCK: 145,
        DOM_VK_COMMA: 188,
        DOM_VK_PERIOD: 190,
        DOM_VK_SLASH: 191,
        DOM_VK_BACK_QUOTE: 192,
        DOM_VK_OPEN_BRACKET: 219,
        DOM_VK_BACK_SLASH: 220,
        DOM_VK_CLOSE_BRACKET: 221,
        DOM_VK_QUOTE: 222,
        DOM_VK_META: 224
    };
}
KeyEvent.DOM_VK_BACK = 225;

browser.init();

/*
 * File:    locales.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief:   functions to handle locale strings.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

Locales = {};

Locales.getLang = function() {
	var lang = navigator.language || navigator.userLanguage;

	return lang;
}

Locales.getLanguageName = Locales.getLang;

Locales.setTextTable = function(textTable) {
	Locales.textTable = textTable;

	return;
}

Locales.setLanguageSupportList = function(langList) {
    Locales.languageList = langList;
}

Locales.getLanguageSupportList = function() {
    return Locales.languageList;
}

Locales.getTextTable = function() {
	return Locales.textTable;
}

Locales.addTextTable = function(textTable) {
	if(!Locales.textTable) {
		Locales.textTable = {};
	}

	for(var key in textTable) {
		Locales.textTable[key] = textTable[key];
	}

	return;
}

Locales.getText = function(text) {
	var str = null;
	
	if(Locales.textTable) {
		str = Locales.textTable[text];
		if(!str) {
			Locales.textTable[text] = text;
		}
	}

	return str ? str : text;
}

window.dappGetText = function(text) {	
	return Locales.getText(text);
}

window.dappGetTitle = function(text) {	
	return dappGetText(text) + ":";
}

window.cantkGetLocale = function() {
	return Locales.getLang();
}
window.Locales = Locales;

/*
 * File:   cantk-rt.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  cantk runtime adapter
 * 
 * Copyright (c) 2015 - 2015 Tangram HD Inc.
 * 
 */
function CantkRT() {
}

CantkRT.init = function(onDeviceReady) {
	window.onload = onDeviceReady;
}

CantkRT.isNative = function() {
	return CantkRT.isCantkRTV8() || CantkRT.isCantkRTCordova();
}

CantkRT.isCantkRTV8 = function() {
	return !!window.cantkRTV8;
}

CantkRT.loadFont = function(name, url) {
	if(window.loadFont) {
		window.loadFont(name, url);
	}
	console.log("load font " + name + ":" + url);
}

CantkRT.isCantkRTCordova = function() {
	return !!window.cantkRTCordova;
}

CantkRT.getViewPort = function() {
	var width;
	var height;

	if(window.displayInfo) {
		width = window.displayInfo.width;
		height = window.displayInfo.height;
	}
	else if (typeof window.innerWidth != 'undefined'){
		width = window.innerWidth;
		height = window.innerHeight;
	}
	else if (typeof document.documentElement != 'undefined'
	&& typeof document.documentElement.clientWidth !=
	'undefined' && document.documentElement.clientWidth != 0)
	{
		width = document.documentElement.clientWidth;
		height = document.documentElement.clientHeight;
	}
	else{
		width = document.getElementsByTagName('body')[0].clientWidth;
		height = document.getElementsByTagName('body')[0].clientHeight;
	}
	
	return {width:width, height:height};
}

CantkRT.getMainCanvas = function() {
	var canvas = null;

	if(CantkRT.canvas) {
		return CantkRT.canvas;
	}

	canvas = document.getElementById('main_canvas');
	if(!canvas) {
		canvas = document.createElement("canvas");
		canvas.id = "main_canvas";
		canvas.style.zIndex = 0;
		document.body.appendChild(canvas);
	}

	if(canvas.setAsMainCanvas) {
		canvas.setAsMainCanvas();
	}

	if(!canvas.flush) {
		canvas.flush = function() {}
	}

	CantkRT.canvas = canvas;

	return canvas;
}

CantkRT.mainCanvasW = 0;
CantkRT.mainCanvasH = 0;
CantkRT.mainCanvasScale = {x:1, y:1};
CantkRT.mainCanvasPostion = {x:0, y:0};

CantkRT.moveMainCanvas = function(x, y) {
	var canvas = CantkRT.getMainCanvas();
	canvas.style.position = "absolute";
	canvas.style.top = y + "px";
	canvas.style.left = x + "px";
	CantkRT.mainCanvasPostion.x = x;
	CantkRT.mainCanvasPostion.y = y;
}

CantkRT.resizeMainCanvas = function(w, h, styleW, styleH) {
	var canvas = CantkRT.getMainCanvas();

	canvas.width = w;
	canvas.height = h;
	canvas.style.width = styleW + "px";
	canvas.style.height = styleH + "px";
	CantkRT.mainCanvasW = w;
	CantkRT.mainCanvasH = h;
	CantkRT.mainCanvasScale.x = w/styleW;
	CantkRT.mainCanvasScale.y = h/styleH;
}

CantkRT.getMainCanvasScale = function() {
	return CantkRT.mainCanvasScale;
}

CantkRT.getMainCanvasPosition = function() {
	return CantkRT.mainCanvasPostion;
}

CantkRT.isResSupportCrossOrgin = function(src) {
	if(src && src.indexOf("file://") < 0 
		&& src.indexOf("data:image") !== 0 
		&& src.indexOf("api.map.baidu.com") < 0 
		&& src.indexOf("maps.googleapis.com") < 0 
		&& src.indexOf(location.host) < 0) {
		return true;
	}
	else {
		return false;
	}
}

CantkRT.createImage = function(src, onLoad, onError) {
	var image = null;
	image = new Image();
	image.onload = function() {
		if(onLoad) {
			onLoad(image);
		}
	}
	
	image.onerror = function(e) {
		if(e) {
			console.log(this.src + " load error: " + e.message);
		}
		else {
			console.log(this.src + " load error");
		}

		if(image.crossOrigin) {
			var src = image.src;
			image.crossOrigin = null;
			image.src = null;
			image.src = src;
			console.log("try without image.crossOrigin:" + src);
			return;
		}

		if(onError) {
			onError(image);
		}

	}
	
	if(CantkRT.isResSupportCrossOrgin(src)) {
		image.crossOrigin = "Anonymous";
	}

	image.src = src;

	return image;
}

CantkRT.createImageFromCanvas = function(canvas, onLoad, onError) {
	if(!canvas) {
		if(onError) {
			onError();
		}

		return null;
	}

	if(onLoad) {
		onLoad(canvas);
	}

	return canvas;
}

window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame 
	|| window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

CantkRT.requestAnimFrame = function(callback) {
	return window.requestAnimationFrame(callback);
}

CantkRT.createSound = function(src, soundEffect, onDone, onFail) {
	var audio = new Audio();

	audio.setAsSoundEffect(soundEffect);
	audio.onload = function() {
		if(onDone) {
			onDone(audio);
		}
	}
	audio.onerror = function(e) {
		if(onFail) {
			onFail(e);
		}
	}
	audio.src = src;

	return audio;
}

CantkRT.createSoundEffect = function(src, onDone, onFail) {
	return CantkRT.createSound(src, true, onDone, onFail);
}

CantkRT.createSoundMusic = function(src, onDone, onFail) {
	return CantkRT.createSound(src, false, onDone, onFail);
}
/*
 * File: utils.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: some tool functions.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

Object.defineProperty(Array.prototype, 'remove', 
{
	enumerable: false,
	value: function(obj, all){
		for (var i=0; i < this.length; ++i ) {
			if ( this[i] === obj ) {
				this.splice(i, 1); 

				if(!all) 
				   break;
			}
		}
		
		return this;
	}
});

Object.defineProperty(Array.prototype, 'insert', 
{
	enumerable: false,
	value: function(index, obj){
		if(index >= 0 && index < this.length) {
			this.splice(index, 0, obj);
		}
		else {
			this.push(obj);
		}

		return this;
	}
});

Object.defineProperty(Array.prototype, 'indexOf', 
{
	enumerable: false,
	value: function(obj){
		var n = this.length;
		for (var i=0; i < n; ++i ) {
			if ( this[i] === obj ) {
				return i;
			}
		}
		
		return -1;
	}
});

Object.defineProperty(Array.prototype, 'find', 
{
	enumerable: false,
	value: function(checkIf){
		var n = this.length;
		for (var i=0; i < n; ++i ) {
			var  iter = this[i];
			if (checkIf(iter)) {
				return iter;
			}
		}

		return null;
	}
});


Object.defineProperty(Array.prototype, 'binarySearch', 
{
	enumerable: false,
	value: function(find, comparator){
		var i = 0;
		var low = 0;
		var comparison = 0; 
		var high = this.length - 1;

		while (low <= high) {
			i = (low + high) >> 1;
			comparison = comparator(this[i], find);
			if (comparison < 0) { low = i + 1; continue; };
			if (comparison > 0) { high = i - 1; continue; };

			return i;
		}

		return -1;
	}
});

Object.defineProperty(Array.prototype, 'has', 
{
	enumerable: false,
	value: function(obj){
    	return this.indexOf(obj) >= 0;
	}
});

Object.defineProperty(Array.prototype, 'destroyData', 
{
	enumerable: false,
	value: function(){
		for(var i = 0; i < this.length; i++) {
			var iter = this[i];

			if(!iter || typeof iter != "object") {
				continue;
			}

			if(iter.destroy && typeof iter.destroy == "function") {
				iter.destroy();
			}
		}

		this.length = 0;  

		return this;
	}
});

Object.defineProperty(Array.prototype, 'clear', 
{
	enumerable: false,
	value: function(destroyData){
		if(destroyData) {
			this.destroyData();
		}
		this.length = 0;  

		return this;
	}
});

Object.defineProperty(Array.prototype, 'copy', 
{
	enumerable: false,
	value: function(src){
		this.clear();

		for (var i= 0 ; i < src.length ; ++i ) {
			var obj = src[i];

			if(obj && obj.dup) {
				obj = obj.dup();
			}

			this.push(obj);	
		}

		return this;
	}
});

function makeUniqRandArray(start, end) {
	if(start >= end) {
		return null;
	}

	var arr = [];
	var range = end - start + 1;

	for(var i = 0; i < range; i++) {
		do {
			var num = start + Math.floor(Math.random() * range);
			if(!arr.has(num)) {
				arr.push(num);
				break;
			}
		}while(1);
	}
	
	return arr;
}

///////////////////////////////////////////////////////////////////

function fixRect(rect) {
	if(rect.w < 0) {
		rect.x = rect.x + rect.w;
		rect.w = -rect.w;
	}

	if(rect.h < 0) {
		rect.y = rect.y + rect.h;
		rect.h = -rect.h;
	}

	return rect;
}

function isPointInRect(point, rect) {
    return point.x >= rect.x
        && point.y >= rect.y
        && point.x < (rect.x + rect.w)
        && point.y < (rect.y + rect.h);
}


function cantkAddEventListener(name, handler) {
	if (window.attachEvent) {
		//IE and Opera
		window.attachEvent(name, handler);
	} else if (window.addEventListener) {
		// IE 6
		window.addEventListener(name, handler);
	} else {
		//FireFox
		document.addEventListener(name, handler, true);
	}

	return;
}

String.prototype.replaceAll = function(reallyDo, replaceWith, ignoreCase) {   
	if (!RegExp.prototype.isPrototypeOf(reallyDo)) {   
		return this.replace(new RegExp(reallyDo, (ignoreCase ? "gi": "g")), replaceWith);   
	}
	 else {   
	 	return this.replace(reallyDo, replaceWith);   
	 }   
}   

/*WordPress convert " to “ ”, we need convert it back.*/
function fixJson(json) {
	var i = 0;
	var str = "";

	json = json.replaceAll("<br>", "");
	
	var n = json.length;
	for(i = 0; i < n; i++) {
		var c = json.charAt(i);

		if(c === '“' || c === '”') {
			c = '"';
		}

		str = str + c;
	}

	return str;
}

String.prototype.trim = function() 
{
	return String(this).replace(/^\s+|\s+$|^\n+|\n+$/g, '');
}

String.prototype.startWith = function(str){var t=this;return t.indexOf(str) == 0;};

String.prototype.endWith = function(str){var t = this;return t.substring(t.length-str.length,t.length) == str;};

String.prototype.isImageFileName = function(){
	var t = this.toLowerCase();

	return t.endWith(".png") || t.endWith(".jpg") || t.endWith("jpeg");
};

function drawDashedRect(canvas, x, y, w, h) {
	var f = 8;
	var e = 4;

	canvas.beginPath();
	drawDashedLine(canvas, {x:x, y:y}, {x:w+x, y:y}, f, e);
	drawDashedLine(canvas, {x:x, y:h+y}, {x:w+x, y:h+y}, f, e);
	drawDashedLine(canvas, {x:x, y:y}, {x:x, y:h+y}, f, e);
	drawDashedLine(canvas, {x:w+x, y:y}, {x:w+x, y:h+y}, f, e);

	return;
}

function drawDashedLine(canvas, start_p, end_p, f, e) {
	if(!canvas || !start_p || !end_p || !f) return;
	

	var x = start_p.x;
	var y = start_p.y;
	
	canvas.moveTo(x, y);
	if(!e) {
		canvas.lineTo(end_p.x, end_p.y);
		
		return;
	}
	
	var dx = end_p.x - start_p.x;
	var dy = end_p.y - start_p.y;
	var length = Math.sqrt(dx*dx + dy*dy);	
	var angle = Math.atan(dy/dx);

	canvas.save();
	canvas.translate(start_p.x, start_p.y);
	canvas.rotate(angle);
	if(end_p.x < start_p.x) {
		canvas.translate(-length, 0);
	}
	canvas.moveTo(0, 0);			
	x = 0;
	while(x < length) {
		x += f;
		if(x > length) {
			x = length;
		}
		canvas.lineTo(x, 0);

		if(x == length) {
			break;
		}

		x += e;
		if(x > length) {
			x = length;
		}
		canvas.moveTo(x, 0);			
	}
	canvas.restore();

	return;
}

var gCacheCanvas = null;
function CacheCanvasGet(width, height) {
	if(!gCacheCanvas) {
		gCacheCanvas = document.createElement("canvas");

		gCacheCanvas.type = "backend_canvas";
		gCacheCanvas.width = width;
		gCacheCanvas.height = height;
	}

	if(gCacheCanvas) {
		if(gCacheCanvas.width < width) {
			gCacheCanvas.width = width;
		}

		if(gCacheCanvas.height < height) {
			gCacheCanvas.height = height;
		}
	}

	return gCacheCanvas;
}

function drawNinePatchEx(context, image, s_x, s_y, s_w, s_h, x, y, w, h) {
	var dx = 0;
	var dy = 0;
	var tw = 0;
	var th = 0;
	var cw = 0;
	var ch = 0;
	var dcw = 0;
	var dch = 0;
	
	if(!image) {
		context.fillRect(x, y, w, h);
		return;
	}

	if(!s_w || s_w > image.width) {
		s_w = image.width;
	}

	if(!s_h || s_h > image.height) {
		s_h = image.height;
	}

	if(w < s_w && h < s_h && (s_w < 3 || s_h < 3)) {
		context.drawImage(image, s_x, s_y, s_w, s_h, x, y, w, h);

		return;
	}

	if(w < s_w) {
		tw = w/2;
		dcw = 0;
		cw = 0;
	}
	else {
		tw = Math.floor(s_w/3);
		dcw = w - tw - tw;
		cw = s_w - tw - tw;
	}

	if(h < s_h) {
		th = h/2;
		dch = 0;
		ch = 0;
	}
	else {
		th = Math.floor(s_h/3);
		dch = h - th - th;
		ch = s_h - th - th;
	}

	/*draw four corner*/
	context.drawImage(image, s_x, s_y, tw, th, x, y, tw, th);
	context.drawImage(image, s_x+s_w-tw, s_y, tw, th, x+w-tw, y, tw, th);
	context.drawImage(image, s_x, s_y+s_h-th, tw, th, x, y+h-th, tw, th);
	context.drawImage(image, s_x+s_w-tw, s_y+s_h-th, tw, th, x+w-tw, y+h-th, tw, th);

	//top/bottom center
	if(dcw > 0) {
		context.drawImage(image, s_x+tw, s_y, cw, th, x+tw, y, dcw, th);
		context.drawImage(image, s_x+tw, s_y+s_h-th, cw, th, x+tw, y+h-th, dcw, th);
	}

	//left/right middle 
	if(dch > 0) {
		context.drawImage(image, s_x, s_y+th, tw, ch, x, y+th, tw, dch);
		context.drawImage(image, s_x+s_w-tw, s_y+th, tw, ch, x+w-tw, y+th, tw, dch);
	}

	//center + middle
	if(dcw > 0 && dch > 0) {
		context.drawImage(image, s_x+tw, s_y+th, cw, ch, x+tw, y+th, dcw, dch);
	}

	return;
}

function drawNinePatch(context, image, x, y, w, h) {
	if(!image) {
		context.fillRect(x, y, w, h);
		return;
	}

	return drawNinePatchEx(context, image, 0, 0, image.width, image.height, x, y, w, h);
}

function drawNinePatchIcon(context, icon, x, y, w, h) {
	var image = icon.getImage();
	var s_x = icon.getX();
	var s_y = icon.getY();
	var s_w = icon.getWidth();
	var s_h = icon.getHeight();

	if(!image) {
		context.fillRect(x, y, w, h);
		return;
	}

	return drawNinePatchEx(context, image, s_x, s_y, s_w, s_h, x, y, w, h);
}

function RoundRect() {
}

RoundRect.TL = 1;
RoundRect.TR = 2;
RoundRect.BL = 4;
RoundRect.BR = 8;

function drawRoundRect(canvas, w, h, r, which) {
	var hw = w >> 1;
	var hh = h >> 1;

	if(w < 0 || h < 0) {
		return;
	}
	
	if(!which) {
		which = RoundRect.TL | RoundRect.TR | RoundRect.BL | RoundRect.BR;
	}

	if((r >= hw || r >= hh) && which === (RoundRect.TL | RoundRect.TR | RoundRect.BL | RoundRect.BR)) {
		canvas.arc(hw, hh, Math.min(hh, hw), 0, Math.PI * 2);
		return;
	}

	if(r) {
		if(which & RoundRect.TL) {
			canvas.arc(r, r, r, Math.PI, 1.5*Math.PI, false);
		}
		else {
			canvas.moveTo(0, 0);
		}

		if(which & RoundRect.TR) {
			canvas.lineTo(w - r, 0);
			canvas.arc(w-r, r, r, 1.5*Math.PI, 2*Math.PI,  false);
		}
		else {
			canvas.lineTo(w, 0);
		}
	
		if(which & RoundRect.BR) {
			canvas.lineTo(w, h-r);
			canvas.arc(w-r, h-r, r, 0, 0.5*Math.PI, false);
		}
		else {
			canvas.lineTo(w, h);
		}

		if(which & RoundRect.BL) {
			canvas.lineTo(r, h);
			canvas.arc(r, h-r, r, 0.5 * Math.PI, Math.PI, false);
		}
		else {
			canvas.lineTo(0, h);
		}
		
		if(which & RoundRect.TL) {
			canvas.lineTo(0, r);
		}
		else {
			canvas.lineTo(0, 0);
		}
	}
	else {
		canvas.rect(0, 0, w, h);
	}

	return;
}

function cantkGetViewPort() {
	return CantkRT.getViewPort();
}

if(!window.orgViewPort) {
	window.orgViewPort = cantkGetViewPort();
}

function layoutText(canvas, fontSize, str, width, flexibleWidth) {
	if(width <= 0 || !width || !str) {
		return [];
	}

	var i = 0;
	var j = 0;
	var wordW = 0;
	var lineW = 0;
	var logicLine = "";
	var logicLines = [];
	var phyLines = str.split("\n");
	var textLayout = new TextLayout(canvas);

	for(i = 0; i < phyLines.length; i++) {
		var line = phyLines[i];

		if(line) {
			textLayout.setText(line);
			while(textLayout.hasNext()) {
				var lineInfo = textLayout.nextLine(width, fontSize, flexibleWidth);
				logicLines.push(lineInfo.text);
			}
		}
		else {
			logicLines.push(" ");
		}
	}

	return logicLines;
}

function codeIsLetter(code) {
	return ((code >= 0x61 && code <= 0x7a) || (code >= 0x41 && code <= 0x5a));
}

function TextLayout(canvas) {
	this.canvas = canvas;

	this.setText = function(str) {
		this.str = str;
		this.startOffset = 0;
		this.lineInfo = {text:"", width:0};

		return;
	}
	
	this.canBreakBefore = function(chr) {
		if(chr === ' '
			|| chr === '\t'
			|| chr === '.'
			|| chr === ']'
			|| chr === ')'
			|| chr === '}'
			|| chr === ','
			|| chr === '?'
			|| chr === ';'
			|| chr === ':'
			|| chr === '!'
			|| chr === '\"'
			|| chr === '\''
			|| chr === '。'
			|| chr === '？'
			|| chr === '、'
			|| chr === '”'
			|| chr === '’'
			|| chr === '】'
			|| chr === '》'
			|| chr === '〉'
			|| chr === '〕'
			|| chr === '）'
			|| chr === '：'
			|| chr === '；'
			|| chr === '，') {
				return false;
		}

		return true;
	}

	this.hasNext = function() {
		return this.startOffset < this.str.length;
	}

	this.nextLine = function(width, fontSize, flexibleWidth) {
		var done = false;
		var lineText = "";
		var str = this.str;
		var i = this.startOffset;
		var length = str.length;
		var n = Math.floor((width/fontSize)*0.75);
		var availableLength = length - this.startOffset;

		if(availableLength < 1) {
			this.lineInfo.text = "";
			this.lineInfo.width = 0;

			return null;
		}
		
		if(availableLength < n) {
			lineText = str.substr(this.startOffset, availableLength);
			this.lineInfo.text = lineText;
			this.lineInfo.width = canvas.measureText(lineText).width;

			this.startOffset = this.startOffset + lineText.length;

			return this.lineInfo;
		}

		if(n > 3) {
			n = n - 3;
		}
	
		lineText = str.substr(this.startOffset, n);
	
		var code = 0;
		var chr = null;
		var chrWidth = 0;
		var nextChar = null;
		var lineWidth = canvas.measureText(lineText).width;

		var flexibleWidth = flexibleWidth ? flexibleWidth : Math.floor(width * 0.3);

		var fontSize2 = 2 * fontSize;
		var maxWidth = width + flexibleWidth;
		var minWidth = width - fontSize2;

		for(i = this.startOffset + n; i < length; i++) {
			chr = str.charAt(i);
			code = str.charCodeAt(i);
			if(chr === '\t') {
				chr = ' ';
			}

			lineText += chr;
			chrWidth  = canvas.measureText(chr).width;
			lineWidth = lineWidth + 1 + chrWidth;
		
			if(chr == "'") {
				continue;
			}

			if(lineWidth > maxWidth) {
				break;
			}
			
			if(lineWidth < minWidth) {
				continue;
			}

			if(codeIsLetter(code)) {
				continue;
			}
			
			if(code == 0x20) {
				if(lineWidth >= width) {
					break;
				}

				var nOfLetter = 0;
				for(var k = i+1; k < length; k++) {
					code = str.charCodeAt(k);

					if(codeIsLetter(code)) {
						nOfLetter++;
					}
					else {
						break;
					}
				}

				if(nOfLetter > 7) {
					break;
				}
				else {
					continue;
				}
			}

			if((i + 1) < length) {
				nextChar = str.charAt(i+1);
				if(lineWidth >= width && this.canBreakBefore(nextChar)) {
					break;
				}
			}
		}

		this.lineInfo.text = lineText;
		this.lineInfo.width = canvas.measureText(lineText).width;
		this.startOffset = this.startOffset + lineText.length;

		return this.lineInfo;
	}

	return this;
}

function getXMLHttpRequest() {
	if (typeof window === 'undefined') {
		throw new Error('no window object present');
	}
	else if (window.XMLHttpRequest) {
		return window.XMLHttpRequest;
	}
	else if (window.ActiveXObject) {
		var axs = [
			'Msxml2.XMLHTTP.6.0',
			'Msxml2.XMLHTTP.3.0',
			'Microsoft.XMLHTTP'
		];
		for (var i = 0; i < axs.length; i++) {
			try {
				var ax = new(window.ActiveXObject)(axs[i]);
				return function () {
					if (ax) {
						var ax_ = ax;
						ax = null;
						return ax_;
					}
					else {
						return new(window.ActiveXObject)(axs[i]);
					}
				};
			}
			catch (e) {}
		}
		throw new Error('ajax not supported in this browser')
	}
	else {
		throw new Error('ajax not supported in this browser');
	}
}

function createXMLHttpRequest() {
	if(!window.XMLHttpRequest) {
		window.XMLHttpRequest = getXMLHttpRequest();
	}

	return new XMLHttpRequest();
}


function httpDownloadFile(url, onDone, autoProxy) {
	var info = {};

	info.url = url;
	info.method = "GET";
	info.responseType = 'blob';
	info.autoProxy = autoProxy;

	info.onDone = function(result, xhr, content) {
		saveAs(content, url.basename());
		if(onDone) {
			onDone(result, xhr, content);
		}
	}

	httpDoRequest(info);

	return;
}

function httpDoRequest(info) {
	var	xhr = createXMLHttpRequest();

	if(!info || !info.url) {
		return false;
	}

	var url = info.url;
	var data = info.data;
	var method = info.method ? info.method : "GET";
	var isCrossDomain = url.indexOf("http") === 0 && url.indexOf(window.location.hostname) < 0;

	if(isCrossDomain) {
		if(info.autoProxy) {
			url = '/proxy.php?url=' + window.btoa(encodeURIComponent(url));
			console.log("use proxy:" + url);
		}
		else {
			xhr.crossOrigin = "Anonymous";
			if(info.withCredentials) {
				xhr.withCredentials = true;
				console.log("cross domain info.withCredentials=true");
			}
		}
	}

	if(info.responseType) {
		xhr.responseType = info.responseType;
	}
	
	if(info.dataType) {
		xhr.dataType = info.dataType;
	}

	xhr.open(method, url, true);

	if(info.noCache) {
		xhr.setRequestHeader('If-Modified-Since', '0');
	}

	if(info.headers) {
		for(var key in info.headers) {
			var value = info.headers[key];
			xhr.setRequestHeader(key, value);
		}
	}

	if(xhr) {
		if(!xhr.onprogress) {
			xhr.onreadystatechange = function() {
				if(info.onProgress) {
					info.onProgress(xhr);
				}
				if(xhr.readyState === 4) {
					if(info.onDone) {
						if(info.responseType && info.responseType.toLowerCase() === "blob") {
							info.onDone(true, xhr, xhr.response);
						}
						else {
							info.onDone(true, xhr, xhr.responseText);
						}
					}
				}
				//console.log("onreadystatechange:" + xhr.readyState);
				return;
			}
		}
		else {
			xhr.onprogress = function(e)  {
				var total = e.total;
				if(info.onProgress) {
					info.onProgress(xhr);
				}
				console.log("get:" + total);
			 }
			
			xhr.onload = function(e)  {
				if(info.onDone) {
					info.onDone(true, xhr, e.target.responseText);
				}
			}
			
			xhr.onerror = function(e)  {
				if(info.onDone) {
					info.onDone(false, xhr, xhr.responseText);
				}
			}
		}
		
		xhr.send(info.data ? info.data : null);
	}

	return true;
}

function httpGetURL(url, onDone, autoProxy, withCredentials) {
	var rInfo = {};
	rInfo.url = url;
	rInfo.onDone = onDone;
	rInfo.autoProxy = autoProxy;
	rInfo.withCredentials = withCredentials;

	httpDoRequest(rInfo);

	return;
}

function httpPostURL(url, data, onDone, autoProxy, withCredentials) {
	var rInfo = {};
	rInfo.url = url;
	rInfo.onDone = onDone;
	rInfo.method = "POST";
	rInfo.data = data;
	rInfo.autoProxy = autoProxy;
	rInfo.withCredentials = withCredentials;

	httpDoRequest(rInfo);

	return;
}

function httpGetJSON(url, onDone, autoProxy, withCredentials) {
	httpGetURL(url, function(result, xhr, data) {
		var json = null;
		if(result) {
			try {
				json = JSON.parse(data);
			}catch(e) {
				console.log("JSON.parse failed： url=" + url + " data:" + data);
			}
		}
		onDone(json);
	}, autoProxy, withCredentials);

	return;
}

window.jsonpIndex = 0;
function httpGetJSONP(url, onDone, options) {
	var jsonp = "callback";
	var name =  "jsonpCallBack" + window.jsonpIndex++;

	window[name] = function(data) {
		if(onDone) {
			try {
				onDone(data);
			}catch(e) {
				console.log(e.message);
			}
		}
		console.log("jsonp data:" + url + "\n" + JSON.stringify(data));
		delete window[name];
	}

	if(options && options.jsonp) {
		jsonp = options.jsonp;
	}

	if(url.indexOf("?") > 0) {
		url += "&"+jsonp+"="+name;
	}
	else {
		url += "?"+jsonp+"="+name;
	}

	var node = document.head ? document.head : document.body;
	var script = document.createElement("script");
	script.onload = function() { 
		console.log("jsonp success:" + url);
	}

	script.onerror = script.onabort = script.oncancel = function(e) {
		console.log("jsonp error:" + url);
	}

	script.src = url;
	node.appendChild(script);

	return;
}

function cantkRestoreViewPort() {
	cantkInitViewPort(1);

	return;
}

function cantkInitViewPort() {
	var value = "";
	var meta = document.createElement('meta');
	var head = document.getElementsByTagName('head')[0];
	var scale = 1/(window.devicePixelRatio||1);	
	var scale1Values = 'initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
	var scaleValues = "initial-scale="+scale+", minimum-scale="+scale+", maximum-scale="+scale+", user-scalable=0";

	var metaScale = 'width=device-width, ' + scaleValues;
	var metaDensity = 'target-densitydpi=device-dpi, width=device-width, ' + scale1Values;

	if(isIPhone()) {
		value = metaScale;
	}
	else if(isAndroid()) {
		var ver = browserVersion();
		if(ver < 537.00 || isWeiXin() || isWeiBo() || isQQ()) {
			value = metaDensity;
		}
		else { 
			value = metaScale;
		}
	}
	else if(isFirefoxMobile()) {
		var vp = cantkGetViewPort();
		value = 'width='+vp.width+', ' + scaleValues; 
	}
	else {
		value =  metaScale;;
	}

	meta.name = 'viewport';
	meta.content = value;
	head.appendChild(meta);
	console.log("viewport: " + value);

	return;
}

function cantkLog(str) {
	console.log(str);

	return;
}

////////////////////////////////////////////////


var gDelayScripts = new Array();

function cantkDelayLoadScript(url) {
	gDelayScripts.push(url);

	return;
}

function loadDelayScriptsNow() {
	var i = 0;
	var tag = null;
	var filename = null;
	var node = document.head ? document.head : document.body;

	for(i = 0; i < gDelayScripts.length; i++) {
		filename = gDelayScripts[i];
		tag = document.createElement("script"); 
		tag.src = filename; 
		node.appendChild(tag);
		console.log("Load: " + filename);
	}
	
	gDelayScripts.clear();

	return;
}

function loadScriptOnce(src) {
	var scripts = document.scripts;

	if(scripts) {
		for(var i = 0; i < scripts.length; i++) {
			var iter = scripts[i];
			if(iter.src && iter.src.indexOf(src) >= 0) {
				console.log("script is loaded: " + src);
				return;
			}
		}
	}
	
	var node = document.head ? document.head : document.body;
	var tag = document.createElement("script");
	tag.src = src; 
	node.appendChild(tag);
	
	console.log("load script: " + src);
	
	return;
	
}

setTimeout(function() {
	loadDelayScriptsNow();
	return;
}, 800);

function delayLoadScripts(hostName) {
	if(hostName) {
		dappSetResHostName(hostName);
	}
	
	return;
}

function getScriptByUrl(url) {
	var scripts = document.getElementsByTagName("script");

	if(scripts) {
		for(var i = 0; i < scripts.length; i++) {
			var iter = scripts[i];
			var src = iter.src;

			if(src.indexOf(url) >= 0) {
				return iter;
			}
		}
	}

	return null;
}

function isScriptLoaded(url) {
	return getScriptByUrl(url) != null;
}


/////////////////////////////////////////////////////////
var requestAnimFrame = CantkRT.requestAnimFrame;

function getQueryParameter(key) {
  var key = key + "=";
  var queryString = window.location.search.substring(1);

  if ( queryString.length > 0 ) {
    begin = queryString.indexOf ( key );
    if ( begin != -1 ) {
      begin += key.length;
      end = queryString.indexOf ( "&" , begin );
        if ( end == -1 ) {
        end = queryString.length
      }
      var value = queryString.substring ( begin, end );

      return decodeURI(value);
    }
  }

  return null; 
}

function cantkGetQueryParam(key) {
	return getQueryParameter(key);
}

function getFontSizeInFont(str) {
	var fontSize = 12;
	var px = str.match(/\d+px/g);

	if(px) {
		fontSize = parseInt(px[0]);
	}
	else {
		var pt = str.match(/\d+pt/g);
		if(pt) {
			fontSize = parseInt(pt[0]) * 1.5;
		}
	}

	return fontSize;
}

function basename(path) {
	return path.replace(/\\/g,'/').replace( /.*\//, '' );
}

function dirname(path) {
	var str = path.replace(/\\/g,'/').replace(/\/[^\/]*$/, '');

	return str ? str : "/";
}

String.prototype.basename = function(withoutExt) {
	var filename = this.replace(/\\/g,'/').replace( /.*\//, '' );

	if(withoutExt) {
		var index = filename.lastIndexOf('.');
		if(index >= 0) {
			filename = filename.substr(0, index);
		}
	}

	return filename;
}

String.prototype.toRelativeURL = function() {
	var str = this;
    var host;
    if(window.location.protocol === "file:") {
		host = dirname(window.location.href) + "/";
	}
	else {
		host = window.location.protocol + "//" + window.location.host + "/";
	}

    if(str.startWith(host)) {
        return str.substring(host.length, str.length);    
    }
    return str;
}

String.prototype.extname = function() {	
	var extName = "";
	var index = this.lastIndexOf('.');

	if(index >= 0) {
		extName = this.substr(index+1);	
	}

	return extName;
}

String.prototype.dirname = function() {
	return this.replace(/\\/g,'/').replace(/\/[^\/]*$/, '');
}

String.prototype.isLower = function() {
	return /^[a-z]+$/.test(this); 
}

String.prototype.isUpper = function() {
	return /^[A-Z]+$/.test(this); 
}

String.prototype.isDigit = function() {
	return /^[0-9]+$/.test(this); 
}

String.prototype.isValidName = function() {
	return /^[0-9]+$|^[A-Z]+$|^[a-z]+$|_/.test(this); 
}

function cantkIsFullscreen() {
	return document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen;
}

function cantkRequestFullscreen(onDone) {
	function onFullscreenChanged(e) {
		if(onDone) {
			onDone(cantkIsFullscreen());
		}
		console.log("fullscreenchange:" + cantkIsFullscreen());

		return true;
	}

	if(cantkIsFullscreen()) {
		onFullscreenChanged();
		return true;
	}

	var element = document.documentElement;
	if (document.documentElement.requestFullscreen) {
		element.addEventListener('fullscreenchange', onFullscreenChanged, true);
		return element.requestFullscreen();
	} else if (document.documentElement.mozRequestFullScreen) {
		element.addEventListener('mozfullscreenchange', onFullscreenChanged, true);
		return element.mozRequestFullScreen();
	} else if (document.documentElement.webkitRequestFullScreen) {
		element.addEventListener('webkitfullscreenchange', onFullscreenChanged, true);
		return element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
	}
	
	return false;
}

function cantkCancelFullscreen() {
	if(document.cancelFullScreen) {
		document.cancelFullScreen();
	}
	else if(document.webkitCancelFullScreen) {
		document.webkitCancelFullScreen();
	}
	else if(document.mozCancelFullScreen) {
		document.mozCancelFullScreen();
	}
}

function saveStrToFile(fileName, content) {
	function get_blob_builder() {
		return window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
	}

	try {
		var BB = get_blob_builder();
		var bb = new BB;
		bb.append(content);
		saveAs(bb.getBlob("text/plain;charset=" + document.characterSet), fileName);
	}catch(e) {
		var bb = new Blob([content], {type:"text/plain;charset=" + document.characterSet});
		saveAs(bb, fileName);
	}

	return;
}

function readLocalTextFile(onSuccess, onFail) {
	function onFileChoosed(file) {
		try {
			var reader = new FileReader();
			reader.onload = function (evt) {
				var result = evt.target.result;
				if(onSuccess) {
					onSuccess(result);
				}
				return;
			};
			
			reader.onerror = function(evt) {
				if(onFail) {
					onFail(evt);
				}
				return;
			};
			reader.readAsText(file);
			reader = null;
		}catch(e) {
			if(onFail) {
				onFail(null);
			}
		}
	}

	var input = document.createElement("input");
	input.type = "file";
	input.multiple = false;
	input.onchange = function(e) {
		if(this.files && this.files.length) {
			var file = this.files[0];
			if(file && (!file.type || file.type.indexOf("text") >= 0)) {
				onFileChoosed(file);
			}
			else {
				console.log("Not text file.");
			}
		}
	}
	input.click();

	input = null;

	return;
}

Math.distanceBetween = function(p1, p2) {
	var dx = p2.x - p1.x;
	var dy = p2.y - p1.y;

	var d = Math.sqrt(dx * dx + dy * dy);

	return d;
}

Math.lineAngle = function(from, to) {
	var dx = to.x - from.x;
	var dy = to.y - from.y;
	var d = Math.sqrt(dx * dx + dy * dy);

	if(dx == 0 && dy == 0) {
		return 0;
	}
	
	if(dx == 0) {
		if(dy < 0) {
			return 1.5 * Math.PI;
		}
		else {
			return 0.5 * Math.PI;
		}
	}

	if(dy == 0) {
		if(dx < 0) {
			return Math.PI;
		}
		else {
			return 0;
		}
	}

	if(dx > 0) {
		if(dy > 0) {
			return Math.asin(dy/d);
		}
		else {
			return 2 * Math.PI - Math.asin(Math.abs(dy)/d);
		}
	}
	else {
		if(dy > 0) {
			return Math.PI - Math.asin(Math.abs(dy)/d);
		}
		else {
			return Math.PI + Math.asin(Math.abs(dy)/d);
		}
	}
}

Math.translatePoint = function(point, angle, distance) {
	var x = point.x;
	var y = point.y;

	if(angle < 0.5 * Math.PI) {
		x = x + distance * Math.cos(angle);
		y = y + distance * Math.sin(angle);
	}
	else if(angle < Math.PI) {
		var a = Math.PI - angle;
		x = x - distance * Math.cos(a);
		y = y + distance * Math.sin(a);
	}
	else if(angle < 1.5 * Math.PI) {
		var a = angle - Math.PI;
		x = x - distance * Math.cos(a);
		y = y - distance * Math.sin(a);
	}
	else {
		var a = 2 * Math.PI - angle;
		x = x + distance * Math.cos(a);
		y = y - distance * Math.sin(a);
	}
	return {x:x, y:y};

}

Math.rotatePoint = function(point, angle) {
	var p = {};

	p.x = point.x * Math.cos(angle) + point.y * Math.sin(angle);
	p.y = point.y * Math.cos(angle) - point.x * Math.sin(angle);

	return p;
}

function dataURLToBlob(dataURL) {
    var BASE64_MARKER = ';base64,';
    if (dataURL.indexOf(BASE64_MARKER) == -1) {
      var parts = dataURL.split(',');
      var contentType = parts[0].split(':')[1];
      var raw = decodeURIComponent(parts[1]);

      return new Blob([raw], {type: contentType});
    }

    var parts = dataURL.split(BASE64_MARKER);
    var contentType = parts[0].split(':')[1];
    var raw = window.atob(parts[1]);
    var rawLength = raw.length;

    var uInt8Array = new Uint8Array(rawLength);

    for (var i = 0; i < rawLength; ++i) {
      uInt8Array[i] = raw.charCodeAt(i);
    }

    return new Blob([uInt8Array], {type: contentType});
 }

window.makeUniqRandArray = makeUniqRandArray;
window.cantkGetQueryParam  = cantkGetQueryParam;

function isWebAudioSupported() {
	return typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined';
}

window.sendStatistics = function(str) {
	window.magicData = str;
	return;
}

window.setStatisticsData = function(data) {
	window.magicData = data;

	return;
}

function showFileDialog(accept, multiple, capture, onDone) {
	var input = document.createElement("input");
	var form = document.getElementById("defform");
	if(!form) {
		form = document.createElement("form");
		form.id = "defform";
		document.body.appendChild(form);
	}

	form.appendChild(input);

	input.type = "file";
	input.accept = accept;
	input.multiple = multiple;
	input.capture = capture;
	input.onchange = function(e) {
		if(onDone) {
			onDone(this.files)
		}

		form.removeChild(input);
	}

	input.click();
}

/////////////////////////////////////////////////////
//Promise
window.Promise = window.Promise || (function(root) {
	function Promise(func) {
		if(typeof func !== 'function') {
			throw new TypeError('func must a function');
		}

		this.state = Promise.STATE_UNFULFILLED;
		this.outcome = void 0;
		this.queue = [];

		if(func !== INTERNAL) {
			Promise.resolveThenable(this, func);
		}
	}

	Promise.STATE_RESOLVE = 'resolve';
	Promise.STATE_REJECT  = 'reject';
	Promise.STATE_UNFULFILLED = 'unfulfilled';

	function INTERNAL() {}

	Promise.resolveThenable = function(promise, thenable) {
		var called = false;

		function onSucceed(value) {
			if(!called) {
				called = true;
				Promise.doResolve(promise, value);
			}
		}

		function onError(error) {
			if(!called) {
				called = true;
				Promise.doReject(promise, error);
			}
		}

		function wrapTheanble() {
			thenable(onSucceed, onError);
		}

		var ret = Promise.safeCall(wrapTheanble);
		if(ret.state === 'error') {
			onError(ret.value);
		}
	};

	Promise.getThen = function(obj) {
		var then = obj && obj.then;
		return typeof obj === 'object' && typeof then  === 'function' && function() {
			then.apply(obj, arguments);
		};
	};

	Promise.safeCall = function(func, param) {
		var ret= {};

		try {
			ret.value = func(param);
			ret.state = 'success';
		}
		catch(err) {
			ret.value = err;
			ret.state = 'error';
		}

		return ret;
	};

	Promise.doResolve = function(promise, value) {
		var result = Promise.safeCall(Promise.getThen, value);

		if(result.state === 'error') {
			return Promise.doReject(promise, result.value);
		}

		if(result.value) {
			Promise.resolveThenable(promise, result.value);	
		}
		else {
			promise.state = Promise.STATE_RESOLVE;
			promise.outcome = value;
			promise.queue.forEach(function(iter) {
				if(typeof iter.onResolve === 'function') {
					Promise.callNextTick(iter.promise, iter.onResolve, value);
				}
				else {
					Promise.doResolve(iter.promise, value);
				}
			});
		}

		return promise;
	};

	Promise.doReject = function(promise, error) {
		promise.state = Promise.STATE_REJECT;
		promise.outcome = error;

		promise.queue.forEach(function(iter) {
			if(typeof iter.onReject === 'function') {
				Promise.callNextTick(iter.promise, iter.onReject, error);
			}
			else {
				Promise.doReject(iter.promise, error);
			}
		});

		return promise;
	};

	Promise.callNextTick = function(promise, hander, param) {
		setTimeout(function() {
			var ret;
			try {
				ret = hander(param);
			}
			catch(err) {
				return Promise.doReject(promise, err);
			}

			if(ret === promise) {
				Promise.doReject(promise, new TypeError('Cannot resolve promise with itself'));
			}
			else {
				Promise.doResolve(promise, ret);
			}
		}, 0);
	};

	Promise.prototype.then = function(onFulfilled, onReject) {
		if(typeof onFulfilled !== 'function' && this.state === Promise.STATE_RESOLVE
			|| typeof onReject !== 'function' && this.state === Promise.STATE_REJECT) {
			return this;
		}

		var newPromise = new this.constructor(INTERNAL);
		if(this.state !== Promise.STATE_UNFULFILLED) {
			var hander = this.state === Promise.STATE_REJECT ? onReject : onFulfilled;
			Promise.callNextTick(newPromise, hander, this.outcome);
		}
		else {
			this.queue.push({promise: newPromise, onResolve: onFulfilled, onReject: onReject});
		}

		return newPromise;
	};

	Promise.prototype.catch = function(onReject) {
		return this.then(null, onReject);
	};

	Promise.resolve = function(value) {
		if(value instanceof this) {
			return value;
		}
		var promise = new this(INTERNAL);
		return Promise.doResolve(promise, value);
	};

	Promise.reject = function(reason) {
		var promise = new this(INTERNAL);
		return Promise.doReject(promise, reason);
	};

	Promise.optimizeThumb = function(doit) {
		return function(iterable) {
			if(!Array.isArray(iterable)) {
				return Promise.reject(new TypeError('iterable must be array'));
			}
			if(!iterable.length) {
				return Promise.resolve([]);
			}
			var promise = new Promise(INTERNAL);
			doit(promise, iterable);

			return promise;
		};
	};

	Promise.all = Promise.optimizeThumb(function(promise, iterable) {
		var result = [],
			called = false,
			count = iterable.length;

		for(var i = 0; i < count; i++) {
			var iter = iterable[i];
			Promise.resolve(iter)
			.then(function(value) {
				result.push(value);
				if(!called && result.length === count) {
					called = true;
					Promise.doResolve(promise, result);
				}
			}, function(error) {
				if(!called) {
					called = true;
					Promise.doReject(promise, error);
				}
			});
		}
	});

	Promise.race = Promise.optimizeThumb(function(promise, iterable) {
		var called = false;

		for(var i = 0; i < iterable.length; i++) {
			var iter = iterable[i];
			Promise.resolve(iter)
			.then(function(value) {
				if(!called) {
					called = true;
					Promise.doResolve(promise, value);
				}
			}, function(error) {
				if(!called) {
					called = true;
					Promise.doReject(promise, error);
				}
			});
		}
	});
	return Promise;
})(this);

window.Deferred = window.Deferred || (function(root) {
	var Promise = root.Promise;

	function Deferred() {
		if(!(this instanceof Deferred)) {
			return new Deferred();
		}

		var self = this;
		this.promise = new Promise(function(resolve, reject) {
			self.reject = reject;
			self.resolve = resolve;
		});
	}

	Deferred.prototype.makeResolver = function() {
		var self = this;
		return function(err, data) {
			if(err) {
				self.reject(err);
			}
			else if(arguments.length > 2) {
				self.resolve(Array.prototype.slice.call(arguments, 1));
			}
			else {
				self.resolve(data);
			}
		};
	};
	return Deferred;
})(this);

void function(global) {
	var isBoolean = function(obj) {
		return obj === true || obj === false || Object.prototype.toString.call(obj) === '[Object Boolean]';
	}
	global.unique = function(array, isSorted, iteratee, context) {
		if(!isBoolean(isSorted)) {
			context = iteratee;
			iteratee = isSorted;
			isSorted = false;
		}
		var result = [],
			seen = [];
		for(var i = 0; i < array.length; i++) {
			var value = array[i],
				computed = iteratee ? iteratee.call(context, value, i, array) : value;
			if(isSorted) {
				if(!i || seen !== computed) {
					result.push(computed);
				}
				seen = computed;
			}
			else if(iteratee) {
				if(seen.indexOf(computed) === -1) {
					seen.push(computed);
					result.push(value);
				}
			}
			else if(result.indexOf(value) === -1) {
				result.push(value);
			}
		}

		return result;
	};
}(this);

function filterResults(n_win, n_docel, n_body) {
	var n_result = n_win ? n_win : 0;
	if (n_docel && (!n_result || (n_result > n_docel)))
		n_result = n_docel;
	return n_body && (!n_result || (n_result > n_body)) ? n_body : n_result;
};

function getScrollLeft() {
	return filterResults (
		window.pageXOffset ? window.pageXOffset : 0,
		document.documentElement ? document.documentElement.scrollLeft : 0,
		document.body ? document.body.scrollLeft : 0
	);
};

function getScrollTop() {
	return filterResults (
		window.pageYOffset ? window.pageYOffset : 0,
		document.documentElement ? document.documentElement.scrollTop : 0,
		document.body ? document.body.scrollTop : 0
	);
};


/*
 * File: struct.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: common used structs
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */
function Rect(x, y, w, h) {
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
	
	return this;
}

Rect.prototype.clone = Rect.prototype.dup = function() {
	return new Rect(this.x, this.y, this.w, this.h);
}

function Point(x, y) {
    this.x = x;
    this.y = y;
    
    return this;
}

Point.prototype.dup = function() {
	return new Point(this.x, this.y);
}

Point.prototype.copy = function(point) {
	this.x = point.x;
	this.y = point.y;

	return;
}

function pointEqual(p1, p2) {
	return p1.x === p2.x && p1.y === p2.y;
}

//intersection and difference is from https://github.com/google/closure-library/blob/master/closure/goog/math/rect.js
Rect.intersection = function(a, b) {
  var x0 = Math.max(a.x, b.x);
  var x1 = Math.min(a.x + a.w, b.x + b.w);

  if (x0 <= x1) {
    var y0 = Math.max(a.y, b.y);
    var y1 = Math.min(a.y + a.h, b.y + b.h);

    if (y0 <= y1) {
      return new Rect(x0, y0, x1 - x0, y1 - y0);
    }
  }
  return null;
};

Rect.hasIntersection = function(a, b) {
  var x0 = Math.max(a.x, b.x);
  var x1 = Math.min(a.x + a.w, b.x + b.w);

  if (x0 <= x1) {
    var y0 = Math.max(a.y, b.y);
    var y1 = Math.min(a.y + a.h, b.y + b.h);

    if (y0 <= y1) {
      return true;
    }
  }
  return false;
};

Rect.difference = function(a, b) {
  var intersection = Rect.intersection(a, b);
  if (!intersection || !intersection.h || !intersection.w) {
    return [a.clone()];
  }

  var result = [];

  var top = a.y;
  var height = a.h;

  var ar = a.x + a.w;
  var ab = a.y + a.h;

  var br = b.x + b.w;
  var bb = b.y + b.h;

  // Subtract off any area on top where A extends past B
  if (b.y > a.y) {
    result.push(new Rect(a.x, a.y, a.w, b.y - a.y));
    top = b.y;
    // If we're moving the top down, we also need to difference the height diff.
    height -= b.y - a.y;
  }
  // Subtract off any area on bottom where A extends past B
  if (bb < ab) {
    result.push(new Rect(a.x, bb, a.w, ab - bb));
    height = bb - top;
  }
  // Subtract any area on left where A extends past B
  if (b.x > a.x) {
    result.push(new Rect(a.x, top, b.x - a.x, height));
  }
  // Subtract any area on right where A extends past B
  if (br < ar) {
    result.push(new Rect(br, top, ar - br, height));
  }

  return result;
};

Rect.subtract2 = function(r1, r2, r3) {
	var all = [];
	var rects = Rect.difference(r1, r2);

	for(var i = 0; i < rects.length; i++) {
		var rs = Rect.difference(rects[i], r3);
		all = all.concat(rs);
	}

	return all;
};
/*!
 *  howler.js v2.0.0-beta8
 *  howlerjs.com
 *
 *  (c) 2013-2016, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup our audio context.
  var ctx = null;
  var usingWebAudio = true;
  var noAudio = false;
  var masterGain = null;
  var canPlayEvent = 'canplaythrough';
  setupAudioContext();

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = ctx ? ctx.state || 'running' : 'running';
      self.autoSuspend = true;

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Set to false to disable the auto iOS enabler.
      self.mobileAutoEnable = true;

      // No audio is available on this system if this is set to true.
      self.noAudio = noAudio;

      // This will be true if the Web Audio API is available.
      self.usingWebAudio = usingWebAudio;

      // Expose the AudioContext when using Web Audio.
      self.ctx = ctx;

      // Expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
      self.masterGain = masterGain;

      // Check for supported codecs.
      if (!noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // When using Web Audio, we just need to adjust the master gain.
        if (usingWebAudio) {
          masterGain.gain.value = vol;
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (usingWebAudio) {
        masterGain.gain.value = muted ? 0 : self._volume;
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && typeof ctx.close !== 'undefined') {
        self.ctx = null;
        ctx.close();
        setupAudioContext();
        self.ctx = ctx;
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext];
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = new Audio();
      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
      var isOpera = /OPR\//.test(navigator.userAgent);

      self._codecs = {
        mp3: !!(!isOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Mobile browsers will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _enableMobileAudio: function() {
      var self = this || Howler;

      // Only run this on iOS if audio isn't already eanbled.
      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk/i.test(navigator.userAgent);
      var isTouch = !!(('ontouchend' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
      if (ctx && (self._mobileEnabled || !isMobile || !isTouch)) {
        return;
      }

      self._mobileEnabled = false;

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function() {
        // Create an empty buffer.
        var buffer = ctx.createBuffer(1, 1, 22050);
        var source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._mobileEnabled = true;
          self.mobileAutoEnable = false;

          // Remove the touch start listener.
          document.removeEventListener('touchend', unlock, true);
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchend', unlock, true);

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !ctx || typeof ctx.suspend === 'undefined' || !usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';
        ctx.suspend().then(function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        });
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!ctx || typeof ctx.resume === 'undefined' || !usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended') {
        self.state = 'resuming';
        ctx.resume().then(function() {
          self.state = 'running';
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];

      // Web Audio or HTML5 Audio?
      self._webAudio = usingWebAudio && !self._html5;

      // Automatically try to enable audio on iOS.
      if (typeof ctx !== 'undefined' && ctx && Howler.mobileAutoEnable) {
        Howler._enableMobileAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // Load the source file unless otherwise specified.
      if (self._preload) {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Extract the file extension from the URL or base64 data URI.
          str = self._src[i];
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }

          if(ext === "php") {
          	ext = str.extname();
          }
        }

        // Check if this extension is available.
        if (Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite Sprite name for sprite playback or sound id to continue previous.
     * @return {Number}        Sound ID.
     */
    play: function(sprite) {
      var self = this;
      var args = arguments;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        var num = 0;
        for (var i=0; i<self._sounds.length; i++) {
          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
            num++;
            id = self._sounds[i]._id;
          }
        }

        if (num === 1) {
          sprite = null;
        } else {
          id = null;
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If we have no sprite and the sound hasn't loaded, we must wait
      // for the sound to load to get our audio's duration.
      if (self._state !== 'loaded' && !self._sprite[sprite]) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(self._soundById(sound._id) ? sound._id : undefined);
          }
        });

        return sound._id;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!args[1]) {
          setTimeout(function() {
            self._emit('play', sound._id);
          }, 0);
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000;
      var duration = ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek;

      // Create a timer to fire at the end of playback or the start of a new loop.
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      if (timeout !== Infinity) {
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Update the parameters of the sound
      sound._paused = false;
      sound._ended = false;
      sound._sprite = sprite;
      sound._seek = seek;
      sound._start = self._sprite[sprite][0] / 1000;
      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._loop = !!(sound._loop || self._sprite[sprite][2]);

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume * Howler.volume();
          node.gain.setValueAtTime(vol, ctx.currentTime);
          sound._playStart = ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (!self._endTimers[sound._id] && timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!args[1]) {
            setTimeout(function() {
              self._emit('play', sound._id);
            }, 0);
          }
        };

        if (self._state === 'loaded') {
          playWebAudio();
        } else {
          // Wait for the audio to load and then begin playback.
          self.once('load', playWebAudio, sound._id);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;
          setTimeout(function() {
            node.play();
            if (!args[1]) {
              self._emit('play', sound._id);
            }
          }, 0);
        };

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        if (self._state === 'loaded') {
          playHtml5();
        } else {
          var listener = function() {
            // Setup the new end timer.
            if (timeout !== Infinity) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(canPlayEvent, listener, false);
          };
          node.addEventListener(canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to pause when capable.
      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // make sure the sound has been created
              if (!sound._node.bufferSource) {
                return self;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              sound._node.bufferSource = null;
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }

          // Fire the pause event, unless `true` is passed as the 2nd argument.
          if (!arguments[1]) {
            self._emit('pause', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @return {Howl}
     */
    stop: function(id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // make sure the sound has been created
              if (!sound._node.bufferSource) {
                return self;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              sound._node.bufferSource = null;
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
              sound._node.currentTime = sound._start || 0;
            }
          }
        }

        if (sound) {
          self._emit('stop', sound._id);
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume * Howler.volume(), ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded') {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol * Howler.volume(), ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          if (self._webAudio && !sound._muted) {
            var currentTime = ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);

            // Fire the event when complete.
            sound._timeout = setTimeout(function(id, sound) {
              delete sound._timeout;
              setTimeout(function() {
                sound._volume = to;
                self._emit('fade', id);
              }, end - ctx.currentTime > 0 ? Math.ceil((end - ctx.currentTime) * 1000) : 0);
            }.bind(self, ids[i], sound), len);
          } else {
            var diff = Math.abs(from - to);
            var dir = from > to ? 'out' : 'in';
            var steps = diff / 0.01;
            var stepLen = len / steps;

            (function() {
              var vol = from;
              sound._interval = setInterval(function(id, sound) {
                // Update the volume amount.
                vol += (dir === 'in' ? 0.01 : -0.01);

                // Make sure the volume is in the right bounds.
                vol = Math.max(0, vol);
                vol = Math.min(1, vol);

                // Round to within 2 decimal points.
                vol = Math.round(vol * 100) / 100;

                // Change the volume.
                self.volume(vol, id, true);

                // When the fade is complete, stop it and fire event.
                if (vol === to) {
                  clearInterval(sound._interval);
                  delete sound._interval;
                  self._emit('fade', id);
                }
              }.bind(self, ids[i], sound), stepLen);
            })();
          }
        }
      }

      return self;
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound._interval) {
        clearInterval(sound._interval);
        delete sound._interval;
        self._emit('fade', id);
      } else if (sound._timeout) {
        clearTimeout(sound._timeout);
        delete sound._timeout;
        sound._node.gain.cancelScheduledValues(ctx.currentTime);
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded') {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.value = rate;
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            self._clearTimer(id[i]);
            self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return self;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (self._state !== 'loaded') {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          self._clearTimer(id);

          // Restart the playback if the sound was playing.
          if (playing) {
            self.play(id, true);
          }

          self._emit('seek', id);
        } else {
          if (self._webAudio) {
            return (sound._seek + (self.playing(id) ? ctx.currentTime - sound._playStart : 0));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not.
     * @param  {Number} id The sound id to check. If none is passed, first sound is used.
     * @return {Boolean}    True if playing and false if not.
     */
    playing: function(id) {
      var self = this;
      var sound = self._soundById(id) || self._sounds[0];

      return sound ? !sound._paused : false;
    },

    /**
     * Get the duration of this sound.
     * @param  {Number} id The sound id to check. If none is passed, first sound is used.
     * @return {Number} Audio duration.
     */
    duration: function(id) {
      var self = this;
      var sound = self._soundById(id) || self._sounds[0];

      return self._duration / sound._rate;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
          self._emit('end', sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to an empty string to stop any downloading.
          sounds[i]._node.src = '';

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(canPlayEvent, sounds[i]._loadFn, false);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);

        // Remove the references in the global Howler object.
        var index = Howler._howls.indexOf(self);
        if (index >= 0) {
          Howler._howls.splice(index, 1);
        }
      }

      // Delete this sound from the cache.
      if (cache) {
        delete cache[self._src];
      }

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];

      if (fn) {
        // Loop through event store and remove the passed function.
        for (var i=0; i<events.length; i++) {
          if (fn === events[i].fn && id === events[i].id) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (var i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function() {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // don't move onto the next task until this one is done
        self.once(task.event, function() {
          self._queue.shift();
          self._loadQueue();
        });

        task.action();
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._playStart = ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        sound._node.bufferSource = null;

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        clearTimeout(self._endTimers[id]);
        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop;
      }
      sound._node.bufferSource.playbackRate.value = self._rate;

      return self;
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._muted = parent._muted;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = Math.round(Date.now() * Math.random());

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume * Howler.volume();

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof ctx.createGain === 'undefined') ? ctx.createGainNode() : ctx.createGain();
        self._node.gain.setValueAtTime(volume, ctx.currentTime);
        self._node.paused = true;
        self._node.connect(masterGain);
      } else {
        self._node = new Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(canPlayEvent, self._loadFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = 'auto';
        self._node.volume = volume;

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._muted = parent._muted;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = Math.round(Date.now() * Math.random());

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      if (self._node.error && self._node.error.code === 4) {
        Howler.noAudio = true;
      }

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorListener, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      if (parent._autoplay) {
        parent.play();
      }

      // Clear the event listener.
      self._node.removeEventListener(canPlayEvent, self._loadFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  // Only define these methods when using Web Audio.
  if (usingWebAudio) {

    var cache = {};

    /**
     * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
     * @param  {Howl} self
     */
    var loadBuffer = function(self) {
      var url = self._src;

      // Check if the buffer has already been cached and use it instead.
      if (cache[url]) {
        // Set the duration from the cache.
        self._duration = cache[url].duration;

        // Load the sound into this Howl.
        loadSound(self);

        return;
      }

      if (/^data:[^;]+;base64,/.test(url)) {
        // Setup polyfill for window.atob to support IE9.
        // Modified from: https://github.com/davidchambers/Base64.js
        window.atob = window.atob || function(input) {
          var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
          var str = String(input).replace(/=+$/, '');
          for (
            var bc = 0, bs, buffer, idx = 0, output = '';
            buffer = str.charAt(idx++);
            ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
          ) {
            buffer = chars.indexOf(buffer);
          }

          return output;
        };

        // Decode the base64 data URI without XHR, since some browsers don't support it.
        var data = atob(url.split(',')[1]);
        var dataView = new Uint8Array(data.length);
        for (var i=0; i<data.length; ++i) {
          dataView[i] = data.charCodeAt(i);
        }

        decodeAudioData(dataView.buffer, self);
      } else {
        // Load the buffer from the URL.
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          // Make sure we get a successful response back.
          var code = (xhr.status + '')[0];
          if (code !== '0' && code !== '2' && code !== '3') {
            self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
            return;
          }

          decodeAudioData(xhr.response, self);
        };
        xhr.onerror = function() {
          // If there is an error, switch to HTML5 Audio.
          if (self._webAudio) {
            self._html5 = true;
            self._webAudio = false;
            self._sounds = [];
            delete cache[url];
            self.load();
          }
        };
        safeXhrSend(xhr);
      }
    };

    /**
     * Send the XHR request wrapped in a try/catch.
     * @param  {Object} xhr XHR to send.
     */
    var safeXhrSend = function(xhr) {
      try {
        xhr.send();
      } catch (e) {
        xhr.onerror();
      }
    };

    /**
     * Decode audio data from an array buffer.
     * @param  {ArrayBuffer} arraybuffer The audio data.
     * @param  {Howl}        self
     */
    var decodeAudioData = function(arraybuffer, self) {
      // Decode the buffer into an audio source.
      ctx.decodeAudioData(arraybuffer, function(buffer) {
        if (buffer && self._sounds.length > 0) {
          cache[self._src] = buffer;
          loadSound(self, buffer);
        }
      }, function() {
        self._emit('loaderror', null, 'Decoding audio data failed.');
      });
    };

    /**
     * Sound is now loaded, so finish setting everything up and fire the loaded event.
     * @param  {Howl} self
     * @param  {Object} buffer The decoded buffer sound source.
     */
    var loadSound = function(self, buffer) {
      // Set the duration.
      if (buffer && !self._duration) {
        self._duration = buffer.duration;
      }

      // Setup a sprite if none is defined.
      if (Object.keys(self._sprite).length === 0) {
        self._sprite = {__default: [0, self._duration * 1000]};
      }

      // Fire the loaded event.
      if (self._state !== 'loaded') {
        self._state = 'loaded';
        self._emit('load');
        self._loadQueue();
      }

      // Begin playback if specified.
      if (self._autoplay) {
        self.play();
      }
    };

  }

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  function setupAudioContext() {
    try {
      if (typeof AudioContext !== 'undefined') {
        ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        ctx = new webkitAudioContext();
      } else {
        usingWebAudio = false;
      }
    } catch(e) {
      usingWebAudio = false;
    }

    if (!usingWebAudio) {
      if (typeof Audio !== 'undefined') {
        try {
          var test = new Audio();

          // Check if the canplaythrough event is available.
          if (typeof test.oncanplaythrough === 'undefined') {
            canPlayEvent = 'canplay';
          }
        } catch(e) {
          noAudio = true;
        }
      } else {
        noAudio = true;
      }
    }

    // Test to make sure audio isn't disabled in Internet Explorer
    try {
      var test = new Audio();
      if (test.muted) {
        noAudio = true;
      }
    } catch (e) {}

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(navigator.platform));
    var appVersion = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(window.navigator.userAgent.toLowerCase());
      if (window.navigator.standalone && !safari || !window.navigator.standalone && !safari) {
        usingWebAudio = false;
      }
    }

    // Create a master gain node.
    if (usingWebAudio) {
      masterGain = (typeof ctx.createGain === 'undefined') ? ctx.createGainNode() : ctx.createGain();
      masterGain.gain.value = 1;
      masterGain.connect(ctx.destination);
    }
  }

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (typeof define === 'function' && define.amd) {
    define([], function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    });
  }

  // Add support for CommonJS libraries such as browserify.
  if (typeof exports !== 'undefined') {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Define globally in case AMD is not available or unused.
  if (typeof window !== 'undefined') {
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  }
})();
/*
 * File: event_target.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: event target
 * 
 * Copyright (c) 2011 - 2015	Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016	Holaverse Inc.
 * 
 */
function TEvent() {
}

TEvent.prototype.preventDefault = function() {
	this.defaultPrevented = true;

	return this;
}

TEvent.prototype.isDefaultPrevented = function() {
	return this.defaultPrevented;
}

TEvent.create = function(type) {
	var event = new TEvent();
	event.type = type;

	return event;
}

function TEventTarget() {
}

TEventTarget.apply = function(obj) {
	if (!obj) {
		return;
	}

	obj.createEvent = TEvent.create;
	obj.hasEventListener = TEventTarget.prototype.hasEventListener;
	obj.dispatchEvent = TEventTarget.prototype.dispatchEvent;
	obj.addEventListener = TEventTarget.prototype.addEventListener;
	obj.removeEventListener = TEventTarget.prototype.removeEventListener;
	obj.resetEvents = TEventTarget.prototype.resetEvents;
	obj.on = TEventTarget.prototype.on;
	obj.off = TEventTarget.prototype.off;

	return;
}

TEventTarget.prototype.resetEvents = function() {
	this.eventListeners = {};
}

TEventTarget.prototype.hasEventListener = function(type) {
	return this.eventListeners && this.eventListeners[type] && this.eventListeners[type].length > 0;
}

TEventTarget.prototype.on = TEventTarget.prototype.addEventListener = function(type, callback) {
	if(!callback || !type) {
		return;
	}

	if(!this.eventListeners) {
		this.eventListeners = {};
	}

	var callbacks = this.eventListeners[type];
	
	if(!callbacks) {
		callbacks = [];
		this.eventListeners[type] = callbacks;
	}

	if(callback) {
		callbacks.push({callback:callback});
	}

	return;
}

TEventTarget.prototype.off = TEventTarget.prototype.removeEventListener = function(type, callback) {
	if(!this.eventListeners || !callback || !type) {
		return;
	}

	var callbacks = this.eventListeners[type];
	if(callbacks) {
		for(var i = 0; i < callbacks.length; i++) {
			var iter = callbacks[i];
			if(iter && iter.callback === callback) {
				callbacks.splice(i, 1);
			}
		}
	}

	return;
}

TEventTarget.prototype.dispatchEvent = function(event) {
	if(!this.eventListeners || !event || !event.type) {
		return false;
	}
	
	var type = event.type;
	var callbacks = this.eventListeners[type];
	
	event.target = this;
	if(callbacks) {
		var n = callbacks.length;
		callbacks = callbacks.slice();

		for(var i = 0; i < n; i++) {
			var iter = callbacks[i];
			var callback = iter.callback;
			try {
				if(callback.call(this, event)) {
					return true;
				}
			}catch(e){
				console.log("%cWarning: dispatchEvent " + type + "(" + e.message + ")\n" + e.stack, "color: red; font-weight: bold");
			}
		}
	}

	return false;
}
/*
 * File: resloader.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: res loader
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function ResLoader() {
}

ResLoader.total = 0;
ResLoader.finished = 0;

ResLoader.reset = function() {
	ResLoader.total = 0;
	ResLoader.finished = 0;

	return;
}

ResLoader.toLoadInc = function(src) {
	ResLoader.total++;
	return;
}

ResLoader.loadedInc = function(src) {
	setTimeout(function() {
		ResLoader.finished++;
		ResLoader.notifyLoadProgress();
	}, 1);

	return;
}

ResLoader.setAssetsConfig = function(assetsConfig) {
	ResLoader.assetsConfig = assetsConfig;
}

ResLoader.mapImageURL = function(url, assetsConfig) {
		return url;
}

ResLoader.setOnChangedListener = function(onChanged) {
	ResLoader.onChanged = onChanged;
}

ResLoader.setOnLoadFinishListener = function(onLoadFinished) {
	ResLoader.onLoadFinished = onLoadFinished;

	return;
}

ResLoader.isLoadCompleted = function() {
	return ResLoader.finished >= ResLoader.total;
}

ResLoader.notifyLoadDone = function() {
	if(ResLoader.onLoadFinished) {
		ResLoader.onLoadFinished();
	}
	console.log("All resource loaded:" + ResLoader.total);
}

ResLoader.notifyLoadProgress = function() {
	var percent = ResLoader.getPercent();
	if(ResLoader.onChanged) {
		ResLoader.onChanged(percent, ResLoader.finished, ResLoader.total);
	}
	
	if(ResLoader.finished >= ResLoader.total) {
		ResLoader.notifyLoadDone();
	}

	var event = {type:ResLoader.EVENT_ASSETS_LOAD_PROGRESS, percent:percent, finished:ResLoader.finished, total:ResLoader.total};
	ResLoader.dispatchEvent(event);

	return;
}

ResLoader.getTotal = function() {
	return ResLoader.total;
}

ResLoader.getFinished = function() {
	return ResLoader.finished;
}

ResLoader.getPercent = function() {
	if(!ResLoader.total) {
		return 100;
	}

	return (ResLoader.finished/ResLoader.total) * 100;
}

ResLoader.cache = {};

ResLoader.addToCache = function(src, obj) {
	ResLoader.cache[src] = obj;
}

ResLoader.dump = function() {
	var i = 0;
	for(var key in ResLoader.cache) {
		var iter = ResLoader.cache[key];
		var str = i + " : " + key.substr(0, 255) + " status=" + (iter.pending ? "pending" : "loaded");
		console.log(str);
		i++;
	}
}

ResLoader.clearCache = function(check) {
	var newCache = {};
	for(var key in ResLoader.cache) {
		var asset = ResLoader.cache[key];

		if(check && check(key)) {
			newCache[key] =  asset;
		}
		else {
			console.log("clear asset:" + key);
		}
	}
	ResLoader.cache = newCache;

	return;
}

ResLoader.getFromCache = function(src) {
	return ResLoader.cache[src];
}

ResLoader.resRoot = null;
ResLoader.setResRoot = function(resRoot) {
	ResLoader.resRoot = resRoot;

	return;
}

ResLoader.toAbsURL = function(url) {
	if(!url || url.indexOf("://") > 0 || url.indexOf("data:") === 0) {
		return url;
	}

	var absURL = url;
	if(ResLoader.resRoot) {
		absURL = ResLoader.resRoot + url;
	}
	else if(url[0] === '/') {
		absURL = location.protocol + "//" + location.host + url;
	}
	else {
		var str = location.protocol + "//" + location.host + location.pathname;
		var path = dirname(str);
		absURL = path + "/" + url;
	}

	return absURL;
}

function ResProxy(src, onSuccess, onFail) {
	this.src = src;
	this.obj = null;
	this.pending = true;
	this.onSuccessList = [onSuccess];
	this.onFailList = [onFail];

	if(src) {
		ResLoader.toLoadInc(src);
		ResLoader.addToCache(src, this);
	}
	else {
		console.log("WARNNING: load null url.");
	}

	return;
}

ResProxy.prototype.onDone = function(obj) {
	this.obj = obj;
	delete this.pending;
	ResLoader.loadedInc(this.src);

	try {
		if(obj) {
			this.callOnSuccess();
		}
		else {
			this.callOnFail();
		}
	}catch(e) {
		console.log("ResProxy.prototype.onDone:" + e.message);
	}

	return;
}

ResProxy.prototype.callOnSuccess = function() {
	var obj = this.obj;
	var src = this.src;

	for(var i = 0; i < this.onSuccessList.length; i++) {
		var onSuccess = this.onSuccessList[i];
		if(!onSuccess) continue;

		if(onSuccess.dataType === "json") {
			ResLoader.callFunc(onSuccess, this.getJsonObj());
		}
		else {
			ResLoader.callFunc(onSuccess, this.obj);
		}
	}

	this.onFailList = [];
	this.onSuccessList = [];

	return;
}

ResProxy.prototype.callOnFail = function() {
	var src = this.src;

	for(var i = 0; i < this.onFailList.length; i++) {
		var onFail = this.onFailList[i];
		if(!onFail) continue;
		ResLoader.callFunc(onFail, null);

	}
	this.onFailList = [];
	this.onSuccessList = [];

	return;
}

ResProxy.prototype.getJsonObj = function() {
	if(this.jsonObj) {
		return this.jsonObj;
	}

	try {
		this.jsonObj = JSON.parse(this.obj);
	}catch(e) {
		console.log("ensureJson:" + e.message);
	}

	return this.jsonObj;
}

ResProxy.prototype.onHitCache = function(onSuccess, onFail) {
	if(this.pending) {
		this.onSuccessList.push(onSuccess);
		this.onFailList.push(onFail);
	}
	else if(this.obj) {
		if(onSuccess.dataType === "json") {
			ResLoader.callFunc(onSuccess, this.getJsonObj());
		}
		else {
			ResLoader.callFunc(onSuccess, this.obj);
		}
	}
	else {
		ResLoader.callFunc(onFail, null);
	}

	return this.obj;
}

ResLoader.callFunc = function(func, data) {
	if(func) {
		try {
			func(data);
		}catch(e) {
			console.log("ResLoader.callFunc:" + e.message);
		}
	}

	return;
}

ResLoader.loadImage = function(url, onSuccess, onFail) {
	var src = ResLoader.mapImageURL(ResLoader.toAbsURL(url), ResLoader.assetsConfig);

	var proxy = ResLoader.getFromCache(src);
	if(proxy) {
		return proxy.onHitCache(onSuccess, onFail);
	}
	else {
		var proxy = new ResProxy(src, onSuccess, onFail);

		return CantkRT.createImage(src, proxy.onDone.bind(proxy), proxy.onDone.bind(proxy));
	}
}

ResLoader.loadAudio = function(url, onSuccess, onFail) {
	var src = ResLoader.toAbsURL(url);
	var proxy = ResLoader.getFromCache(src);
	if(proxy) {
		return proxy.onHitCache(onSuccess, onFail);
	}

	var audio = new Audio();

	proxy = new ResProxy(src, onSuccess, onFail);

	audio.volume = 0.8;
	audio.addEventListener('loadstart', function (e) {
		console.log("load start:" + url);
	});
	
	audio.addEventListener('canplay', function (e) {
		console.log("canplay:" + url);
	});

	audio.addEventListener('canplaythrough', function (e) {
		console.log("canplaythrough:" + url);
		proxy.onDone(audio);
	});

	audio.addEventListener('error', function (e) {
		console.log("error:" + url);
		proxy.onDone(null);
	});

	audio.src = src;
	audio.load();

	return audio;
}

ResLoader.loadJson = function(url, onSuccess, onFail) {
	var src = ResLoader.toAbsURL(url);
	var proxy = ResLoader.getFromCache(src);
	onSuccess.dataType = "json";
	if(proxy) {
		return proxy.onHitCache(onSuccess, onFail);
	}

	proxy = new ResProxy(src, onSuccess, onFail);
	httpGetURL(src, function(result, xhr, data) {
		proxy.onDone(data);
	});

	return;
}

ResLoader.loadData = function(url, onSuccess, onFail) {
	var src = ResLoader.toAbsURL(url);
	var proxy = ResLoader.getFromCache(src);
	
	onSuccess.dataType = "string";
	if(proxy) {
		return proxy.onHitCache(onSuccess, onFail);
	}

	proxy = new ResProxy(src, onSuccess, onFail);
	httpGetURL(src, function(result, xhr, data) {
		proxy.onDone(data);
	});

	return;
}

ResLoader.loadScriptsSync = function(srcs, onCompleted) {
	var i = 0;
	var n = srcs.length;

	ResLoader.toLoadInc("scripts begin");
	function loadNext() {
		if(i < n) {
			var iter = srcs[i];
			
			i++;
			console.log("load script("+i+"/"+n+"):" + iter);
			ResLoader.loadScript(iter, window.studioDevMode, loadNext, loadNext);
		}
		else {
			if(onCompleted) {
				onCompleted();
			}
			ResLoader.loadedInc("scripts done");
			console.log("load scripts done.");
		}
	}

	loadNext();
}

ResLoader.loadScript = function(src, force, onSuccess, onFail) {
	var script = null;
	var scripts = document.scripts;
	var node = document.head ? document.head : document.body;
	var timestamp = "timestamp=" + Date.now();
	if(src.indexOf("?") < 0) {
		timestamp = "?" + timestamp;
	}
	else {
		timestamp = "&" + timestamp;
	}

	if(scripts) {
		for(var i = 0; i < scripts.length; i++) {
			var iter = scripts[i];
			if(iter.src && iter.src.indexOf(src) >= 0) {
				script = iter;
				if(onSuccess) {
					onSuccess();
				}

				if(force) {
					document.head.removeChild(script);
					break;
				}
				else {
					return;
				}
			}
		}
	}

	ResLoader.toLoadInc(src);
	script = document.createElement("script");
	script.onload = function() { 
		if(onSuccess) {
			onSuccess();
		}
		ResLoader.loadedInc(src);
	}

	script.onerror = script.onabort = script.oncancel = function(e) {
		if(onFail) {
			onFail();
		}
		ResLoader.loadedInc(src);
	}

	if(!force) {
		script.src = src;
	}
	else {
		script.src = src + timestamp;
	}
	node.appendChild(script);

	return;
}

ResLoader.loadFonts = function(fonts) {
	if(CantkRT.isCantkRTV8()) {
		return ResLoader.loadFontsRT(fonts);
	}
	else {
		return ResLoader.loadFontsWeb(fonts);
	}
}

ResLoader.loadFontsRT = function(fonts) {
	for(var i = 0; i < fonts.length; i++) {
		var iter = fonts[i];
		var name = iter.basename(true);
		CantkRT.loadFont(name, iter);
	}	

	return;
}

ResLoader.loadFontsWeb = function(fonts) {
	var styleStr = "";
	for(var i = 0; i < fonts.length; i++) {
		var iter = fonts[i];
		var name = iter.basename(true);
		var str = "font-family:'"+name+"';\n";
			str += "src: url('"+iter+"') ";
			if(iter.indexOf(".ttf") > 0 || iter.indexOf("TTF") > 0) {
				str += "format('truetype');\n";
			}
			else if(iter.indexOf(".woff") > 0) {
				str += "format('woff');\n";
			}
			else if(iter.indexOf(".otf") > 0) {
				str += "format('opentype');\n";
			}
			else {
				console.log("not supported:" + iter);
			}

			var fontFaceStr = "@font-face {\n";
			fontFaceStr += str;
			fontFaceStr += "}\n";
			styleStr += fontFaceStr;
	}

	var style = document.createElement("style");
	style.onload = function() {
		console.log("font style loaded.");
	}

	style.innerHTML = styleStr;
	document.head.appendChild(style);
	console.log(styleStr);

	return;
}

TEventTarget.apply(ResLoader);
ResLoader.EVENT_ASSETS_LOAD_PROGRESS = "assets-load-progress";


/*
 * File:    plist.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief:   plist parser
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function PList() {
	this.options = {};
}

PList.ST_NONE = 0;
PList.ST_TEXT = 1;
PList.ST_END_TAG = 2;
PList.ST_START_TAG = 3;

PList.prototype.onStateChanged = function(state, str) {
	switch(this._parseState) {
		case PList.ST_START_TAG: {
			this.tagName = str;
			break;
		}
		case PList.ST_END_TAG: {
			this.tagName = null;
			break;
		}
		case PList.ST_TEXT: {
			if(this.tagName === "key") {
				this._propName = str;
			}
			else if(this.tagName === "real") {
				this.options[this._propName] = parseFloat(str);
			}
			else if(this.tagName === "integer") {
				this.options[this._propName] = parseInt(str);
			}
			else if(this.tagName === "string") {
				this.options[this._propName] = str;
			}

			break;
		}
	}

	this._parseState = state;
}

PList.prototype.dump = function() {
	console.log(JSON.stringify(this.options, null, "\t"))
}

PList.prototype.get = function(name) {
	if(name) {
		return this.options[name];
	}
	else {
		return this.options;
	}
}

PList.prototype.parse = function(buff) {
	var str = "";
	var n = buff.length;
	this.options = {};

	this._parseState = PList.ST_NONE;
	for(var i = 0; i < n; i++) {
		var c = buff[i];
		if(c === "<") {
			if(buff[i+1] === "/") {
				i++;
				this.onStateChanged(PList.ST_END_TAG, str);
			}
			else {
				this.onStateChanged(PList.ST_START_TAG, str);
			}
			str = "";
		}
		else if(c === ">") {
			this.onStateChanged(PList.ST_TEXT, str);
			str = "";
		}
		else {
			str += c;
		}
	}

	return this.options;
}

/*
 * File:    bitmap_font.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief:   fnt file parser
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

function BitmapFont() {
}

//http://www.angelcode.com/products/bmfont/doc/file_format.html
BitmapFont.prototype.parseFontLine = function(fontInfo, line) {
	var words = line.split(" ");

	var lineInfo = {};
	var name = words[0];
	var n = words.length;

	for(var i = 1; i < n; i++) {
		var kevValue = words[i].split('=');
		var key = kevValue[0];
		var value = kevValue[1];
		lineInfo[key] = value;
	}

	switch(name) {
		case "page": {
			var pageDesc = {};
			pageDesc.id = lineInfo.id;
			pageDesc.file = lineInfo.file.replace(/"/g,"").replace(/\r/, "");

			fontInfo.pagesDesc[pageDesc.id] = pageDesc;

			break;
		}
		case "char": {
			var charDesc = {};
			var c = String.fromCharCode(lineInfo.id);

			charDesc.c = c;
			charDesc.id = lineInfo.id;
			charDesc.x = parseInt(lineInfo.x);
			charDesc.y = parseInt(lineInfo.y);
			charDesc.w = parseInt(lineInfo.width);
			charDesc.h = parseInt(lineInfo.height);
			charDesc.ox = parseInt(lineInfo.xoffset);
			charDesc.oy = parseInt(lineInfo.yoffset);
			charDesc.rw = parseInt(lineInfo.xadvance);
			charDesc.page = lineInfo.page;

			fontInfo.charsDesc[c] = charDesc;

			break;
		}
	}

	return;
}

BitmapFont.prototype.parse = function(data) {
	var fontInfo = {};
	fontInfo.charsDesc = {};
	fontInfo.pagesDesc = {};

	var lines = data.split("\n");
	for(var i = 0; i < lines.length; i++) {
		this.parseFontLine(fontInfo, lines[i]);
	}

	this.fontInfo = fontInfo;

	return fontInfo;
}

BitmapFont.prototype.getCharDesc = function(c) {
	return this.fontInfo ? this.fontInfo.charsDesc[c] : null;
}

BitmapFont.prototype.getCharsDesc = function(c) {
	return this.fontInfo ? this.fontInfo.charsDesc : null;
}

BitmapFont.prototype.getPagesDesc = function() {
	return this.fontInfo ? this.fontInfo.pagesDesc : null;
}

BitmapFont.prototype.getFontInfo  = function() {
	return this.fontInfo;
}

/*
 * File: w_image.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: image adapter
 *
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 *
 */

function WImage(src, onLoad) {
	this.src = src;
   	this.onLoadCallback = [];
	this.image = WImage.nullImage;
   	this.setSizeInfo(0, 0, 0, 0, false, false, 0, 0, 0, 0);
	this.setImageSrc(src, onLoad);

	return;
}

WImage.prototype.setSizeInfo = function(x, y, w, h, rotated, trimmed, ox, oy, rw, rh) {
	this.rect = {x:x >> 0, y:y >> 0, w:w >> 0, h:h >> 0, rotated:rotated, trimmed:trimmed, ox:ox >> 0, oy:oy >> 0, rw:rw >> 0, rh:rh >> 0};
}

WImage.prototype.appendOnLoadCallback = function(onLoad) {
    if(onLoad){
        this.onLoadCallback.push(onLoad);
    }
}

WImage.prototype.notifyLoadDone = function(img) {
	this.image = img;
	var callbacks = this.onLoadCallback;

	for(var i = 0, j = callbacks.length; i < j; i++){
		callbacks[i](img);
	}
	this.onLoadCallback.length = 0;
}

WImage.prototype.initFromJson = function(src, json) {
	var sharpOffset = src.indexOf("#");
	var jsonURL = src.substr(0, sharpOffset);
	var name = src.substr(sharpOffset+1);
	var path = dirname(jsonURL);
	var filename = json.file ? json.file : json.meta.image;
	var imageSrc = path + "/" + filename;
	var info = json.frames[name];

	if(!info) {
		console.log("not found src: " + src);
		return;
	}

	var rect = info.frame || info;

	if(!rect) {
		alert("Invalid src: " + src);
		return;
	}

	if(info.trimmed) {
		this.setSizeInfo(rect.x, rect.y, rect.w, rect.h, info.rotated,
			true, info.spriteSourceSize.x, info.spriteSourceSize.y, info.sourceSize.w, info.sourceSize.h);;
	}
	else {
		this.setSizeInfo(rect.x, rect.y, rect.w, rect.h, info.rotated,
			false, 0, 0, rect.w, rect.h);
	}

	var me = this;
	ResLoader.loadImage(imageSrc, function(img) {
		me.notifyLoadDone(img);
	});

	return;
}

WImage.prototype.initFromRowColIndex = function(src, rowcolIndex) {
	var me = this;
	var rows = parseInt(rowcolIndex[1]);
	var cols = parseInt(rowcolIndex[2]);
	var index = parseInt(rowcolIndex[3]);

	ResLoader.loadImage(src, function(img) {
		var tileW = Math.round(img.width/cols);
		var tileH = Math.round(img.height/rows);
		var w = Math.floor(img.width/cols);
		var h = Math.floor(img.height/rows);
		var col = index%cols;
		var row = Math.floor(index/cols);

		var x = col * tileW;
		var y = row * tileH;
		me.setSizeInfo(x, y, w, h, false, false, 0, 0, w, h);
		me.notifyLoadDone(img);
	});

	rowcolIndex = null;

	return;
}

WImage.prototype.initFromXYWH = function(src, xywh) {
	var me = this;
	var x = parseInt(xywh[1]);
	var y = parseInt(xywh[2]);
	var w = parseInt(xywh[3]);
	var h = parseInt(xywh[4]);

	this.image = ResLoader.loadImage(src, function(img) {
		me.setSizeInfo(x, y, w, h, false, false, 0, 0, w, h);
		me.notifyLoadDone(img);
	});
	xywh = null;

	return;
}

WImage.prototype.setImage = function(image) {
	this.image = image;

	return this;
}

WImage.prototype.initFromDataURL = function(src, onLoad) {
	var me = this;
	this.src = src;
	this.image = CantkRT.createImage(src, function(img) {
		me.setSizeInfo(0, 0, img.width, img.height, false, false, 0, 0, img.width, img.height);
		me.notifyLoadDone(img);
	});
}

WImage.prototype.setImageSrc = function(src, onLoad) {
	this.appendOnLoadCallback(onLoad);

	if(!src) {
		this.notifyLoadDone(WImage.nullImage);
		return;
	}

	if(src.indexOf("data:") === 0) {
		this.initFromDataURL(src, onLoad);
		return;
	}

	var me = this;
	var url = ResLoader.toAbsURL(src);

	this.src = url;
	var sharpOffset = url.indexOf("#");
	if(sharpOffset > 0) {
		var meta = url.substr(sharpOffset+1);
		var rowcolIndex = meta.match(/r([0-9]+)c([0-9]+)i([0-9]+)/i);
		var xywh = meta.match(/x([0-9]+)y([0-9]+)w([0-9]+)h([0-9]+)/i);

		if(!rowcolIndex && !xywh) {
			var jsonURL = url.substr(0, sharpOffset);
			ResLoader.loadJson(jsonURL, function(json) {
                if(Array.isArray(json)) {
                    var find = false;
                    var target = null;
                    for(var i = 0; i < json.length; i++) {
                        var frames = Object.keys(json[i].frames);
                        find = frames.some(function(imagename) {
                            if(imagename === meta) {
                                target = json[i];
                                return true;
                            }
                        });
                        if(find) {
                            break;
                        }
                    }
                    return me.initFromJson(url, target || json, onLoad);
                }
				me.initFromJson(url, json, onLoad);
			});
		}
		else {
			url = url.substr(0, sharpOffset);
			if(rowcolIndex) {
				this.initFromRowColIndex(url, rowcolIndex, onLoad);
			}
			if(xywh){
				this.initFromXYWH(url, xywh, onLoad);
			}

			rowcolIndex = null;
			xywh = null;
		}
	}
	else {
		this.image = ResLoader.loadImage(url, function(img) {
			var w = img.width;
			var h = img.height;
			me.setSizeInfo(0, 0, w, h, false, false, 0, 0, w, h);
			me.notifyLoadDone(img);
		});
	}

	return;
}

WImage.prototype.getImageRect = function() {
	return this.rect;
}

WImage.prototype.getImageSrc = function() {
	return this.src;
}

WImage.prototype.getRealImageSrc = function() {
	if(this.image) {
		return this.image.src;
	}
	else {
		var src = this.src;
		var offset = src.indexOf("#");

		if(offset > 0) {
			src = src.substr(0, offset);
			src = src.replace(".json", ".png");
			console.log("Warning: image is not loaded yet.");
		}

		return src;
	}
}

WImage.prototype.isLoaded = function() {
	return this.image && this.image.complete;
}

WImage.prototype.getImage = function() {
	return this.image;
}

WImage.isValid = function(image) {
	return image && image.image && image.image.width && image.image.height;
}

WImage.cache = {};
WImage.nullImage = new Image();
WImage.nullWImage = new WImage();
WImage.nullWImage.image = null;

WImage.clearCache = function(check) {
	var newCache = {};
	for(var key in WImage.cache) {
		var asset = WImage.cache[key];

		if(check && check(key)) {
			newCache[key] =  asset;
		}
		else {
			console.log("clear image:" + key);
		}
	}
	WImage.cache = newCache;

	return;
}

WImage.create = function(src, onLoad) {
	if(!src) {
		return WImage.nullWImage;
	}

	var url = ResLoader.toAbsURL(src);
	var image = WImage.cache[url];

	if(image) {
		if(onLoad) {
			var img = image.image;
			if(img.complete) {
				onLoad(img);
			}else{
                image.appendOnLoadCallback(onLoad)
            }
		}
	}
	else {
		image = new WImage(url, onLoad);
		WImage.cache[url] = image;
	}

	return image;
}

WImage.createWithImage = function(img) {
	var image = WImage.nullWImage;

	if(img) {
		if(img.src) {
			return WImage.create(img.src);
		}

		image = new WImage();
		image.setImage(img);
		image.setSizeInfo(0, 0, img.width, img.height, false, false, 0, 0, img.width, img.height);
	}

	return image;
}

//////////////////////////////////////////////////////////////////

WImage.DISPLAY_CENTER = 0;
WImage.DISPLAY_TILE   = 1;
WImage.DISPLAY_9PATCH = 2;
WImage.DISPLAY_SCALE  = 3;
WImage.DISPLAY_AUTO = 4;
WImage.DISPLAY_DEFAULT = 5;
WImage.DISPLAY_SCALE_KEEP_RATIO  = 6;
WImage.DISPLAY_TILE_V = 7;
WImage.DISPLAY_TILE_H = 8;
WImage.DISPLAY_AUTO_SIZE_DOWN = 9;
WImage.DISPLAY_FIT_WIDTH = 10;
WImage.DISPLAY_FIT_HEIGHT = 11;
WImage.DISPLAY_3PATCH_V = 12;
WImage.DISPLAY_3PATCH_H = 13;

WImage.prototype.draw = function(canvas, display, x, y, dw, dh) {
	var image = this.getImage();
	var srcRect = this.getImageRect();

	return WImage.draw(canvas, image, display, x, y, dw, dh, srcRect);
}

WImage.getImageRectDefault = function(image) {
	return {x:0, y:0, w:image.width, h:image.height, trimmed:false};
}

WImage.draw = function(canvas, image, display, x, y, dw, dh, srcRect) {
	if(!image || !image.width) return;

	var dx = 0;
	var dy = 0;
	var sr = srcRect || WImage.getImageRectDefault(image);
	var sw = sr.w;
	var sh = sr.h;
	var sx = sr.x;
	var sy = sr.y;
	var ox = sr.ox || 0;
	var oy = sr.oy || 0;
	var imageWidth  = sr.rw || sr.w;
	var imageHeight = sr.rh || sr.h;

    if(imageHeight === 0 || imageWidth === 0) {
        return;
    }

	switch(display) {
		case WImage.DISPLAY_CENTER: {
			dx = (x + ((dw - imageWidth) >> 1)) + ox;
			dy = (y + ((dh - imageHeight) >> 1)) + oy;

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, sw, sh);
			break;
		}
		case WImage.DISPLAY_AUTO_SIZE_DOWN: {
			var scale = Math.min(Math.min(dw/imageWidth, dh/imageHeight), 1);
			var iw = imageWidth*scale;
			var ih = imageHeight*scale;

			dx = x + ((dw - iw) >> 1);
			dy = y + ((dh - ih) >> 1);
			dx += (ox*scale);
			dy += (oy*scale);
			dw = (sw*scale);
			dh = (sh*scale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
			break;
		}
		case WImage.DISPLAY_SCALE: {
			var xScale = dw/imageWidth;
			var yScale = dh/imageHeight;

			dx = (x + ox*xScale);
			dy = (y + oy*yScale);
			dw = (sw*xScale);
			dh = (sh*yScale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
			break;
		}
		case WImage.DISPLAY_AUTO: {
			var scale = Math.min(dw/imageWidth, dh/imageHeight);
			var iw = (imageWidth*scale);
			var ih = (imageHeight*scale);

			dx = x + ((dw - iw) >> 1);
			dy = y + ((dh - ih) >> 1);
			dx += (ox*scale);
			dy += (oy*scale);

			dw = (sw*scale);
			dh = (sh*scale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
			break;
		}
		case WImage.DISPLAY_9PATCH: {
			dx = x + ox;
			dy = y + oy;
			dw -= (imageWidth - sw);
			dh -= (imageHeight - sh);
			drawNinePatchEx(canvas, image, sx, sy, sw, sh, dx, dy, dw, dh);

			break;
		}
        case WImage.DISPLAY_3PATCH_V:
            dx = x + ox;
            dy = y + oy;
            dw -= (imageWidth - sw);
			dh -= (imageHeight - sh);

            dw = Math.max(dw, 0);
            dh = Math.max(dh, 0);
            var sstep = sh / 3;
            var dstep = dh / 3;
            var hc = Math.min(sstep, dstep);
            canvas.drawImage(image, sx, sy, sw, sstep, dx, dy, dw, hc);
            canvas.drawImage(image, sx, sy + sstep, sw, sstep, dx, dy + hc, dw, Math.max(dh - 2*sstep, dstep));
            hc = hc + Math.max(dh - 2*sstep, dstep);
            canvas.drawImage(image, sx, sy + 2*sstep, sw, sstep, dx, dy + hc, dw, Math.min(sstep, dstep));
            break;
        case WImage.DISPLAY_3PATCH_H:
            dx = x + ox;
            dy = y + oy;
            dw -= (imageWidth - sw);
			dh -= (imageHeight - sh);

            dw = Math.max(dw, 0);
            dh = Math.max(dh, 0);
            var sstep = sw / 3;
            var dstep = dw / 3;
            var wc = Math.min(sstep, dstep);
            canvas.drawImage(image, sx, sy, sstep, sh, dx, dy, wc, dh);
            canvas.drawImage(image, sx + sstep, sy, sstep, sh, dx + wc, dy, Math.max(dw - 2*sstep, dstep), dh);
            wc = wc + Math.max(dw - 2*sstep, dw / 3);
            canvas.drawImage(image, sx + 2*sstep, sy, sstep, sh, dx + wc, dy, Math.min(sstep, dstep), dh);
            break;
		case WImage.DISPLAY_SCALE_KEEP_RATIO: {
			var scale = Math.max(dw/imageWidth, dh/imageHeight);

			dx = (x + ox*scale);
			dy = (y + oy*scale);
			dw = (sw*scale);
			dh = (sh*scale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

			break;
		}
		case WImage.DISPLAY_TILE: {
			dx = x;
			dy = y;

			imageWidth = sw;
			imageHeight = sh;
			var maxDx = x + dw;
			var maxDy = y + dh;
			while(dy < maxDy) {
				dx = x;
				sh = Math.min(maxDy-dy, imageHeight);
				while(dx < maxDx) {
					sw = Math.min(maxDx-dx, imageWidth);
					canvas.drawImage(image, sx, sy, sw, sh, dx, dy, sw, sh);
					dx = dx + sw;
				}
				dy = dy + sh;
			}
			break;
		}
		case WImage.DISPLAY_TILE_H: {
			var maxDx = x + dw;
			dx = x;
			imageWidth = sw;
			imageHeight = sh;
			sh = Math.min(dh, imageHeight);
			while(dx < maxDx) {
				sw = Math.min(maxDx-dx, imageWidth);
				canvas.drawImage(image, sx, sy, sw, sh, dx, y, sw, dh);
				dx = dx + sw;
			}
			break;
		}
		case WImage.DISPLAY_TILE_V: {
			var maxDy = y + dh;
			dy = y;
			imageWidth = sw;
			imageHeight = sh;
			sw = Math.min(dw, imageWidth);
			while(dy < maxDy) {
				sh = Math.min(maxDy-dy, imageHeight);
				canvas.drawImage(image, sx, sy, sw, sh, x, dy, dw, sh);
				dy = dy + sh;
			}
			break;
		}
		case WImage.DISPLAY_FIT_WIDTH: {
			var scale = dw/imageWidth;

			dx = (x + ox*scale);
			dy = (y + oy*scale);
			dw = (sw*scale);
			dh = (sh*scale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

			break;
		}
		case WImage.DISPLAY_FIT_HEIGHT: {
			var scale = dh/imageHeight;

			dx = (x + ox*scale);
			dy = (y + oy*scale);
			dw = (sw*scale);
			dh = (sh*scale);

			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

			break;
		}
		default: {
			dx = x + ox;
			dy = y + oy;
			canvas.drawImage(image, sx, sy, sw, sh, dx, dy, sw, sh);
			break;
		}
	}

	return;
}

window.WImage = WImage;


/*
 * File: widget.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: widget is base class of all ui element.
 * 
 * Copyright (c) 2011 - 2015	Li XianJing <xianjimli@hotmail.com>
 * 
 */
 
function WWidget() {
}

WWidget.STATE_NORMAL	  = "state-normal";
WWidget.STATE_ACTIVE	  = "state-active";
WWidget.STATE_OVER		  = "state-over";
WWidget.STATE_DISABLE     = "state-disable";
WWidget.STATE_DISABLE_SELECTED = "state-disable-selected";
WWidget.STATE_SELECTED         = "state-selected";
WWidget.STATE_NORMAL_CURRENT   = "state-normal-current";

WWidget.TYPE_NONE = 0;
WWidget.TYPE_USER = 13;
WWidget.TYPE_FRAME = "frame";
WWidget.TYPE_FRAMES = "frames";
WWidget.TYPE_TOOLBAR = "toolbar";
WWidget.TYPE_TITLEBAR= "titlebar";
WWidget.TYPE_MINIMIZE_BUTTON = "button.minimize";
WWidget.TYPE_FLOAT_MENU_BAR = "float-menubar";

WWidget.TYPE_POPUP = "popup";
WWidget.TYPE_DIALOG = "dialog";
WWidget.TYPE_DRAGGABLE_DIALOG = "draggable-dialog";
WWidget.TYPE_WINDOW = "window";
WWidget.TYPE_VBOX = "vbox";
WWidget.TYPE_HBOX = "hbox";
WWidget.TYPE_MENU = "menu";
WWidget.TYPE_MENU_BAR = "menu-bar";
WWidget.TYPE_MENU_BUTTON = "menubar.button";
WWidget.TYPE_GRID_ITEM = "grid-item";
WWidget.TYPE_MENU_ITEM = "menu.item";
WWidget.TYPE_MENU_BAR_ITEM = "menubar.item";
WWidget.TYPE_CONTEXT_MENU_ITEM = "contextmenu.item";
WWidget.TYPE_CONTEXT_MENU_BAR = "contextmenu-bar";
WWidget.TYPE_VSCROLL_BAR = "vscroll-bar";
WWidget.TYPE_HSCROLL_BAR = "hscroll-bar";
WWidget.TYPE_SCROLL_VIEW = "scroll-view";
WWidget.TYPE_GRID_VIEW = "grid-view";
WWidget.TYPE_LIST_VIEW = "list-view";
WWidget.TYPE_LIST_ITEM = "list-item";
WWidget.TYPE_LIST_ITEM_RADIO = "list-item-radio";
WWidget.TYPE_IMAGE_VIEW = "image-view";
WWidget.TYPE_TREE_VIEW = "tree-view";
WWidget.TYPE_TREE_ITEM = "tree-item";
WWidget.TYPE_ACCORDION = "accordion";
WWidget.TYPE_ACCORDION_ITEM = "accordion-item";
WWidget.TYPE_ACCORDION_TITLE = "accordion-title";
WWidget.TYPE_PROPERTY_TITLE = "property-title";
WWidget.TYPE_PROPERTY_SHEET = "property-sheet";
WWidget.TYPE_PROPERTY_SHEETS = "property-sheets";
WWidget.TYPE_VIEW_BASE = "view-base";
WWidget.TYPE_COMPONENT_MENU_ITEM = "menuitem.component";
WWidget.TYPE_WINDOW_MENU_ITEM = "menuitem.window";
WWidget.TYPE_MESSAGE_BOX = "messagebox";
WWidget.TYPE_IMAGE_TEXT = "icon-text";
WWidget.TYPE_BUTTON = "button";
WWidget.TYPE_KEY_VALUE = "key-value";
WWidget.TYPE_LABEL = "label";
WWidget.TYPE_LINK = "link";
WWidget.TYPE_EDIT = "edit";
WWidget.TYPE_TEXT_AREA = "text-area";
WWidget.TYPE_COMBOBOX = "combobox";
WWidget.TYPE_SLIDER = "slider";
WWidget.TYPE_PROGRESSBAR = "progressbar";
WWidget.TYPE_RADIO_BUTTON = "radio-button";
WWidget.TYPE_CHECK_BUTTON = "check-button";
WWidget.TYPE_COLOR_BUTTON = "color-button";
WWidget.TYPE_COLOR_TILE = "color-tile";
WWidget.TYPE_TAB_BUTTON = "tab-button";
WWidget.TYPE_TAB_CONTROL = "tab-control";
WWidget.TYPE_TAB_BUTTON_GROUP = "tab-button-group";
WWidget.TYPE_TIPS = "tips";
WWidget.TYPE_HLAYOUT = "h-layout";
WWidget.TYPE_VLAYOUT = "v-layout";
WWidget.TYPE_BUTTON_GROUP = "button-group";
WWidget.TYPE_COMBOBOX_POPUP = "combobox-popup";
WWidget.TYPE_COMBOBOX_POPUP_ITEM = "combobox-popup-item";
WWidget.TYPE_COLOR_EDIT = "color-edit";
WWidget.TYPE_RANGE_EDIT = "range-edit";
WWidget.TYPE_FILENAME_EDIT = "filename-edit";
WWidget.TYPE_FILENAMES_EDIT = "filenames-edit";
WWidget.TYPE_CANVAS_IMAGE = "canvas-image";
WWidget.TYPE_ICON_BUTTON = "icon-button";

WWidget.BORDER_STYLE_NONE   = 0;
WWidget.BORDER_STYLE_LEFT   = 1;
WWidget.BORDER_STYLE_RIGHT  = 2;
WWidget.BORDER_STYLE_TOP    = 4;
WWidget.BORDER_STYLE_BOTTOM = 8;
WWidget.BORDER_STYLE_ALL    = 0xffff;

WWidget.prototype = {};
WWidget.prototype.init = function(parent, x, y, w, h) {
	this.text = "";
	this.tag = null;
	this.tips = null;
	this.enable = true;
	this.visible = true; 
	this.parent = parent;
	this.checkEnable = null;

	this.children = [];
	this.point = {x:0, y:0};
	this.rect  = {x:x, y:y, w:w, h:h};
	this.setState(WWidget.STATE_NORMAL);
	this.imageDisplay = WImage.DISPLAY_9PATCH;
	this.borderStyle = WWidget.BORDER_STYLE_ALL;
	this.cursor = "default";

	if(this.parent) {
		var border = parent.border ? parent.border : 0;
		var pw = parent.rect.w - 2 * border;
		var ph = parent.rect.h - 2 * border;

		if(x > 0 && x < 1) {
			this.rect.x = pw * x + border;
		}
		if(w > 0 && w <= 1) {
			this.rect.w = pw * w;
		}
		if(y > 0 && y < 1) {
			this.rect.y = ph * y + border;
		}
		if(h > 0 && h <= 1) {
			this.rect.h = ph * h;
		}
		
		parent.appendChild(this);
	}

	return this;
}

WWidget.prototype.useTheme = function(type) {
	this.themeType = type;

	return this;
}

WWidget.prototype.isSelected = function() {
	return this.selected;
}

WWidget.prototype.setSelected = function(value) {
	this.selected = value;

	return this;
}

WWidget.prototype.setSelectable = function(selectable) {
	this.selectable = selectable;

	return true;
}

WWidget.prototype.setNeedRelayout = function(value) {
	this.needRelayout = value;

	return;
}

WWidget.prototype.onAppendChild = function(child) {
}

WWidget.prototype.appendChild = function(child) {
	child.parent = this;
	this.children.push(child);
	this.onAppendChild(child);
	this.needRelayout = true;

	return;
}

WWidget.prototype.getWindowManager = function() {
	return WWindowManager.getInstance();
}

WWidget.prototype.getFrameRate = function() {
	return WWindowManager.getInstance().getFrameRate();
}

WWidget.prototype.showFPS = function(maxFpsMode) {
	return WWindowManager.getInstance().showFPS(maxFpsMode);
}

WWidget.prototype.isPointerDown = function() {
	return WWindowManager.getInstance().isPointerDown();
}

WWidget.prototype.isClicked = function() {
	var win = this.getWindow();
	if(win) {
		return win.isClicked();
	}
	else {
		return WWindowManager.getInstance().isClicked();
	}
}

WWidget.prototype.isAltDown = function() {
	return WWindowManager.getInstance().isAltDown();
}

WWidget.prototype.isCtrlDown = function() {
	return WWindowManager.getInstance().isCtrlDown();
}

WWidget.prototype.getApp = function() {
	return WWindowManager.getInstance().getApp();
}

WWidget.prototype.getCanvas2D = function() {
	return this.getWindow().getCanvas2D();
}

WWidget.prototype.getCanvas = function() {
	return this.getWindow().getCanvas();
}

WWidget.prototype.getLastPointerPoint = function() {
	return WWindowManager.getInstance().getLastPointerPoint();
}

WWidget.prototype.getTopWindow = function() {
	 return this.getWindow();
}

WWidget.prototype.getWindow = function() {
	if(!this.parent) {
		return this;
	}

	var p = this.parent;
	while(p.parent) {
		p = p.parent;
	}

	return p;
}

WWidget.prototype.getParent = function() {
	return this.parent;
}

WWidget.prototype.getX = function() {
	return this.rect.x;
}

WWidget.prototype.getY = function() {
	return this.rect.y;
}

WWidget.prototype.getWidth = function() {
	return this.rect.w;
}

WWidget.prototype.getHeight = function() {
	return this.rect.h;
}

WWidget.prototype.getPositionInView = function() {
	var x = this.getX();
	var y = this.getY();
	var point = {x:0, y:0};
	var iter = this.getParent();

	while(iter != null) {
		x += iter.getX();
		y += iter.getY();
		if(iter.isScrollView) {
			x = x - iter.xOffset;
			y = y - iter.yOffset;
		}
		iter = iter.getParent();
	}

	point.x = x;
	point.y = y;

	return point;
}

WWidget.prototype.getAbsPosition =  function() {
	var x = this.rect.x;
	var y = this.rect.y;

	for(var parent = this.parent; parent; parent = parent.parent) {
		x = x + parent.rect.x;
		y = y + parent.rect.y;
	}
	
	return {x: x, y: y};
}

WWidget.prototype.getPositionInWindow =  function() {
	var x = 0;
	var y = 0;

	if(this.parent) {
		for(var iter = this; iter !== null; iter = iter.parent) {
			if(!iter.parent) {
				break;
			}

			x = x + iter.rect.x;
			y = y + iter.rect.y;
		}
	}

	return {x: x, y: y};
}

WWidget.prototype.translatePoint = function(point) {
	var p = this.getAbsPosition();

	return {x:point.x - p.x, y: point.y - p.y};
}

WWidget.prototype.postRedrawAll = function() {
	WWindowManager.getInstance().postRedraw(null);

	return;
}

WWidget.prototype.postRedraw = function(rect) {
	WWindowManager.getInstance().postRedraw(null);
	
	return;
}

WWidget.prototype.redraw = function(rect) {
	var p = this.getAbsPosition();
	
	if(!rect) {
		rect = {x:0, y:0, w:this.rect.w, h:this.rect.h};
	}

	rect.x = p.x + rect.x;
	rect.y = p.y + rect.y;
	
	WWindowManager.getInstance().redraw(rect);
	
	return;
}

WWidget.prototype.isPointIn = function(point) {
	return isPointInRect(point, this.rect);
}

WWidget.prototype.findTargetWidgetEx = function(point, recursive) {
	 if(!this.visible || !this.isPointIn(point)) {
		return null;
	 }

	 if(recursive && this.children.length > 0) {
		  var n = this.children.length - 1;
		  var p = this.point;
		  p.x = point.x - this.rect.x;
		  p.y = point.y - this.rect.y;
		  
		  for(var i = n; i >= 0; i--) {
				var iter = this.children[i];
				var ret = iter.findTargetWidget(p);
				
				if(ret !== null) {
					 return ret;
				}
		  }
	 }
	 
	 return this;
}
	
WWidget.prototype.findTargetWidget = function(point) {
	 return this.findTargetWidgetEx(point, true);
}

WWidget.widgetsPool = {};

WWidget.getWidget = function(type) {
	var widgets = WWidget.widgetsPool[type];
	if(widgets && widgets.length) {
		return widgets.pop();
	}

	return null;
}

WWidget.putWidget = function(widget) {
	if(widget) {
		var type = widget.type;
		var widgets = WWidget.widgetsPool[type];
		if(!widgets) {
			WWidget.widgetsPool[type] = [];
			widgets = WWidget.widgetsPool[type];
		}
		delete widget.selectable;

		widget.themeType = null;
		widget.userData = null;
		widget.handleGesture = null;
		widget.handleClicked = null;
		widget.handleLongPressed = null;
		widget.handleDoubleClicked = null;
		widget.handleContextMenu = null;
		widget.handleKeyUp = null;
		widget.handleKeyDown = null;
		widget.handleWheel = null;
		widget.onChanged = null;
		widget.onChange = null;
		widget.onMoved = null;
		widget.onSized = null;
		widget.clickedHandler = null;
		widget.removedHandler = null;
		widget.stateChangedHandler = null;

		if(widget.onBeforePaint) {
			widget.onBeforePaint = null;
		}
		if(widget.onAfterPaint) {
			widget.onAfterPaint = null;
		}
		if(widget.onGetText) {
			widget.onGetText = null;
		}
		widgets.push(widget);
	}

	return;
}

WWidget.prototype.setRemovedHandler = function(removedHandler) {
	this.removedHandler = removedHandler;
	
	return this;
}


WWidget.prototype.onRemoved = function() {
	if(this.removedHandler) {
		this.removedHandler();
	}

	return;
}

WWidget.prototype.removeChild = function(child) {
	child.remove();

	return this;
}

WWidget.prototype.remove = function() {
	var parent = this.parent;
	if(parent) {
		parent.children.remove(this);
		if(parent.target === this) {
			parent.target = null;
		}

		this.parent = null;
		this.onRemoved();
		parent.setNeedRelayout(true);
	}

	return this;
}

WWidget.prototype.cleanUp = function() {
}

WWidget.prototype.destroy = function() {
	if(this.children.length) {
		this.destroyChildren();
	}

	this.remove();
	this.cleanUp();

	WWidget.putWidget(this);

	return;
}

WWidget.prototype.destroyChildren = function() {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[0];
		iter.destroy();
	}
	this.target = null;
	this.children.length = [];
	this.setNeedRelayout(true);

	return;
}

WWidget.prototype.forEachChild = function(onVisit) {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		onVisit(iter);
	}

	return;
}

WWidget.prototype.setTextOf = function(name, text, notify) {
	var child = this.lookup(name, true);

	if(child) {
		child.setText(text, notify);
	}
	else {
		console.log("not found " + name);
	}

	return child;
}

WWidget.prototype.setValueOf = function(name, value, notify) {
	var child = this.lookup(name, true);

	if(child) {
		child.setValue(value, notify);
	}
	else {
		console.log("not found " + name);
	}

	return child;
}

WWidget.prototype.setVisibleOf = function(name, value) {
	var child = this.lookup(name, true);

	if(child) {
		child.setVisible(value);
	}
	else {
		console.log("not found " + name);
	}

	return child;
}

WWidget.prototype.setValue = function(value) {
	return this.setText(value);
}

WWidget.prototype.getValue = function() {
	return this.getText();
}

WWidget.prototype.setText = function(text) {
	this.text = (text || text === 0) ? text.toString() : "";
	this.setNeedRelayout(true);

	return this;
}

WWidget.prototype.getText = function() {
	if(this.onGetText) {
		return this.onGetText();
	}

	return this.text;
}

WWidget.prototype.setTips = function(tips) {
	this.tips = tips;

	return this;
}

WWidget.prototype.getTips = function() {
	return this.tips;
}

WWidget.prototype.setInputTips = function(tips) {
	this.inputTips = tips;

	return this;
}

WWidget.prototype.getInputTips = function() {
	return this.inputTips;
}

WWidget.prototype.drawInputTips = function(canvas) {
	var h = this.rect.h;
	var w = this.rect.w;
	var y = this.rect.h >> 1;
	var x = this.leftMargin || 2;
	var text = this.getText();
	var inputTips = this.getInputTips();
	
	if(text || !inputTips || this.type !== WWidget.TYPE_EDIT || this.editing) {
		return;	
	}

	var style = this.getStyle();
	canvas.save();
	canvas.font = style.font;
	canvas.fillStyle = "#E0E0E0";

	canvas.beginPath();
	canvas.rect(0, 0, w - x, h);
	canvas.clip();

	canvas.textAlign = 'left';
	canvas.textBaseline = 'middle';
	canvas.fillText(inputTips, x, y);

	canvas.restore();

	return;
}

WWidget.prototype.drawTips = function(canvas) {
	var tips = this.getTips();
	if(tips) {
		var style = this.getStyle();
		var x = this.rect.w >> 1;
		var y = this.rect.h >> 1;
		var font = style.tipsFont || style.font;
		var textColor = style.tipsTextColor || style.textColor;

		if(font && textColor) {
			canvas.textAlign = "center";
			canvas.textBaseline = "middle";
			canvas.font = font;
			canvas.fillStyle = textColor;
			canvas.fillText(tips, x, y);
		}
	}

	return this;
}

WWidget.prototype.setID = function(id) {
	 this.id = id;
	 
	 return this;
}

WWidget.prototype.getID = function() {
	return this.id;
}

WWidget.prototype.setName = function(name) {
	 this.name = name;
	 
	 return this;
}

WWidget.prototype.getName = function() {
	return this.name;
}

WWidget.prototype.setTag = function(tag) {
	 this.tag = tag;
	 
	 return this;
}

WWidget.prototype.getTag = function() {
	return this.tag;
}

WWidget.prototype.setUserData = function(userData) {
	 this.userData = userData;
	 
	 return this;
}

WWidget.prototype.getUserData = function() {
	return this.userData;
}

WWidget.prototype.setEnable = function(value) {
	this.enable = value;

	return this;
}

WWidget.prototype.changeCursor = function() {
	var canvas = this.getCanvas();
	if(canvas.style.cursor !== this.cursor) {
		canvas.style.cursor = this.cursor;
	}

	return this;
}

WWidget.prototype.onStateChanged = function(state) {
	if(this.stateChangedHandler) {
		this.stateChangedHandler(state);
	}

	if(state === WWidget.STATE_OVER || state === WWidget.STATE_ACTIVE) {
		this.changeCursor();
	}

	return this;
}

WWidget.prototype.setState = function(state, recursive) {
	if(this.state !== state) {
		this.state = state;
		this.onStateChanged(state);
		if(state === WWidget.STATE_OVER) {
			WWindowManager.getInstance().setTipsWidget(this);
		}
	}

	if(recursive && this.target) {
		this.target.setState(state, recursive);
	}

	return this;
}

WWidget.prototype.measure = function(canvas) {
	 return;
}

WWidget.prototype.move = function(x, y) {
	this.rect.x = x;
	this.rect.y = y;
	if(this.onMoved) {
		this.onMoved();
	}

	return this;
}

WWidget.prototype.moveToCenter = function(moveX, moveY) {
	var pw = this.parent.rect.w;
	var ph = this.parent.rect.h;

	if(moveX) {
		this.rect.x = (pw - this.rect.w) >> 1;
	}

	if(moveY) {
		this.rect.y = (ph - this.rect.h) >> 1;
	}

	return this;
}

WWidget.prototype.moveToBottom = function(border) {
	var ph = this.parent.rect.h;

	this.rect.y = ph - this.rect.h - border;

	return this;
}

WWidget.prototype.moveDelta = function(dx, dy) {
	this.rect.x = this.rect.x + dx;
	this.rect.y = this.rect.y + dy;
	if(this.onMoved) {
		this.onMoved();
	}

	return this;
}

WWidget.prototype.resize = function(w, h) {
	this.rect.w = w;
	this.rect.h = h;
	if(this.onSized) {
		this.onSized();
	}
	this.setNeedRelayout(true);

	return this;
}

WWidget.prototype.setStateChangedHandler = function(stateChangedHandler) {
	 this.stateChangedHandler = stateChangedHandler;
	 
	 return this;
}

WWidget.prototype.setContextMenuHandler = function(contextMenuHandler) {
	this.handleContextMenu = contextMenuHandler;

	return this;
}

WWidget.prototype.setClickedHandler = function(clickedHandler) {
	 this.clickedHandler = clickedHandler;
	 
	 return this;
}

WWidget.prototype.setKeyDoneHandler = function(handleKeyDown) {
	this.handleKeyDown = handleKeyDown;

	return this;
}

WWidget.prototype.setKeyUpHandler = function(handleKeyUp) {
	this.handleKeyUp = handleKeyUp;

	return this;
}

WWidget.prototype.onClicked = function(point) {
	if(this.handleClicked) {
		this.handleClicked(point);
	}

	if(this.clickedHandler) {
		this.clickedHandler(this, point);
	}

	this.postRedraw();

	return this.clickedHandler != null;
}

WWidget.prototype.lookup = function(id, recursive) {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];	
		if(iter.id === id) {
			return iter;
		}
	}

	if(recursive) {
		for(var i = 0; i < n; i++) {
			var iter = this.children[i];	
			var ret = iter.lookup(id, recursive);
			if(ret) {
				return ret;
			}
		}
	}

	return null;
}

WWidget.prototype.onRelayout = function(canvas, force) {
}

WWidget.prototype.relayout = function(canvas, force) {
	if((!this.needRelayout && !force) || !this.children.length) {
		return this;
	}
	
	this.onRelayout(canvas, force);
	this.needRelayout = false;

	return this;
}

WWidget.prototype.setLineWidth = function(lineWidth) {
	this.lineWidth = lineWidth;

	return this;
}

WWidget.prototype.getLineWidth = function(style) {
	return this.lineWidth ? this.lineWidth : style.lineWidth;
}

WWidget.prototype.setRoundRadius = function(roundRadius) {
	this.roundRadius = roundRadius;

	return this;
}

WWidget.prototype.ensureTheme = function() {
	if(this.themeType) {
		this.theme = WThemeManager.get(this.themeType);
	}
	else {
		this.theme = WThemeManager.get(this.type);
	}

	return this;
}

WWidget.prototype.getStyle = function(_state) {
	var style = null;
	this.ensureTheme();
	var state = _state ? _state : this.state;

	if(!this.enable) {
		if(this.selectable && this.isSelected()) {
			style = this.theme[WWidget.STATE_DISABLE_SELECTED];
		}
		else {
			style = this.theme[WWidget.STATE_DISABLE];
		}
	}
	else {
		if(this.selectable && this.selected) {
			style = this.theme[WWidget.STATE_SELECTED];
		}
		else if(state === WWidget.STATE_OVER) {
			style = this.theme[WWidget.STATE_OVER];
		}
		else if(state === WWidget.STATE_ACTIVE) {
			style = this.theme[WWidget.STATE_ACTIVE];
		}
		else {
			style = this.theme[WWidget.STATE_NORMAL];
		}
	}
	
	if(!style) {
		style = this.theme[WWidget.STATE_NORMAL];
	}

	return style;
}

WWidget.prototype.setImageDisplay = function(imageDisplay) { 
	this.imageDisplay = imageDisplay;

	return this;
}

WWidget.prototype.setBorderStyle = function(borderStyle) {
	this.borderStyle = borderStyle;

	return this;;
}

WWidget.prototype.paintBackground = function(canvas) {
	var style =  this.getStyle();
	if(style) {
		if(style.bgImage) {
			this.paintBackgroundImage(canvas, style);
		}
		else {
			this.paintBackgroundColor(canvas, style);
		}
	}
}

WWidget.prototype.paintBackgroundImage = function(canvas, style) {
	var dst  = this.rect;
	var image = style.bgImage.getImage();
	var src = style.bgImage.getImageRect();
	var imageDisplay = style.imageDisplay ? style.imageDisplay : this.imageDisplay;

	if(image) {
		var topOut = style.topOut ? style.topOut : 0;
		var leftOut = style.leftOut ? style.leftOut : 0;
		var rightOut = style.rightOut ? style.rightOut : 0;
		var bottomOut = style.bottomOut ? style.bottomOut : 0;

		var x = -leftOut;
		var y = -topOut;
		var w = dst.w + rightOut + leftOut;
		var h = dst.h + bottomOut + topOut;

		style.bgImage.draw(canvas, imageDisplay, x, y, w, h, src);
	}
}

WWidget.prototype.paintLeftBorder = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(0, h);
	canvas.stroke();
}

WWidget.prototype.paintRightBorder = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(w, 0);
	canvas.lineTo(w, h);
	canvas.stroke();
}

WWidget.prototype.paintTopBorder = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(w, 0);
	canvas.stroke();
}

WWidget.prototype.paintBottomBorder = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, h);
	canvas.lineTo(w, h);
	canvas.stroke();
}

WWidget.prototype.paintBackgroundColor = function(canvas, style) {
	var dst  = this.rect;

	canvas.beginPath();
	if(this.roundRadius || style.roundRadius) {
		var roundRadius = Math.min((dst.h >> 1) - 1, style.roundRadius || this.roundRadius);
		drawRoundRect(canvas, dst.w, dst.h, roundRadius);	
	}
	else {
		canvas.rect(0, 0, dst.w, dst.h);
	}
	
	if(style.fillColor) {
		canvas.fillStyle = style.fillColor;
		canvas.fill();
	}

	var lineWidth = this.getLineWidth(style);
	if(!lineWidth || !style.lineColor || this.borderStyle === WWidget.BORDER_STYLE_NONE) {
		return;
	}

	var w = this.getWidth();
	var h = this.getHeight();
	canvas.lineWidth = lineWidth;
	canvas.strokeStyle = style.lineColor;
	if(this.borderStyle === WWidget.BORDER_STYLE_ALL) {
		canvas.stroke();
		canvas.beginPath();
		return;
	}
	
	if(this.borderStyle & WWidget.BORDER_STYLE_LEFT) {
		this.paintLeftBorder(canvas, w, h);
	}

	if(this.borderStyle & WWidget.BORDER_STYLE_RIGHT) {
		this.paintRightBorder(canvas, w, h);
	}
	
	if(this.borderStyle & WWidget.BORDER_STYLE_TOP) {
		this.paintTopBorder(canvas, w, h);
	}
	
	if(this.borderStyle & WWidget.BORDER_STYLE_BOTTOM) {
		this.paintBottomBorder(canvas, w, h);
	}
	canvas.beginPath();
	
	return;
}

WWidget.prototype.paintSelf = function(canvas) {
	 return this;
}

WWidget.prototype.beforePaint = function(canvas) {
	if(this.onBeforePaint) {
		this.onBeforePaint(canvas);
	}
	return this;
}

WWidget.prototype.afterPaint = function(canvas) {
	if(this.onAfterPaint) {
		this.onAfterPaint(canvas);
	}
	return this;
}

WWidget.prototype.setPaintFocusLater = function(paintFocusLater) {
	this.paintFocusLater = paintFocusLater;

	return this;
}

WWidget.prototype.paintChildren = function(canvas) {
	if(this.paintFocusLater) {
		this.paintChildrenFocusLater(canvas);
	}
	else {
		this.paintChildrenDefault(canvas);
	}

	return this;
}

WWidget.prototype.paintChildrenDefault = function(canvas) {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.draw(canvas);
	}

	return;
}

WWidget.prototype.paintChildrenFocusLater = function(canvas) {
	var focusChild = null;
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		var iterFocused = (iter.state === WWidget.STATE_OVER || iter.state === WWidget.STATE_ACTIVE);

		if(iterFocused) {
			focusChild = iter;
		}
		else {
			iter.draw(canvas);
		}
	}

	if(focusChild) {
		focusChild.draw(canvas);
	}

	return;
}

WWidget.prototype.ensureImages = function() {
	return;
}

WWidget.prototype.draw = function(canvas) {
	 if(!this.visible) {
		  return;
	 }

	if(this.checkEnable) {
		this.setEnable(this.checkEnable());
	}

	this.ensureImages();

	canvas.save();
	this.relayout(canvas, false);

	canvas.translate(this.rect.x, this.rect.y);
	this.beforePaint(canvas);
	this.paintBackground(canvas);
	this.paintSelf(canvas);
	this.paintChildren(canvas);	
	this.drawInputTips(canvas);
	this.afterPaint(canvas);
	canvas.closePath();
	canvas.restore();

	return;
}

WWidget.prototype.setVisible = function(visible) {
	this.visible = visible;

	return this;
}

WWidget.prototype.isVisible = function() {
	return this.visible;
}

WWidget.prototype.onShow = function(visible) {
	return true;
}

WWidget.prototype.show = function(visible) {
	var visible = !!visible;
	if(visible != this.visible) {
		this.visible = visible;
		this.onShow(visible);
	}

	return this;
}

WWidget.prototype.showAll = function(visible) {
	var n = this.children.length;
	
	this.show(visible);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.showAll(visible);
	}
	
	if(!this.parent) {
		this.postRedraw();
	}
	
	return this;
}

WWidget.prototype.selectAllChildren = function(selected) {
	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		if(iter.checkable) {
			iter.setChecked(selected);
		}
	}

	return this;
}

WWidget.prototype.closeWindow = function(retInfo) {
	this.getWindow().close(retInfo);

	return this;
}
	
WWidget.prototype.findTarget = function(point) {
	var p = this.getAbsPosition();
	this.point.x = point.x - p.x;
	this.point.y = point.y - p.y;
	var n = this.children.length;	
	if(n > 0) {
		for(var i = n - 1; i >= 0; i--) {
			var iter = this.children[i];

			if(!iter.visible) {
				continue;
			}

			if(isPointInRect(this.point, iter.rect)) {
				return iter;
			}
		}
	}

	return null;
}

////////////////////////////////////////////
WWidget.prototype.onPointerDown = function(point) {
	if(!this.enable) return false;
	
	var target = this.findTarget(point);
	if(this.target !== target) {
		if(this.target) {
			this.target.setState(WWidget.STATE_NORMAL);
		}
	}

	if(target) {
		target.setState(WWidget.STATE_ACTIVE);
		target.onPointerDown(point);
	}
	else {
		this.changeCursor();
	}

	this.target = target;
	this.postRedraw();

	return true;
}

WWidget.prototype.onPointerMove = function(point) {
	if(!this.enable) return false;

	this.pointerOverr = isPointInRect(point, this.rect);
	var target = this.isPointerDown() ? this.target : this.findTarget(point);

	if(this.target !== target) {
		if(this.target) {
			this.target.setState(WWidget.STATE_NORMAL, true);
		}
	}

	if(target) {
		if(this.isPointerDown()) {
			target.setState(WWidget.STATE_ACTIVE);
		}
		else {
			target.setState(WWidget.STATE_OVER);
		}
		target.onPointerMove(point);
	}
	else {
		this.changeCursor();
	}
	
	this.target = target;
	this.postRedraw();

	return true;
}

WWidget.prototype.onPointerUp = function(point) {
	if(!this.enable) return false;
	
	var target = this.findTarget(point);
	if(this.target !== target) {
		if(this.target) {
			this.target.setState(WWidget.STATE_NORMAL);
			this.target.onPointerUp(point);
		}
	}
	
	if(target) {
		target.setState(WWidget.STATE_OVER);
		target.onPointerUp(point);
	}
	else {
		this.changeCursor();
	}
		
	if(this.isClicked()) {
		try {
			this.onClicked(point);
		}catch(e) {
			console.debug('stack:', e.stack);
			console.debug("this.onClicked:" + e.message);
		}
	}

	this.target = target;
	this.postRedraw();

	return true;
}

WWidget.prototype.onKeyDown = function(code) {
	if(this.target) {
		this.target.onKeyDown(code);
	}

	if(this.handleKeyDown) {
		this.handleKeyDown(code);
	}

	console.log("onKeyDown WWidget:" + this.type + " code=" + code)
	return;
}

WWidget.prototype.onKeyUp = function(code) {
	if(this.target) {
		this.target.onKeyUp(code);
	}
	
	if(this.handleKeyUp) {
		this.handleKeyUp(code);
	}
	console.log("onKeyUp WWidget:" + this.type + " code=" + code)
	return;
}	

WWidget.prototype.onWheel = function(delta) {
	if(this.target) {
		return this.target.onWheel(delta);
	}

	if(this.handleWheel) {
		return this.handleWheel(delta);
	}

	return false;
}


WWidget.prototype.onDoubleClick = function(point) {
	var target = null;

	if(this.grabWidget) {
		target = this.grabWidget;
	}
	else {
		target = this.findTarget(point);
	}
	 
	if(target) {
		target.onDoubleClick(point);
		this.target = target;
	}

	if(this.state !== WWidget.STATE_DISABLE && this.handleDoubleClicked) {
		this.handleDoubleClicked(point);
	}
	
	return;
}

WWidget.prototype.onContextMenu = function(point) {
	var target = this.findTarget(point);

	if(target) {
		target.onContextMenu(point);
		this.target = target;
	}

	if(this.state !== WWidget.STATE_DISABLE && this.handleContextMenu) {
		this.handleContextMenu(point);
	}

	return;
}

WWidget.prototype.onLongPress = function(point) {
	var target = this.findTarget(point);
	 
	 if(target) {
		  target.onLongPress(point);
		  this.target = target;
	 }
	
	if(this.state !== WWidget.STATE_DISABLE && this.handleLongPressed) {
		this.handleLongPressed(point);
	}

	return;
}

WWidget.prototype.onGesture = function(gesture) {
	var target = this.findTarget(point);

	if(target) {
		 target.onGesture(gesture);
	}

	if(this.state !== WWidget.STATE_DISABLE && this.handleGesture) {
		this.handleGesture(gesture);
	}

	return;
}

WWidget.prototype.setCursor = function(cursor) {
	this.cursor = cursor;

	return this;
}

WWidget.canvasPool = [];
WWidget.resizeCanvas = function(canvas, w, h) {
    canvas.width = w;
    canvas.height = h;
}

WWidget.getCanvas = function(x, y, w, h, zIndex) {
	var canvas = null;
	if(WWidget.canvasPool.length) {
		canvas = WWidget.canvasPool.pop();
	}
	else {
		canvas = document.createElement('canvas');
	}
    
    WWidget.resizeCanvas(canvas, w, h);
	canvas.style.position = "absolute";
	canvas.style.opacity = 1;
	canvas.style.left = x + "px";
	canvas.style.top = y + "px";
	canvas.style.width = w + "px";
	canvas.style.height = h + "px";
	canvas.style.zIndex = zIndex;

	return canvas;
}

WWidget.putCanvas = function(canvas) {
	canvas.style.zIndex = -1;
	canvas.style.opacity = 0;
	WWidget.canvasPool.push(canvas);
}

WWidget.tipsCanvas = null;
WWidget.getTipsCanvas = function(x, y, w, h, zIndex) {
	if(!WWidget.tipsCanvas) {
		WWidget.tipsCanvas = WWidget.getCanvas(x, y, w, h, zIndex);
		document.body.appendChild(WWidget.tipsCanvas);
	}

	var canvas = WWidget.tipsCanvas;

	canvas.width = w;
	canvas.height = h;
	canvas.style.position = "absolute";
	canvas.style.opacity = 1;
	canvas.style.left = x + "px";
	canvas.style.top = y + "px";
	canvas.style.width = w + "px";
	canvas.style.height = h + "px";
	canvas.style.zIndex = zIndex;

	return canvas;
}

WWidget.hideTipsCanvas = function() {
	var canvas = WWidget.tipsCanvas;
	if(canvas) {
		canvas.style.zIndex = -1;
	}
}
/*
 * File: theme.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: cantk theme.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function WThemeManager() {
}

WThemeManager.newStyle = function(font, fillColor, textColor, lineColor, bgImage) {
	var style = {};

	if(font) {
		style.font = font;
	}

	if(bgImage) {
		style.bgImage = bgImage;
	}

	if(fillColor) {
		style.fillColor = fillColor;
	}

	if(textColor) {
		style.textColor = textColor;
	}

	if(lineColor) {
		style.lineColor = lineColor;
	}

	return style;
}

WThemeManager.newTheme = function() {
	var theme = {};

	theme[WWidget.STATE_NORMAL]  = WThemeManager.newStyle("13pt bold sans-serif ", null, "#000000", "#000000");
	theme[WWidget.STATE_ACTIVE]  = WThemeManager.newStyle("13pt bold sans-serif ", null, "#000000");
	theme[WWidget.STATE_OVER]    = WThemeManager.newStyle("13pt bold sans-serif ", null, "#000000");
	theme[WWidget.STATE_DISABLE] = WThemeManager.newStyle("13pt bold sans-serif ", null, "Gray");
	theme[WWidget.STATE_SELECTED]= WThemeManager.newStyle("13pt bold sans-serif ", null, "Gray");

	return theme;
}

WThemeManager.themes = {};
WThemeManager.imagesURL = null;
WThemeManager.defaultTheme = WThemeManager.newTheme();
WThemeManager.themeURL = "/ide/theme/default/theme.json";

WThemeManager.setImagesURL = function(imagesURL) {
	WThemeManager.imagesURL = imagesURL;

	return;
}

WThemeManager.getIconImageURL = function() {
	return WThemeManager.imagesURL;
}

WThemeManager.getImageURL = function() {
	return WThemeManager.imagesURL;
}

WThemeManager.imagesCache = {};
WThemeManager.createImage = function(url) {
	var image = WThemeManager.imagesCache[url];
	if(!image) {
		image = WImage.create(url);
	}

	return image;
}

WThemeManager.getIconImage = function(name) {
	if(name.endWith(".png")) {
		return WThemeManager.getImage(name);
	}
	else {
		return WThemeManager.getImage(name + ".png");
	}
}

WThemeManager.getBgImage = function(name) {
	return this.getImage(name);
}

WThemeManager.getImage = function(name) {
	if(!WThemeManager.imagesURL) {
		return null;
	}
	
	var url = WThemeManager.imagesURL + "#" + name;
	return this.createImage(url);
}

WThemeManager.setTheme = function(theme) {
	WebStorage.set("wtkTheme", theme);
	location.href = location.href;

	return;
}

WThemeManager.getThemeURL = function() {
	var themeURL = getQueryParameter("theme-url");
	if(themeURL) {
		return themeURL;
	}
	
	var theme = getQueryParameter("theme");
	if(theme) {
		return "/ide/images/"+theme+"/theme.json";
	}

	var wtkTheme = WebStorage.get("wtkTheme");
	if(wtkTheme) {
		return "/ide/images/"+wtkTheme+"/theme.json";
	}

	return WThemeManager.themeURL;
}

WThemeManager.getDefaultFont = function(themeJson) {
	var font = null;
	var global = themeJson.global;
	if(global && global.font) {
		if(browser.isWindows()) {
			font = global.font.windows;
		}
		else if(browser.isLinux()) {
			font = global.font.linux;
		}
		else if(browser.isMacOSX()) {
			font = global.font.macosx;
		}
	}

	return font;
}

WThemeManager.applyDefaultFont = function(style, defaultFont) {
	var font = style.font || {};
	
	if(defaultFont) {
		if(!font.family) {
			font.family = defaultFont.family || "sans";
		}

		if(!font.size) {
			font.size = defaultFont.size || 10;
		}

		if(!font.weight) {
			font.weight = "normal";
		}
	}

	style.fontInfo = font;
	style.fontSize = font.size;
	style.font =font.weight + " " + font.size + "px " + font.family;
	
	return;
}

WThemeManager.loadTheme = function(themeURL, themeJson) {
	var path = dirname(themeURL);
	var imagesURL = path + "/" + (themeJson.imagesURL ? themeJson.imagesURL : "images.json");
	WThemeManager.setImagesURL(imagesURL);

	var font = WThemeManager.getDefaultFont(themeJson);
	var widgetsTheme = themeJson.widgets;

	for(var name in widgetsTheme) {
		var widgetTheme = widgetsTheme[name];
		for(var state in widgetTheme) {
			var style = widgetTheme[state];
			if(typeof style !== "object") continue;

			if(style.bgImage) {
				style.bgImage = WThemeManager.getImage(style.bgImage);
			}
			if(style.fgImage) {
				style.fgImage = WThemeManager.getImage(style.fgImage);
			}
			if(style.bgImageTips) {
				style.bgImageTips = WThemeManager.getImage(style.bgImageTips);
			}
			if(style.checkedImage) {
				style.checkedImage = WThemeManager.getImage(style.checkedImage);
			}
			if(style.uncheckedImage) {
				style.uncheckedImage = WThemeManager.getImage(style.uncheckedImage);
			}
			WThemeManager.applyDefaultFont(style, font);
		}
	}

	WThemeManager.themes = widgetsTheme;
	WThemeManager.themesLoaded = true;
	WThemeManager.jqueryTheme = themeJson.jqueryTheme;
	WThemeManager.codeEditorTheme = themeJson.codeEditorTheme;

	if(WThemeManager.overrideThemeData) {
		WThemeManager.mergeTheme(WThemeManager.overrideThemeData);
	}

	return;
}

WThemeManager.setOverrideThemeData = function(widgetsTheme) {
	if(WThemeManager.themesLoaded) {
		WThemeManager.mergeTheme(widgetsTheme);
	}else {
		WThemeManager.overrideThemeData = widgetsTheme;
	}

	return;
}

WThemeManager.mergeTheme = function(widgetsTheme) {
	for(var name in widgetsTheme) {
		var widgetTheme = widgetsTheme[name];
		for(var state in widgetTheme) {
			var style = widgetTheme[state];
			if(typeof style !== "object") continue;

			if(style.bgImage) {
				style.bgImage = WThemeManager.createImage(style.bgImage);
			}
			if(style.fgImage) {
				style.fgImage = WThemeManager.createImage(style.fgImage);
			}
			if(style.bgImageTips) {
				style.bgImageTips = WThemeManager.createImage(style.bgImageTips);
			}
			if(style.checkedImage) {
				style.checkedImage = WThemeManager.createImage(style.checkedImage);
			}
			if(style.uncheckedImage) {
				style.uncheckedImage = WThemeManager.createImage(style.uncheckedImage);
			}
			if(style.font) {
				style.fontSize = getFontSizeInFont(style.font);
				if(style.fontSize) {
					style.fontSize = 12;
				}
			}
		}
	
		WThemeManager.themes[name] = widgetsTheme[name]
	}

	return;
}

WThemeManager.getCodeEditorTheme = function() {
	return WThemeManager.codeEditorTheme;
}

WThemeManager.getJQueryTheme = function() {
	return WThemeManager.jqueryTheme;
}

WThemeManager.loadThemeURL = function(url) {
	if(!url) {
		url = WThemeManager.getThemeURL();
	}

	httpGetJSON(url, function onThemeData(themeJson) {
		WThemeManager.loadTheme(url, themeJson);
		var wm = WWindowManager.getInstance();
		if(wm) {
			wm.postRedraw();
		}
	});

	return;
}

WThemeManager.exist = function(name) {
	return WThemeManager.themes[name] != null;
}

WThemeManager.dump = function() {
	var str = JSON.stringify(WThemeManager.themes, null, "\t");
	console.log(str);

	return;
}

WThemeManager.get = function(name, noDefault) {
	name = name.toString();

	var theme = WThemeManager.themes[name];

	if(!theme) {
		if(noDefault) {
			WThemeManager.themes[name] = WThemeManager.newTheme();
			theme = WThemeManager.themes[name];
		}
		else {
			theme = WThemeManager.defaultTheme;
		}
	}

	return theme;
}

WThemeManager.set = function(name, state, font, textColor, fillColor, lineColor, bgImage) {
	if(state === null) {
		WThemeManager.setOneState(name, WWidget.STATE_NORMAL, font, textColor, fillColor, lineColor, bgImage);
		WThemeManager.setOneState(name, WWidget.STATE_ACTIVE, font, textColor, fillColor, lineColor, bgImage);
		WThemeManager.setOneState(name, WWidget.STATE_OVER, font, textColor, fillColor, lineColor, bgImage);
		WThemeManager.setOneState(name, WWidget.STATE_SELECTED, font, textColor, fillColor, lineColor, bgImage);
		WThemeManager.setOneState(name, WWidget.STATE_DISABLE, font, textColor, fillColor, lineColor, bgImage);
	}
	else {
		WThemeManager.setOneState(name, state, font, textColor, fillColor, lineColor, bgImage);
	}

	return;
}

WThemeManager.setOneState = function(name, state, font, textColor, fillColor, lineColor, bgImage) {
	name = name.toString();

	var theme = WThemeManager.themes[name];

	if(!theme) {
		theme = WThemeManager.newTheme();
		WThemeManager.themes[name] = theme;
	}

	if(font) {
		theme[state].font = font;
	}
	
	if(textColor) {
		theme[state].textColor = textColor;
	}

	if(bgColor) {
		theme[state].fillColor = bgColor;
	}

	if(lineColor) {
		theme[state].lineColor = lineColor;
	}

	if(bgImage) {
		theme[state].bgImage = bgImage;
	}

	return;
}

/*
 * File: window.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: window
 * 
 * Copyright (c) 2011 - 2015	Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016	Holaverse Inc.
 * 
 */
 
function WWindow() {
}

WWindow.prototype = new WWidget();
WWindow.prototype.init = function(manager, x, y, w, h) {
	this.type = this.type ? this.type : WWidget.TYPE_WINDOW;
	WWidget.prototype.init.call(this, null, x, y, w, h);
	
	this.grabWidget = null;
	this.manager = manager ? manager : WWindowManager.getInstance();

	var me = this;
	setTimeout(function() {
		me.manager.addWindow(me);
	}, 0);

	this.onClosed = null;
	this.closeHandler = null;
	this.pointerDownPosition = {x:0, y:0};
	this.pointerUpPosition = {x:0, y:0};
	this.pointerLastPosition = {x:0, y:0};

	return this;
}

WWindow.prototype.grab = function(widget) {
	this.grabWidget = widget;
	this.manager.grab(this);
	
	return this;
}

WWindow.prototype.ungrab = function() {
	this.grabWidget = null;
	this.manager.ungrab(this);
	
	return this;
}

WWindow.prototype.moveToCenter = function() {
	var view = cantkGetViewPort();
	var sw = Math.min(this.manager.w, view.width);
	var sh = Math.min(this.manager.h, view.height);
	
	var x = (sw - this.rect.w)/2;
	var y = (sh - this.rect.h)/2 + getScrollTop();

	this.rect.x = x;
	this.rect.y = y;
	
	return this;
}

WWindow.prototype.onPointerDown = function(point) {
	this.pointerDown = true;
	this.pointerDownPosition.x = point.x;
	this.pointerDownPosition.y = point.y;
	this.pointerLastPosition.x = point.x;
	this.pointerLastPosition.y = point.y;

	if(this.grabWidget) {
		this.grabWidget.onPointerDown(point);
	}
	else {
		WWidget.prototype.onPointerDown.call(this, point);
	}
	
	this.postRedraw();

	return;
}

WWindow.prototype.onPointerMove = function(point) {
	this.pointerLastPosition.x = point.x;
	this.pointerLastPosition.y = point.y;

	if(this.grabWidget) {
		this.grabWidget.onPointerMove(point);
	}
	else {
		WWidget.prototype.onPointerMove.call(this, point);
	}
	
	this.postRedraw();

	return;
}

WWindow.prototype.onPointerUp = function(point) {
	if(!this.pointerDown) {
//		return;
	}

	this.pointerUpPosition.x = point.x;
	this.pointerUpPosition.y = point.y;
	if(this.grabWidget) {
		this.grabWidget.onPointerUp(point);
	}
	else {
		WWidget.prototype.onPointerUp.call(this, point);
	}
	this.pointerDown = false;
	
	this.postRedraw();

	return;
}

WWindow.prototype.isClicked = function() {
	var dx = this.pointerLastPosition.x - this.pointerDownPosition.x;
	var dy = this.pointerLastPosition.y - this.pointerDownPosition.y;

	return Math.abs(dx) < 5 && Math.abs(dy) < 5;
}

WWindow.prototype.onContextMenu = function(point) {
	if(this.grabWidget) {
		this.grabWidget.onContextMenu(point);
	}
	else {
		WWidget.prototype.onContextMenu.call(this, point);
	}

	return;
}

WWindow.prototype.onKeyDown = function(code) {
	if(this.grabWidget) {
		 this.grabWidget.onKeyDown(code);
	}
	else {
		WWidget.prototype.onKeyDown.call(this, code);
	}

	return;
}

WWindow.prototype.onKeyUp = function(code) {
	if(this.grabWidget) {
		 this.grabWidget.onKeyUp(code);
	}
	else {
		WWidget.prototype.onKeyUp.call(this, code);
	}

	return;
}

WWindow.prototype.beforePaint = function(canvas) {
	canvas.beginPath();
	canvas.rect(0, 0, this.rect.w, this.rect.h);
	canvas.clip();
	canvas.beginPath();

	return;
}

WWindow.prototype.show = function(visible) {
	WWidget.prototype.show.call(this, visible);
	this.manager.setTopWindowAsTarget();
	
	return this;
}

WWindow.prototype.close = function(retInfo) {
	var me = this;
	setTimeout(function() {
		me.closeSync(retInfo);
	},10);

	return this;
}

WWindow.prototype.setCloseHandler = function(closeHandler) {
	this.closeHandler = closeHandler;

	return this;
}

WWindow.prototype.closeSync = function(retInfo) {
	if(this.onClosed) {
		this.onClosed(retInfo);
	}

	if(this.closeHandler) {
		this.closeHandler();
	}

	this.manager.ungrab(this);
	this.manager.removeWindow(this);
	this.destroy();

	return;
}

WWindow.prototype.getCanvas2D = function() {
	return WWindowManager.getInstance().getCanvas2D();
}

WWindow.prototype.getCanvas = function() {
	return WWindowManager.getInstance().getCanvas();
}

WWindow.create =  function(manager, x, y, w, h) {
	var win = new WWindow();

	return win.init(manager, x, y, w, h);
}
/*
 * File: web_storage.js 
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Web Storage
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */


function WebStorage()  {
}

WebStorage.nameSpace = "";
WebStorage.setNameSapce = function(nameSpace) {
	WebStorage.nameSpace = nameSpace;

	return;
}

WebStorage.getNameSapceKey = function(key) {	
	if(WebStorage.nameSpace) {
		return WebStorage.nameSpace +"-"+ key;
	}
	else {
		return key;
	}
}

WebStorage.getStorage = function() {
	if(window.localStorage) {
		return window.localStorage;
	}

	return {};
}

WebStorage.set = function(key, value, compress) {
	var storage = WebStorage.getStorage();
	
	key = WebStorage.getNameSapceKey(key);
	if(compress && !isIE()) {
		storage.setItem(key, strCompress(value));
	}
	else {
		storage.setItem(key, value);
	}

	return;
}

WebStorage.get = function(key, decompress) {
	var storage = WebStorage.getStorage();

	key = WebStorage.getNameSapceKey(key);
	if(decompress && !isIE()) {
		return strDecompress(storage.getItem(key));
	}
	else {
		return storage.getItem(key);
	}
}

WebStorage.remove = function(key) {
	var storage = WebStorage.getStorage();

	key = WebStorage.getNameSapceKey(key);
	storage.removeItem(key);

	return;
}

WebStorage.getInt = function(key) {
	var n = 0;
	var value = WebStorage.get(key);

	if(value) {
		n = parseInt(value);
	}
	
	return n;
}

//////////////////////////////////////////////////////

WebStorage.getSessionStorage = function() {
	if(window.sessionStorage) {
		return window.sessionStorage;
	}

	return {};
}

WebStorage.setSession = function(key, value, compress) {
	var storage = WebStorage.getSessionStorage();
	
	key = WebStorage.getNameSapceKey(key);
	if(compress && !isIE()) {
		storage.setItem(key, strCompress(value));
	}
	else {
		storage.setItem(key, value);
	}

	return;
}

WebStorage.getSession = function(key, decompress) {
	var storage = WebStorage.getSessionStorage();

	key = WebStorage.getNameSapceKey(key);
	if(decompress && !isIE()) {
		return strDecompress(storage.getItem(key));
	}
	else {
		return storage.getItem(key);
	}
}

WebStorage.removeSession = function(key) {
	var storage = WebStorage.getSessionStorage();

	key = WebStorage.getNameSapceKey(key);
	storage.removeItem(key);

	return;
}

WebStorage.reset = function() {
	for(var key in localStorage) {
		localStorage.removeItem(key);
	}
}

WebStorage.dump = function() {
	for(var key in localStorage) {
		console.log(key + ":" + localStorage[key]);
	}
}

/*
 * File: window_manager.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: window manager
 * 
 * Copyright (c) 2011 - 2015	Li XianJing <xianjimli@hotmail.com>
 * 
 */
  
function WWindowManager() {
	return;
}

WWindowManager.create = function(app, canvas, eventElement) {
	WWindowManager.instance = new WWindowManager();
	WEventsManager.setEventsConsumer(WWindowManager.instance, eventElement);

	return WWindowManager.instance.init(app, canvas);
}

WWindowManager.getInstance = function() {
	return WWindowManager.instance;
}

WWindowManager.prototype.init = function(app, canvas) {
	this.app = app;
	this.canvas = canvas;
	
	this.w = canvas.width;
	this.h = canvas.height;
	
	this.last_point = 0;
	this.pointerDown = 0;
	this.target = null;
	this.drawCount = 0;
	this.requestCount = 0;
	this.startTime = Date.now();
	this.windows = new Array();
	this.grabWindows = new Array();
	this.eventLogging = false;
	this.pointerDownPoint = {x:0, y:0};
	this.lastPointerPoint = {x:0, y:0};
	this.enablePaint = true;
	this.beforeDrawHandlers = [];

	return this;
}

WWindowManager.prototype.getApp = function() {
	return this.app;
}

WWindowManager.onMultiTouch = function(action, points, event) {
}

WWindowManager.prototype.onMultiTouch = function(action, points, event) {
	for(var i = 0; i < points.length; i++) {
		this.translatePoint(points[i]);
	}

	WWindowManager.onMultiTouch(action, points, event);
}

WWindowManager.prototype.preprocessEvent = function(type, e, arg) {
	this.currentEvent = e.originalEvent ? e.originalEvent : e;
	return true;
}

WWindowManager.prototype.getCanvas = function() {
	return this.canvas;
}

WWindowManager.prototype.getWidth = function() {
	return this.w;
}

WWindowManager.prototype.getHeight = function() {
	return this.h;
}

WWindowManager.prototype.findTargetWin = function(point) {
	 var target = null;
	 var nr = this.grabWindows.length;
	 
	 if(nr > 0) {
	  	for(var i = nr-1; i >= 0; i--) {
		  target = this.grabWindows[i];
		  if(!target.visible) {
		  	continue;
		  }

		  return target;
	 	}
	 }
	  
	  nr = this.windows.length;
	  for(var i = nr-1; i >= 0; i--) {
			var win = this.windows[i];
			if(!win.visible) {
				 continue;
			}
			
			if(isPointInRect(point, win.rect)) {
				 target = win;
				 break;
			 }
	  }
		  
	 return target;
}
		
WWindowManager.prototype.resize = function(w, h) {
	this.w = w;
	this.h = h;
	this.postRedraw();

	return;
}

WWindowManager.prototype.grab = function(win) {
	 this.grabWindows.push(win);
	 
	 return;
}

WWindowManager.prototype.ungrab = function(win) {
	 this.grabWindows.remove(win);
	 
	 return;
}

WWindowManager.prototype.onDoubleClick = function(point) {	
    this.translatePoint(point);
	 this.target = this.findTargetWin(point);
	 
	if(this.target) {
		 this.target.onDoubleClick(point);
	 }
	 else {
		 console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	 }
	 
	return;
}

WWindowManager.prototype.onLongPress = function(point) {	
	 this.target = this.findTargetWin(point);
	 
	if(this.target) {
		 this.target.onLongPress(point);
	 }
	 else {
		 console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	 }
	 
	return;
}

WWindowManager.prototype.onGesture = function(gesture) {	
	cantkHideAllInput();

	var point = {x:this.w/2, y:this.h/2};
	this.target = this.findTargetWin(point);

	if(this.target) {
		this.target.onGesture(gesture);
		console.log("WWindowManager.prototype.onGesture: scale=" + gesture.scale + " rotation=" + gesture.rotation);
	}
	else {
		 console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	}
	 
	return;
}

WWindowManager.setInputScale = function(xInputScale, yInputScale) {	
	WWindowManager.xInputScale = xInputScale;
	WWindowManager.yInputScale = yInputScale;

	return;
}

WWindowManager.setInputOffset = function(xInputOffset, yInputOffset) {	
	WWindowManager.xInputOffset = xInputOffset;
	WWindowManager.yInputOffset = yInputOffset;

	return;
}


WWindowManager.prototype.getInputScale = function() {	
	return {x:WWindowManager.xInputScale, y:WWindowManager.yInputScale};
}

WWindowManager.prototype.translatePoint = function(point) {	
	if(WWindowManager.xInputOffset) {
		point.x -= WWindowManager.xInputOffset;
	}
	
	if(WWindowManager.yInputOffset) {
		point.y -= WWindowManager.yInputOffset;
	}

	if(WWindowManager.xInputScale) {
		point.x = Math.round(point.x * WWindowManager.xInputScale);
	}

	if(WWindowManager.yInputScale) {
		point.y = Math.round(point.y * WWindowManager.yInputScale);
	}

	return point;
}

WWindowManager.prototype.onPointerDown = function(point) {	
	cantkHideAllInput();

	this.translatePoint(point);
	this.target = this.findTargetWin(point);

	for(var i = 0; i < this.windows.length; i++) {
		var win = this.windows[i];
		if(win.state === WWidget.STATE_SELECTED && win !== this.target) {
			win.setState(WWidget.STATE_NORMAL);
		}
	}

	this.pointerDown = true;
	this.pointerDownPoint.x = point.x;
	this.pointerDownPoint.y = point.y;
	this.lastPointerPoint.x = point.x;
	this.lastPointerPoint.y = point.y;

	if(this.target) {
		point.time = Date.now();
		 this.target.onPointerDown(point);
	 }
	 else {
		 console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	 }
	 
	return;
}

WWindowManager.prototype.onPointerMove = function(point) {
	this.translatePoint(point);
	var target = this.findTargetWin(point);
	  
	this.lastPointerPoint.x = point.x;
	this.lastPointerPoint.y = point.y;

	if(this.target && target != this.target) {
		 this.target.onPointerMove(point);
	}
	this.target = target;
	if(this.target) {
		point.time = Date.now();
		this.target.onPointerMove(point);
	}
	
	return;
}

WWindowManager.prototype.onPointerUp = function(point) {
	this.translatePoint(point);
	point = this.lastPointerPoint;
	this.target = this.findTargetWin(point);
	 
	if(this.target) {
		point.time = Date.now();
		this.target.onPointerUp(point);
	 }
	 else {
		  console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	 }
	this.pointerDown = false;
	
	return;
}

WWindowManager.prototype.getLastPointerPoint = function() {
	return this.lastPointerPoint;
}

WWindowManager.prototype.isPointerDown= function() {
	return this.pointerDown;
}

WWindowManager.prototype.isClicked = function() {
	var dx = Math.abs(this.lastPointerPoint.x - this.pointerDownPoint.x);
	var dy = Math.abs(this.lastPointerPoint.y - this.pointerDownPoint.y);

	return (dx < 10 && dy < 10);
}

WWindowManager.prototype.isCtrlDown = function() {
	return this.currentEvent && this.currentEvent.ctrlKey;
}

WWindowManager.prototype.isAltDown = function() {
	return this.currentEvent && this.currentEvent.altKey;
}

WWindowManager.prototype.onContextMenu = function(point) {
	 this.target = this.findTargetWin(point);
	 
	if(this.target) {
		 this.target.onContextMenu(point);
	 }
	 else {
		  console.log("Window Manager: no target for x=" + point.x + " y=" + point.y);
	 }
	
	return;
}

WWindowManager.prototype.onKeyDown = function(code) {
	if(!this.target) {
		this.target = this.findTargetWin({x:50, y:50});
		console.log("onKeyDown: findTargetWin=" + this.target);
	}

	if(this.target !== null) {
		 this.target.onKeyDown(code);
	}
			
	return;
}

WWindowManager.prototype.onKeyUp = function(code) {
	if(this.target !== null) {
		this.target.onKeyUp(code);
	}
	
	return;
}

WWindowManager.prototype.onWheel = function(delta) {
	this.postRedraw();

	if(!this.target) {
		this.target = this.findTargetWin({x:50, y:50});
		console.log("onWheel : findTargetWin=" + this.target);
	}

	if(this.target !== null) {
		 return this.target.onWheel(delta);
	}
			
	return false;
}

WWindowManager.prototype.dispatchPointerMoveOut = function() {
	this.onPointerMove({x:-1, y:-1});
	this.target = null;

	return this;
}

WWindowManager.prototype.setTopWindowAsTarget = function() {
	var windows = this.windows;
	var n = windows.length;

	this.target = null;
	for(var i = n - 1; i >= 0; i--) {
		var iter = windows[i];
		if(iter.visible) {
			this.target = iter;
			break;
		}
	}

	return this;
}

WWindowManager.prototype.addWindow = function(win) {
	this.dispatchPointerMoveOut();
	this.target = win;
	this.windows.push(win);
	this.postRedraw();

	return;
}

WWindowManager.prototype.removeWindow = function(win) {
	this.ungrab(win);
	if(this.target === win) {
		this.target = null;
	}
	this.windows.remove(win);
	this.postRedraw();
	
	return;
}

WWindowManager.prototype.getFrameRate = function() {
	var duration = Date.now() - this.startTime;
	var fps = Math.round(1000  * this.drawCount / duration);

	if(duration > 1000) {
		this.drawCount = 0;
		this.startTime = Date.now();
	}

	return fps;
}

WWindowManager.prototype.setMaxFPSMode = function(maxFpsMode) {
	this.maxFpsMode = maxFpsMode;

	return this;
}

WWindowManager.prototype.showFPS = function(shouldShowFPS) {
	this.drawCount = 1;
	this.startTime = Date.now();
	this.shouldShowFPS = shouldShowFPS;

	return this;
}

WWindowManager.prototype.getPaintEnable = function() {
	return this.enablePaint;
}

WWindowManager.prototype.setPaintEnable = function(enablePaint) {
	this.enablePaint = enablePaint;
	console.log("setPaintEnable:" + enablePaint);

	if(enablePaint) {
		this.postRedraw();
	}

	return this;
}

WWindowManager.prototype.onDrawFrame = function() {
	this.drawCount++;
	this.requestCount = 0;
	this.draw();

	return;
}

WWindowManager.prototype.postRedraw = function(rect) {
	if(!this.enablePaint) {
		return;
	}
	
	this.requestCount++;
	if(this.requestCount < 2) {
		requestAnimationFrame(this.onDrawFrame.bind(this));
	}

	return;
}

WWindowManager.prototype.setTipsWidget = function(widget) {
	this.tipsWidget = widget;

	return;
}

WWindowManager.prototype.drawTips = function(canvas) {
	var tipsWidget = this.tipsWidget;
	if(!tipsWidget || !tipsWidget.parent) return;

	WWidget.hideTipsCanvas();
	var p = tipsWidget.getPositionInView();

	var win = tipsWidget.getWindow();
	if(win.canvas) {
		canvas = win.canvas.getContext("2d");
		var p = tipsWidget.getPositionInWindow();
		canvas.save();
		canvas.translate(p.x, p.y);
		canvas.beginPath();
		tipsWidget.drawTips(canvas);
		canvas.restore();
	}
	else {
		canvas.save();
		canvas.translate(p.x, p.y);
		canvas.beginPath();
		tipsWidget.drawTips(canvas);
		canvas.restore();
	}

	return;
}

WWindowManager.prototype.beforeDrawWindows = function(canvas) {}

WWindowManager.prototype.afterDrawWindows = function(canvas) {}

WWindowManager.prototype.drawWindows = function(canvas) {
    var nr = this.windows.length;
    this.beforeDrawWindows(canvas);
    for (var i = 0; i < nr; i++) {
        var win = this.windows[i];
        win.draw(canvas);
    }
    this.drawTips(canvas);
    this.afterDrawWindows(canvas);

    return;
}

WWindowManager.prototype.redrawRect = function(rect) {
	var canvas = this.getCanvas2D();
	canvas.save();
	if(rect) {
		canvas.beginPath();
		canvas.rect(rect.x, rect.y, rect.w, rect.h);
		canvas.clip();
	}
	this.drawWindows(canvas);
	canvas.restore();

	return;
}

//overwrite checkNeedRedraw to limit fps 
WWindowManager.prototype.checkNeedRedraw = function(timeStep) {
	return true;
}

WWindowManager.canvasContextName = "2d";
WWindowManager.setCanvasContextName = function(name) {
	WWindowManager.canvasContextName = name;
}

WWindowManager.prototype.getCanvas2D = function() {
	if(!this.ctx) {
		var ctx = this.canvas.getContext(WWindowManager.canvasContextName);

		if(!ctx) {
			ctx = this.canvas.getContext("2d");
			ctx["imageSmoothingEnabled"] = true;
		}

		if(!ctx.beginFrame) {
			ctx.beginFrame = function() {}
		}
		if(!ctx.endFrame) {
			ctx.endFrame = function() {}
		}
		if(!ctx.clipRect) {
			ctx.clipRect = function(x, y, w, h) {
				ctx.beginPath();
				ctx.rect(x, y, w, h);
				ctx.clip();
				ctx.beginPath();
			}
		}
		this.ctx = ctx;
	}

	return this.ctx;
}

WWindowManager.prototype.doDraw = function(ctx) {
	var now = Date.now();
	var timeStep = now - (this.lastUpdateTime || 0);

	if(!this.checkNeedRedraw(timeStep)) {
		return;
	}

	ctx.now = now;
	ctx.animating = 0;
	ctx.needRedraw = 0;
	ctx.timeStep = timeStep;
	ctx.lastUpdateTime = this.lastUpdateTime;
	WWindowManager.dispatchTimers(ctx.now);

	ctx.save();
	this.drawWindows(ctx);
	ctx.restore();

	if(this.shouldShowFPS) {
		var str = this.getFrameRate();
		var w = 100;
		var h = 30;
		ctx.beginPath();
		ctx.rect(0, 0, w, h);
		ctx.fillStyle = "Black";
		ctx.fill();
		
		ctx.save();
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.font = "20px Sans";
		ctx.fillStyle = "White";
		ctx.fillText(str, w >> 1, h >> 1);
		ctx.restore();
	}

	if(window.cantkRTV8 || this.maxFpsMode || ctx.needRedraw > 0) {
		this.postRedraw();
	}

	this.lastUpdateTime = ctx.now;
}

WWindowManager.prototype.draw = function() {
	var ctx = this.getCanvas2D();

	ctx.beginFrame();
	this.doDraw(ctx);
	ctx.endFrame();

	return;
}

WWindowManager.timerID = 1000;
WWindowManager.timerFuncs = [];
WWindowManager.intervalFuncs = [];

WWindowManager.dispatchTimers = function(t) {
	var arr = WWindowManager.timerFuncs;
	var n = arr.length;
	if(n > 0) {
		WWindowManager.timerFuncs = [];
		for(var i = 0; i < n; i++) {
			var info = arr[id];
			if(info.removed) continue;

			if(info.timeout <= t) {
				callback.call(window);
			}
			else {
				WWindowManager.timerFuncs.push(info);
			}
		}
	}

	arr = WWindowManager.intervalFuncs;
	n = arr.length;
	if(n > 0) {
		WWindowManager.intervalFuncs = [];
		for(var i = 0; i < n; i++) {
			var info = arr[id];
			if(info.removed) continue;

			if(info.timeout <= t) {
				callback.call(window);
				info.timeout = t + info.duration;
			}
			WWindowManager.timerFuncs.push(info);
		}
	}

	return;
}

WWindowManager.setTimeout = function(callback, duration) {
	if(!callback) return;

	var id = WWindowManager.timerID++;
	var info = {id:id, callback:callback};
	info.timeout = Date.now() + duration/1000;

	WWindowManager.timerFuncs.push(info);

	return id;
}

WWindowManager.setInterval = function(callback, duration) {
	if(!callback) return;

	var id = WWindowManager.timerID++;
	var info = {id:id, callback:callback};

	info.duration = duration/1000;
	info.timeout = Date.now() + info.duration;

	WWindowManager.intervalFuncs.push(info);

	return id;
}

WWindowManager.removeTimerInArr = function(arr, id) {
	var n = arr.length;
	for(var i = 0; i < n; i++) {
		var iter = arr[i];
		if(iter.id === id) {
			iter.removed = true;
			break;
		}
	}

	return;
}

WWindowManager.clearTimeout = function(id) {
	WWindowManager.removeTimerInArr(WWindowManager.timerFuncs, id);
}

WWindowManager.clearInterval = function(id) {
	WWindowManager.removeTimerInArr(WWindowManager.intervalFuncs, id);
}

/*
 * File:   w_events_manager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  manage all input events
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function WEventsManager() {
	this.point = {};
	this.lastPoint = {};
	this.pointerDownPoint = {};
	this.longPressDuration = 600;
}

WEventsManager.prototype.setEventsConsumer = function(eventsConsumer, element) {
	if(!this.eventsConsumer) {
		this.eventsConsumer = eventsConsumer;
		this.addEventListeners(element);
	}
}

WEventsManager.prototype.cancelDefaultAction = function(event) {
	var e = event || window.event;
    
	if (e.preventDefault) {
		e.preventDefault();
	}
	else {
		e.returnValue = false;
	}

	return false;
}

WEventsManager.prototype.targetIsEditor = function(e) {
	var tag = e.srcElement ? e.srcElement : e.target; 
	var name = tag.localName ? tag.localName : tag.tagName;

	name = name.toLowerCase();
	if(name != "body" && name != "canvas") {
		return true;
	}
	
	return false;
}

WEventsManager.prototype.shouldIgnoreKey = function(event) {
	var e = event || window.event;
	var code = e.keyCode;
	
	if(code === KeyEvent.DOM_VK_F5 || code === KeyEvent.DOM_VK_F12 || code === KeyEvent.DOM_VK_F11) {
		return true;
	}
	
	if(this.targetIsEditor(e)) {
		return true;
	}

	return false;
}

WEventsManager.prototype.onKeyDownGlobal = function(event) {
	var e = event || window.event;
	var code = e.keyCode;

	if(this.shouldIgnoreKey(e)) {
		return true;
	}
	else {
		this.onKeyDown(code, e);
		return this.cancelDefaultAction(e);
	}
}

WEventsManager.prototype.onKeyUpGlobal = function(event) {
	var e = event || window.event;
	var code = e.keyCode;
	if(this.shouldIgnoreKey(e)) {
		return true;
	}
	else {
		this.onKeyUp(code, e);
		return this.cancelDefaultAction(e);
	}
}

WEventsManager.prototype.onWheelGlobal = function(event) {
	var e = window.event || event ;
	if(EditorElement.imeOpen) return true;

	if(e.target && e.target.localName !== "canvas"){
		return this.cancelDefaultAction(e);
	}

	var delta = e.wheelDelta || e.detail * -8;
	if(delta) {
		if(this.onWheel(delta, e)) {
			return this.cancelDefaultAction(e);
		}
	}

	return true;
}

WEventsManager.prototype.onTizenKeys = function(e) {
	if (e.keyName == "back") {
		this.onKeyDown(KeyEvent.DOM_VK_BACK_BUTTON, e);
		this.onKeyUp(KeyEvent.DOM_VK_BACK_BUTTON, e);
	}
	else if (e.keyName == "menu") {
		this.onKeyDown(KeyEvent.DOM_VK_MENU_BUTTON, e);
		this.onKeyUp(KeyEvent.DOM_VK_MENU_BUTTON, e);
	}
}

WEventsManager.prototype.onPhonegapBackButton = function() {
	this.onKeyDown(KeyEvent.DOM_VK_BACK_BUTTON);
	this.onKeyUp(KeyEvent.DOM_VK_BACK_BUTTON);
}

WEventsManager.prototype.onPhonegapMenuButton = function() {
	this.onKeyDown(KeyEvent.DOM_VK_MENU_BUTTON);
	this.onKeyUp(KeyEvent.DOM_VK_MENU_BUTTON);
}

WEventsManager.prototype.onPhonegapSearchButton = function() {
	this.onKeyDown(KeyEvent.DOM_VK_SEARCH_BUTTON);
	this.onKeyUp(KeyEvent.DOM_VK_SEARCH_BUTTON);
}

WEventsManager.prototype.addEventListeners = function(element) {
	if(!element) {
		element = window;
	}

	document.addEventListener('tizenhwkey', this.onTizenKeys.bind(this));
	document.addEventListener("backbutton", this.onPhonegapBackButton.bind(this));
	document.addEventListener("menubutton", this.onPhonegapMenuButton.bind(this));
	document.addEventListener("searchbutton", this.onPhonegapSearchButton.bind(this));
	if(this.isPointer()) {
		WEventsManager.pointerDeviceType = "pointer";
		element.addEventListener('pointerdown', this.onPointerDownGlobal.bind(this));
		element.addEventListener('pointermove', this.onPointerMoveGlobal.bind(this));
		element.addEventListener('pointerup', this.onPointerUpGlobal.bind(this));
		element.addEventListener('mousewheel', this.onWheelGlobal.bind(this));
	}
	else if(this.isMSPointer()) {
		WEventsManager.pointerDeviceType = "pointer";
		element.addEventListener('MSPointerDown', this.onPointerDownGlobal.bind(this));
		element.addEventListener('MSPointerMove', this.onPointerMoveGlobal.bind(this));
		element.addEventListener('MSPointerUp', this.onPointerUpGlobal.bind(this));
		element.addEventListener('mousewheel', this.onWheelGlobal.bind(this));
	}
	else if(isMobile()) {
		WEventsManager.pointerDeviceType = "touch";
		element.addEventListener('MSPointerDown', this.onPointerDownGlobal.bind(this));
		element.addEventListener('touchstart', this.onTouchStartGlobal.bind(this));
		element.addEventListener('touchmove', this.onTouchMoveGlobal.bind(this));
		element.addEventListener('touchend', this.onTouchEndGlobal.bind(this));
	}
	else {
		WEventsManager.pointerDeviceType = "mouse";
		element.addEventListener('dblclick', this.onDoubleClickGlobal.bind(this));
		element.addEventListener('mousewheel', this.onWheelGlobal.bind(this));
		element.addEventListener('DOMMouseScroll', this.onWheelGlobal.bind(this));
		element.addEventListener('mousedown', this.onMouseDownGlobal.bind(this));
		element.addEventListener('mousemove', this.onMouseMoveGlobal.bind(this));
		element.addEventListener('mouseup', this.onMouseUpGlobal.bind(this));
	}
	window.addEventListener('keyup', this.onKeyUpGlobal.bind(this));
	window.addEventListener('keydown', this.onKeyDownGlobal.bind(this));

	return;
}

WEventsManager.prototype.isMultiTouchEvent = function(e) {
	return e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 1;
}

WEventsManager.points = [{},{},{},{},{},{},{},{}];
WEventsManager.prototype.getAbsPoint = function(e, i) {
	var index = i || 0;
	var p = WEventsManager.points[index];

	if(e) {
		p.x = Math.max(e.pageX, e.x || e.clientX);
		p.y = Math.max(e.pageY, e.y || e.clientY);
		p.event = e;

		this.lastPoint.x = p.x;
		this.lastPoint.y = p.y;
		this.lastPointEvent = e;
	}
	else {
		p = this.lastPoint;
	}

	return p;
}
  
WEventsManager.prototype.getPointerList = function(e) {
    var pointers = [];
    var pointer;
    if (this.touchList) {
      for (var i = 0; i < this.touchList.length; i++) {
        var touch = this.touchList[i];
        // Add 2 to avoid clashing with the mouse identifier.
        pointer = new Pointer(touch.identifier + 2, PointerTypes.TOUCH, touch);
        pointers.push(pointer);
      }
    } else if (this.msPointerList) {
      for (var identifier in this.msPointerList) {
        if (!this.msPointerList.hasOwnProperty(identifier)) continue;
        pointer = this.msPointerList[identifier];
        pointer = new Pointer(identifier, pointer.textPointerType, pointer);
        pointers.push(pointer);
      }
    }
    if (this.mouseEvent) {
      pointers.push(new Pointer(MOUSE_ID, PointerTypes.MOUSE, this.mouseEvent));
    }
    return pointers;
  }

WEventsManager.prototype.isPointer = function() {
	return window.navigator.pointerEnabled;
}

WEventsManager.prototype.isMSPointer = function() {
    return window.navigator.msPointerEnabled;
}

WEventsManager.prototype.isRightMouseEvent = function(event) {
	var ret = false;
    if (event.which === null) {
       ret = (event.button > 2 && event.button !== 4);
	}
    else {
       ret = (event.which > 2 && event.which !== 2);
	}

	return ret;
}

WEventsManager.prototype.onDoubleClickGlobal = function(event) {
	var e = window.event || event ;
	if(this.targetIsEditor(e)) {
		return true;
	}

	if(!this.isRightMouseEvent(e)) {
		this.onDoubleClick(this.getAbsPoint(e), e);
	}

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onMouseDownGlobal = function(event) {
	var e = window.event || event ;
	if(this.targetIsEditor(e)) {
		return true;
	}

	if(!this.isRightMouseEvent(e)) {
		this.onPointerDown(this.getAbsPoint(e), e);
	}

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onMouseMoveGlobal = function(event) {
	var e = window.event || event ;
	if(this.targetIsEditor(e) && !this.pointerDown) {
		return true;
	}

	this.onPointerMove(this.getAbsPoint(e), e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onMouseUpGlobal = function(event) {
	var e = window.event || event ;
	if(this.targetIsEditor(e) && !this.pointerDown) {
		return true;
	}

	if(this.isRightMouseEvent(e)) {
		this.onContextMenu(this.getAbsPoint(e), e);
	}
	else {
		this.onPointerUp(this.getAbsPoint(e), e);
	}

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.getTouchList = function(event) {
	return event.touches || event.changedTouches || event.touchList;
}

WEventsManager.prototype.getTouchPoints = function(e) {
	var points = [];
	var touchList = this.getTouchList(e);
	var n = touchList.length;

	for(var i = 0; i < n; i++) {
		var touch = touchList[i];
		var point = this.getAbsPoint(touch, i);
		
		point.event = e;
		point.id = touch.identifier;
		points.push(point);
	}

	return points;
}

WEventsManager.prototype.onTouchStartGlobal = function(event) {
	var e = window.event || event ;
	var points = this.getTouchPoints(e);
	
	if(points.length === 1) {
		this.point.x = points[0].x;
		this.point.y = points[0].y;

		this.onPointerDown(this.point, e);
	}
	this.onMultiTouch("touchstart", points, e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onTouchMoveGlobal = function(event) {
	var e = window.event || event ;
	var points = this.getTouchPoints(e);
	
	if(points.length === 1) {
		this.point.x = points[0].x;
		this.point.y = points[0].y;

		this.onPointerMove(this.point, e);
	}
	this.onMultiTouch("touchmove", points, e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onTouchEndGlobal = function(event) {
	var e = window.event || event ;
	var points = this.getTouchPoints(e);

	if(!points.length) {
        var last = this.lastPointerTime;
        var cur = new Date();
        this.lastPointerTime = cur; 
        var dbClick = false;
        if(last) {
            var diff = cur - last;
            if(diff < 200) {
                dbClick = true;
                this.lastPointerTime = 0;
            }
        }
		if(dbClick) {
            this.onDoubleClick(this.getAbsPoint(null), e);
        }
        this.onPointerUp(this.getAbsPoint(null), e);
	}

	this.onMultiTouch("touchend", points, e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onPointerDownGlobal = function(event) {
	var e = window.event || event ;

	this.onPointerDown(this.getAbsPoint(e), e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onPointerMoveGlobal = function(event) {
	var e = window.event || event ;

	this.onPointerMove(this.getAbsPoint(e), e);

	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onPointerUpGlobal = function(event) {
	var e = window.event || event ;

	this.onPointerUp(this.getAbsPoint(e), e);
	
	return this.cancelDefaultAction(e);
}

WEventsManager.prototype.onKeyDown = function(code, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onKeyDown(code);
	}
}

WEventsManager.prototype.onKeyUp = function(code, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onKeyUp(code);
	}
}

WEventsManager.prototype.onWheel = function(delta, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onWheel(delta);
	}
}

WEventsManager.prototype.onLongPress = function() {
	this.onContextMenu(this.lastPoint, this.lastPointEvent);
}

WEventsManager.prototype.onMultiTouch = function(action, points, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onMultiTouch(action, points, event);
	}
}

WEventsManager.prototype.onPointerDown = function(point, event) {
	this.pointerDown = true;

	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onPointerDown(point);
		//console.log("onPointerDown:" + point.x + "x" + point.y);
	}
}

WEventsManager.prototype.onPointerMove = function(point, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onPointerMove(point);
	}
}

WEventsManager.prototype.onPointerUp = function(point, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onPointerUp(point);
		//console.log("onPointerUp:" + point.x + "x" + point.y);
	}

	this.pointerDown = false;
}

WEventsManager.prototype.onDoubleClick = function(point, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onDoubleClick(point);
	}
}

WEventsManager.prototype.onContextMenu = function(point, event) {
	if(this.eventsConsumer.preprocessEvent(0, event)) {
		this.eventsConsumer.onContextMenu(point);
	}
	//console.log("onContextMenu:" + point.x + "x" + point.y);
}

WEventsManager.targetIsCanvas = function(e) {
	var tag = e.srcElement ? e.srcElement : e.target; 
	var name = tag.localName ? tag.localName : tag.tagName;

	name = name.toLowerCase();
	if(name === "canvas") {
		return true;
	}
	
	return false;
}

WEventsManager.getInstance = function() {
	if(!WEventsManager.instance) {
		WEventsManager.instance = new WEventsManager();
	}

	return WEventsManager.instance;
}

WEventsManager.prototype.getPointerDeviceType = function() {
	return WEventsManager.pointerDeviceType;
}

WEventsManager.prototype.getInputScale = function() {
	return this.eventsConsumer.getInputScale();
}


WEventsManager.setEventsConsumer = function(eventsConsumer, element) {
	WEventsManager.getInstance().setEventsConsumer(eventsConsumer, element);
};

/*
 * File: edit.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: wrap input/textarea
 * 
 * Copyright (c) 2011 - 2015	Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016	Holaverse Inc.
 * 
 */

function EditorElement() {
	this.element = null;
}

EditorElement.prototype.setElement = function(element) {
	this.element = element;

	return;
}

EditorElement.prototype.setWrap = function(wrap) {
	this.element.wrap = wrap;
	
	return;
}

EditorElement.prototype.setMaxLength = function(maxLength) {
	this.element.maxLength = maxLength;

	return this;
}

EditorElement.prototype.showBorder = function(show) {
	if(show) {
		this.element.style.background = 'white';
		this.element.style.border ='1px solid';
		this.element.style.outline = '1px';
	}
	else {
		this.element.style.background = 'transparent';
		this.element.style.border ='0px solid';
		this.element.style.outline = 'none';
	}

	return;
}

EditorElement.prototype.setOnChangedHandler = function(onChanged) {
	var me = this;
	this.onChanged = onChanged;

	this.element.onblur = function() {
		if(me.onChanged) {
			me.onChanged(this.value);
		}
	}

	if(isMobile()) {
		this.element.onchange = function() {
			if(me.onChanged) {
				me.onChanged(this.value);
			}
		}
	}

	return this;
}

EditorElement.prototype.setOnChangeHandler = function(onChange) {
	var me = this;
	this.onChange = onChange;

	this.element.onkeypress = function(e) {
		if(me.onChange) {
			me.onChange(this.value);
		}
	}

	if(this.isInput) {
		this.element.onkeydown = function(e) {
			if(e.keyCode === 13) {
				this.blur();
			}
		}
	}

	this.element.oninput = function(e) {
		if(me.onChange) {
			me.onChange(this.value);
		}
	}
	
	if(!isMobile()) {
		this.element.onchange = function() {
			if(me.onChange) {
				me.onChange(this.value);
			}
		}
	}

	return this;
}

EditorElement.prototype.selectText = function() {
	if(this.element) {
		this.element.select();
	}

	return this;
}

EditorElement.prototype.setZIndex = function(zIndex) {
	this.element.style['z-index'] = zIndex;

	return;
}

EditorElement.prototype.setFontSize = function(fontSize) {
	this.element.style['font-size'] = fontSize + "pt";

	return;
}

EditorElement.prototype.setScrollType = function(scrollType) {
	this.element.style['overflow-y'] = scrollType;
	this.element.style['overflow-x'] = scrollType;

	return;
}

EditorElement.prototype.show = function() {
	this.isVisibile = true;
	this.element.style.visibility = 'visible';
	this.element.style.zIndex = 8;
	this.element.style.opacity = 1;

	if(!isMobile()) {
		this.showBorder(false);
	}

	this.element.focus();
	EditorElement.imeOpen = true;

	return;
}

EditorElement.prototype.hide = function() {
	this.isVisibile = false;
	this.element.style.opacity = 0;
	this.element.style.zIndex = 0;
	this.element.style.visibility = 'hidden';  
	this.element.blur();
	this.element.onchange = null;
	EditorElement.imeOpen = false;
	if(isMobile()) {
		CantkRT.moveMainCanvas(0, 0);
	}

	if(this.onHide) {
		this.onHide();
	}

	if(this.shape) {
		this.shape.editing = false;
	}

	return;
}

EditorElement.prototype.setInputType = function(type) {
	this.element.type = type;

	return;
}

EditorElement.getMainCanvas = function() {
	if(typeof UIElement !== 'undefined') {
		return UIElement.getMainCanvas();	
	}
	else {
		return CantkRT.getMainCanvas();	
	}

	return;
}

EditorElement.getMainCanvasScale = function(force) {
	if(typeof UIElement !== 'undefined') {
		return UIElement.getMainCanvasScale();
	}
	else {
		if(!EditorElement.canvasScale || force) {
			var xScale = 1;
			var yScale = 1;
			EditorElement.canvasScale = {};
			var mainCanvas = EditorElement.getMainCanvas();
			
			if(mainCanvas.style.width && mainCanvas.style.height) {
				xScale = mainCanvas.width/parseFloat(mainCanvas.style.width);
				yScale = mainCanvas.height/parseFloat(mainCanvas.style.height);
			}

			EditorElement.canvasScale.x = xScale;
			EditorElement.canvasScale.y = yScale;
		}

		return EditorElement.canvasScale;	
	}

	return;
}

function setElementPosition(element, x, y) {
	var scale = EditorElement.getMainCanvasScale();

	x = x/scale.x;
	y = y/scale.y;
	element.style.position = "absolute";
	element.style.left = Math.round(x) + "px";
	element.style.top = Math.round(y) + "px";
	element.style["opacity"] = 1.0;

	return;
}

EditorElement.prototype.blur = function() {
	this.element.blur();
}

EditorElement.prototype.move = function(x, y) {
	this.element.style.position = "absolute";
	this.element.style.left = x + "px";
	this.element.style.top = y + "px";

	return;
}

EditorElement.prototype.setTextColor = function(color) {
	this.element.style.color = color;
}

EditorElement.prototype.setBgColor = function(color) {
	this.element.style.background = color;
}

EditorElement.prototype.setFontSize = function(fontSize) {
	this.element.style.fontSize = fontSize + "px";

	return;
}

EditorElement.prototype.resize = function(w, h) {
	this.element.style.width = w + "px";
	this.element.style.height = (h-4) + "px";

	return;
}

EditorElement.prototype.getText = function() {
	return this.element.value;
}

EditorElement.prototype.setText = function(text) {
	this.element.value = text;

	return;
}

EditorElement.prototype.setShape = function(shape) {
	if(this.shape) {
		this.hide();
	}

	this.shape = shape;
	
	if(this.shape) {
		this.shape.editing = true;
		this.show();
	}

	return;
}

EditorElement.create = function(element, id) {
	var edit = new EditorElement();

	element.id = id;
	edit.setElement(element);
	edit.setFontSize(14);
	edit.isInput = element.tagName === "INPUT" || element.localName === "input";

	return edit;
}

var gCanTkInput = null;
function cantkShowInput(inputType, fontSize, text, x, y, w, h) {
	x = Math.round(x);
	y = Math.round(y);
	w = Math.round(w);
	h = Math.round(h);

	if(!gCanTkInput) {
		gCanTkInput = EditorElement.createSingleLineEdit();
	}

	gCanTkInput.setInputType(inputType);
	gCanTkInput.setFontSize(fontSize);
	gCanTkInput.setText(text);
	gCanTkInput.move(x, y);
	gCanTkInput.resize(w, h);
	gCanTkInput.show();

	return gCanTkInput;
}

var gCanTkTextArea = null;
function cantkShowTextArea(text, fontSize, x, y, w, h) {
	x = Math.round(x);
	y = Math.round(y);
	w = Math.round(w);
	h = Math.round(h);

	if(!gCanTkTextArea) {
		gCanTkTextArea = EditorElement.createMultiLineEdit();
	}
	
	gCanTkTextArea.move(x, y);
	gCanTkTextArea.resize(w, h);
	gCanTkTextArea.setFontSize(fontSize);
	gCanTkTextArea.setText(text);
	gCanTkTextArea.show();

	return gCanTkTextArea;
}

function cantkMoveEditorWhenResize() {
	if(gCanTkInput && gCanTkInput.isVisibile && gCanTkInput.shape && gCanTkInput.shape.isUIElement) {
		var shape = gCanTkInput.shape;
		var rect = shape.getEditorRect();
		var x = rect.x;
		var y = rect.y;
		var w = rect.w;
		var h = rect.h;

		gCanTkInput.move(x, y);
		gCanTkInput.resize(w, h);

		console.log("Move Input To: (" + x + ", " + y + ")");
	}
	
	if(gCanTkTextArea && gCanTkTextArea.isVisibile && gCanTkTextArea.shape && gCanTkTextArea.shape.isUIElement) {
		var shape = gCanTkTextArea.shape;
		var rect = shape.getEditorRect();
		var x = rect.x;
		var y = rect.y;
		var w = rect.w;
		var h = rect.h;

		gCanTkTextArea.move(x, y);
		gCanTkTextArea.resize(w, h);
		
		console.log("Move TextArea To: (" + x + ", " + y + ")");
	}

	return;
}

function cantkIsEditorActive() {
	if(gCanTkInput && gCanTkInput.isVisibile) {
		return true;
	}

	if(gCanTkTextArea && gCanTkTextArea.isVisibile) {
		return true;
	}

	return false;
}

function cantkHideAllInput() {
	if(gCanTkInput && gCanTkInput.isVisibile) {
		if(gCanTkInput.element.onchange) {
			gCanTkInput.element.onchange();
		}
		gCanTkInput.hide();
	}

	if(gCanTkTextArea && gCanTkTextArea.isVisibile) {
		if(gCanTkTextArea.element.onchange) {
			gCanTkTextArea.element.onchange();
		}
		gCanTkTextArea.hide();
	}

	return;
}

EditorElement.createSingleLineEdit = function() {
	var id = "singlelineedit";
	var element = document.createElement("input");
	document.body.appendChild(element);

	return EditorElement.create(element, id);
}

EditorElement.createMultiLineEdit = function() {
	var id = "multilineedit";
	var element = document.createElement("textarea");
    element.style.resize = "none";
	document.body.appendChild(element);

	return EditorElement.create(element, id);
};

/*
 * File:    path-animation.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief:   path animation
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function BasePath() {
	return;
}

BasePath.prototype.getPosition = function(t) {
	return {x:0, y:0};
}

BasePath.prototype.getDirection = function(t) {
	var p1 = this.getPosition(t);
	var p2 = this.getPosition(t+0.1);

	return BasePath.angleOf(p1, p2);
}

BasePath.prototype.getStartPoint = function() {
	return this.startPoint ? this.startPoint : this.getPosition(0);
}

BasePath.prototype.getEndPoint = function() {
	return this.endPoint ? this.endPoint : this.getPosition(this.duration);
}

BasePath.prototype.getSamples = function() {
	return this.samples;
}

BasePath.prototype.draw = function(ctx) {
	var n = this.getSamples();
	var p = this.getStartPoint();	

	ctx.moveTo(p.x, p.y);
	for(var i = 0; i <= n; i++) {
		var t = this.duration*i/n;
		var p = this.getPosition(t);
		ctx.lineTo(p.x, p.y);
	}

	return this;
}

BasePath.angleOf = function(from, to) {
	var dx = to.x - from.x;
	var dy = to.y - from.y;
	var d = Math.sqrt(dx * dx + dy * dy);

	if(dx == 0 && dy == 0) {
		return 0;
	}
	
	if(dx == 0) {
		if(dy < 0) {
			return 1.5 * Math.PI;
		}
		else {
			return 0.5 * Math.PI;
		}
	}

	if(dy == 0) {
		if(dx < 0) {
			return Math.PI;
		}
		else {
			return 0;
		}
	}

	var angle = Math.asin(Math.abs(dy)/d);
	if(dx > 0) {
		if(dy > 0) {
			return angle;
		}
		else {
			return 2 * Math.PI - angle;
		}
	}
	else {
		if(dy > 0) {
			return Math.PI - angle;
		}
		else {
			return Math.PI + angle;
		}
	}
}

/////////////////////////////////////////////////////

function LinePath(duration, interpolator, x1, y1, x2, y2) {
	this.dx = x2 - x1;
	this.dy = y2 - y1;
	this.x1 = x1;
	this.x2 = x2;
	this.y1 = y1;
	this.y2 = y2;
	this.duration = duration;
	this.interpolator = interpolator;
	this.angle = BasePath.angleOf({x:x1,y:y1}, {x:x2, y:y2});
	this.startPoint = {x:this.x1, y:this.y1};
	this.endPoint = {x:this.x2, y:this.y2};
	
	return;
}

LinePath.prototype = new BasePath();
LinePath.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;

	var x = this.x1 + this.dx * percent;
	var y = this.y1 + this.dy * percent;

	return {x:x, y:y};
}

LinePath.prototype.getDirection = function(t) {
	return this.angle;
}

LinePath.prototype.draw = function(ctx) {
	ctx.moveTo(this.x1, this.y1);
	ctx.lineTo(this.x2, this.y2);

	return this;
}

LinePath.create = function(duration, interpolator, x1, y1, x2, y2) {
	return new LinePath(duration, interpolator, x1, y1, x2, y2);
}

/////////////////////////////////////////////////////

function ArcPath(duration, interpolator, xo, yo, r, sAngle, eAngle) {
	this.xo = xo;
	this.yo = yo;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	this.duration = duration;
	this.interpolator = interpolator;
	this.angleRange = eAngle - sAngle;
	
	this.startPoint = this.getPosition(0);	
	this.endPoint = this.getPosition(duration);	

	return;
}

ArcPath.prototype = new BasePath();
ArcPath.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	var angle = this.sAngle + percent * this.angleRange;
	
	var x = this.xo + this.r * Math.cos(angle);
	var y = this.yo + this.r * Math.sin(angle);

	return {x:x, y:y};
}

ArcPath.prototype.getDirection = function(t) {
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	var angle = this.sAngle + percent * this.angleRange + Math.PI * 0.5;

	return angle;
}

ArcPath.prototype.draw = function(ctx) {
	ctx.arc(this.xo, this.yo, this.r, this.sAngle, this.eAngle, this.sAngle > this.eAngle);

	return this;
}

ArcPath.create = function(duration, interpolator, xo, yo, r, sAngle, eAngle) {
	return new ArcPath(duration, interpolator, xo, yo, r, sAngle, eAngle);
}

/////////////////////////////////////////////////////

function ParaPath(duration, interpolator, x1, y1, ax, ay, vx, vy) {
	this.x1 = x1;
	this.y1 = y1;
	this.ax = ax;
	this.ay = ay;
	this.vx = vx;
	this.vy = vy;
	this.duration = duration;
	this.interpolator = interpolator;

	this.startPoint = this.getPosition(0);	
	this.endPoint = this.getPosition(duration);	
	var dx = Math.abs(this.endPoint.x-this.startPoint.x);
	var dy = Math.abs(this.endPoint.y-this.startPoint.y);
	this.samples = Math.max(dx, dy);

	return;
}

ParaPath.prototype = new BasePath();
ParaPath.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	
	t = (percent * this.duration)/1000;
	var x = 0.5 * this.ax * t * t + this.vx * t + this.x1;
	var y = 0.5 * this.ay * t * t + this.vy * t + this.y1;

	return {x:x, y:y};
}

ParaPath.create = function(duration, interpolator, x1, y1, ax, ay, vx, vy) {
	return new ParaPath(duration, interpolator, x1, y1, ax, ay, vx, vy);
}

/////////////////////////////////////////////////////

function SinPath(duration, interpolator, x1, y1, waveLenth, v, amplitude, phaseOffset) {
	this.x1 = x1;
	this.y1 = y1;
	this.v = v;
	this.amplitude = amplitude;
	this.waveLenth = waveLenth;
	this.duration = duration;
	this.phaseOffset = phaseOffset ? phaseOffset : 0;
	this.interpolator = interpolator;
	this.range = 2 * Math.PI * (v * duration * 0.001)/waveLenth;

	this.startPoint = this.getPosition(0);	
	this.endPoint = this.getPosition(duration);	
	var dx = Math.abs(this.endPoint.x-this.startPoint.x);
	var dy = Math.abs(this.endPoint.y-this.startPoint.y);
	this.samples = Math.max(dx, dy);

	return;
}

SinPath.prototype = new BasePath();
SinPath.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	t = percent * this.duration;

	var x = (t * this.v)/1000 + this.x1;
	var y = this.amplitude * Math.sin(percent * this.range + this.phaseOffset) + this.y1;

	return {x:x, y:y};
}

SinPath.create = function(duration, interpolator, x1, y1, waveLenth, v, amplitude, phaseOffset) {
	return new SinPath(duration, interpolator, x1, y1, waveLenth, v, amplitude, phaseOffset);
}

/////////////////////////////////////////////////////

function Bezier3Path(duration, interpolator, x1, y1, x2, y2, x3, y3, x4, y4) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
	this.x4 = x4;
	this.y4 = y4;
	
	this.duration = duration;
	this.interpolator = interpolator;
	this.startPoint = this.getPosition(0);	
	this.endPoint = this.getPosition(duration);	

	return;
}

Bezier3Path.prototype = new BasePath();
Bezier3Path.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	
	t = percent;
	var t2 = t * t;
	var t3 = t2 * t;

	var t1 = 1 - percent;
	var t12 = t1 * t1;
	var t13 = t12 * t1;

	//http://wenku.baidu.com/link?url=HeH8EMcwvOjp-G8Hc-JIY-RXAvjRMPl_l4ImunXSlje-027d01NP8SkNmXGlbPVBioZdc_aCJ19TU6t3wWXW5jqK95eiTu-rd7LHhTwvATa
	//P = P0*(1-t)^3 + 3*P1*(1-t)^2*t + 3*P2*(1-t)*t^2 + P3*t^3;

	var x = (this.x1*t13) + (3*t*this.x2*t12) + (3*this.x3*t1*t2) + this.x4*t3;
	var y = (this.y1*t13) + (3*t*this.y2*t12) + (3*this.y3*t1*t2) + this.y4*t3;

	return {x:x, y:y};
}

Bezier3Path.prototype.draw = function(ctx) {
	ctx.moveTo(this.x1, this.y1);
	ctx.bezierCurveTo(this.x2, this.y2, this.x3, this.y3, this.x4, this.y4);
}

Bezier3Path.create = function(duration, interpolator, x1, y1, x2, y2, x3, y3, x4, y4) {
	return new Bezier3Path(duration, interpolator, x1, y1, x2, y2, x3, y3, x4, y4);
}

/////////////////////////////////////////////////////

function Bezier2Path(duration, interpolator, x1, y1, x2, y2, x3, y3) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
	
	this.duration = duration;
	this.interpolator = interpolator;
	this.startPoint = this.getPosition(0);	
	this.endPoint = this.getPosition(duration);	

	return;
}

Bezier2Path.prototype = new BasePath();
Bezier2Path.prototype.getPosition = function(time) {
	var t = time;
	var timePercent = Math.min(t/this.duration, 1);
	var percent = this.interpolator ? this.interpolator.get(timePercent) : timePercent;
	
	t = percent;
	var t2 = t * t;

	var t1 = 1 - percent;
	var t12 = t1 * t1;

	//P = (1-t)^2 * P0 + 2 * t * (1-t) * P1 + t^2*P2;
	var x = (this.x1*t12) + 2 * this.x2 * t * t1 + this.x3 * t2;
	var y = (this.y1*t12) + 2 * this.y2 * t * t1 + this.y3 * t2;

	return {x:x, y:y};
}

Bezier2Path.prototype.draw = function(ctx) {
	ctx.moveTo(this.x1, this.y1);
	ctx.quadraticCurveTo(this.x2, this.y2, this.x3, this.y3);
}

Bezier2Path.create = function(duration, interpolator, x1, y1, x2, y2, x3, y3) {
	return new Bezier2Path(duration, interpolator, x1, y1, x2, y2, x3, y3);
}

function PathAnimation(x, y) {
	this.startPoint = {x:x, y:y};
	this.reset();

	return;
}

PathAnimation.prototype.getStartPoint = function() {
	return this.startPoint;
}

PathAnimation.prototype.getEndPoint = function() {
	return this.endPoint;
}

PathAnimation.prototype.reset = function() {
	this.endPoint = {x:this.startPoint.x, y:this.startPoint.y};
	this.duration = 0;
	this.paths = [];

	return this;
}

PathAnimation.prototype.addPath = function(path) {
	this.paths.push({path:path, startTime:this.duration});
	this.endPoint = path.getEndPoint();
	this.duration += path.duration;

	return this;
}

PathAnimation.prototype.addLine = function(duration, interpolator, p1, p2) {
	return this.addPath(LinePath.create(duration, interpolator, p1.x, p1.y, p2.x, p2.y));
}

PathAnimation.prototype.addArc = function(duration, interpolator, origin, r, sAngle, eAngle) {
	return this.addPath(ArcPath.create(duration, interpolator, origin.x, origin.y, r, sAngle, eAngle));
}

PathAnimation.prototype.addPara = function(duration, interpolator, p, a, v) {
	return this.addPath(ParaPath.create(duration, interpolator, p.x, p.y, a.x, a.y, v.x, v.y));
}

PathAnimation.prototype.addSin = function(duration, interpolator, p, waveLenth, v, amplitude, phaseOffset) {
	return this.addPath(SinPath.create(duration, interpolator, p.x, p.y, waveLenth, v, amplitude, phaseOffset));
}

PathAnimation.prototype.addBezier = function(duration, interpolator, p1, p2, p3, p4) {
	return this.addPath(Bezier3Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y, p4.x,p4.y));
}

PathAnimation.prototype.addQuad = function(duration, interpolator, p1, p2, p3) {
	return this.addPath(Bezier2Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y));
}

PathAnimation.prototype.getDuration = function() {
	return this.duration;
}

PathAnimation.prototype.getPathInfoByTime = function(elapsedTime) {
	var t = 0;	
	var paths = this.paths;
	var n = paths.length;

	for(var i = 0; i < n; i++) {
		var iter = paths[i];
		var path = iter.path;
		var startTime = iter.startTime;
		if(elapsedTime >= startTime && elapsedTime < (startTime + path.duration)) {
			return iter;
		}
	}

	return null;
}

PathAnimation.prototype.getPosition = function(elapsedTime) {
	var info = this.getPathInfoByTime(elapsedTime);

	return info ? info.path.getPosition(elapsedTime - info.startTime) : this.endPoint;
}

PathAnimation.prototype.getDirection = function(elapsedTime) {
	var info = this.getPathInfoByTime(elapsedTime);

	return info ? info.path.getDirection(elapsedTime - info.startTime) : 0;
}

PathAnimation.prototype.draw = function(ctx) {
	var paths = this.paths;
	var n = paths.length;
	
	for(var i = 0; i < n; i++) {
		var iter = paths[i];
		ctx.beginPath();
		iter.path.draw(ctx);
		ctx.stroke();
	}

	return this;
}

PathAnimation.prototype.forEach = function(visit) {
	var paths = this.paths;
	var n = paths.length;
	
	for(var i = 0; i < n; i++) {
		visit(paths[i]);
	}

	return this;
};

//! stable.js 0.1.5, https://github.com/Two-Screen/stable
//! © 2014 Angry Bytes and contributors. MIT licensed.

(function() {

// A stable array sort, because `Array#sort()` is not guaranteed stable.
// This is an implementation of merge sort, without recursion.

var stable = function(arr, comp) {
    return exec(arr.slice(), comp);
};

stable.inplace = function(arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
        pass(result, null, arr.length, arr);
    }

    return arr;
};

// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
        comp = function(a, b) {
            return String(a).localeCompare(b);
        };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
        return arr;
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);

        var tmp = arr;
        arr = buffer;
        buffer = tmp;
    }

    return arr;
}

// Run a single pass with the given chunk size.
var pass = function(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len) r = len;
        if (e > len) e = len;

        // Iterate both chunks in parallel.
        li = l;
        ri = r;
        while (true) {
            // Compare the chunks.
            if (li < r && ri < e) {
                // This works for a regular `sort()` compatible comparator,
                // but also for a simple comparator like: `a > b`
                if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                }
                else {
                    result[i++] = arr[ri++];
                }
            }
            // Nothing to compare, just flush what's left.
            else if (li < r) {
                result[i++] = arr[li++];
            }
            else if (ri < e) {
                result[i++] = arr[ri++];
            }
            // Both iterators are at the chunk ends.
            else {
                break;
            }
        }
    }
};

Object.defineProperty(Array.prototype, 'stableSort', 
{
	enumerable: false,
	value: function(comp) {
		var newArr = stable(this, comp);

		for(var i = 0; i < newArr.length; i++) {
			this[i] = newArr[i];
		}

		return this;
	}
});

})();
/*
 * File: assets_downloader.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: assets downloader for Runtime.
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function AssetsDownloader() {
}

AssetsDownloader.requests = {};
AssetsDownloader.createFontsRequest = function() {
	return AssetsDownloader.createRequest("__fonts__");
}

AssetsDownloader.createAudiosRequest = function() {
	return AssetsDownloader.createRequest("__audios__");
}

AssetsDownloader.createRequest = function(name) {
	var req = AssetsDownloader.requests[name];

	if(!req) {
		req = new AssetsDownloader.Request(name);
		AssetsDownloader.requests[name] = req;
	}

	return req;
}

AssetsDownloader.isDownloaded = function(name) {
	var req = AssetsDownloader.requests[name];

	return req && req.loaded;
}

AssetsDownloader.isAvailable = function() {
	return (!!window.downloadAssets) || AssetsDownloader.simulateDownload;
}

AssetsDownloader.simulateDownload = false;
AssetsDownloader.download = function(req) {
	if(window.downloadAssets && !req.loaded) {
		window.downloadAssets(req.name, req.onEvent.bind(req));
	}
	else if(AssetsDownloader.simulateDownload) {
		function stepIt() {
			req.percent += 20;
			req.onEvent({type:"progress", value:req.percent});
			if(req.percent < 100) {
				setTimeout(stepIt.bind(req), 500);
			}
		}

		req.percent = 0;
		setTimeout(stepIt.bind(req), 1000);
	}else{
		req.onEvent({type:"progress", value:100});
	}

	return req;
}

AssetsDownloader.downloadMulti = function(names, onProgress, onDone) {
	var queue = [];
	var totalSize = 0;
	var finishSize = 0;

	function downloadNext() {
		if(queue.length < 1) {
			if(onDone) {
				onDone();	
			}
		}else{
			var req = queue.pop();
			req.on("progress", onOneProgress);
			AssetsDownloader.download(req);
			console.log("Download : " + req.name)
		}
	}

	function onOneProgress(event) {
		var reqFinishSize = finishSize + this.size * (event.value/100);

		var percent = 100 * reqFinishSize/totalSize;
		if(onProgress) {
			onProgress(percent, reqFinishSize, totalSize);
		}
		
		console.log("percent=" + percent);
		if(event.value >= 100) {
			console.log("Download done: " + this.name)
			this.off("progress", onOneProgress);
			finishSize += this.size;
			downloadNext();
		}
	}
	
	for(var i = 0; i < names.length; i++) {
		var r = AssetsDownloader.createRequest(names[i]);
		queue.push(r);
		totalSize += r.size;
	}

	downloadNext();

	return;
}

AssetsDownloader.Request = function(name) {
	this.name = name;
	if(window.getAssetsSize) {
		this.size = window.getAssetsSize(name);
	}else{
		this.size = 1024;
	}
	
	if(window.getAssetsDownloadedSize) {
		this.donwloadedSize = window.getAssetsDownloadedSize(name);
	}else{
		this.donwloadedSize = 0;
	}

	this.loaded = this.donwloadedSize >= this.size;

	return this;
}

AssetsDownloader.Request.prototype.onEvent = function(event) {
	if(event.type === "progress" && event.value >= 100) {
		this.loaded = true;	
	}

	if(event.type === "error") {
		this.error = event.value;
	}

	var me = this;
	setTimeout(function() {
		me.dispatchEvent(event);
	}, 0);
}

TEventTarget.apply(AssetsDownloader.Request.prototype); 

/**
 * @method downloadAssets
 *
 * 加载指定场景的资源。
 *
 * @param {String} sceneName 要加载的场景的名称。
 * @param {Function} onEvent 回调函数。原型为onEvent(event)。
 *
 * event的成员有：
 *
 * type: "progress"表示进度, "error"表示错误。
 * value: type为"progress"时，value表示进度的百分比，取值0-100。type为"error"时，value表示具体的错误信息。
 */
//function downloadAssets(sceneName, onEvent) 

/**
 * @method getAssetsSize
 *
 * 获取指定场景的资源大小(字节)。
 * @return {Number} 资源的大小。
 * 
 */
//function getAssetsSize(sceneName)

/**
 * @method getAssetsDownloadedSize
 *
 * 获取指定场景的资源已经下载的大小(字节)。
 * @return {Number} 获取指定场景的资源已经下载的大小。
 * 
 */
//function getAssetsDownloadedSize(sceneName)



function isArrayish(obj) {
	if (!obj) {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

var colorNames = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var reverseNames = {};
// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.abbrreg = /^#([a-fA-F0-9]{3})$/;
cs.hexreg = /^#([a-fA-F0-9]{6})$/;
cs.rgbareg = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
cs.perreg = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
cs.keywordreg = /(\D+)/;

cs.cache = {};
cs.get.rgb = function (string) {
	var color = cs.cache[string];

	if(!color) {
		color = cs.get.rgbSlow(string);
		cs.cache[string] = color;
	}

	return color;
}

cs.get.rgbSlow = function (string) {
	var i;
	var match;

	var rgb = [0, 0, 0, 1];
	if (!string) {
		return rgb;
	}

	if (match = string.match(cs.abbrreg)) {
		match = match[1];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}
	} else if (match = string.match(cs.hexreg)) {
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}
	} else if (match = string.match(cs.rgbareg)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(cs.perreg)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(cs.keywordreg)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	}

	for (i = 0; i < rgb.length; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}
};

cs.to.hex = function (rgb) {
	return '#' + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')'
		: 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

function Int16DataBuffer(initSize) {
	this.size = 0;
	this.capacity = initSize;

	this.buffer = new ArrayBuffer(initSize * 2);
	this.init16Buffer = new Int16Array(this.buffer);
}

Int16DataBuffer.prototype.extendTo = function(size) {
	var buffer = new ArrayBuffer(size * 2);
	var init16Buffer = new Int16Array(buffer);

	init16Buffer.set(this.init16Buffer, 0);

	this.capacity = size; 
	this.buffer = buffer;
	this.init16Buffer = init16Buffer;
}

Int16DataBuffer.prototype.extendIfFull = function(n) {
	if((this.size + n) > this.capacity) {
		this.extendTo(Math.round(this.capacity * 1.2) + n);
	}
}

Int16DataBuffer.prototype.pushX = function() {
	var arr = arguments;
	var n = arr.length;
	var offset = this.size;
	this.extendIfFull(n);

	this.size += n;
	var buffer = this.init16Buffer;
	for(var i = 0; i < n; i++, offset++) {
		buffer[offset] = arr[i];
	}

	return this;
}

Int16DataBuffer.prototype.push1 = function(a) {
	this.extendIfFull(1);
	this.init16Buffer[this.size++] = a;

	return this;
}

Int16DataBuffer.prototype.push2 = function(a, b) {
	this.extendIfFull(2);
	this.init16Buffer[this.size++] = a;
	this.init16Buffer[this.size++] = b;

	return this;
}

Int16DataBuffer.prototype.push3 = function(a, b, c) {
	this.extendIfFull(3);
	this.init16Buffer[this.size++] = a;
	this.init16Buffer[this.size++] = b;
	this.init16Buffer[this.size++] = c;

	return this;
}

Int16DataBuffer.prototype.push4 = function(a, b, c, d) {
	this.extendIfFull(4);
	this.init16Buffer[this.size++] = a;
	this.init16Buffer[this.size++] = b;
	this.init16Buffer[this.size++] = c;
	this.init16Buffer[this.size++] = d;

	return this;
}

Int16DataBuffer.prototype.push5 = function(a, b, c, d, e) {
	this.extendIfFull(5);
	this.init16Buffer[this.size++] = a;
	this.init16Buffer[this.size++] = b;
	this.init16Buffer[this.size++] = c;
	this.init16Buffer[this.size++] = d;
	this.init16Buffer[this.size++] = e;

	return this;
}

Int16DataBuffer.prototype.push6 = function(a, b, c, d, e, f) {
	this.extendIfFull(6);
	this.init16Buffer[this.size++] = a;
	this.init16Buffer[this.size++] = b;
	this.init16Buffer[this.size++] = c;
	this.init16Buffer[this.size++] = d;
	this.init16Buffer[this.size++] = e;
	this.init16Buffer[this.size++] = f;

	return this;
}

Int16DataBuffer.prototype.reset = function() {
	this.size = 0;
}

Int16DataBuffer.prototype.getReadBuffer = function() {
	var buffer = new Int16Array(this.buffer, 0, this.size);
	buffer.size = this.size;

	return buffer;
}

Int16DataBuffer.prototype.getWriteBuffer = function(n) {
	this.extendIfFull(n);
	var buffer = this.init16Buffer;

	return buffer;
}

Int16DataBuffer.prototype.getBufferType = function() {
	return "init16";
}

Int16DataBuffer.prototype.getElementBytes = function() {
	return 2;
}

Int16DataBuffer.prototype.dup = function() {
	var db = Int16DataBuffer.create(this.size);

	var n = this.size;
	db.size = this.size;
	var src = this.init16Buffer;
	var dst = db.init16Buffer;

	for(var i = 0; i < n; i++) {
		dst[i] = src[i];
	}

	return db;
}

Int16DataBuffer.create = function(initSize) {
	var db = new Int16DataBuffer(initSize);

	return db;
}

Int16DataBuffer.prototype.dump = function() {
	var n = this.size;
	var buffer = this.init16Buffer;

	console.log(this.size + " " + this.capacity + " " + this.getBufferType() + " " + this.getElementBytes());

	console.log(Array.prototype.join.call(buffer, ","));
}

Int16DataBuffer.test = function() {
	var db = Int16DataBuffer.create(4);
	db.pushX(1, 2, 3, 3, 5, 6, 7, 8, 9, 10, 11);
	db.dump();

	var buffer = db.getReadBuffer();
	console.log("buffer(" + buffer.length + ")["+ Array.prototype.join.call(buffer, ",") + "]");
}

Int16DataBuffer.test();
;
(function(m) {
'use strict';

// Sutherland-Hodgeman polygon clipping algorithm

function polygonclip(points, bbox) {

    var result, edge, prev, prevInside, i, p, inside;

    // clip against each side of the clip rectangle
    for (edge = 1; edge <= 8; edge *= 2) {
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);

        for (i = 0; i < points.length; i++) {
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);

            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

            if (inside) result.push(p); // add a point if it's inside

            prev = p;
            prevInside = inside;
        }

        points = result;

        if (!points.length) break;
    }

    return result;
}

// intersect a segment against one of the 4 lines that make up the bbox

function intersect(a, b, edge, bbox) {
    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
           null;
}

// bit code reflects the point position relative to the bbox:

//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

function bitCode(p, bbox) {
    var code = 0;

    if (p[0] < bbox[0]) code |= 1; // left
    else if (p[0] > bbox[2]) code |= 2; // right

    if (p[1] < bbox[1]) code |= 4; // bottom
    else if (p[1] > bbox[3]) code |= 8; // top

    return code;
}

Math.polygonclip = polygonclip;
console.log(this);
}(this));

var result = Math.polygonclip(
	[[10, -10], [10, 30], [20, 30], [20, -10]],
	[0, 0, 20, 20]);

console.log(result);	
(function () {
var sinTable = [];
for(var i = 0; i < 360; i++) {
	var rad = i/57.2957;
	sinTable.push(Math.sin(rad) + 0.000001);
}

Math.sinFast = function(rad) {
	var index = ((rad * 57.2957)>>0)%360;
	if(index < 0) {
		index += 360;
	}

	return sinTable[index];
}

Math.cosFast = function(rad) {
	return Math.sinFast(rad + Math.PI*0.5);
}

}());

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

"use strict";

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === this.Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} a Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mult = function (out, a, b0, b1, b2, b3, b4, b5) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];

    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;

    return out;
};


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
//mat2d.rotate = function (out, a, rad) {
//    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
//        s = mat2d.sin(rad),
//        c = mat2d.cos(rad);
//    out[0] = a0 *  c + a2 * s;
//    out[1] = a1 *  c + a3 * s;
//    out[2] = a0 * -s + a2 * c;
//    out[3] = a1 * -s + a3 * c;
//    out[4] = a4;
//    out[5] = a5;
//    return out;
//};

mat2d.rotate = function (a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = mat2d.sin(rad),
        c = mat2d.cos(rad);
    a[0] = a0 *  c + a2 * s;
    a[1] = a1 *  c + a3 * s;
    a[2] = a0 * -s + a2 * c;
    a[3] = a1 * -s + a3 * c;
};
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
//mat2d.scale = function(out, a, v0, v1) {
//    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
//    out[0] = a0 * v0;
//    out[1] = a1 * v0;
//    out[2] = a2 * v1;
//    out[3] = a3 * v1;
//    out[4] = a4;
//    out[5] = a5;
//    return out;
//};

mat2d.scale = function(a, v0, v1) {
    a[0] *= v0;
    a[1] *= v0;
    a[2] *= v1;
    a[3] *= v1;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
//mat2d.translate = function(out, a, v0, v1) {
//    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
//
//    out[0] = a0;
//    out[1] = a1;
//    out[2] = a2;
//    out[3] = a3;
//    out[4] = a0 * v0 + a2 * v1 + a4;
//    out[5] = a1 * v0 + a3 * v1 + a5;
//    return out;
//};

mat2d.translate = function(a, v0, v1) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    a[4] = a0 * v0 + a2 * v1 + a4;
    a[5] = a1 * v0 + a3 * v1 + a5;
};

mat2d.points = [{x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}];

mat2d.transformPoint = function(m, x, y, index) {
	var p = mat2d.points[index||0];

    p.x = m[0] * x + m[2] * y + m[4];
    p.y = m[1] * x + m[3] * y + m[5];
    
    return p;
};

mat2d.transformPointInt = function(m, x, y, index) {
	var p = mat2d.points[index||0];

    p.x = ((m[0] * x + m[2] * y + m[4]) * 10) >> 0;
    p.y = ((m[1] * x + m[3] * y + m[5]) * 10) >> 0;
    
    return p;
};

mat2d.transformPoints = function(m, arr) {
	for(var i = 0; i < arr.length; i+=2) {
		var x = arr[i];
		var y = arr[i+1];
		arr[i] = m[0] * x + m[2] * y + m[4];
		arr[i+1] = m[1] * x + m[3] * y + m[5];
	}

	return arr;
}

mat2d.sin = Math.sinFast;
mat2d.cos = Math.cosFast;

/*
 * File: shader.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: webgl shader program
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function WebGLProgram() {
}

WebGLProgram.activeProgram = null;
WebGLProgram.prototype.create = function(gl, buffer, fsSource, vsSource) {
	this.gl = gl;
	this.buffer = buffer;

	var program = gl.createProgram();
	var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fsSource);
	var vertexShader = this.createShader(gl.VERTEX_SHADER, vsSource);

	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);

	var lineStatus = gl.getProgramParameter(program, gl.LINK_STATUS);
	if(!lineStatus) {
		alert("Could not initialise shaders:" + gl.getProgramInfoLog(program));
	}

	this.program = program;
	this.init();

	return this;
}

WebGLProgram.prototype.init = function() {
}

WebGLProgram.prototype.createShader = function(type, source) {
	var gl = this.gl;
	var shader = gl.createShader(type);

	gl.shaderSource(shader, source);
	gl.compileShader(shader);

	if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

WebGLProgram.prototype.use = function() {
	if(WebGLProgram.activeProgram !== this.program) {
		this.gl.useProgram(this.program);
		WebGLProgram.activeProgram = this.program;
	}
}

WebGLProgram.prototype.destroy = function() {
	this.gl.deleteProgram(this.program);
	this.gl.program = null;
}

WebGLProgram.prototype.createDataBuffer = function(data) {
	return Int16DataBuffer.create(data);
}

WebGLProgram.prototype.getDataBufferElementSize = function() {
	return 2;
}

WebGLProgram.prototype.getDataBufferElementType = function() {
	return this.gl.SHORT;
}

/*
 * File: draw_image.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: shader to draw image.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function WebGLProgramDrawImage(name, gl, buffer, custom) {
	var fs = this.fs.replace(/custom-shader/, custom);

	this.name = name;
	this.create(gl, buffer, fs, this.vs);

	WebGLProgramDrawImage.programs[name] = this;
}

WebGLProgramDrawImage.prototype = new WebGLProgram();
WebGLProgramDrawImage.prototype.fs = [
	"precision mediump float;",
	"varying vec4 color;",
	"varying vec2 vTextureCoord;",
	"uniform vec4 size;",
	"uniform sampler2D texture;",
	"void main(void) {",
	"custom-shader",
	"}"].join("\n");

WebGLProgramDrawImage.prototype.vs = [
	"precision mediump float;",
	"attribute vec4 aTextureCoord;",
	"attribute vec2 aVertexPosition;",
	"uniform vec4 size;",
	"varying vec4 color;",
	"varying vec2 vTextureCoord;",
	"void main(void) {",
	"    vec2 viewSize = size.xy;",
	"    vec2 textureSize = size.zw;",
	"    vec2 pos = (vec2(aVertexPosition.x/10.0, viewSize.y-aVertexPosition.y/10.0)/ viewSize) * 2.0 - 1.0;",
	"    gl_Position = vec4(pos, 0, 1.0);",
	"    vec2 v = vec2(aTextureCoord.x, aTextureCoord.y)/textureSize;",
	"    vTextureCoord = vec2(v.s, 1.0-v.t);",
	"    float alpha = aTextureCoord.z/256.0;",
	"    float tint = aTextureCoord.w/256.0;",
	"    color = vec4(tint, tint, tint, alpha);",
	"}"].join("\n");

WebGLProgramDrawImage.prototype.init = function() {
	var gl = this.gl;
	var program = this.program;

	program.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
	program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");

	program.size = gl.getUniformLocation(program, "size");
	program.samplerUniform = gl.getUniformLocation(program, "texture");

	return;
}
	
WebGLProgramDrawImage.prototype.addTriangle = function(dataBuffer, alpha, tint, u0, v0, x0, y0, u1, v1, x1, y1, u2, v2, x2, y2) {
	var isClockWise = (x1-x0)*(y2-y1)-(y1-y0)*(x2-x1) >= 0;
	if(isClockWise) {
		return dataBuffer.pushX(
				u0, v0, alpha, tint, x0, y0, 
				u1, v1, alpha, tint, x1, y1, 
				u2, v2, alpha, tint, x2, y2
			);
	}else{
		return dataBuffer.pushX(
				u0, v0, alpha, tint, x0, y0, 
				u2, v2, alpha, tint, x2, y2,
				u1, v1, alpha, tint, x1, y1 
			);
	}
}

WebGLProgramDrawImage.prototype.draw = function(image, _bufferData) {
	this.use();

	var gl = this.gl;
	var program = this.program;
	var elementType = this.getDataBufferElementType();
	var elementSize = this.getDataBufferElementSize();
	var stride = elementSize * 6;

	var texture = image.texture;
	if(texture.dirty) {
		texture.update();
	}

	var bufferData = _bufferData;
	var vetexCount = bufferData.size/6;
	gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.DYNAMIC_DRAW);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);

	gl.vertexAttribPointer(program.aTextureCoord, 4, elementType, false, stride, 0);
	gl.enableVertexAttribArray(program.aTextureCoord);

	gl.vertexAttribPointer(program.aVertexPosition, 2, elementType, false, stride, elementSize * 4);
	gl.enableVertexAttribArray(program.aVertexPosition);
	
	gl.uniform4f(program.size, gl.w, gl.h, texture.w, texture.h);
	
	gl.drawArrays(gl.TRIANGLES, 0, vetexCount);
}

WebGLProgramDrawImage.defaultCustomFs = [
	"  vec4 c = texture2D(texture, vTextureCoord) * color;",
	"  if(c.a > 0.01) {",
	"     gl_FragColor = c;",
	"  }else{",
	"     discard;",
	"  }",
	""].join("\n");

WebGLProgramDrawImage.create = function(gl, buffer) {
	var program = new WebGLProgramDrawImage("normal", gl, buffer, WebGLProgramDrawImage.defaultCustomFs);

	return program;
}

WebGLProgramDrawImage.grayCustomFs = [
	"    vec4 c = texture2D(texture, vTextureCoord);",
	"    float gray = c.r*0.3 + c.g*0.59 + c.b*0.11;",
	"    gl_FragColor = vec4(gray, gray, gray, c.a) * color;"].join("\n");

WebGLProgramDrawImage.createGray = function(gl, buffer) {
	var program = new WebGLProgramDrawImage("gray", gl, buffer, WebGLProgramDrawImage.grayCustomFs);

	return program;
}

WebGLProgramDrawImage.programs = {};
WebGLProgramDrawImage.init = function(gl, buffer) {
	WebGLProgramDrawImage.create(gl, buffer);
	WebGLProgramDrawImage.createGray(gl, buffer);
}

WebGLProgramDrawImage.get = function(name) {
	return WebGLProgramDrawImage.programs[name] || WebGLProgramDrawImage.programs.normal;
}
/*
 * File: draw_primitives.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: shader to stroke/fill lines and curve.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function WebGLProgramDrawPrimitives(gl, buffer) {
	this.create(gl, buffer, this.fs, this.vs);
}

WebGLProgramDrawPrimitives.prototype = new WebGLProgram();
WebGLProgramDrawPrimitives.prototype.fs = [
	"precision mediump float;",
	'varying vec4 vColor;',
	"void main(void) {",
	"    gl_FragColor = vColor;",
	"}"].join("\n");

WebGLProgramDrawPrimitives.prototype.vs = [
	"precision mediump float;",
	'attribute vec2 aVertexPosition;',
	"uniform vec4 aSizeAlphaTint;",
	"uniform vec4 aColor;",
	'varying vec4 vColor;',
	"void main(void) {",
	"   vec2 size = vec2(aSizeAlphaTint.x, aSizeAlphaTint.y);",
	"   float tint = aSizeAlphaTint.z/256.0;",
	"	float alpha = aSizeAlphaTint.w/256.0;",
	"   vec3 pos = vec3(aVertexPosition.x/10.0, aVertexPosition.y/10.0, 1.0);",
	"   vec2 pos2 = (vec2(pos.x, size.y-pos.y)/size) * 2.0 - 1.0;",
	"   gl_Position = vec4(pos2, 0, 1.0);",
	"	vColor = aColor * vec4(tint, tint, tint, alpha);",
	"}"].join("\n");

WebGLProgramDrawPrimitives.prototype.init = function() {
	var gl = this.gl;
	var program = this.program;

	program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");

	program.aColor = gl.getUniformLocation(program, "aColor");
	program.aSizeAlphaTint = gl.getUniformLocation(program, "aSizeAlphaTint");

	return;
}

WebGLProgramDrawPrimitives.prototype.clip = function(start, end) {
	this.draw(this.gl.TRIANGLE_FAN, start, end);
}

WebGLProgramDrawPrimitives.prototype.stroke = function(start, end) {
	this.draw(this.gl.LINE_STRIP, start, end);
}

WebGLProgramDrawPrimitives.prototype.fill = function(start, end) {
	this.draw(this.gl.TRIANGLE_FAN, start, end);
}

WebGLProgramDrawPrimitives.prototype.prepareDraw = function(bufferData, color, alpha, tint) {
	this.use();

	var gl = this.gl;
	var program = this.program;
	var elementType = this.getDataBufferElementType();
	var elementSize = this.getDataBufferElementSize();

	gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.DYNAMIC_DRAW);

	gl.vertexAttribPointer(program.aVertexPosition, 2, elementType, false, 0, 0);
	gl.enableVertexAttribArray(program.aVertexPosition);
	
	gl.uniform4f(program.aColor, color.r, color.g, color.b, color.a);
	gl.uniform4f(program.aSizeAlphaTint, gl.w, gl.h, tint, alpha);
}

WebGLProgramDrawPrimitives.prototype.draw = function(type, start, end) {
	var gl = this.gl;
	var begin = start >> 1;
	var n = (end - start) >> 1;

	gl.drawArrays(type, begin, n);
}


WebGLProgramDrawPrimitives.prototype.createDataBuffer = function(data) {
	return Int16DataBuffer.create(data);
}

WebGLProgramDrawPrimitives.prototype.getDataBufferElementSize = function() {
	return 2;
}

WebGLProgramDrawPrimitives.prototype.getDataBufferElementType = function() {
	return this.gl.SHORT;
}

/*
 * File: typed_array_ext.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: some functions to extend typed array.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

Int16Array.prototype.push = function() {
	var arr = arguments;
	var size = this.size;
	var length = this.length;

	var n = arr.length;
	for(var i = 0; i < n && size < length; i++) {
		this[size++] = arr[i];
	}
	this.size = size;

	return this;
}

Int16Array.prototype.extend = function() {
	var size = this.size;
	var newSize = this.length + 1024;
	var newDataBuffer = Int16Array.create(newSize);

	newDataBuffer.size = size;
	for(var i = 0; i < size; i++) {
		newDataBuffer[i] = this[i];
	}

	return newDataBuffer;
}

Float32Array.prototype.extend = function() {
	var size = this.size;
	var newSize = this.length + 1024;
	var newDataBuffer = Float32Array.create(newSize);

	newDataBuffer.size = size;
	for(var i = 0; i < size; i++) {
		newDataBuffer[i] = this[i];
	}

	return newDataBuffer;
}

Int16Array.prototype.pushX = function() {
	var me = this;
	var arr = arguments;
	var n = arr.length;

	if((this.size + 1024 + n) > this.length) {
		me = this.extend();
	}

	var start = this.size;
	for(var i = 0; i < n; i++, start++) {
		me[start] = arr[i];
	}
	me.size += n;

	return me;
}

Int16Array.prototype.push1 = function(a) {
	var me = this;
	if((this.size + 10) >= this.length) {
		me = this.extend();
	}
	
	me[this.size++] = a;

	return me;
}

Float32Array.prototype.push1 = function(a) {
	var me = this;
	if((this.size + 10) >= this.length) {
		me = this.extend();
	}
	
	me[this.size++] = a;

	return me;
}

Int16Array.prototype.push2 = function(a, b) {
	var me = this;
	if((this.size + 10) >= this.length) {
		me = this.extend();
	}
	
	me[this.size++] = a;
	me[this.size++] = b;

	return me;
}

Float32Array.prototype.push2 = function(a, b) {
	var me = this;
	if((this.size + 10) >= this.length) {
		me = this.extend();
	}
	
	me[this.size++] = a;
	me[this.size++] = b;

	return me;
}

Float32Array.prototype.pushX = function() {
	var me = this;
	var arr = arguments;
	var n = arr.length;

	if((this.size + 1024 + n) > this.length) {
		me = this.extend();
	}

	var start = this.size;
	for(var i = 0; i < n; i++, start++) {
		me[start] = arr[i];
	}
	me.size += n;

	return me;
}

Float32Array.prototype.pushArr = Int16Array.prototype.pushArr = function(arr) {
	var me = this;
	var n = arr.length;

	if((this.size + 1024 + n) > this.length) {
		me = this.extend();
	}

	var start = this.size;
	for(var i = 0; i < n; i++, start++) {
		me[start] = arr[i];
	}
	me.size += n;

	return me;
}

Float32Array.prototype.reset = Int16Array.prototype.reset = function() {
	this.size = 0;

	return this;
}

Int16Array.create = function(data) {
	var arr = new Int16Array(data);	
	arr.size = 0;

	return arr;
}

Float32Array.create = function(data) {
	var arr = new Float32Array(data);	
	arr.size = 0;

	return arr;
}

Int16Array.prototype.dup = function() {
	var size = this.size;
	var newDataBuffer = Int16Array.create(size);

	for(var i = 0; i < size; i++) {
		newDataBuffer[i] = this[i];
	}
	newDataBuffer.size = size;

	return newDataBuffer;
}

Float32Array.prototype.dup = function() {
	var size = this.size;
	var newDataBuffer = Float32Array.create(size);

	for(var i = 0; i < size; i++) {
		newDataBuffer[i] = this[i];
	}
	newDataBuffer.size = size;

	return newDataBuffer;
}

Float32Array.prototype.slice = Int16Array.prototype.slice = Array.prototype.slice;

/**
 * Based on the Public Domain MaxRectanglesBinPack.cpp source by Jukka Jylänki
 * https://github.com/juj/RectangleBinPack/
 *
 * Based on C# port by Sven Magnus
 * http://unifycommunity.com/wiki/index.php?title=MaxRectanglesBinPack
 *
 * Based on ActionScript3 by DUZENGQIANG
 * http://www.duzengqiang.com/blog/post/971.html
 *
 * Ported to javascript by 06wj
 * https://github.com/06wj/MaxRectsBinPack
 */
(function(){
    /**
     * Rect
     * @param {Number} x      矩形坐标x
     * @param {Number} y      矩形坐标y
     * @param {Number} width  矩形宽
     * @param {Number} height 矩形高
     */
    function Rect(x, y, width, height){
        this.x = x||0;
        this.y = y||0;
        this.width = width||0;
        this.height = height||0;
    }

    Rect.prototype = {
        constructor:Rect,
        /**
         * clone 复制
         * @return {Rect}
         */
        clone:function(){
            return new Rect(this.x, this.y, this.width, this.height);
        }
    };

    Rect.isContainedIn = function(a, b){
        return a.x >= b.x && a.y >= b.y
            && a.x+a.width <= b.x+b.width
            && a.y+a.height <= b.y+b.height;
    };

    var BestShortSideFit = 0; ///< -BSSF: Positions the Rectangle against the short side of a free Rectangle into which it fits the best.
    var BestLongSideFit = 1; ///< -BLSF: Positions the Rectangle against the long side of a free Rectangle into which it fits the best.
    var BestAreaFit = 2; ///< -BAF: Positions the Rectangle into the smallest free Rectangle into which it fits.
    var BottomLeftRule = 3; ///< -BL: Does the Tetris placement.
    var ContactPointRule = 4; ///< -CP: Choosest the placement where the Rectangle touches other Rectangles as much as possible.

    /**
     * MaxRectanglesBinPack
     * @param {Number} width 容器宽度
     * @param {Number} height 容器高度
     * @param {Boolean} allowRotate 是否允许旋转
     */
    function MaxRectsBinPack(width, height, allowRotate){
        this.binWidth = 0;
        this.binHeight = 0;
        this.allowRotate = false;

        this.usedRectangles = [];
        this.freeRectangles = [];

        this.init(width, height, allowRotate);
    }

    MaxRectsBinPack.prototype = {
        constructor:MaxRectsBinPack,
        /**
         * 初始化
         * @param {Number} width 容器宽度
         * @param {Number} height 容器高度
         * @param {Boolean} allowRotate 是否允许旋转
         */
        init:function(width, height, allowRotate){
            this.binWidth = width;
            this.binHeight = height;
            this.allowRotate = allowRotate||false;

            this.usedRectangles.length = 0;
            this.freeRectangles.length = 0;
            this.freeRectangles.push(new Rect(0, 0, width, height));
        },
        /**
         * insert a new rect
         * @param  {Number} width  矩形宽
         * @param  {Number} height 矩形高
         * @param  {Number} method 分配方法 0~4
         * @return {Rect}
         */
        insert:function(width, height,  method){
            var newNode = new Rect();
            var score1 = {
                value:0
            };

            var score2 = {
                value:0
            };
            method = method||0;
            switch(method) {
                case BestShortSideFit:
                    newNode = this._findPositionForNewNodeBestShortSideFit(width, height, score1, score2);
                    break;
                case BottomLeftRule:
                    newNode = this._findPositionForNewNodeBottomLeft(width, height, score1, score2);
                    break;
                case ContactPointRule:
                    newNode = this._findPositionForNewNodeContactPoint(width, height, score1);
                    break;
                case BestLongSideFit:
                    newNode = this._findPositionForNewNodeBestLongSideFit(width, height, score2, score1);
                    break;
                case BestAreaFit:
                    newNode = this._findPositionForNewNodeBestAreaFit(width, height, score1, score2);
                    break;
            }

            if (newNode.height === 0){
                return newNode;
            }

            this._placeRectangle(newNode);
            return newNode;
        },
        /**
         * 插入一组矩形
         * @param  {Array} rectangles 矩形数组
         * @param  {Number} method 分配方法 0~4
         * @return {Array} 成功插入的数组
         */
        insert2:function(rectangles, method){
            var res = [];
            while(rectangles.length > 0) {
                var bestScore1 = Infinity;
                var bestScore2 = Infinity;
                var bestRectangleIndex = -1;
                var bestNode = new Rect();

                for(var i= 0; i < rectangles.length; i++) {
                    var score1 = {
                        value:0
                    };
                    var score2 = {
                        value:0
                    };
                    var newNode = this._scoreRectangle(rectangles[i].width, rectangles[i].height, method, score1, score2);

                    if (score1.value < bestScore1 || (score1.value == bestScore1 && score2.value < bestScore2)) {
                        bestScore1 = score1.value;
                        bestScore2 = score2.value;
                        bestNode = newNode;
                        bestRectangleIndex = i;
                    }
                }

                if (bestRectangleIndex == -1){
                    return res;
                }

                this._placeRectangle(bestNode);
                var rect = rectangles.splice(bestRectangleIndex, 1)[0];
                rect.x = bestNode.x;
                rect.y = bestNode.y;

                res.push(rect);
            }
            return res;
        },
        _placeRectangle:function(node){
            var numRectanglesToProcess = this.freeRectangles.length;
            for(var i= 0; i < numRectanglesToProcess; i++) {
                if (this._splitFreeNode(this.freeRectangles[i], node)) {
                    this.freeRectangles.splice(i,1);
                    i--;
                    numRectanglesToProcess--;
                }
            }

            this._pruneFreeList();
            this.usedRectangles.push(node);
        },
        _scoreRectangle:function(width, height, method, score1, score2){
            var newNode = new Rect();
            score1.value = Infinity;
            score2.value = Infinity;
            switch(method) {
                case BestShortSideFit:
                    newNode = this._findPositionForNewNodeBestShortSideFit(width, height, score1, score2);
                    break;
                case BottomLeftRule:
                    newNode = this._findPositionForNewNodeBottomLeft(width, height, score1, score2);
                    break;
                case ContactPointRule:
                    newNode = this._findPositionForNewNodeContactPoint(width, height, score1);
                    // todo: reverse
                    score1 = -score1; // Reverse since we are minimizing, but for contact point score bigger is better.
                    break;
                case BestLongSideFit:
                    newNode = this._findPositionForNewNodeBestLongSideFit(width, height, score2, score1);
                    break;
                case BestAreaFit:
                    newNode = this._findPositionForNewNodeBestAreaFit(width, height, score1, score2);
                    break;
            }

            // Cannot fit the current Rectangle.
            if (newNode.height === 0) {
                score1.value = Infinity;
                score2.value = Infinity;
            }

            return newNode;
        },
        _occupancy:function(){
            var usedRectangles = this.usedRectangles;
            var usedSurfaceArea = 0;
            for(var i= 0; i < usedRectangles.length; i++){
                usedSurfaceArea += usedRectangles[i].width * usedRectangles[i].height;
            }

            return usedSurfaceArea/(this.binWidth * this.binHeight);
        },
        _findPositionForNewNodeBottomLeft:function(width, height, bestY, bestX){
            var freeRectangles = this.freeRectangles;
            var bestNode = new Rect();
            //memset(bestNode, 0, sizeof(Rectangle));

            bestY.value = Infinity;
            var rect;
            var topSideY;
            for(var i= 0; i < freeRectangles.length; i++) {
                rect = freeRectangles[i];
                // Try to place the Rectangle in upright (non-flipped) orientation.
                if (rect.width >= width && rect.height >= height) {
                    topSideY = rect.y + height;
                    if (topSideY < bestY.value || (topSideY == bestY.value && rect.x < bestX.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = width;
                        bestNode.height = height;
                        bestY.value = topSideY;
                        bestX.value = rect.x;
                    }
                }
                if (this.allowRotate && rect.width >= height && rect.height >= width) {
                    topSideY = rect.y + width;
                    if (topSideY < bestY.value || (topSideY == bestY.value && rect.x < bestX.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = height;
                        bestNode.height = width;
                        bestY.value = topSideY;
                        bestX.value = rect.x;
                    }
                }
            }
            return bestNode;
        },
        _findPositionForNewNodeBestShortSideFit:function(width, height, bestShortSideFit, bestLongSideFit){
            var freeRectangles = this.freeRectangles;
            var bestNode = new Rect();
            //memset(&bestNode, 0, sizeof(Rectangle));

            bestShortSideFit.value = Infinity;

            var rect;
            var leftoverHoriz;
            var leftoverVert;
            var shortSideFit;
            var longSideFit;

            for(var i= 0; i < freeRectangles.length; i++) {
                rect = freeRectangles[i];
                // Try to place the Rectangle in upright (non-flipped) orientation.
                if (rect.width >= width && rect.height >= height) {
                    leftoverHoriz = Math.abs(rect.width - width);
                    leftoverVert = Math.abs(rect.height - height);
                    shortSideFit = Math.min(leftoverHoriz, leftoverVert);
                    longSideFit = Math.max(leftoverHoriz, leftoverVert);

                    if (shortSideFit < bestShortSideFit.value || (shortSideFit == bestShortSideFit.value && longSideFit < bestLongSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = width;
                        bestNode.height = height;
                        bestShortSideFit.value = shortSideFit;
                        bestLongSideFit.value = longSideFit;
                    }
                }
                var flippedLeftoverHoriz;
                var flippedLeftoverVert;
                var flippedShortSideFit;
                var flippedLongSideFit;
                if (this.allowRotate && rect.width >= height && rect.height >= width) {
                    flippedLeftoverHoriz = Math.abs(rect.width - height);
                    flippedLeftoverVert = Math.abs(rect.height - width);
                    flippedShortSideFit = Math.min(flippedLeftoverHoriz, flippedLeftoverVert);
                    flippedLongSideFit = Math.max(flippedLeftoverHoriz, flippedLeftoverVert);

                    if (flippedShortSideFit < bestShortSideFit.value || (flippedShortSideFit == bestShortSideFit.value && flippedLongSideFit < bestLongSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = height;
                        bestNode.height = width;
                        bestShortSideFit.value = flippedShortSideFit;
                        bestLongSideFit.value = flippedLongSideFit;
                    }
                }
            }

            return bestNode;
        },
        _findPositionForNewNodeBestLongSideFit:function(width, height, bestShortSideFit, bestLongSideFit){
            var freeRectangles = this.freeRectangles;
            var bestNode = new Rect();
            //memset(&bestNode, 0, sizeof(Rectangle));
            bestLongSideFit.value = Infinity;
            var rect;

            var leftoverHoriz;
            var leftoverVert;
            var shortSideFit;
            var longSideFit;
            for(var i= 0; i < freeRectangles.length; i++) {
                rect = freeRectangles[i];
                // Try to place the Rectangle in upright (non-flipped) orientation.
                if (rect.width >= width && rect.height >= height) {
                    leftoverHoriz = Math.abs(rect.width - width);
                    leftoverVert = Math.abs(rect.height - height);
                    shortSideFit = Math.min(leftoverHoriz, leftoverVert);
                    longSideFit = Math.max(leftoverHoriz, leftoverVert);

                    if (longSideFit < bestLongSideFit.value || (longSideFit == bestLongSideFit.value && shortSideFit < bestShortSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = width;
                        bestNode.height = height;
                        bestShortSideFit.value = shortSideFit;
                        bestLongSideFit.value = longSideFit;
                    }
                }

                if (this.allowRotate && rect.width >= height && rect.height >= width) {
                    leftoverHoriz = Math.abs(rect.width - height);
                    leftoverVert = Math.abs(rect.height - width);
                    shortSideFit = Math.min(leftoverHoriz, leftoverVert);
                    longSideFit = Math.max(leftoverHoriz, leftoverVert);

                    if (longSideFit < bestLongSideFit.value || (longSideFit == bestLongSideFit.value && shortSideFit < bestShortSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = height;
                        bestNode.height = width;
                        bestShortSideFit.value = shortSideFit;
                        bestLongSideFit.value = longSideFit;
                    }
                }
            }
            return bestNode;
        },
        _findPositionForNewNodeBestAreaFit:function(width, height, bestAreaFit, bestShortSideFit){
            var freeRectangles = this.freeRectangles;
            var bestNode = new Rect();
            //memset(&bestNode, 0, sizeof(Rectangle));

            bestAreaFit.value = Infinity;

            var rect;

            var leftoverHoriz;
            var leftoverVert;
            var shortSideFit;
            var areaFit;

            for(var i= 0; i < freeRectangles.length; i++) {
                rect = freeRectangles[i];
                areaFit = rect.width * rect.height - width * height;

                // Try to place the Rectangle in upright (non-flipped) orientation.
                if (rect.width >= width && rect.height >= height) {
                    leftoverHoriz = Math.abs(rect.width - width);
                    leftoverVert = Math.abs(rect.height - height);
                    shortSideFit = Math.min(leftoverHoriz, leftoverVert);

                    if (areaFit < bestAreaFit.value || (areaFit == bestAreaFit.value && shortSideFit < bestShortSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = width;
                        bestNode.height = height;
                        bestShortSideFit.value = shortSideFit;
                        bestAreaFit = areaFit;
                    }
                }

                if (this.allowRotate && rect.width >= height && rect.height >= width) {
                    leftoverHoriz = Math.abs(rect.width - height);
                    leftoverVert = Math.abs(rect.height - width);
                    shortSideFit = Math.min(leftoverHoriz, leftoverVert);

                    if (areaFit < bestAreaFit.value || (areaFit == bestAreaFit.value && shortSideFit < bestShortSideFit.value)) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = height;
                        bestNode.height = width;
                        bestShortSideFit.value = shortSideFit;
                        bestAreaFit.value = areaFit;
                    }
                }
            }
            return bestNode;
        },
        /// Returns 0 if the two intervals i1 and i2 are disjoint, or the length of their overlap otherwise.
        _commonIntervalLength:function(i1start, i1end, i2start, i2end){
            if (i1end < i2start || i2end < i1start){
                return 0;
            }
            return Math.min(i1end, i2end) - Math.max(i1start, i2start);
        },
        _contactPointScoreNode:function(x, y, width, height){
            var usedRectangles = this.usedRectangles;
            var score = 0;

            if (x == 0 || x + width === this.binWidth)
                score += height;
            if (y == 0 || y + height === this.binHeight)
                score += width;
            var rect;
            for(var i= 0; i < usedRectangles.length; i++) {
                rect = usedRectangles[i];
                if (rect.x == x + width || rect.x + rect.width == x)
                    score += this._commonIntervalLength(rect.y, rect.y + rect.height, y, y + height);
                if (rect.y == y + height || rect.y + rect.height == y)
                    score += this._commonIntervalLength(rect.x, rect.x + rect.width, x, x + width);
            }
            return score;
        },
        _findPositionForNewNodeContactPoint:function(width, height, bestContactScore){
            var freeRectangles = this.freeRectangles;
            var bestNode = new Rect();
            //memset(&bestNode, 0, sizeof(Rectangle));

            bestContactScore.value = -1;

            var rect;
            var score;
            for(var i= 0; i < freeRectangles.length; i++) {
                rect = freeRectangles[i];
                // Try to place the Rectangle in upright (non-flipped) orientation.
                if (rect.width >= width && rect.height >= height) {
                    score = this._contactPointScoreNode(rect.x, rect.y, width, height);
                    if (score > bestContactScore.value) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = width;
                        bestNode.height = height;
                        bestContactScore = score;
                    }
                }
                if (this.allowRotate && rect.width >= height && rect.height >= width) {
                    score = this._contactPointScoreNode(rect.x, rect.y, height, width);
                    if (score > bestContactScore.value) {
                        bestNode.x = rect.x;
                        bestNode.y = rect.y;
                        bestNode.width = height;
                        bestNode.height = width;
                        bestContactScore.value = score;
                    }
                }
            }
            return bestNode;
        },
        _splitFreeNode:function(freeNode, usedNode){
            var freeRectangles = this.freeRectangles;
            // Test with SAT if the Rectangles even intersect.
            if (usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x ||
                usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y)
                return false;
            var newNode;
            if (usedNode.x < freeNode.x + freeNode.width && usedNode.x + usedNode.width > freeNode.x) {
                // New node at the top side of the used node.
                if (usedNode.y > freeNode.y && usedNode.y < freeNode.y + freeNode.height) {
                    newNode = freeNode.clone();
                    newNode.height = usedNode.y - newNode.y;
                    freeRectangles.push(newNode);
                }

                // New node at the bottom side of the used node.
                if (usedNode.y + usedNode.height < freeNode.y + freeNode.height) {
                    newNode = freeNode.clone();
                    newNode.y = usedNode.y + usedNode.height;
                    newNode.height = freeNode.y + freeNode.height - (usedNode.y + usedNode.height);
                    freeRectangles.push(newNode);
                }
            }

            if (usedNode.y < freeNode.y + freeNode.height && usedNode.y + usedNode.height > freeNode.y) {
                // New node at the left side of the used node.
                if (usedNode.x > freeNode.x && usedNode.x < freeNode.x + freeNode.width) {
                    newNode = freeNode.clone();
                    newNode.width = usedNode.x - newNode.x;
                    freeRectangles.push(newNode);
                }

                // New node at the right side of the used node.
                if (usedNode.x + usedNode.width < freeNode.x + freeNode.width) {
                    newNode = freeNode.clone();
                    newNode.x = usedNode.x + usedNode.width;
                    newNode.width = freeNode.x + freeNode.width - (usedNode.x + usedNode.width);
                    freeRectangles.push(newNode);
                }
            }

            return true;
        },
        _pruneFreeList:function(){
            var freeRectangles = this.freeRectangles;
            for(var i = 0;i < freeRectangles.length; i++)
                for(var j= i+1; j < freeRectangles.length; j++) {
                    if (Rect.isContainedIn(freeRectangles[i], freeRectangles[j])) {
                        freeRectangles.splice(i,1);
                        break;
                    }
                    if (Rect.isContainedIn(freeRectangles[j], freeRectangles[i])) {
                        freeRectangles.splice(j,1);
                    }
                }
        }
    };

    window.MaxRectsBinPack = MaxRectsBinPack;
})();
Math.normalize = function(x, y, r)
{
    var d = Math.sqrt(x*x+y*y);
    if (d > 0.000001) {
        var id = 1.0 / d;
        r.x = x * id;
        r.y = y * id;
    }
	r.d = d;

    return r;
}

Math.cross = function(dx0, dy0, dx1, dy1) 
{ 
	return dx1*dy0 - dx0*dy1; 
}

Math.ptEquals = function(x1, y1, x2, y2, tol)
{
	var dx = x2 - x1;
	var dy = y2 - y1;
	return dx*dx + dy*dy < tol*tol;
}

Math.distPtSeg = function(x, y, px, py, qx, qy)
{
	var pqx, pqy, dx, dy, d, t;
	pqx = qx-px;
	pqy = qy-py;
	dx = x-px;
	dy = y-py;
	d = pqx*pqx + pqy*pqy;
	t = pqx*dx + pqy*dy;
	if (d > 0) t /= d;
	if (t < 0) t = 0;
	else if (t > 1) t = 1;
	dx = px + t*pqx - x;
	dy = py + t*pqy - y;
	return dx*dx + dy*dy;
}

function parseFontSize(font) {
	var fontSize = 12;
	var arr = font.match(/\d+pt|\d+px/g);
	if(arr) {
		var size = arr[0];
		fontSize = parseInt(size);
		if(size.indexOf("pt") > 0) {
			fontSize = Math.round(fontSize * 1.2);
		}
	}

	return fontSize;
}

/*
 * File: auto_packer.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: auto packer glyphs and small images into a big canvas.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function AutoPacker() {
}

AutoPacker.prototype.init = function(gl) {
	this.gl = gl;
	this.w = 512;
	this.h = 1024;
	this.imageMaxWidth  = 256;
	this.imageMaxHeight = 256;
	this.canvas = document.createElement("canvas");
	this.canvas.cannotPack = true;
	this.glyphCache = {};
	this.imagesCache = [];
	this.createTexture();
	this.setOverflow(false);

	return this.reset();
}

AutoPacker.prototype.resetImagesCache = function() {
	var imagesCache = this.imagesCache;
	var n = imagesCache.length;
	for(var i = 0; i < n; i++) {
		var image = imagesCache[i];
		image.ox = 0;
		image.oy = 0;
		image.packed = false;
		image.texture = null;
	}

	imagesCache.length = 0;
}

AutoPacker.prototype.extendCanvas = function() {
	if(this.isOverflow()) {
		if(this.w < 2048 || this.h < 2048) {
			if(this.w < this.h) {
				this.w = this.w << 1;
			}else{
				this.h = this.h << 1;
			}
		}else{
			if(this.imageMaxWidth > this.imageMaxHeight) {
				this.imageMaxWidth = this.imageMaxWidth << 1;
			}
			else {
				this.imageMaxHeight = this.imageMaxHeight << 1;
			}
		}

		this.setOverflow(false);
		console.log("extend canvas to " + this.w + "x" + this.h);
	}
	
	this.canvas.width = this.w;
	this.canvas.height = this.h;
	this.ctx = this.canvas.getContext("2d");
}

AutoPacker.prototype.reset = function() {
	this.resetImagesCache();
	this.glyphCache = {};
	this.extendCanvas();

	var ctx = this.ctx;
	ctx.textAlign = "left";
	ctx.textBaseline = "middle";
	ctx.clearRect(0, 0, this.w, this.h);

	this.binPacker = new MaxRectsBinPack(this.w, this.h, false);

	return this;
}

AutoPacker.prototype.getAvailableRect = function(w, h) {
	var r = this.binPacker.insert(w, h, 0);

	if(r) {
		r.w = w;
		r.h = h;
	}

	return r;
}

AutoPacker.prototype.addGlyph = function(font, fontSize, color, c) {
	var ctx = this.ctx;
	if(ctx.font !== font) {
		ctx.font = font;
	}

	if(ctx.fillStyle !== color) {
		ctx.fillStyle = color;
	}

	var charWidth = Math.ceil(ctx.measureText(c).width);
	var charHeight = Math.ceil(fontSize * 1.3);
	var hMargin = charWidth >> 2;
	var vMargin = fontSize >> 2;

	var rect = this.getAvailableRect(charWidth + hMargin*2, charHeight + vMargin*2);

	if(rect) {
		rect.x += hMargin;
		rect.y += vMargin;
		rect.w = charWidth;
		rect.h = charHeight;
		if(font.indexOf("italic") >= 0) {
			rect.charW = rect.w + hMargin;
		}else{
			rect.charW = rect.w;
		}

		var key = AutoPacker.toGlyphKey(font, c, color);

		ctx.fillText(c, rect.x, rect.y + (rect.h >> 1));
		this.glyphCache[key] = rect;
		this.setDirty(true);
	}

	return rect;
}

AutoPacker.prototype.measureText = function(font, str, color, outRect) {
	var width = 0;
	var n = str.length;
	var fontSize = parseFontSize(font);

	for(var i = 0; i < n; i++) {
		var c = str[i];
		var r = this.getGlyph(font, c, color);

		if(!r) {
			r = this.addGlyph(font, fontSize, color, c);
		}

		if(r) {
			width += r.w;
		}
	}

	outRect.w = width;
	outRect.h = fontSize;

	return outRect;
}

AutoPacker.toGlyphKey = function(font, c, color) {
	return font+c+color;
}

AutoPacker.prototype.hasGlyph = function(font, c, color) {
	return !!this.glyphCache[AutoPacker.toGlyphKey(font, c, color)];
}

AutoPacker.prototype.setOverflow = function(overflow) {
	this.overflow = overflow;
}

AutoPacker.prototype.isOverflow = function(overflow) {
	return this.overflow;
}

AutoPacker.prototype.getGlyph = function(font, c, color) {
	return this.glyphCache[AutoPacker.toGlyphKey(font, c, color)];	
}

AutoPacker.prototype.packImage = function(image) {
	if(!image.src || image.src.indexOf("data:") === 0 || image.width > this.imageMaxWidth || image.height > this.imageMaxHeight) {
		image.ox = 0;
		image.oy = 0;
		image.cannotPack = true;
		return;
	}

	var rect = this.getAvailableRect(image.width + 4, image.height + 4);
	if(rect.height < image.height) {
		image.ox = 0;
		image.oy = 0;
		this.setOverflow(true);

		return;
	}

	var x = rect.x + 2;
	var y = rect.y + 2;
	var texture = this.canvas.texture;

	this.setDirty(true);
	this.ctx.drawImage(image, x, y);
	
	image.ox = x;
	image.oy = y;
	image.packed = true;

	if(image.texture && image.texture !== texture)  {
		this.gl.deleteTexture(image.texture);
	}

	image.texture = this.canvas.texture;
	this.imagesCache.push(image);

	return;
}

AutoPacker.prototype.setDirty = function(dirty) {
	this.canvas.texture.setDirty(dirty);
}

AutoPacker.prototype.createTexture = function() {
	var gl = this.gl;
	var texture = gl.createTexture();
	
	texture.src = null;
	texture.image = this.canvas;
	this.canvas.texture = texture;

	texture.dirty = true;
	texture.setDirty = function(dirty) {
		this.dirty = dirty;
	}

	texture.update = function() {
		if(!this.dirty) return;
		
		var image = this.image;
		this.dirty = false;
		this.w = image.width;
		this.h = image.height;
		gl.bindTexture(gl.TEXTURE_2D, this);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
}

AutoPacker.prototype.getImage = function() {
	return this.canvas;
}


function CanvasRenderingContext2DWebGL(options){
	this.distTol = 0.01;
	this.tessTol = 0.0025;
	this.currentID = 1000;

	this.fps = 0;
	this.lastX = 0;
	this.lastY = 0;
	this.firstX = 0;
	this.firstY = 0;
	this.showFPS = false;
	this.renderTimes = 0;
	this.startTime = Date.now();
	this.lastSeconds = (this.startTime/1000) >> 0;
	this.drawCalls = 0;
	this.drawImageCalls = 0;
	this.drawImageCount = 0;
	this.fillCount = 0;
	this.strokeCount = 0;
	this.clipLevel = 0;
	this.canvasWidth = 0;
	this.canvasHeight = 0;
	this.canvasWidth10 = 0;
	this.canvasHeight10 = 0;
	this.zeroPoint = {x:0, y:0};
	this.tempRect = {x:0, y:0, w:0, h:0};
	this.webglOptions = options || CanvasRenderingContext2DWebGL.webglOptions;
}

CanvasRenderingContext2DWebGL.webglOptions = {
	antialias: false, 
	stencil: true, 
	preserveDrawingBuffer:true, 
	premultipliedAlpha:false
};

CanvasRenderingContext2DWebGL.prototype.save = function() {
	this.stack.push(this.state.clone());
}

CanvasRenderingContext2DWebGL.prototype.restore = function() {
	var oldState = this.state;	
	var state = this.stack.pop();

	if(state) {
		if(state.clipRect || oldState.clipRect) {
			if(!state.clipRect || !oldState.clipRect || state.clipRect !== oldState.clipRect) {
				this.doClipRect(state.clipRect);
			}
		}

		if(state.clipPaths || oldState.clipPaths) {
			if(!state.clipPaths || !oldState.clipPaths || state.clipPaths.id !== oldState.clipPaths.id) {
				this.clearClip(oldState.clipPaths);
			}
		}

		this.state = state;
		if(oldState.globalCompositeOperation !== state.globalCompositeOperation) {
			this.globalCompositeOperationApply(state.globalCompositeOperation);
		}
	}else{
		console.log("restore times > save times.");
	}

	CanvasRenderingContext2DWebGL.destroyState(oldState);
}

CanvasRenderingContext2DWebGL.prototype.scale = function(x, y) {
	mat2d.scale(this.state.m, x, y);
};

CanvasRenderingContext2DWebGL.prototype.rotate = function(angle) {
	mat2d.rotate(this.state.m, angle);
};

CanvasRenderingContext2DWebGL.prototype.translate = function(x, y) {
	mat2d.translate(this.state.m, x, y);
};

CanvasRenderingContext2DWebGL.prototype.transform = function(a, b, c, d, e, f) {
	var m = this.state.m;
	mat2d.mult(m, m, a, b, c, d, e, f);
};

CanvasRenderingContext2DWebGL.prototype.setTransform = function(a, b, c, d, e, f) {
	mat2d.set(this.state.m, a, b, c, d, e, f);
};

CanvasRenderingContext2DWebGL.prototype.scaleArr = function(arr, x, y) {
	mat2d.scale(this.state.m, arr[x], arr[y]);
}

CanvasRenderingContext2DWebGL.prototype.rotateArr = function(arr, index) {
	mat2d.rotate(this.state.m, arr[index]);
}

CanvasRenderingContext2DWebGL.prototype.translateArr = function(arr, x, y) {
	mat2d.translate(this.state.m, arr[x], arr[y]);
}

CanvasRenderingContext2DWebGL.prototype.transformMatrix = function(matrix) {
	var m = this.state.m;
	mat2d.multiply(m, m, matrix);
}

CanvasRenderingContext2DWebGL.prototype.setTransformMatrix = function(matrix) {
	mat2d.copy(this.state.m, matrix);
};


Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "globalTint", {
	get: function () {
		return this.state.globalTint;
	},
	set: function(value) {
		this.state.globalTint = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "globalImageFilter", {
	get: function () {
		return this.state.globalImageFilter;
	},
	set: function(value) {
		this.state.globalImageFilter = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "globalAlpha", {
	get: function () {
		return this.state.globalAlpha;
	},
	set: function(value) {
		this.state.globalAlpha = value;
	},
	enumerable: false,
	configurable: true
});

CanvasRenderingContext2DWebGL.prototype.globalCompositeOperationApply = function(compositeOperation) {
	var gl = this.gl;
	this.commitDrawImage();

	//FIXME: not test yet
	if ("darker" == compositeOperation) {
		gl.blendEquation(gl.FUNC_SUBTRACT);
	} else {
		gl.blendEquation(gl.FUNC_ADD);
	}

	switch(compositeOperation) {
		case "source-over":
			//
			//gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			//
			gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
			break;
		case "destination-over":
			gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
			break;
		case "clear":
			gl.blendFunc(gl.ZERO, gl.ZERO);
			break;
		case "copy":
		case "source":
			gl.blendFunc(gl.ONE, gl.ZERO);
			break;
		case "destination":
			gl.blendFunc(gl.ZERO, gl.ONE);
			break;
		case "source-atop":
			gl.blendFunc(gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			break;
		case "destination-atop":
			gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA);
			break;
		case "source-in":
			gl.blendFunc(gl.DST_ALPHA, gl.ZERO);
			break;
		case "destination-in":
			gl.blendFunc(gl.ZERO, gl.SRC_ALPHA);
			break;
		case "source-out":
			gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ZERO);
			break;
		case "destination-out":
			gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
			break;
		case "lighter":
		case "darker":
			gl.blendFunc(gl.ONE, gl.ONE);
			break;
		case "xor":
			gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			break;
		case "normal":
		default:
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			break;
	}
}

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "globalCompositeOperation", {
	get: function () {
		return this.state.globalCompositeOperation;
	},
	set: function(value) {
		if(value !== this.state.globalCompositeOperation) {
			this.state.globalCompositeOperation = value;
			this.globalCompositeOperationApply(value);
		}
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "strokeStyle", {
	get: function () {
		return this.state.strokeStyle.str;
	},
	set: function(value) {
		var color = this.state.strokeStyle.str;
		if(value && color !== value) {
			this.state.strokeStyle =  CanvasRenderingContext2DWebGL.parseColor(value);
		}
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "fillStyle", {
	get: function () {
		return this.state.fillStyle.str;
	},
	set: function(value) {
		var color = this.state.fillStyle.str;
		if(value && color !== value) {
			this.state.fillStyle = CanvasRenderingContext2DWebGL.parseColor(value);
		}
	},
	enumerable: false,
	configurable: true
});

CanvasRenderingContext2DWebGL.prototype.clearRect = function(x, y, w, h) {
	this.beginPath();
	this.rect(x, y, w, h);
	this.fill();
	this.beginPath();
};

CanvasRenderingContext2DWebGL.prototype.fillRect = function(x, y, w, h) {
	this.beginPath();
	this.rect(x, y, w, h);
	this.fill();
	this.beginPath();
};

CanvasRenderingContext2DWebGL.prototype.strokeRect = function(x, y, w, h) {
	this.beginPath();
	this.rect(x, y, w, h);
	this.stroke();
	this.beginPath();
};

CanvasRenderingContext2DWebGL.prototype.stroke = function() {
	if(this.lineWidth && this.strokeStyle) {
		this.gl.lineWidth(this.lineWidth);
		this.commitDrawImage();
		
		this.strokeCount++;
		var program = this.drawPrimitivesProgram;
		this.drawPrimitives(program, this.drawPrimitiveQueue, program.stroke, this.state.strokeStyle);
	}
}

CanvasRenderingContext2DWebGL.prototype.fill = function() {
	if(this.fillStyle) {
		this.commitDrawImage();

		this.fillCount++;
		var program = this.drawPrimitivesProgram;
		this.drawPrimitives(program, this.drawPrimitiveQueue, program.fill, this.state.fillStyle);
	}
}

CanvasRenderingContext2DWebGL.prototype.drawStencil = function(drawPrimitiveQueue, level, clear) {
	var gl = this.gl;
	var program = this.drawPrimitivesProgram;
	var passOp = clear ? gl.DECR : gl.INCR;
	
	gl.stencilMask(0xff);
	gl.stencilFunc(gl.ALWAYS, 1, 0xff);
	gl.stencilOp(gl.KEEP, gl.KEEP, passOp);
	gl.colorMask(false, false, false, false);

	this.drawPrimitives(program, drawPrimitiveQueue, program.clip, this.stencilColor);

	gl.stencilMask(0);
	gl.stencilFunc(gl.EQUAL, level, 0xff);
	gl.colorMask(true, true, true, true);
//  for test	
//	this.drawPrimitives(program, drawPrimitiveQueue, program.stroke, this.strokeStyle);
}

CanvasRenderingContext2DWebGL.prototype.clearClip = function(drawPrimitiveQueue) {
	var gl = this.gl;
	if(!drawPrimitiveQueue) {
		gl.disable(gl.STENCIL_TEST);	

		return;
	}

	this.commitDrawImage();
	this.drawStencil(drawPrimitiveQueue, --this.clipLevel, true);
}

CanvasRenderingContext2DWebGL.prototype.clip = function() {
	this.savePrimitiveQueueForClip();

	var gl = this.gl;
	if(this.clipLevel === 0) {
		gl.enable(gl.STENCIL_TEST);	
	}

	this.commitDrawImage();
	var drawPrimitiveQueue = this.state.clipPaths;
	if(drawPrimitiveQueue) {
		this.drawStencil(drawPrimitiveQueue, ++this.clipLevel, false);
	}
}


CanvasRenderingContext2DWebGL.prototype.drawPrimitives = function(program, drawPrimitiveQueue, drawFunc, color) {
	var dataBuffer = drawPrimitiveQueue.dataBuffer.getReadBuffer();
	var paths = drawPrimitiveQueue.paths;
	var state = this.state;

	var end = 0;
	var start = 0;
	var arr = null;
	var n = paths.size;
	var tint = state.globalTint * 256 >> 0;
	var alpha = state.globalAlpha * 256 >> 0;

	program.prepareDraw(dataBuffer, color, alpha, tint);
	for(var i = 0; i < n; i++) {
		var start = paths[i];
		if(i < (n-1)) {
			end = paths[i+1]
		}else{
			end = dataBuffer.size;
		}

		if(end > start) {
			this.drawCalls++;
			drawFunc.call(program, start, end);
		}
	}
};

CanvasRenderingContext2DWebGL.prototype.doClipRect = function(rect) {
	var gl = this.gl;
	var canvas = this.canvas;
	var canvasWidth = canvas.width;
	var canvasHeight = canvas.height;

	this.commitDrawImage();
	gl.enable(gl.SCISSOR_TEST);

	if(!rect || !rect.w || !rect.h) {
		gl.scissor(0, 0, canvasWidth, canvasHeight);
	}else{

		var virtualWidth = gl.w;
		var virtualHeight = gl.h;
		var scaleX = canvasWidth/virtualWidth;
		var scaleY = canvasHeight/virtualHeight;

		var yy = (rect.y-1) * scaleY;
		var x = rect.x * scaleX;
		var w = rect.w * scaleX;
		var h = rect.h * scaleY;
		var y = canvasHeight-(yy+h);
		gl.scissor(x, y, w, h);
	}
}

CanvasRenderingContext2DWebGL.prototype.clipRect = function(x, y, w, h) {
	var state = this.state;
	var m = state.m;
	var p = mat2d.transformPoint(m, x, y);
	var oldClipRect = state.clipRect;
	
	state.clipRect = {x:p.x, y:p.y, w:w, h:h};

	if(oldClipRect) {
		state.clipRect = Rect.intersection(state.clipRect, oldClipRect);
	}

	if(state.clipRect) {
		this.doClipRect(state.clipRect);
	}
};

CanvasRenderingContext2DWebGL.prototype.drawGlyph = function(image, program, sx, sy, sw, sh, dx, dy, dw, dh) {
	this.prepareDrawImage(image, program);
	this.drawImageEx(image, sx, sy, sw, sh, dx*10, dy*10, (dx+dw)*10, dy*10, (dx+dw)*10, (dy+dh)*10, dx*10, (dy+dh)*10); 
}

CanvasRenderingContext2DWebGL.prototype.doFillText = function(text, x, y, maxWidth) {
	var ox = x;
	var oy = y;
	var gl = this.gl;
	var r = this.tempRect;
	var font = this.font || "16px sans";
	var gc = this.autoPacker;
	var fillStyle = this.state.fillStyle;
	var color = fillStyle.str;

	if(!this.autoPacker.measureText(font, text, color, r)) {
		console.log("invalid font size");	
		return;
	}

	var image = this.autoPacker.getImage();

	switch(this.textAlign) {
		case "right": {
			ox = x - r.w;
			break;
		}
		case "center": {
			ox = x - (r.w >> 1);
			break;
		}
		default: break;
	}

	switch(this.textBaseline) {
		case "bottom": {
			oy = y - r.h;
			break;
		}
		case "middle": {
			oy = y - (r.h >> 1);
			break;
		}
		default:break;
	}
	var n = text.length;
	var program = WebGLProgramDrawImage.get("normal");
	for(var i = 0; i < n; i++) {
		var c = text[i];
		var rc = gc.getGlyph(font, c, color);
		if(rc) {
			this.drawGlyph(image, program, rc.x, rc.y, rc.charW, rc.h, ox, oy, rc.charW, rc.h);
			ox += rc.w;
		}
	}
	return;
}

CanvasRenderingContext2DWebGL.prototype.fillText = function(text, x, y, maxWidth) {
	var m = this.state.m;
	var p = mat2d.transformPointInt(m, x, y);
	this.doFillText(text, p.x/10, p.y/10, maxWidth);
};

CanvasRenderingContext2DWebGL.prototype.strokeText = function() {
	console.log("strokeText NOT IMPL");
};


CanvasRenderingContext2DWebGL.prototype.drawImageTriArr = function(image, arr) {
	var offset = 0;
	var n = (arr.length/12) >> 0;

	for(var i = 0; i < n; i++) {
		this.drawImageTri(image, arr[offset++], arr[offset++], arr[offset++], arr[offset++],
			arr[offset++], arr[offset++], arr[offset++], arr[offset++],
			arr[offset++], arr[offset++], arr[offset++], arr[offset++]);
	}
}

CanvasRenderingContext2DWebGL.prototype.drawImageTri = function(image, u0, v0, x0, y0, u1, v1, x1, y1, u2, v2, x2, y2) {
	var m = this.state.m;
	var p0 = mat2d.transformPointInt(m, x0, y0, 0);
	var p1 = mat2d.transformPointInt(m, x1, y1, 1);
	var p2 = mat2d.transformPointInt(m, x2, y2, 2);
	
	var isClockWise = (p1.x-p0.x)*(p2.y-p1.y)-(p1.y-p0.y)*(p2.x-p1.x) >= 0;
	if(isClockWise) {
		this.doDrawImageTri(image, u0, v0, p0.x, p0.y, u1, v1, p1.x, p1.y, u2, v2, p2.x, p2.y);
	}else{
		this.doDrawImageTri(image, u0, v0, p0.x, p0.y, u2, v2, p2.x, p2.y, u1, v1, p1.x, p1.y);
	}
}

CanvasRenderingContext2DWebGL.prototype.doDrawImageTri = function(image, u0, v0, x0, y0, u1, v1, x1, y1, u2, v2, x2, y2) {
	this.drawImageCount++;

	if(image.complete) {
		var ox = image.ox;
		var oy = image.oy;
		var state = this.state;
		var drawImageQueue = this.drawImageQueue;
		var program = WebGLProgramDrawImage.get(state.globalImageFilter);

		this.prepareDrawImage(image, program);
		drawImageQueue.dataBuffer = program.addTriangle(drawImageQueue.dataBuffer, 
			state.globalAlpha * 256 >>0, state.globalTint * 256 >> 0,  
			u0+ox, v0+oy, x0, y0, u1+ox, v1+oy, x1, y1, u2+ox, v2+oy, x2, y2);
	}
};

CanvasRenderingContext2DWebGL.prototype.drawImage = function(image, _sx, _sy, _sw, _sh, _dx, _dy, _dw, _dh) {
	var sx, sy, sw, sh, dx, dy, dw, dh;

	if(!image.width) {
		return;
	}

	if(_dh) {
		sx = _sx;
		sy = _sy;
		sw = _sw;
		sh = _sh;
		dx = _dx;
		dy = _dy;
		dw = _dw;
		dh = _dh;
	}else if(_sw) {
		sx = 0;
		sy = 0;
		sw = image.width;
		sh = image.height;
		dx = _sx;
		dy = _sy;
		dw = _sw;
		dh = _sh;
	}else {
		sx = 0;
		sy = 0;
		sw = image.width;
		sh = image.height;
		dx = _sx;
		dy = _sy;
		dw = sw;
		dh = sh;
	}
	
	var state = this.state;
	var program = WebGLProgramDrawImage.get(state.globalImageFilter);
	this.prepareDrawImage(image, program);

	var m = state.m;
   	var a = m[0];
   	var b = m[1];
   	var c = m[2];
   	var d = m[3];
   	var e = m[4];
   	var f = m[5];
	var top = dy;
	var left = dx;
	var right = dx+dw;
	var bottom = dy+dh;

    var x1 = ((a * left + c * top + e) * 10) >> 0;
	var y1 = ((b * left + d * top + f) * 10) >> 0;

    var x2 = ((a * right + c * top + e) * 10) >> 0;
	var y2 = ((b * right + d * top + f) * 10) >> 0;
    
    var x3 = ((a * right + c * bottom + e) * 10) >> 0;
	var y3 = ((b * right + d * bottom + f) * 10) >> 0;
    
    var x4 = ((a * left + c * bottom + e) * 10) >> 0;
	var y4 = ((b * left + d * bottom + f) * 10) >> 0;

	var cw10 = this.canvasWidth10;
	var ch10 = this.canvasHeight10;
	if((x1 < 0 && x2 < 0 && x3 < 0 && x4 < 0) 
		|| (y1 < 0 && y2 < 0 && y3 < 0 && y4 < 0)
		|| (x1 > cw10 && x2 > cw10 && x3 > cw10 && x4 > cw10) 
		|| (y1 > ch10 && y2 > ch10 && y3 > ch10 && y4 > ch10)) {
		this.drawImageCount++;
		return;
	}

	this.drawImageEx(image, sx+image.ox, sy+image.oy, sw, sh, x1, y1, x2, y2, x3, y3, x4, y4);
}

CanvasRenderingContext2DWebGL.prototype.prepareDrawImage = function(image, program) {
	var drawImageQueue = this.drawImageQueue;
	if(drawImageQueue.image) {
		if(drawImageQueue.image.texture !== image.texture || drawImageQueue.program !== program
				|| drawImageQueue.globalCompositeOperation !== this.state.globalCompositeOperation) {

			this.commitDrawImage();
			drawImageQueue.image = image; 
			drawImageQueue.program = program;
			if(!image.cannotPack && !image.packed) {
				this.autoPacker.packImage(image);
				this.loadTextureWithImage(image);
			}
		}
	}else{
		if(!image.cannotPack && !image.packed) {
			this.autoPacker.packImage(image);
			this.loadTextureWithImage(image);
		}

		drawImageQueue.image = image; 
		drawImageQueue.program = program;
	}
}

CanvasRenderingContext2DWebGL.prototype.drawImageEx = function(image, sx, sy, sw, sh, x1, y1, x2, y2, x3, y3, x4, y4) {
	this.drawImageCount++;
	var dataBuffer = this.drawImageQueue.dataBuffer;
	var out = dataBuffer.getWriteBuffer(100);
	
	var offset = dataBuffer.size;
	var tint = this.state.globalTint * 256 >> 0;
	var alpha = this.state.globalAlpha * 256 >> 0;

	out[offset++] = sx;
	out[offset++] = sy;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x1;
	out[offset++] = y1;

	out[offset++] = sx+sw;
	out[offset++] = sy;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x2;
	out[offset++] = y2;
	
	out[offset++] = sx+sw;
	out[offset++] = sy+sh;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x3;
	out[offset++] = y3;
	
	out[offset++] = sx+sw;
	out[offset++] = sy+sh;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x3;
	out[offset++] = y3;
	
	out[offset++] = sx;
	out[offset++] = sy+sh;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x4;
	out[offset++] = y4;
	
	out[offset++] = sx;
	out[offset++] = sy;
	out[offset++] = alpha;
	out[offset++] = tint;
	out[offset++] = x1;
	out[offset++] = y1;
	dataBuffer.size = offset;

	return;
}

CanvasRenderingContext2DWebGL.prototype.commitDrawImage = function() {
	var drawImageQueue = this.drawImageQueue;
	var dataBuffer = drawImageQueue.dataBuffer.getReadBuffer();
	
	if(dataBuffer.size < 1 || !drawImageQueue.image) {
		return;
	}
	
	this.drawImageBatch(drawImageQueue.image, drawImageQueue.program, dataBuffer);

	drawImageQueue.dataBuffer.reset();
	drawImageQueue.image = null;
	drawImageQueue.program = null;
	drawImageQueue.globalCompositeOperation = this.globalCompositeOperation;

	return;
}


Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "lineWidth", {
	get: function () {
		return this.state.lineWidth;
	},
	set: function(value) {
		this.state.lineWidth = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "lineCap", {
	get: function () {
		return this.state.lineCap;
	},
	set: function(value) {
		this.state.lineCap = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "lineJoin", {
	get: function () {
		return this.state.lineJoin;
	},
	set: function(value) {
		this.state.lineJoin = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "miterLimit", {
	get: function () {
		return this.state.miterLimit;
	},
	set: function(value) {
		this.state.miterLimit = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "font", {
	get: function () {
		return this.state.font;
	},
	set: function(value) {
		this.state.font = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "textAlign", {
	get: function () {
		return this.state.textAlign;
	},
	set: function(value) {
		this.state.textAlign = value;
	},
	enumerable: false,
	configurable: true
});

Object.defineProperty(CanvasRenderingContext2DWebGL.prototype, "textBaseline", {
	get: function () {
		return this.state.textBaseline;
	},
	set: function(value) {
		this.state.textBaseline = value;
	},
	enumerable: false,
	configurable: true
});

CanvasRenderingContext2DWebGL.prototype.beginPath = function() {
	this.drawPrimitiveQueue.dataBuffer.reset();
	this.drawPrimitiveQueue.paths.reset();
}

CanvasRenderingContext2DWebGL.prototype.closePath = function() {
	this.addPoint(this.firstX, this.firstY, false);
};

CanvasRenderingContext2DWebGL.prototype.savePrimitiveQueueForClip = function() {
	var drawPrimitiveQueue = this.drawPrimitiveQueue;
	if(drawPrimitiveQueue.dataBuffer.size < 6) {
		return;
	}
	
	this.state.clipPaths = {
		id : this.currentID++,
		paths : drawPrimitiveQueue.paths.dup(),
		dataBuffer : drawPrimitiveQueue.dataBuffer.dup()
	}
}

CanvasRenderingContext2DWebGL.prototype.hasPoint = function() {
	return this.drawPrimitiveQueue.dataBuffer.size > 0;
}

CanvasRenderingContext2DWebGL.prototype.addPoint = function(x, y, newPath) {
	var drawPrimitiveQueue = this.drawPrimitiveQueue;
	var dataBuffer = drawPrimitiveQueue.dataBuffer;
	
	if(newPath) {
		this.firstX = x;
		this.firstY = y;
		drawPrimitiveQueue.paths.push1(dataBuffer.size);
	}
	
	this.lastX = x;
	this.lastY = y;
	drawPrimitiveQueue.dataBuffer = dataBuffer.pushX(x, y);

	return;
}

CanvasRenderingContext2DWebGL.prototype.moveTo = function(x, y) {
	var m = this.state.m;
	var p = mat2d.transformPointInt(m, x, y);

	this.addPoint(p.x, p.y, true);
};

CanvasRenderingContext2DWebGL.prototype.lineTo = function(x, y) {
	var m = this.state.m;
	var p = mat2d.transformPointInt(m, x, y);

	this.addPoint(p.x, p.y, false);
};

CanvasRenderingContext2DWebGL.prototype.getWidth = function() {
	return this.canvas.w || this.canvas.width;
}

CanvasRenderingContext2DWebGL.prototype.getHeight = function() {
	return this.canvas.h || this.canvas.height;
}

CanvasRenderingContext2DWebGL.prototype.bigRect = function(p1, p2, p3, p4) {
	var cw10 = this.canvasWidth10;
	var ch10 = this.canvasHeight10;
	var ret = Math.polygonclip([[p1.x, p1.y], [p2.x, p2.y], [p3.x, p3.y], [p4.x, p4.y]], [-10, -10, cw10+20, ch10+20]);

	if(ret) {
		var n = ret.length;
		for(var i = 0; i < n; i++) {
			var p = ret[i];
			if(!i) {
				this.addPoint(p[0], p[1], true);
			}else {
				this.addPoint(p[0], p[1], false);
			}
		}
	}
}

CanvasRenderingContext2DWebGL.prototype.rect = function(x, y, w, h) {
	var m = this.state.m;
	var p1 = mat2d.transformPointInt(m, x, y, 0);
	var p2 = mat2d.transformPointInt(m, x+w, y, 1);
	var p3 = mat2d.transformPointInt(m, x+w, y+h, 2);
	var p4 = mat2d.transformPointInt(m, x, y+h, 3);
	var cw = this.canvasWidth;
	var ch = this.canvasHeight;
	var cw10 = this.canvasWidth10;
	var ch10 = this.canvasHeight10;

	if((p1.x < 0 && p2.x < 0 && p3.x < 0 && p4.x < 0) 
		|| (p1.y < 0 && p2.y < 0 && p3.y < 0 && p4.y < 0)
		|| (p1.x > cw10 && p2.x > cw10 && p3.x > cw10 && p4.x > cw10) 
		|| (p1.y > ch10 && p2.y > ch10 && p3.y > ch10 && p4.y > ch10)) {
		return;
	}

	if(w > (cw+1) || h > (ch+1)) {
		//clip big rect
		this.bigRect(p1, p2, p3, p4);
	}else{
		this.addPoint(p1.x, p1.y, true);
		this.addPoint(p2.x, p2.y, false);
		this.addPoint(p3.x, p3.y, false);
		this.addPoint(p4.x, p4.y, false);
		this.addPoint(p1.x, p1.y, false);
	}
};


//
// code adapted from nanovg begin {
// https://github.com/memononen/nanovg
//
CanvasRenderingContext2DWebGL.prototype.tesselateBezier = function(x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
	var x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234;
	var dx,dy,d2,d3;

	if (level > 10) return;

	x12 = (x1+x2)*0.5;
	y12 = (y1+y2)*0.5;
	x23 = (x2+x3)*0.5;
	y23 = (y2+y3)*0.5;
	x34 = (x3+x4)*0.5;
	y34 = (y3+y4)*0.5;
	x123 = (x12+x23)*0.5;
	y123 = (y12+y23)*0.5;

	dx = x4 - x1;
	dy = y4 - y1;
	d2 = Math.abs(((x2 - x4) * dy - (y2 - y4) * dx));
	d3 = Math.abs(((x3 - x4) * dy - (y3 - y4) * dx));

	if ((d2 + d3)*(d2 + d3) < this.tessTol * (dx*dx + dy*dy)) {
		this.addPoint(x4, y4, type);
		return;
	}

	x234 = (x23+x34)*0.5;
	y234 = (y23+y34)*0.5;
	x1234 = (x123+x234)*0.5;
	y1234 = (y123+y234)*0.5;

	this.tesselateBezier(x1,y1, x12,y12, x123,y123, x1234,y1234, level+1, 0); 
	this.tesselateBezier(x1234,y1234, x234,y234, x34,y34, x4,y4, level+1, type); 
}

CanvasRenderingContext2DWebGL.prototype.doArcTo = function(x1, y1, x2, y2, radius) {
	var rn = {x:0, y:0};
	var x0 = this.lastX;
	var y0 = this.lastY;
	var dx0,dy0, dx1,dy1, a, d, cx,cy, a0,a1;
	var ccw = false;

	if (!this.hasPoint()) {
		return;
	}

	if (Math.ptEquals(x0,y0, x1,y1, this.distTol) ||
			Math.ptEquals(x1,y1, x2,y2, this.distTol) ||
			Math.distPtSeg(x1,y1, x0,y0, x2,y2) < this.distTol*this.distTol ||
			radius < this.distTol) {
		this.addPoint(x1, y1, false);
		return;
	}

	dx0 = x0-x1;
	dy0 = y0-y1;
	dx1 = x2-x1;
	dy1 = y2-y1;
	Math.normalize(dx0, dy0, rn);
	dx0 = rn.x;
	dy0 = rn.y;

	Math.normalize(dx1, dy1, rn);
	dx1 = rn.x;
	dy1 = rn.y;

	a = Math.acos(dx0*dx1 + dy0*dy1);
	d = radius / Math.tan(a/2.0);

	if (d > 10000.0) {
		this.addPoint(x1, y1, false);
		return;
	}

	if (Math.cross(dx0,dy0, dx1,dy1) > 0.0) {
		cx = x1 + dx0*d + dy0*radius;
		cy = y1 + dy0*d + -dx0*radius;
		a0 = Math.atan2(dx0, -dy0);
		a1 = Math.atan2(-dx1, dy1);
		ccw = false;
	} else {
		cx = x1 + dx0*d + -dy0*radius;
		cy = y1 + dy0*d + dx0*radius;
		a0 = Math.atan2(-dx0, dy0);
		a1 = Math.atan2(dx1, -dy1);
		ccw = true;
	}

	this.doArc(cx, cy, radius, a0, a1, ccw);
}

CanvasRenderingContext2DWebGL.prototype.doArc = function(cx, cy, r, a0, a1, ccw)
{
	var a = 0, da = 0, hda = 0, kappa = 0;
	var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
	var px = 0, py = 0, ptanx = 0, ptany = 0;
	var vals = new Array(3 + 5*7 + 100);
	var i, ndivs, nvals;
	var newPath = !this.hasPoint();

	da = a1 - a0;
	if (!ccw) {
		if (Math.abs(da) >= Math.PI*2) {
			da = Math.PI*2;
		} else {
			while (da < 0.0) da += Math.PI*2;
		}
	} else {
		if (Math.abs(da) >= Math.PI*2) {
			da = -Math.PI*2;
		} else {
			while (da > 0.0) da -= Math.PI*2;
		}
	}

	// Split arc into max 90 degree segments.
	ndivs = Math.floor(Math.max(1, Math.min((Math.abs(da) / (Math.PI*0.5) + 0.5), 5)));
	hda = (da / ndivs) / 2.0;
	kappa = Math.abs(4.0 / 3.0 * (1.0 - Math.cos(hda)) / Math.sin(hda));

	if (ccw) {
		kappa = -kappa;
	}

	nvals = 0;
	for (i = 0; i <= ndivs; i++) {
		a = a0 + da * (i/ndivs);
		dx = Math.cos(a);
		dy = Math.sin(a);
		x = cx + dx*r;
		y = cy + dy*r;
		tanx = -dy*r*kappa;
		tany = dx*r*kappa;

		if (i == 0) {
			this.addPoint(x, y, newPath);
		} else {
			this.bezierTo(px+ptanx, py+ptany, x-tanx, y-tany, x, y);
		}
		px = x;
		py = y;
		ptanx = tanx;
		ptany = tany;
	}

	return;
}

CanvasRenderingContext2DWebGL.prototype.quadTo = function(cx, cy, x, y) {
	var x0 = this.lastX;
	var y0 = this.lastY;
	var c1x = x0 + 2.0/3.0*(cx - x0);
	var c1y = y0 + 2.0/3.0*(cy - y0);
	var c2x = x + 2.0/3.0*(cx - x);
	var c2y = y + 2.0/3.0*(cy - y);

	this.bezierTo(c1x, c1y, c2x, c2y, x, y);
}

CanvasRenderingContext2DWebGL.prototype.bezierTo = function(c1x, c1y, c2x, c2y, x, y) {
	this.tesselateBezier(this.lastX, this.lastY, c1x, c1y, c2x, c2y, x, y, 0, 0);
}

//
// } code adapted from nanovg end
//

CanvasRenderingContext2DWebGL.prototype.quadraticCurveTo = function(cpx, cpy, x, y) {
	var m = this.state.m;
	var cp = mat2d.transformPointInt(m, cpx, cpy, 0);
	var p = mat2d.transformPointInt(m, x, y, 1);

	this.quadTo(cp.x, cp.y, p.x, p.y);
};

CanvasRenderingContext2DWebGL.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
	var m = this.state.m;
	var cp1 = mat2d.transformPointInt(m, cp1x, cp1y, 0);
	var cp2 = mat2d.transformPointInt(m, cp2x, cp2y, 1);
	var p = mat2d.transformPointInt(m, x, y, 2);

	this.bezierTo(cp1.x, cp1.y, cp2.x, cp2.y, p.x, p.y);
};

CanvasRenderingContext2DWebGL.prototype.arcTo = function(x1, y1, x2, y2, radius) {
	var m = this.state.m;
	var r = radius*10 >> 0;
	var p1 = mat2d.transformPointInt(m, x1, y1, 0);
	var p2 = mat2d.transformPointInt(m, x2, y2, 1);

	this.doArcTo(p1.x, p1.y, p2.x, p2.y, r);
};

CanvasRenderingContext2DWebGL.prototype.arc = function(x, y, radius, startAngle, endAngle, ccw) {
	var r = radius*10 >> 0;
	var m = this.state.m;
	var p = mat2d.transformPointInt(m, x, y);
	var cw10 = this.canvasWidth10;
	var ch10 = this.canvasHeight10;

	if((p.x - r) > cw10 || (p.x + r) < 0 || (p.y - r) > ch10 || (p.y + r) < 0) {
		return;
	}

	this.doArc(p.x, p.y, r, startAngle, endAngle, ccw);
};

CanvasRenderingContext2DWebGL.getWebGLContext = function(canvas, webglOptions) {
	var gl = null;
	var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var options = webglOptions || CanvasRenderingContext2DWebGL.webglOptions;
	for (var i = 0; i < names.length; i++) {
		try {
      		gl = canvas.getContext(names[i], options);
		} catch(e) {}
    
		if (gl) {
			break;
		}
	}

	return gl;
}

CanvasRenderingContext2DWebGL.prototype.initGL = function(canvas) {
	var gl = CanvasRenderingContext2DWebGL.getWebGLContext(canvas, this.webglOptions);

	gl.w = canvas.width;
	gl.h = canvas.height;

//	gl.cullFace(gl.BACK);
//	gl.frontFace(gl.CW);
//	gl.enable(gl.CULL_FACE);
	gl.enable(gl.BLEND);
	gl.enable(gl.STENCIL_TEST);
	gl.disable(gl.DEPTH_TEST);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	this.gl = gl;
	this.canvas = canvas;
	this.buffer = gl.createBuffer();
	
	WebGLProgramDrawImage.init(gl, this.buffer);
	this.drawPrimitivesProgram = new WebGLProgramDrawPrimitives(gl, this.buffer);

	return gl;
}

CanvasRenderingContext2DWebGL.prototype.isPOT = function(n) {
	return n > 0 && (n & (n - 1)) === 0;
}

CanvasRenderingContext2DWebGL.prototype.loadTextureWithImage = function(image) {
	if(image.texture || !image.width) {
		return image;
	}

	var gl = this.gl;
	var texture = gl.createTexture();
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	
	image.texture = texture;
	image.ox = 0;
	image.oy = 0;
	texture.w = image.width;
	texture.h = image.height;
	texture.src = image.src;

	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

	//NPOT
	if(this.isPOT(image.width) && this.isPOT(image.height)) {
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	}
	else {
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	}

	gl.bindTexture(gl.TEXTURE_2D, null);

	return image;
}

CanvasRenderingContext2DWebGL.prototype.drawImageBatch = function(image, program, bufferData) {
	this.drawCalls++;
	this.drawImageCalls++;

	program.draw(image, bufferData);
}

CanvasRenderingContext2DWebGL.prototype.beginFrame = function() {
	var gl = this.gl;
	var w = this.getWidth();
	var h = this.getHeight();
	var canvas = this.canvas;

	this.drawCalls = 0;
	this.drawImageCalls = 0;
	this.drawImageCount = 0;
	this.fillCount = 0;
	this.strokeCount = 0;
	this.clipLevel = 0;
	this.canvasWidth = w;
	this.canvasHeight = h;
	this.canvasWidth10 = w * 10;
	this.canvasHeight10 = h * 10;

	if(gl.w !== w || gl.h !== h) {
		gl.w = w;
		gl.h = h;
		gl.clearColor(1.0, 1.0, 1.0, 1.0);
		gl.viewport(0, 0, canvas.width, canvas.height);
	}

	if(this.showFPS) {
		this.renderTimes++;
		this.startTime = Date.now();
		this.thisSeconds = (this.startTime/1000) >> 0;	

		if(this.thisSeconds !== this.lastSeconds) {
			this.fps = this.renderTimes;
			this.lastSeconds = this.thisSeconds;
			this.renderTimes = 0;
		}
	}

	if(this.webglOptions.preserveDrawingBuffer) {
		gl.clear(gl.STENCIL_BUFFER_BIT);
	}else {
		gl.clear(gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
	}

	this.lastX = 0;
	this.lastY = 0;
	this.firstX = 0;
	this.firstY = 0;

	this.lineWidth = 1;
	this.globalAlpha = 1;
	this.globalTint = 1;
	this.textAlign = "left";
	mat2d.identity(this.state.m);
	this.textBaseline = "middle";
	this.globalImageFilter = "normal";
	this.state.fillStyle = CanvasRenderingContext2DWebGL.fillStyle;
	this.state.strokeStyle = CanvasRenderingContext2DWebGL.strokeStyle;
	this.stencilColor = CanvasRenderingContext2DWebGL.stencilColor;
	this.globalCompositeOperation = "source-over";
	this.beginPath();

	if(this.autoPacker.isOverflow()) {
		this.autoPacker.reset();
	}
}

CanvasRenderingContext2DWebGL.prototype.drawStat = function(stat) {
	this.save();
    this.fillStyle = this.statusBgColor;
	this.fillRect(0, 0, 280, 35);

	var str = stat + " images(" + this.drawImageCount + "/" + this.drawImageCalls + ") calls:" + this.drawCalls;

	this.font = this.statusFont;
	this.fillStyle = this.statusFontColor;
	this.textBaseline = "top";
	this.textAlign = "left";
	this.fillText(str, 5, 5);
	this.restore();

	return;
}

CanvasRenderingContext2DWebGL.prototype.onEndFrame = function() {
	if(this.showFPS) {
		var stat = this.fps;
		this.drawStat(stat);
	}
}

CanvasRenderingContext2DWebGL.prototype.endFrame = function() {
	var n = this.stack.length;

	if(n > 0) {
		for(var i = 0; i < n; i++) {
			this.restore();
		}
		console.log("restore times < save times.");
	}

	mat2d.identity(this.state.m);
	this.globalAlpha = 1;
	this.globalTint = 1;
	this.globalCompositeOperationApply("source-over");

	this.onEndFrame();
	this.commitDrawImage();
}

CanvasRenderingContext2DWebGL.colors = {};
CanvasRenderingContext2DWebGL.parseColor = function(str) {
	var cacheColor = CanvasRenderingContext2DWebGL.colors[str];
	if(cacheColor) {
		return cacheColor;
	}

	var s = str || "white";
	var c = cs.get(s.toLowerCase());

	if(!c) {
		c = cs.get("white");
	}

	var value = c.value;
	var color = {
		r : value[0]/255,
		g : value[1]/255,
		b : value[2]/255,
		a : value[3],
		str:str
	};

	CanvasRenderingContext2DWebGL.colors[str] = color;

	return color;
}

CanvasRenderingContext2DWebGL.State = function() {
	this.font = "16px sans";
	this.lineWidth = 1;
	this.globalAlpha = 1;
	this.globalTint = 1;
	this.m = mat2d.create();
	this.clipRect = null;
	this.clipPaths = null;
	this.textAlign = "left";
	this.textBaseline = "middle";
	this.globalImageFilter = "normal";
	this.globalCompositeOperation = "source-over";
	this.fillStyle = CanvasRenderingContext2DWebGL.fillStyle;
	this.strokeStyle = CanvasRenderingContext2DWebGL.strokeStyle;
}

CanvasRenderingContext2DWebGL.createState = function() {
	if(CanvasRenderingContext2DWebGL.stateCache.length) {
		return CanvasRenderingContext2DWebGL.stateCache.pop();
	}else{
		return new CanvasRenderingContext2DWebGL.State();
	}
}

CanvasRenderingContext2DWebGL.stateCache = [];
CanvasRenderingContext2DWebGL.destroyState = function(s) {
	if(s.clipRect) {
		s.clipRect = null;
	}
	if(s.clipPaths) {
		s.clipPaths = null;
	}
	CanvasRenderingContext2DWebGL.stateCache.push(s);
}

CanvasRenderingContext2DWebGL.State.prototype.clone = function() {
	var s = CanvasRenderingContext2DWebGL.createState();

	if(this.clipRect) {
		s.clipRect = this.clipRect;
	}

	if(this.clipPaths) {
		s.clipPaths = this.clipPaths;
	}

	mat2d.copy(s.m, this.m);

	s.font = this.font;
	s.lineWidth = this.lineWidth;
	s.textAlign = this.textAlign;
	s.fillStyle = this.fillStyle;
	s.strokeStyle = this.strokeStyle;
	s.textBaseline = this.textBaseline;
	s.globalTint = this.globalTint;
	s.globalAlpha = this.globalAlpha;
	s.globalImageFilter = this.globalImageFilter;
	s.globalCompositeOperation = this.globalCompositeOperation;

	return s;
}

CanvasRenderingContext2DWebGL.prototype.init = function(canvas) {
	this.stack = [];
	this.state = CanvasRenderingContext2DWebGL.createState();
	
	this.initGL(canvas);
	this.lastUpdateTime = Date.now();

	var drawImageProgram = WebGLProgramDrawImage.get();
	this.drawImageQueue = {};
	this.drawImageQueue.globalAlpha = 256;
	this.drawImageQueue.globalCompositeOperation = 0;
	this.drawImageQueue.dataBuffer = drawImageProgram.createDataBuffer(20*1024);
	
	this.drawPrimitiveQueue = {};
	this.drawPrimitiveQueue.paths = Int16Array.create(1024);
	this.drawPrimitiveQueue.dataBuffer = this.drawPrimitivesProgram.createDataBuffer(20*1024);
	this.autoPacker = new AutoPacker();
	this.autoPacker.init(this.gl);
	this.statusFont = "20px sans";
	this.statusFontColor = "Green";
	this.statusBgColor = "rgba(0,0,0,1)";

	return this;
}

CanvasRenderingContext2DWebGL.prototype.ensureCtx2d = function() {
	if(this.ctx2d) {
		return;
	}
	this.canvas2d = document.createElement("canvas");
	this.ctx2d = this.canvas2d.getContext("2d");
}

CanvasRenderingContext2DWebGL.prototype.measureText = function(text) {
	this.ensureCtx2d();
	this.ctx2d.font = this.font;
	return this.ctx2d.measureText(text);
}

CanvasRenderingContext2DWebGL.prototype.setShowFPS = function(showFPS) {
	this.showFPS = showFPS;
}

CanvasRenderingContext2DWebGL.create = function(canvas, options) {
	var ctx = new CanvasRenderingContext2DWebGL(options);

	CanvasRenderingContext2DWebGL.fillStyle = CanvasRenderingContext2DWebGL.parseColor("white");
	CanvasRenderingContext2DWebGL.strokeStyle = CanvasRenderingContext2DWebGL.parseColor("black");
	CanvasRenderingContext2DWebGL.stencilColor = CanvasRenderingContext2DWebGL.parseColor("white");

	return ctx.init(canvas);
}

HTMLCanvasElement.prototype.getContextOrg = HTMLCanvasElement.prototype.getContext;
HTMLCanvasElement.prototype.getContext = function(type, options) {
	if(this.webglCtx) {
		return this.webglCtx;
	}

	if(type === "2d-webgl") {
		if(!this.webglCtx) {
			this.webglCtx = CanvasRenderingContext2DWebGL.create(this, options);
		}
		return this.webglCtx;
	}else{
		return HTMLCanvasElement.prototype.getContextOrg.call(this, type, options);
	}
}
var gCantkBuildDate = "2016年 06月 30日 星期四 18:16:48 CST";console.log("cantk build date: " + gCantkBuildDate);
if(!window.CanTK) {
	window.CanTK = {};
}

window.CanTK.config = {
	logoImageSrc : null,
	progressBarBgSrc : null,
	progressBarFgSrc : null
};
/*
 * File: shape.js
 * Brief: Base class of all shapes.
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

function Shape() {
	return;
}

Shape.MODE_EDITING = 0;
Shape.MODE_RUNNING = 1;
Shape.MODE_PREVIEW = 2;

Shape.HIT_TEST_NONE = 0;
Shape.HIT_TEST_TL = 1;
Shape.HIT_TEST_TM = 2;
Shape.HIT_TEST_TR = 3;
Shape.HIT_TEST_ML = 4;
Shape.HIT_TEST_MR = 5;
Shape.HIT_TEST_BL = 6;
Shape.HIT_TEST_BM = 7;
Shape.HIT_TEST_BR = 8;
Shape.HIT_TEST_HANDLE = 9;
Shape.HIT_TEST_WORKAREA = 10;
Shape.HIT_TEST_ROTATION = 11;
Shape.HIT_TEST_MOVE = 12;
Shape.HIT_TEST_MAX = 13;
Shape.HIT_TEST_MM = -1;

Shape.ALIGN_LEFT = 1;
Shape.ALIGN_RIGHT = 2;
Shape.ALIGN_TOP = 3;
Shape.ALIGN_BOTTOM = 4;
Shape.ALIGN_CENTER = 5;
Shape.ALIGN_MIDDLE = 6;
Shape.ALIGN_TO_SAME_WIDTH = 7;
Shape.ALIGN_TO_SAME_HEIGHT = 8;
Shape.ALIGN_DIST_VER = 9;
Shape.ALIGN_DIST_HOR = 10;

Shape.STAT_CREATING_0 = 0;
Shape.STAT_CREATING_1 = 1;
Shape.STAT_CREATING_2 = 2;
Shape.STAT_NORMAL = 3;

Shape.TEXT_NONE = 0;
Shape.TEXT_INPUT = 1;
Shape.TEXT_TEXTAREA = 2;

Shape.EVT_POINTER_DOWN = 1;
Shape.EVT_POINTER_MOVE = 0;
Shape.EVT_POINTER_UP = -1;

Shape.prototype.initPanelShape = function() {
    return;
}

Shape.prototype.initIconShape = function() {
   return;
}

Shape.prototype.setNearRange = function(nearRange) {
	this.nearRange = nearRange;

	return this;
}

Shape.prototype.getNearRange = function() {
	return this.nearRange ? this.nearRange : 20;	
}

Shape.prototype.findNear = function(point) {
	return null;
}

Shape.prototype.getCreatingShape = function() {
	return this.view ? this.view.getCreatingShape() : null;
}

Shape.prototype.getTextCookie = function(point) {
	return 0;
}

Shape.isTransparentColor = function(color) {
	return !color || color === "rgba(0,0,0,0)";
}

Shape.prototype.isFillColorTransparent = function() {
	return Shape.isTransparentColor(this.style.fillColor);
}

Shape.prototype.isStrokeColorTransparent = function() {
	return Shape.isTransparentColor(this.style.lineColor);
}

Shape.prototype.isTextColorTransparent = function() {
	return Shape.isTransparentColor(this.style.textColor);
}

Shape.prototype.setParent = function(parentShape) {
	this.parentShape = parentShape;
	return this;
}

Shape.prototype.getParent = function(name) {
	if(name) {
		for(var iter = this.parentShape; iter != null; iter = iter.parentShape) {
			if(iter.name === name || iter.type === name) {
				return iter;
			}
		}
	}

	return name ? null : this.parentShape;
}

Shape.prototype.textEditable = function(point) {
	return true;
}

Shape.prototype.setInputType = function(inputType) {
	this.inputType = inputType;

	return this;
}

Shape.prototype.editText = function(point) {
	return;
}

Shape.prototype.exec = function(cmd) {
	if(this.app) {
		this.app.exec(cmd);
	}
	else {
		cmd.doit();
		delete cmd;
	}

	return;
}

Shape.prototype.setTextTitle = function(textTitle) {
	this.textTitle = textTitle;

	return this;
}
	
Shape.prototype.initShape = function(x, y, w, h, type) {
	this.w = w;
	this.h = h;
	this._x = x;
	this._y = y;
	this._left = x;
	this._top = y;
	this.type = type;
	this.text = "";
	this.app = null;
	this.view = null;
	this.rotation = 0;
	this.scaleX = 1;
	this.scaleY = 1;
	this.selected = false;
	this.parentShape = null;
	this.pointerDown = false;	
	this.userMovable = true;
	this.userResizable = true;
	this.state = Shape.STAT_NORMAL;
	this.lastPosition = {x:0, y:0};
	this.selectMarkPoint = {x:0, y:0};
	this.textType = Shape.TEXT_INPUT;
	this.setDefaultStyle();
	this.setTextAlignV("middle");
	this.setTextAlignH("center");
	this.hitTestResult = Shape.HIT_TEST_NONE;

	return;
}

Shape.prototype.setDefaultStyle = function() {
	this.style = new ShapeStyle();
	this.setStyle(Shape.getDefaultStyle());

	return this;
}

Shape.prototype.setState = function(state) {
	this.state = state;
	
	return this;
}

Shape.prototype.setTextType= function(textType) {
	this.textType = textType;
	
	return this;
}

Shape.prototype.isSelected = function() {
	return this.selected;
}

Shape.prototype.userRemovable = function() {
	return true;
}

Shape.prototype.intersectWithRect = function(rect) {
	var ret = false;
	var x = this.getX();
	var y = this.getY();
	var w = this.getWidth();
	var h = this.getHeight();

	var p1 = {x:x, y:y};
	var p2 = {x:x+w, y:y+h};
	var p3 = {x:x+w, y:y};
	var p4 = {x:x, y:y+h};

	return isPointInRect(p1, rect) || isPointInRect(p2, rect) 
		|| isPointInRect(p3, rect) || isPointInRect(p4, rect);
}


Shape.prototype.isThisInRect = function(rect) {
	var ret = false;
	var x = this.getX();
	var y = this.getY();
	var w = this.getWidth();
	var h = this.getHeight();
	
	if((x >= rect.x && x < (rect.x + rect.w))
		&& (y >= rect.y && y < (rect.y + rect.h))) {
		ret = true;
	}
	
	return ret;
}

Shape.prototype.isClicked = function() {
	if(this.view) {
		return this.view.isClicked();
	}

	return false;
}

Shape.prototype.isAltDown = function() {
	if(this.view) {
		return this.view.isAltDown();
	}

	return false;
}

Shape.prototype.isCtrlDown = function() {
	if(this.view) {
		return this.view.isCtrlDown();
	}

	return false;
}

Shape.prototype.onMoving = function() {
}

Shape.prototype.onMoved = function() {

}

Shape.prototype.onSized = function() {

}

Shape.prototype.onUserMoved = function(x, y) {

}

Shape.prototype.onUserResized = function() {

}

Shape.prototype.fixChildPosition = function(child) {
	var maxW = this.w;
	var maxH = this.h;
	var dx = child.left >= 0 ? child.left : 0;
	var dy = child.top >= 0 ? child.top : 0;

	if((dx + child.w) > maxW) {
		dx = maxW - child.w; 
	}

	if((dy + child.h) > maxH) {
		dy = maxH - child.h;
	}

	child.left = dx;
	child.top = dy;

	return;
}

Shape.prototype.fixPosition = function() {
	if(!this.parentShape) {
		return;
	}

	this.parentShape.fixChildPosition(this);

	return;
}

Shape.prototype.move = function(x, y) {
	if(this.left !== x || this.top !== y) {
		this.setLeftTop(x, y);

		if(!this.isIcon) {
			this.fixPosition();
			this.onMoved();
		}
	}

	return this;
}

Shape.prototype.moveDelta = function(dx, dy) {
	return this.move(this.left + dx, this.top + dy);
}

Shape.prototype.getWidth = function() {
	return this.w;
}

Shape.prototype.getHeight = function() {
	return this.h;
}

Shape.prototype.getPositionInScreen = function() {
	var pv = {x:0, y:0};
	var scale = this.getRealScale();
	var p = this.getPositionInView();
	
	if(this.view) {
		pv = this.view.getAbsPosition();
	}

	p.x = pv.x + p.x * scale;
	p.y = pv.y + p.y * scale;

	return p;
}

Shape.prototype.getRealScale = function() {
	return this.view ? this.view.getScale() : 1;
}

Shape.prototype.getAbsPosition = function() {
	var p = this.getPositionInView();

	if(this.view) {
		var pv = this.view.getAbsPosition();
		p.x = p.x + pv.x;
		p.y = p.y + pv.y;
	}

	return p;
}

Shape.prototype.getPositionInView = function() {
	var x = this.getX();
	var y = this.getY();
	var point = {x:0, y:0};
	var iter = this.parentShape;

	while(iter != null) {
		x += iter.left;
		y += iter.top;
		iter = iter.parentShape;
	}

	point.x = x;
	point.y = y;

	return point;
}


Shape.prototype.getXinView = function() {
	var x = this.getPositionInView().x; 

	return x;
}

Shape.prototype.getYinView = function() {
	var y = this.getPositionInView().y; 

	return y;
}

Shape.prototype.getX = function() {
	return this.x;
}

Shape.prototype.getY = function() {
	return this.y;
}

Shape.prototype.setX = function(x) {
	this.x = x;

	return this;
}

Shape.prototype.setY = function(y) {
	this.y = y;
	
	return this;
}

Shape.prototype.align = function(type, value) {
	return;
}

Shape.prototype.setRotatable = function(rotatable) {
	this.rotatable = rotatable;
	
	return this;
}

Shape.prototype.setScaleX = function(scaleX) {
	this.scaleX = scaleX;

	return this;
}

Shape.prototype.setScaleY = function(scaleY) {
	this.scaleY = scaleY;

	return this;
}

Shape.prototype.getScale = Shape.prototype.getScaleX = function() {
	return this.scaleX !== undefined ? this.scaleX : this.scale;
}

Shape.prototype.getScaleY = function() {
	return this.scaleY !== undefined ? this.scaleY : this.scale;
}

Shape.prototype.setScale = function(scaleX, scaleY) {
	this.scaleX = scaleX;
	this.scaleY = scaleY !== undefined ? scaleY : scaleX;

	return this;
}

Shape.prototype.getRotation = function() {
	return this.rotation;
}

Shape.prototype.setRotation = function(rotation) {
	this.rotation = rotation;
	
	return this;
}

Shape.prototype.getOpacity = function() {
	return this.opacity;
}

Shape.prototype.setOpacity = function(opacity) {
	this.opacity = Math.max(0, opacity);
	this.opacity = Math.min(1, this.opacity);

	return this;
}

Shape.prototype.setStyle = function(style) {
	this.style.copy(style);
	this.textNeedRelayout = true;
	
	return this;
}

Shape.prototype.getStyle = function() {
	return this.style;
}

Shape.prototype.setName = function(name) {
	this.name = name;

	return this;
}

Shape.prototype.getName = function() {
	return this.name;
}

Shape.prototype.getLocaleText = function(text) {
	return text;
}

Shape.prototype.getLocaleInputTips = function(text) {
	return dappGetText(text);
}
	
Shape.prototype.setNeedRelayoutText = function() {
	this.textNeedRelayout = true;

	return this;
}	

Shape.prototype.setTextAlignH = function(hTextAlign) {
	this.hTextAlign = hTextAlign;

	return this;
}

Shape.prototype.setTextAlignV = function(vTextAlign) {
	this.vTextAlign = vTextAlign;

	return this;
}

Shape.prototype.getTextAlignH = function() {
	var hTextAlign = this.hTextAlign ? this.hTextAlign : "left";

	return hTextAlign;
}

Shape.prototype.getTextAlignV = function() {
	var vTextAlign = this.vTextAlign ? this.vTextAlign : "top";

	return vTextAlign;
}

Shape.prototype.toText = function(value) {
	if(value !== null && value != undefined) {
		return value + "";
	}
	else {
		return "";
	}
}

Shape.prototype.setText = function(text) {
	this.text = this.toText(text);
	this.textNeedRelayout = true;
	
	return this;
}

Shape.prototype.setText2 = function(text) {
	this.text2 = text;
	
	return this;
}

Shape.prototype.setText3 = function(text) {
	this.text3 = text;
	
	return this;
}

Shape.prototype.getText = function() {
	return this.text;
}

Shape.prototype.getApp = function() {
	return this.app;
}

Shape.prototype.getView = function() {
	return this.view;
}

Shape.prototype.setApp = function(app) {
	this.app = app;
	
	return this;
}

Shape.prototype.setView = function(view) {
	this.view = view;
	
	return this;
}

Shape.prototype.redrawSelf = function() {
	if(this.view) {
		var scale = this.getRealScale();
		var p = this.getPositionInView();
		var rect = {x: p.x*scale, y:p.y*scale, w:this.w*scale, h:this.h*scale};

		this.view.redraw(rect);
	}
	
	return;
}

Shape.prototype.postRedraw = function(rect) {
	if(this.view) {
		this.view.postRedraw(rect);
	}
	
	return;
}

Shape.prototype.beforePropertyChanged = function() {
	return;
}

Shape.prototype.afterPropertyChanged = function() {
	return;
}

Shape.prototype.showProperty = function() {
	return;
}

Shape.prototype.setSelectedMarkSize = function(selectedMarkSize) {
	this.selectedMarkSize = selectedMarkSize;

	return;
}

Shape.prototype.paint = function(canvas) {
	this.paintSelf(canvas);

	if(this.near) {
		var p = this.near.point;
		var r = this.getNearRange();

		canvas.beginPath();
		canvas.arc(p.x, p.y, 4, 0, Math.PI * 2);
		canvas.fillStyle = "Red";
		canvas.fill();

		canvas.beginPath();
		canvas.lineWidth = 2;
		canvas.arc(p.x, p.y, r, 0, Math.PI * 2);
		canvas.strokeStyle = "Black";
		canvas.stroke();
	}

	return;
}

Shape.prototype.paintSelf = function(canvas) {
	return;
}

Shape.prototype.setSelected = function(selected) {
	if(selected) {
		this.selectedTime = Date.now();
	}

	if(this.selected === selected) {
		return;
	}

	this.selected = selected;
	if(this.view && this.view.onShapeSelected) {
		this.view.onShapeSelected(this);
	}

	return;
}

Shape.prototype.isVisible = function() {
	return true;
}

Shape.prototype.findNearPoint = function(rect) {
	var p = null;

	for(var i = 0; i < 100; i++) {
		p = this.getNearPoint(i);

		if(!p) {
			break;
		}
		
		if(isPointInRect(p, rect)) {
			var near = {shape:this};
			near.nearPointIndex = i;
			near.point = {x:p.x, y:p.y};

			return near;
		}
	}

	return null;
}

Shape.prototype.dup = function() {
	var g = ShapeFactoryGet().createShape(this.type, C_CREATE_FOR_PROGRAM);

	g.fromJson(this.toJson());
	g.state = Shape.STAT_NORMAL;

	return g;
}


Shape.prototype.hitTest = function(point) {
	return Shape.HIT_TEST_NONE;
}

Shape.prototype.showProperty = function() {
	return;
}

Shape.prototype.onLongPress = function(point) {
	return;
}

Shape.prototype.onGesture = function(gesture) {
}

Shape.prototype.onDoubleClick = function(point) {
	return true;
}

Shape.prototype.onPointerDown = function(point) {
	this.pointerDown = true;
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		return false;
	}
	
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	this.handlePointerEvent(point, Shape.EVT_POINTER_DOWN);
	
	return true;
}

Shape.prototype.handlePointerEvent = function(point, evt) {
	return false;
}

Shape.prototype.onPointerMove = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, Shape.EVT_POINTER_MOVE);
		return true;
	}
	
	return false;
}

Shape.prototype.onPointerUp = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, Shape.EVT_POINTER_UP);
		this.hitTestResult = Shape.HIT_TEST_NONE;
		
		return true;
	}
	this.pointerDown = false;
	
	return false;
}

Shape.prototype.onKeyDown = function(code) {
	console.log("onKeyUp Widget: code=" + code)
	return;
}

Shape.prototype.onKeyUp = function(code) {
	console.log("onKeyUp Widget: code=" + code)
	return;
}

Shape.prototype.canBeComponent = function() {
	return false;
}

Shape.prototype.shouldShowContextMenu = function() {
	return true;
}

Shape.prototype.toJson = function() {
	return null;
}

Shape.prototype.fromJson = function(js) {
	return this;
}

Shape.prototype.afterApplyFormat = function() {
	return;
}

Shape.prototype.applyFormat = function(js) {
	if(!js) {
		return;
	}

	for(var key in js) {
		var value = js[key];
		var type = typeof value;
		if(type === "function" || type === "object" || type === "undefined") {
			continue;
		}

		if(key == "type") {
			continue;
		}

		if(type === "number" || type === "string" || type === "boolean") {
			this[key] = value;
		}
	}

	if(js.images) {
		for(var key in js.images) {
			var value = js.images[key];
			
			if(key === "display") {
				this.images[key] = value;
			}
			else {
				var src = value.getImageSrc();
				this.setImage(key, src);
			}
		}
	}

	if(js.style) {
		this.style.fromJson(js.style);
	}
	
	if(js.animations) {
		this.animations = JSON.parse(js.animations);
		this.defaultAnimationName = js.defaultAnimationName;
	}

	this.afterApplyFormat();
	this.textNeedRelayout = true;

	return;
}

Shape.prototype.setUserMovable = function(value) {
	this.userMovable = value;

	return this;
}

Shape.prototype.setUserResizable = function(value) {
	this.userResizable = value;

	return this;
}

Shape.prototype.isUserMovable = function() {
	return this.userMovable && !this.isLocked();
}

Shape.prototype.isUserResizable = function() {
	return this.userResizable;
}

function splitText(text) {
	text = text.replaceAll("\r\n", "\n");
	text = text.replaceAll("\r", "\n");

	return text.split("\n--\n");
}

Shape.onRestacked = function(shapes, shape) {
}

function restackShapeInArray(shapes, offset) {
	var n = 0;
	var pos = 0;
	var s = null;
	var new_pos = 0;
	var selectedShape = null;

	for(var i = 0; i < shapes.length; i++) {
		s = shapes[i];
		if(s.selected) {
			n++;
			if(!selectedShape) {
				selectedShape = s;
				pos = i;
			}
		}
	}

	if(n > 1 || !selectedShape) {
		return;
	}

	new_pos = pos + offset;
	if(new_pos < 0 || new_pos >= shapes.length) {
		return;
	}

	shapes[pos] = shapes[new_pos];
	shapes[new_pos] = selectedShape;
	Shape.onRestacked(shapes, selectedShape);

	return;
}

function getParentShapeOfShape(shape, view) {
	var p = shape.parentShape ? shape.parentShape : shape.container;

	if(!p) {
		p = view;
	}

	return p;
}

function getParentShapeOfShapes(shapes) {
	if(!shapes || shapes.length === 0) {
		return null;
	}

	var firstShape = shapes[0];
	var parentShape = firstShape.parentShape;

	for(var i = 0; i < shapes.length; i++) {
		var shape = shapes[i];

		if(shape.parentShape != parentShape) {
			return null;
		}
	}

	return parentShape ? parentShape : firstShape.view;
}

Shape.prototype.getTextColor = function(canvas) {
	return this.style.textColor;
}

Shape.prototype.getBgColor = function(canvas) {
	return this.style.fillColor;
}

Shape.prototype.getLineColor = function(canvas) {
	return this.style.lineColor;
}

Shape.prototype.defaultDrawText = function(canvas) {
	var width = this.getWidth(true);
	var text = this.getLocaleText(this.text);

	if(!text || this.editing) {
		return;
	}
	
	canvas.save();
	canvas.beginPath();
	canvas.lineWidth = 1;
	canvas.font = this.style.getFont();
	canvas.fillStyle = this.getTextColor();
	canvas.strokeStyle = this.getLineColor();

	var lines = text.split(/\n/);
	if(lines.length < 2) {
		if(this.singleLineMode || canvas.measureText(text).width < 1.2 * width) {
			this.draw1LText(canvas);
		}
		else {
			this.drawMLText(canvas);
		}
	}
	else {
		this.drawMLText(canvas);
	}
	canvas.restore();

	return;
}

Shape.prototype.draw1LText = function(canvas, drawAll) {
	var text = this.getLocaleText(this.text);

	if(!text || this.editing) {
		return;
	}

    if(!this.lines){
        this.layoutText(canvas);
    }
	
    if(!this.lines) {
		return;
	}
    text = this.lines[0];

	var x = 0;
	var y = 0;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var hTextAlign = this.getTextAlignH();
	var vTextAlign = this.getTextAlignV();
	var textU = this.style.textU;
	var fontSize = this.style.fontSize;
	var textWidth = canvas.measureText(text).width;

	var lx = 0;
	var ly = 0;
	var lw = Math.min(textWidth, width);

	switch(vTextAlign) {
		case "middle": {
			y = this.h >> 1;
			canvas.textBaseline = "middle";
			if(textU) {
				ly = Math.floor(y + fontSize * 0.8);
			}
			break;
		}
		case "bottom": {
			y = this.h - this.vMargin;
			canvas.textBaseline = "bottom";
			if(textU) {
				ly = y;
			}
			break;
		}
		default: {
			y = this.vMargin;
			canvas.textBaseline = "top";
			if(textU) {
				ly = Math.floor(y + fontSize * 1.5);
			}
			break;
		}
	}

	switch(hTextAlign) {
		case "center": {
			x = this.w >> 1;
			canvas.textAlign = "center";
			if(textU) {
				lx = Math.max((this.w - textWidth) >> 1, 0);
			}
			break;
		}
		case "right": {
			x = this.w - this.hMargin;
			canvas.textAlign = "right";
			if(textU) {
				lx = Math.max((this.w - textWidth - hMargin), 0);
			}
			break;
		}
		default: {
			x = this.hMargin;
			canvas.textAlign = "left";
			if(textU) {
				lx = x;
			}
			break;
		}
	}
	
	if(textU) {
		canvas.moveTo(lx, ly);
		canvas.lineTo(lx + lw, ly);
		canvas.stroke();
	}

	canvas.fillText(text, x, y, width);
	
	return textWidth;
}

Shape.prototype.drawMLText = function(canvas, drawAll) {
	if(!this.lines){
        this.layoutText(canvas);
    }

	if(!this.lines) {
		return;
	}

	var x = 0;
	var y = 0;
	var lx = 0;
	var ly = 0;
	var lw = 0;
	var vMargin = this.vMargin;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var hTextAlign = this.getTextAlignH();
	var vTextAlign = this.getTextAlignV();

	var textU = this.style.textU;
	var fontSize = this.style.fontSize;
	var textLineHeight = this.getTextLineHeight();
	var textHeight = this.getTextHeight();

	canvas.textBaseline = "top";
	switch(vTextAlign) {
		case "middle": {
			y = (this.h - textHeight) >> 1;
			break;
		}
		case "bottom": {
			y = this.h - textHeight - vMargin;
			break;
		}
		default: {
			y = vMargin;
			break;
		}
	}

	y = y < 0 ? 0: y;

	for(var i = 0; i < this.lines.length; i++) {
		var str = this.lines[i];
		if(!str || str == " ") {
			y += fontSize;
			continue;
		}
		
		if((y + textLineHeight) >= this.h && !drawAll) {
			break;
		}

		var textWidth = canvas.measureText(str).width;

		lw = Math.min(textWidth, width);
		ly = Math.floor(y + (fontSize + textLineHeight)/2);

		switch(hTextAlign) {
			case "center": {
				x = this.w >> 1;
				canvas.textAlign = "center";
				if(textU) {
					lx = Math.max((this.w - textWidth) >> 1, 0);
				}
				break;
			}
			case "right": {
				x = this.w - hMargin;
				canvas.textAlign = "right";
				if(textU) {
					lx = Math.max((this.w - textWidth - hMargin), 0);
				}
				break;
			}
			default: {
				x = hMargin;
				canvas.textAlign = "left";
				if(textU) {
					lx = x;
				}
				break;
			}
		}

		if(textU) {
			canvas.moveTo(lx, ly);
			canvas.lineTo(lx + lw, ly);
			canvas.stroke();
		}
		canvas.fillText(str, x, y, width);

		y += textLineHeight;
	}

	return;
}

Shape.prototype.getTextHeight = function() {
	var h = 0;
	var fontSize = this.style.fontSize;
	var lineHeight = this.getTextLineHeight();

	if(!this.text || !this.lines) {
		return lineHeight;
	}

	for(var i = 0; i < this.lines.length; i++) {
		var str = this.lines[i];
		if(!str || str == " ") {
			h += fontSize;
		}
		else {
			h += lineHeight;
		}
	}

	return h;
}

Shape.prototype.getTextLineHeight = function() {
	return Math.floor(this.style.fontSize * 1.5);
}

Shape.prototype.setTextShadow = function(textShadow) {
	this.textShadow = textShadow;

	return this;
}

Shape.prototype.isValid = function() {
	return !this.isInvalid;
}

Shape.prototype.canCopy = function() {
	return true;
}

Shape.prototype.onDestroy = function() {
}

Shape.prototype.onRemoved = function(parent) {
}

Shape.prototype.detachFromParent = function() {
}

Shape.prototype.destroy = function() {
	this.detachFromParent();

	if(this.container) {
		this.container = null;
	}

	this.app = null;
	this.view = null;

	if(this.children) {
		this.children.clear(true);
		this.children = null;
	}

	if(this.images) {
		this.images = null;
	}

	if(this.events) {
		this.events = null;
	}

	if(this.style) {
		this.style = null;
	}

	this.onDestroy();
	this.isInvalid = true;
	this.jsonData = null;

	return;
}

Shape.prototype.isInDesignMode = function() {
	return false;
}

Shape.iconShapeStyle = null;
Shape.getIconShapeStyle = function() {
	if(!Shape.iconShapeStyle) {
		Shape.iconShapeStyle = ShapeStyle.create();
		Shape.iconShapeStyle.setLineWidth(1);
		Shape.iconShapeStyle.setFontSize(8);
		Shape.iconShapeStyle.setLineColor("Black");
		Shape.iconShapeStyle.setFillColor("White");
		Shape.iconShapeStyle.setTextColor("Black");
	}

	return Shape.iconShapeStyle;
}

Shape.defaultStyle = null;
Shape.getDefaultStyle = function() {
	if(!Shape.defaultStyle) {	
		Shape.defaultStyle = ShapeStyle.create();
	}

	return Shape.defaultStyle;
}

/*
 * File: shape_style.js
 * Brief: shape style
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */
function ShapeStyle() {
}
	
ShapeStyle.prototype.getFont = function() {
	var font = "";
	
	if(this.textI) {
		font = "italic  "
	}
	
	if(this.textB) {
		font = font + "bold "
	}
	
	font = font + this.fontSize + "pt \"" + this.fontFamily + "\"";

	return font;
}

ShapeStyle.prototype.setLineWidth = function(value) {
	this.lineWidth = value > 0 ? value : 1;

	return;
}

ShapeStyle.prototype.setLineColor = function(value) {
	this.lineColor = value;

	return;
}

ShapeStyle.prototype.setFillColor = function(value) {
	this.fillColor = value;

	return;
}

ShapeStyle.prototype.setTextColor = function(value) {
	this.textColor = value;

	return;
}

ShapeStyle.prototype.setFontSize = function(value) {
	var fontSize = Math.max(value, 6);

	this.fontSize = fontSize;

	return;
}

ShapeStyle.prototype.setFontFamily = function(fontFamily) {
	this.fontFamily = fontFamily ? fontFamily : "serif";

	return;
}

ShapeStyle.prototype.setTextB = function(value) {
	this.textB = value;

	return;
}

ShapeStyle.prototype.setTextU = function(value) {
	this.textU = value;

	return;
}

ShapeStyle.prototype.setTextI = function(value) {
	this.textI = value;

	return;
}

ShapeStyle.prototype.getStrokeStyle = function(canvas) {
	return this.strokeColor;
}

ShapeStyle.prototype.copy = function(other) {
	var js = other.toJson();

	this.fromJson(js);

	return ;
}

ShapeStyle.prototype.toJson = function() {
	var o = {};

	for(var key in this) {
		var value = this[key];
		if(typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			o[key] = value;
		}
	}

	return o;
}

ShapeStyle.prototype.fromJson = function(js) {
	for(var key in js) {
		var value = js[key];
		if(key.length < 4) continue;
		if(typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			this[key] = value;
		}
	}

	return;
}

ShapeStyle.prototype.dup = function() {
	var other = new ShapeStyle();
	
	other.copy(this);
	
	return other;
}

ShapeStyle.prototype.equalTo = function(style) {
	var thisJson = JSON.stringify(this.toJson());
	var otherJson = JSON.stringify(style.toJson());

	return thisJson === otherJson;
}

ShapeStyle.createFromJson = function(js) {
	var style = new ShapeStyle();

	style.fromJson(js);

	return style;
}

ShapeStyle.create = function() {
	return new ShapeStyle();
}

/*
 * File: r_shape.js
 * Brief: Base class of all rectangle shapes.
 * Web Site: http://www.drawapp8.com
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2011 - 2013  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function RShape() {
	return;
}

RShape.prototype = new Shape();

RShape.prototype.MIN_SIZE = 10;
RShape.prototype.isRect = true;

RShape.prototype.getX = function() {
	if(this.anchor) {
		return this._x;
	}
	else {
		return this._left;
	}
}

RShape.prototype.getY = function() {
	if(this.anchor) {
		return this._y;
	}
	else {
		return this._top;
	}
}

RShape.prototype.setX = function(x) {
	return this.setPosition(x, this.y);
}

RShape.prototype.setY = function(y) {
	return this.setPosition(this.x, y);
}

RShape.prototype.getLeft = function() {
	return this._left;
}

RShape.prototype.getTop = function() {
	return this._top;
}

RShape.prototype.setLeft = function(left) {
	this._left = left;

	return this;
}

RShape.prototype.setTop = function(top) {
	this._top = top;
	
	return this;
}

RShape.prototype.setLeftTop = function(left, top) {
	this._left = left;
	this._top = top;

	return this;
}

RShape.prototype.setPivot = function(x, y) {
	this.pivotX = x;
	this.pivotY = y;

	return this;
}

RShape.prototype.getPivot = function() {
	return {x:this.pivotX, y:this.pivotY};
}

RShape.prototype.onPositionChanged = function() {
}

RShape.prototype.getAnchorX = function() {
	return this.getAnchor().x;
}

RShape.prototype.getAnchorY = function() {
	return this.getAnchor().y;
}

RShape.prototype.setAnchorX = function(x) {
	return this.setAnchor(x, this.getAnchorY());
}

RShape.prototype.setAnchorY = function(y) {
	return this.setAnchor(this.getAnchorX(), y);
}

RShape.prototype.setAnchor = function(x, y) {
	var anchor = this.getAnchor();

	anchor.x = x;
	anchor.y = y;

	this.pivotX = x;
	this.pivotY = y;

	this._x = this._left + (this.w * x);
	this._y = this._top + (this.h * y);

	return this;
}

RShape.prototype.getAnchor = function() {
	if(!this.anchor) {
		this.anchor = {x:0, y:0};
		this._x = this._left;
		this._y = this._top;
	}

	return this.anchor;
}

RShape.prototype.getPosition = function() {
	var p = {};

	if(!this.anchor) {
		p.x = this._left;
		p.y = this._top;
	}
	else {
		p.x = this._x;
		p.y = this._y;
	}

	return p;
}

RShape.prototype.setPosition = function(x, y) {
	var changed = (this._x !== x || this._y !== y);

	this._x = x;
	this._y = y;

	if(this.anchor) {
		var left = this._x - this.w * this.anchor.x;
		var top  = this._y - this.h * this.anchor.y;
		this.setLeftTop(left, top);
	}
	else {
		this.setLeftTop(this._x, this._y);
	}

	if(changed) {
		this.onPositionChanged();
	}

	return this;
}

RShape.prototype.realResize = RShape.prototype.setSize = function(w, h) {
	if(this.w !== w || this.h !== h) {
		var ww = Math.max(Math.round(w), 4);
		var hh = Math.max(Math.round(h), 4);

		if(this.anchor) {
			this._left = this._x - ww * this.anchor.x;
			this._top = this._y - hh * this.anchor.y;
		}
		this.w = ww;
		this.h = hh;

		this.textNeedRelayout = true;
	}
	
	return this;
}


RShape.prototype.initRShape = function(x, y, w, h, type) {
	this.initShape(x, y, w, h, type);

	this.w = w;
	this.h = w;
	this.opacity = 1;
	this.hMargin = 0;
	this.vMargin = 0;
	this.rotation = 0;
	this.defWidth = w;
	this.defHeight = w;
	this.enable = true;
	this.visible = true;
	this.events = {};
	this.pivotX = 0.5;
	this.pivotY = 0.5;
	this.text = "";
	this.pointerDown = false;
	this.lastPosition = {x:0, y:0};
	this.pointerDownPosition = {x:0, y:0};
	this.setScale(1, 1);
	if(w === 0 || h === 0) {
		this.w = this.MIN_SIZE;
		this.h = this.MIN_SIZE;	
		this.setState(Shape.STAT_CREATING_0);
	}

	return;
}

RShape.prototype.onPointerDown = function(point) {
	if(!this.enable && !this.isInDesignMode()) {
		console.log(this.name + " is disable, ignore pointer events.");
		return;
	}

	this.pointerDownPosition.x = point.x;
	this.pointerDownPosition.y = point.y;
	this.postRedraw();

	return this.onPointerDownNormal(point);
}

RShape.prototype.onPointerMove = function(point) {
	if(!this.enable && !this.isInDesignMode()) {
		console.log("Ignore pointer event because this.enable is false.");
		return;
	}

	if(this.isLocked()) {
		return false;
	}

	return this.onPointerMoveNormal(point);
}

RShape.prototype.onPointerUp = function(point) {
	if(!this.enable && !this.isInDesignMode()) {
		console.log("Ignore pointer event because this.enable is false.");
		return;
	}

	var ret = this.onPointerUpNormal(point);
	this.pointerDown = false;
	this.postRedraw();

	return ret;
}

RShape.prototype.onPointerDownNormal = function(point) {
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		return false;
	}
	
	this.pointerDown = true;
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	this.handlePointerEvent(point, 1);

	return true;
}

RShape.prototype.onPointerMoveNormal = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, 0);
		return true;
	}

	return false;
}

RShape.prototype.onPointerUpNormal = function(point) {
	if(this.hitTestResult) {
		this.handlePointerEvent(point, -1);
		this.hitTestResult = Shape.HIT_TEST_NONE;

		return true;
	}

	return false;
}

RShape.prototype.fixSize = function() {
	if(this.w < this.MIN_SIZE) {
		this.w = this.MIN_SIZE;
	}

	if(this.h < this.MIN_SIZE) {
		this.h = this.MIN_SIZE;
	}

	if(this.wMin && this.w < this.wMin) {
		this.w = this.wMin;
	}
	
	if(this.wMax && this.w > this.wMax) {
		this.w = this.wMax;
	}
	
	if(this.hMax && this.h > this.hMax) {
		this.h = this.hMax;
	}
	
	if(this.hMin && this.h < this.hMin) {
		this.h = this.hMin;
	}

	if(this.whRadio) {
		if(this.whRadio > 1) {
			this.h = Math.floor(this.w / this.whRadio);
		}
		else {
			this.w = Math.floor(this.h * this.whRadio);
		}
	}
	
	if(this.parentShape) {	
		this.parentShape.fixChildSize(this);
	}

	return;
}

RShape.prototype.fixChildSize = function(child) {
	var maxW = this.w;
	var maxH = this.h;
	if((child.x + child.w) > maxW) {
		child.w = maxW - child.x;
	}

	if((child.y + child.h) > maxH) {
		child.h = maxH - child.y;
	}

	return;
}

RShape.prototype.setDefSize= function(w, h) {
	this.defWidth = w;
	this.defHeight = h;

	this.w = w;
	this.h = h;

	return this;
}

RShape.prototype.setSizeLimit = function(wMin, hMin, wMax, hMax, whRadio) {
	this.wMin = wMin;
	this.wMax = wMax;
	this.hMin = hMin;
	this.hMax = hMax;
	this.whRadio = whRadio;

	return this;
}

RShape.prototype.resizeDelta = function(dw, dh) {
	this.resize(this.w + dw, this.h + dh);

	return;
}

RShape.prototype.resize = function(w, h) {
	if(this.w !== w || this.h !== h) {
		this.setSize(w, h);

		if(!this.isIcon) {
			this.onSized();
			this.fixSize();
		}
	}

	return this;
}

RShape.prototype.translate = function(canvas) {
	canvas.translate(this._left, this._top);

	return;
}

RShape.prototype.setClipRect = function(x, y, w, h) {
	if(arguments.length > 3) {
		var r = {};
		r.x = x;
		r.y = y;
		r.w = w;
		r.h = h;
		this.clipInfo = r;
	}
	else {
		this.clipInfo = null;
	}

	return this;
}

RShape.prototype.setClipCircle = function(x, y, r) {
	if(arguments.length > 2) {
		circle = {};
		circle.x = x;
		circle.y = y;
		circle.r = r;
		this.clipInfo = circle;
	}
	else {
		this.clipInfo = null;
	}

	return this;
}

RShape.prototype.onClip = function(canvas) {
	if(this.clipInfo) {
		var info = this.clipInfo;

		canvas.beginPath();
		if(info.r) {
			canvas.arc(info.x, info.y, info.r, 0, Math.PI * 2);
		}
		else {
			canvas.rect(info.x, info.y, info.w, info.h);
		}
		canvas.clip();
		canvas.beginPath();
	}
}

RShape.prototype.applyScale = function(canvas) {
	var scaleX = this.getScaleX();
	var scaleY = this.getScaleY();

	var px = this.w * this.pivotX;
	var py = this.h * this.pivotY;
	canvas.translate(px, py);
	canvas.scale(scaleX, scaleY);
	canvas.translate(-px, -py);
}

RShape.prototype.applyRotation = function(canvas) {
	if(Math.abs(this.rotation) > 0.0001) {
		var px = this.w * this.pivotX;
		var py = this.h * this.pivotY
		canvas.translate(px, py);
		canvas.rotate(this.rotation);
		canvas.translate(-px, -py);
	}
}

RShape.prototype.applyTransform = function(canvas) {
	canvas.globalAlpha *=  this.opacity;

	if(this.offsetX) {
		canvas.translate(this.offsetX, 0);
	}

	if(this.offsetY) {
		canvas.translate(0, this.offsetY);
	}

	this.applyRotation(canvas);
	this.applyScale(canvas);

	return;
}

RShape.prototype.isPointIn = function(canvas, point) {
	return isPointInRect(point, this);
}

RShape.prototype.drawImage = function(canvas) {
	return;
}

RShape.prototype.paintShape = function(canvas) {
	canvas.rect(0, 0, this.w, this.h);		

	return;
}

RShape.prototype.setTextNeedRelayout = function(value) {
	this.textNeedRelayout = value;

	return this;
}

RShape.prototype.layoutText = function(canvas) {
	if(!this.textNeedRelayout || this.textType === Shape.TEXT_NONE) {
		return;
	}

	canvas.font = this.style.getFont();
	var vMargin = this.vMargin ? this.vMargin : 10;
	
	var w = this.w - 2 * vMargin;
	if(w > 0) {
		this.lines = layoutText(canvas, this.style.fontSize, this.getLocaleText(this.text), w);
	}
	else {
		this.lines = [];
	}

	this.textNeedRelayout = false;

	return;
}

RShape.prototype.drawTextUnderLine = function(canvas, textX, textY, text) {
	var x = 0;
	var y = 0;
	var h = 0;
	var w = 0;
	if(!this.style.textU) {
		return;
	}
	
	w = canvas.measureText(text).width;
	if(this.textBaseline === "middle") {
		h = this.style.fontSize/2;
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}
	else if(this.textBaseline === "top") {
		h = this.style.fontSize;
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}
	else {
		if(this.textAlign === "center") {
			x = textX - w/2;
		}
		else if(this.textAlign === "left") {
			x = textX ;
		}
		else {
			x = textX - w;
		}
	}

	y = textY + h;

	canvas.moveTo(x, y);
	canvas.lineTo(x+ w, y);
	canvas.lineWidth = 1;
	canvas.stroke();

	return;
}

RShape.prototype.needDrawTextTips = function() {
	return true;
}

RShape.prototype.setInputTips = function(inputTips) {
	this.inputTips = inputTips;

	return this;
}

RShape.prototype.getTextTipsPosition = function() {
	var pos = {};

	pos.x = this.getWidth() >> 1;
	pos.y = this.getHeight() >> 1;
	pos.textAlign = "center";
	pos.textBaseline = "middle";

	return pos;
}

RShape.prototype.drawTextTips = function(canvas) {
	if(this.text || this.isIcon || this.w < 120 || this.h < 20 || this.editing) {
		return;
	}

	var pos = this.getTextTipsPosition();

	var x = pos.x;
	var y = pos.y;

	canvas.textAlign = pos.textAlign;
	canvas.textBaseline = pos.textBaseline;

	canvas.font = this.style.getFont();
	canvas.fillStyle = "#E0E0E0";	
	if(this.inputTips) {
		canvas.fillText(this.getLocaleInputTips(this.inputTips), x, y, this.getWidth());
	}

	return;
}

RShape.prototype.getOneLineText = function(canvas, text) {
	var line = "";
	var w = this.getWidth(true);

	if(canvas.measureText(text).width <= w) {
		return text;
	}

	for(var i = 0; i < text.length; i++) {
		var str = text[i];
		w = w - canvas.measureText(str).width;
		if(w < 0) {
			break;
		}
	
		line = line + str;
	}

	return line;
}

RShape.prototype.setMargin = function(vMargin, hMargin) {
	this.vMargin = Math.floor(Math.min(vMargin, 0.5 * this.w));
	this.hMargin = Math.floor(Math.min(hMargin, 0.5 * this.h));

	return this;
}

RShape.prototype.getVMargin = function() {
	return this.vMargin ? this.vMargin : 0;
}

RShape.prototype.getHMargin = function() {
	return this.hMargin ? this.hMargin : 0;
}

RShape.prototype.setWidth = function(width) {
	return this.setSize(width, this.h);
}

RShape.prototype.setHeight = function(height) {
	return this.setSize(this.w, height);
}

RShape.prototype.getWidth = function(withoutMargin) {
	if(withoutMargin) {
		return this.w - 2 * this.getHMargin();
	}
	else {
		return this.w;
	}
}

RShape.prototype.getHeight = function(withoutMargin) {
	if(withoutMargin) {
		return this.h - 2 * this.getVMargin();
	}
	else {
		return this.h;
	}
}

RShape.prototype.drawText = function(canvas) {
	this.defaultDrawText(canvas);

	return;
}

RShape.prototype.prepareStyle = function(canvas) {
	var style = this.style;
	canvas.lineWidth = style.lineWidth;			
	canvas.strokeStyle = style.lineColor;
	canvas.fillStyle = style.fillColor;

	return;
}

RShape.prototype.resetStyle = function(canvas) {
	canvas.shadowOffsetX = 0;
	canvas.shadowOffsetY = 0;
	canvas.shadowBlur    = 0;
	canvas.fillStyle = "White";
	canvas.beginPath();

	return;
}

RShape.prototype.strokeFill = function(canvas) {
	if(this.style.enableShadow || isOldIE()) {
		if(canvas.lineWidth >= 1) {
			if(!this.isStrokeColorTransparent()) {
				canvas.stroke();	
			}
		}

		if(!this.isFillColorTransparent()) {
			canvas.fill();
		}
	}
	else {
		if(!this.isFillColorTransparent()) {
			canvas.fill();	
		}

		if(canvas.lineWidth >= 1) {
			if(!this.isStrokeColorTransparent()) {
				canvas.stroke();	
			}
		}
	}

	return;
}

RShape.prototype.paintSelf = function(canvas) {
	return;
}

RShape.prototype.getCanvasContext2D = function() {
	return this.view.getCanvas2D();
}

RShape.prototype.getHitTestCanavs = function() {
	var canvas = this.view.getCanvas2D();
	if(CantkRT.isCantkRTCordova()) {
		return canvas.getCanvasRenderingContext2D("2d");
	}
	else {
		return canvas;
	}
}

RShape.prototype.hitTest = function(point) {
	var ret = Shape.HIT_TEST_NONE;

	if(!this.enable && !this.isInDesignMode()) {
		return ret;
	}

	var me = this;
	var canvas = this.getHitTestCanavs();

	function applyTransform(canvas) {
		me.translate(canvas);
		me.applyTransform(canvas);
	}
	
	if(this.isPointInMatrix({x: 0, y: 0, w: this.w, h: this.h}, point, applyTransform)) {
		ret = Shape.HIT_TEST_MM;
	}

	return ret;
}

//lock is used only in IDE
RShape.prototype.isLocked = function() {
	return false;
}

RShape.prototype.lock = function() {
	this.locked = true;

	return this;
}

RShape.prototype.unlock = function() {
	this.locked = false;

	return this;
}

RShape.prototype.execMoveResize = function(x, y, w, h) {
	if(window.MoveResizeCommand) {
		this.exec(new MoveResizeCommand(this, x, y, w, h));	
	}
	else {
		if(x || x === 0) {
			this.setLeft(x);
		}
		if(y || y === 0) {
			this.setTop(y);
		}
		if(w || w === 0) {
			this.w = w;
		}
		if(h || h === 0) {
			this.h = h;
		}
	}

	return;
}

RShape.prototype.onUserMoving = function() {
}

RShape.prototype.onUserResizing = function() {
}

RShape.prototype.onUserRotating = function() {
}

RShape.prototype.handlePointerEvent = function(point, type) {
	if(type === Shape.EVT_POINTER_DOWN) {
		this.saveLeft = this.getLeft();
		this.saveTop = this.getTop();;
		this.saveW = this.w;
		this.saveH = this.h;
		this.saveRotation = this.rotation;

		return;
	}
	
	var saveW = this.saveW;
	var saveH = this.saveH;
	var dx = point.x - this.pointerDownPosition.x;
	var dy = point.y - this.pointerDownPosition.y;
	
	var newDLeft = 0;
	var newDTop = 0;
	var newW = saveW;
	var newH = saveH;
	switch(this.hitTestResult) {
		case Shape.HIT_TEST_TL: {
			newDLeft = dx;
			newDTop = dy;
			newW = saveW - dx;
			newH = saveH - dy;
			break;
		}
		case Shape.HIT_TEST_TM: {
			newDTop = dy;
			newH = saveH - dy;	
			break;
		}			
		case Shape.HIT_TEST_TR: {
			newDLeft = 0;
			newDTop = dy;
			newW = saveW + dx;
			newH = saveH - dy;
			break;
		}
		case Shape.HIT_TEST_ML: {
			newDLeft = dx;
			newW = saveW - dx;		
			break;
		}			
		case Shape.HIT_TEST_MR: {
			newW = saveW  + dx;				
			break;
		}				
		case Shape.HIT_TEST_BL: {
			newDLeft = dx;
			newW = saveW - dx;
			newH = saveH + dy;			
			break;
		}
		case Shape.HIT_TEST_BM: {
			newH = saveH + dy;			
			break;
		}			
		case Shape.HIT_TEST_BR: {
			newW = saveW + dx;
			newH = saveH + dy;			
			break;
		}			
		case Shape.HIT_TEST_MOVE: 
		case Shape.HIT_TEST_MM: {		
			newDLeft = dx;
			newDTop = dy;
			break;
		}
		case Shape.HIT_TEST_ROTATION: {
			var cx = (this.w >> 1) + this.getLeft();
			var cy = (this.h >> 1) + this.getTop();
			var angle = Math.lineAngle({x:cx, y:cy}, point) + Math.PI * 0.5;

			if(angle > Math.PI * 2) {
				angle = angle - Math.PI * 2;
			}
			this.setRotation(angle);
			this.onUserRotating();
			if(type === Shape.EVT_POINTER_UP) {
				var rotation = this.rotation;
				this.rotation = this.saveRotation;
				this.exec(AttributeCommand.create(this, "rotation", null, rotation));
			}
			break;
		}
		default:break;
	}	
	
	if(type === Shape.EVT_POINTER_UP) {
		if(!this.isUserMovable()) {
			this.setLeftTop(this.saveLeft, this.saveTop);
		}

		if(!this.isUserResizable()) {
			this.w = saveW;
			this.h = saveH;
		}
		
		var w = this.w;
		var h = this.h;
		var left = this.getLeft();
		var top = this.getTop();

		if(left !== this.saveLeft || top !== this.saveTop || w !== saveW || h !== saveH) {
			this.w = saveW;
			this.h = saveH;
			this.setLeftTop(this.saveLeft, this.saveTop);

			left = (left === this.saveLeft) ? null : Math.round(left);
			top = (top === this.saveTop) ? null : Math.round(top);
			w = (w === saveW) ? null : Math.round(w);
			h = (h === saveH) ? null : Math.round(h);

			this.execMoveResize(left, top, w, h);
			this.onUserMoved();
			this.onUserResized();
		}
	}
	else {
		if(newDLeft || newDTop) {
			if(this.isUserMovable()) {
				this.setLeftTop(Math.round(this.saveLeft + newDLeft), Math.round(this.saveTop + newDTop));
				this.onUserMoving();
			}
		}
		
		if(saveW !== newW || saveH !== newH) {
			if(this.isUserResizable()) {
				this.w = Math.max(Math.round(newW), this.MIN_SIZE);
				this.h = Math.max(Math.round(newH), this.MIN_SIZE);

				this.onUserResizing();
			}
		}
	}
	
	if(this.hitTestResult === Shape.HIT_TEST_HANDLE) {
		dx = point.x - this.lastPosition.x;
		dy = point.y - this.lastPosition.y;
		this.moveHandle(dx, dy);
	}
	
	this.postRedraw();
	
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;

	return true;
}

RShape.prototype.onKeyDown = function(code) {
	return;
}

RShape.prototype.onKeyUp = function(code) {
	return;
}		

RShape.prototype.toJson = function() {
	var o = {};

	return this.doToJson(o);
}

RShape.saveProps =  ["type", "name", "uid", "z", "w", "h", "pivotX", "pivotY", "rotation", "opacity", "hMargin", "vMargin", "scaleX", "scaleY", "spacer", "roundRadius", "runtimeVisible", "enable", "visible", "text", "iconVMargin", "iconHMargin", "locked"];

RShape.prototype.propsToJson = function(o, props) {
	var n = props.length;
	for(var i = 0; i < n; i++) {
		var key = props[i];
		var value = this[key];
		if(value !== undefined) {
			o[key] = value;
		}
	}

	return this;
}

RShape.prototype.propsFromJson = function(js, props) {
	var n = props.length;
	for(var i = 0; i < n; i++) {
		var key = props[i];
		var value = js[key];
		if(value !== undefined) {
			this[key] = value;
		}
	}

	return this;
}

RShape.prototype.doToJson = function(o) {
	this.propsToJson(o, RShape.saveProps);

	o.x = this.left;
	o.y = this.top;
	o.style = this.style.toJson();
	
	return o;
}

RShape.prototype.onFromJsonDone = function(js) {
}

RShape.prototype.fromJson = function(js) {
	this.isUnpacking = true;
	this.doFromJson(js);
	this.onFromJsonDone(js);
	this.isUnpacking = false;

	return this;
}

RShape.prototype.doFromJson = function(js) {
	this.textNeedRelayout = true;
	this.state = Shape.STAT_NORMAL;
	this.propsFromJson(js, RShape.saveProps);

	if(js.x !== undefined) {
		this.left = js.x;
	}
	if(js.y !== undefined) {
		this.top = js.y;
	}

    if(js.docURL !== undefined && js.docURL.length > 0) {
        this.docURL = js.docURL;
    }

	this.setText(js.text);
	this.setEnable(js.enable);
	this.setVisible(js.visible !== false);
	this.style.fromJson(js.style);

	return;
}

RShape.prototype.setImage = function(value) {
	if(value === this.imageUrl) {
		return;
	}

	this.imageUrl = value;
	this.image = new WImage(value);
	
	return this;
}


RShape.prototype.asIcon = function() {
	this.setSize(36, 36);

	if(!this.isIcon) {
		this.setStyle(Shape.getIconShapeStyle());
	}

	this.isIcon = true;

	return;
}	

RShape.prototype.showProperty = function() {
	var app = this.getApp();
	if(app) {
		app.showRShapePropertyDialog(this);
	}

	return;
}
	
RShape.prototype.getMoveDeltaX = function() {
	return this.view ? this.view.getMoveDeltaX() : 0; 
}

RShape.prototype.getMoveDeltaY = function() {
	return this.view ? this.view.getMoveDeltaY() : 0;
}

RShape.prototype.getMoveAbsDeltaX = function() {
	return this.view ? this.view.getMoveAbsDeltaX() : 0;
}

RShape.prototype.getMoveAbsDeltaY = function() {
	return this.view ? this.view.getMoveAbsDeltaY() : 0;
}

RShape.prototype.setRoundRadius = function(roundRadius) {
	this.roundRadius = roundRadius;

	return this;
}

RShape.prototype.setFillColor = function(fillColor) {
	this.style.setFillColor(fillColor);

	return this;
}

RShape.prototype.setLineColor = function(lineColor) {
	this.style.setLineColor(lineColor);

	return this;
}

RShape.prototype.setTextColor = function(textColor) {
	this.style.setTextColor(textColor);

	return this;
}

RShape.prototype.getFillColor = function() {
	return this.style.fillColor;
}

RShape.prototype.getLineColor = function() {
	return this.style.lineColor;
}

RShape.prototype.getTextColor = function() {
	return this.style.textColor;
}

Object.defineProperty(RShape.prototype, "x", {
	get: function () {
		return this.getX();
	},
	set: function (value) {
		this.setX(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "y", {
	get: function () {
		return this.getY();
	},
	set: function (value) {
		this.setY(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "left", {
	get: function () {
		return this.getLeft();
	},
	set: function (value) {
		this.setLeft(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "top", {
	get: function () {
		return this.getTop();
	},
	set: function (value) {
		this.setTop(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "width", {
	get: function () {
		return this.getWidth();
	},
	set: function (value) {
		this.setWidth(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "height", {
	get: function () {
		return this.getHeight();
	},
	set: function (value) {
		this.setHeight(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "anchorX", {
	get: function () {
		return this.getAnchorX();
	},
	set: function (value) {
		this.setAnchorX(value);
	},
	enumerable: true,
	configurable: true
});

Object.defineProperty(RShape.prototype, "anchorY", {
	get: function () {
		return this.getAnchorY();
	},
	set: function (value) {
		this.setAnchorY(value);
	},
	enumerable: true,
	configurable: true
});


function RShapeInit(g, type) {
	g.initRShape(0, 0, 40, 40, type);

	return g;
}

/*
 * File: shape_factory.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: register all built-in shapes.
 * 
 * Copyright (c) 2011 - 2014  Li XianJing <xianjimli@hotmail.com>
 * 
 */

var C_CREATE_FOR_USER = 0;
var C_CREATE_FOR_ICON = 1;
var C_CREATE_FOR_PROGRAM = 2;

function ShapeCreator(type, name, icon, visible) {
	this.type = type;
	this.icon = icon;
	this.name = name;
	this.visible = visible;

	this.isVisibleToUser = function() {
		return this.visible;
	}
	
	this.getID = function() {
		return this.type;
	}
	
	this.getIcon = function() {
		return this.icon;
	}
	
	this.getName = function() {
		return this.name;
	}

	this.createIconShape = function() {
		if(!this.iconShape) {
			this.iconShape = this.createShape(C_CREATE_FOR_ICON);
            this.iconShape.initIconShape();
		}
	
		return this.iconShape;
	}
	
	this.createShape = function(createReason) {
		return null;
	}
	
	return;
}

function ShapeFactory() {
	this.defaultCategory = null;
	this.recentUsed = [];
	this.creators = [];
	this.categories = {};
	this.categoryNames = [];
	this.diagramTypes = [];
	this.listeners = [];

	ShapeFactory.CATEGORY_RECENT_USED = "Recent Used";
	ShapeFactory.CATEGORY_USER_COMPONENTS = "User Component";
    ShapeFactory.CATEGORY_USER = "User";
    ShapeFactory.CATEGORY_GAME = "Game";
    ShapeFactory.CATEGORY_ORGANIZATION = "Organization";

	this.setDefaultCategory = function(defaultCategory) {
		this.defaultCategory = defaultCategory;

		return;
	}

	this.getDiagramTypes = function() {
		return this.diagramTypes;
	}

	this.addDiagramType = function(type, defaultCategory) {
		var obj = {name:type, defaultCategory:defaultCategory};

		this.diagramTypes.push(obj);

		return;
	}

	this.removeCategoryName = function(name) {
		this.categoryNames.remove(name);

		return;
	}

	this.removeShapeCreator = function(type, category) {
		var creator = this.find(type);
		var categoryCreators = this.categories[category];
		if(creator) {
			this.creators.remove(creator);
			if(categoryCreators) {
				categoryCreators.remove(creator);
				this.notifyChanged("remove", category, creator);
			}
		}

		return;
	}

	this.isPlacehodler = function(category) {
		return category === "---";
	}
	
	this.isUserComponents = function(category) {
		return category === ShapeFactory.CATEGORY_USER_COMPONENTS;
	}

	this.addPlaceholder = function() {
		this.categoryNames.push("---");

		return;
	}

	this.loadRecentUsedShapeCreators = function() {
		var str = WebStorage.get("recentUsed");
		var types = str ? JSON.parse(str) : [];

		for(var i = 0; i < types.length; i++) {
			var type = types[i];
			var creator = this.find(type);
			if(creator) {
				this.addShapeCreator(creator, ShapeFactory.CATEGORY_RECENT_USED);
				this.recentUsed.push(type);
			}
		}

		return;
	}

	this.addRecentUsedShapeCreator = function(type) {
		var creator = this.find(type);
		if(creator) {
			this.recentUsed.remove(type);
			this.recentUsed.push(type);

			if(this.recentUsed.length > 10) {
				this.recentUsed.shift();
			}
			WebStorage.set("recentUsed", JSON.stringify(this.recentUsed));

			this.addShapeCreator(creator, ShapeFactory.CATEGORY_RECENT_USED);
		}
	}

	this.addShapeCreator = function(creator, category) {
		this.notifyChanged("add", category, creator);

		if(category != ShapeFactory.CATEGORY_RECENT_USED) {
			this.creators.push(creator);
		}

		if(category) {
			if(!this.defaultCategory) {
				this.setDefaultCategory(category);
			}

			if(!this.categories[category]) {
				this.categories[category] = [];

				if(category == ShapeFactory.CATEGORY_RECENT_USED) {
					this.categoryNames.unshift(category);
				}
				else {
					this.categoryNames.push(category);
				}
			}
			
			this.categories[category].remove(creator);
			if(category == ShapeFactory.CATEGORY_RECENT_USED) {
				this.categories[category].unshift(creator);
			}
			else {
				this.categories[category].push(creator);
			}
		}
//		console.log("Register: category=" + category + " id=" + creator.getID());

		return;
	}

	this.getCategoryNames = function() {
		return this.categoryNames;
	}
	
	this.getDefaultCategory = function() {
		return this.categories[this.defaultCategory];
	}

	this.getByCategory = function(category) {
		return this.categories[category];
	}
	
	this.find = function(type) {
		for(var i = 0; i < this.creators.length; i++) {
			var c = this.creators[i];
			if(c.getID() === type) {
				return c;
			}
		}
		
		return null;
	}

	this.createShapeByUser = function(type, exactly) {
		return this.createShape(type, C_CREATE_FOR_USER, exactly);
	}
	
	this.createShapeByProgram = function(type, exactly) {
		return this.createShape(type, C_CREATE_FOR_PROGRAM, exactly);
	}

	this.createShape = function(type, createReason, exactly) {
		if(!type) {
			return null;
		}

		var c = this.find(type);
		if(c) {
			var s = c.createShape(createReason);
            if(createReason === C_CREATE_FOR_USER) {
                s.initPanelShape(); 
            }
            return s;
		}
		
		console.log("not found type " + type + ", create ui-unkown instead.");

		if(!exactly) {
			c = this.find("ui-unkown");
			if(c) {
				return c.createShape(createReason);
			}

			return null;
		}
	}

	this.addListener = function(func) {
		this.listeners.push(func);

		return this;
	}

	this.removeListener = function(func) {
		this.listeners.remove(func);

		return this;
	}
	
	this.notifyChanged = function(type, category, creator) {
		var listeners = this.listeners;
		for(var i = 0; i < listeners.length; i++) {
			var func = listeners[i];
			if(func) {
				func(type, category, creator);
			}
		}

		return;
	}

	return;
}

ShapeFactory.instance = null;

ShapeFactory.getInstance = function() {
	if(!ShapeFactory.instance) {
		ShapeFactory.instance = new ShapeFactory();
		setTimeout(function() {
			ShapeFactory.instance.loadRecentUsedShapeCreators();
		}, 2000);
	}

	return ShapeFactory.instance;
}


function ShapeFactoryGet() {
	return ShapeFactory.getInstance();
}

function dappSetDefaultCategory(name) {
	return ShapeFactory.getInstance().setDefaultCategory(name);
}

function cantkRegShapeCreator(creator, category) {
	return ShapeFactory.getInstance().addShapeCreator(creator, category);
}
/*
 * File: view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief: view
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TView() {
}

TView.prototype = new WWidget();

TView.prototype.init = function(parent, x, y, w, h) {
	WWidget.prototype.init.call(this, parent, x, y, w, h);

	this.scale = 1;
	this.wmRect = {};
	this.lastPointerPosition = {x:0, y:0};
	this.pointerDownPosition = {x:0, y:0};

	return this;
}

TView.prototype.setDoc = function(doc) {
	this.doc = doc;

	return this;
}

TView.prototype.loadJson = function(json) {
	return this.doc.loadJson(json);
}

TView.prototype.loadString = function(str) {
	return this.doc.loadString(str);
}

TView.prototype.loadURL = function(url) {
	return this.doc.loadURL(url);
}

TView.prototype.getDeviceConfig = function() {
	return this.doc.getDeviceConfig();
}

TView.prototype.getWindowManager = function() {
	return this.doc.getWindowManager();
}

TView.prototype.getCurrentWindow = function() {
	return this.doc.getCurrentWindow();
}

TView.prototype.getMetaInfo = TView.prototype.getMeta = function() {
	return this.doc.getMeta();
}

TView.prototype.getMoveDeltaX = function() {
	return this.moveDeltaX;
}

TView.prototype.getMoveDeltaY = function() {
	return this.moveDeltaY;
}

TView.prototype.getMoveAbsDeltaX = function() {
	return this.moveAbsDeltaX;
}

TView.prototype.getMoveAbsDeltaY = function() {
	return this.moveAbsDeltaY;
}

TView.prototype.updateLastPointerPoint = function(point, pointerDown) {
	if(pointerDown) {
		this.pointerDownPosition.x = point.x;
		this.pointerDownPosition.y = point.y;
	}

	this.moveDeltaX = point.x - this.lastPointerPosition.x;
	this.moveDeltaY = point.y - this.lastPointerPosition.y;
	this.moveAbsDeltaX = point.x - this.pointerDownPosition.x;
	this.moveAbsDeltaY = point.y - this.pointerDownPosition.y;
	this.lastPointerPosition.x = point.x;
	this.lastPointerPosition.y = point.y;

	return;
}

TView.prototype.autoScale = function() {
	var wm = this.getWindowManager();

	if(!wm) return;
	
	var scale = 1;
	var w = this.getWidth();
	var h = this.getHeight();
	
	if(wm.w < wm.h) {
		scale = h/(wm.h+100);
	}
	else {
		scale = w/(wm.w+100);
	}

	if(scale > 1) {
		scale = 1;
	}

	this.zoomTo(scale);

	return;
}

TView.prototype.getScale = function() {
	return this.scale;
}

TView.prototype.onScaled = function(scale) {
	return;
}

TView.prototype.zoomTo = TView.prototype.setScale = function(scale) {

	this.scale = Math.min(2, Math.max(0.5, Math.round(scale * 10)/10));
	this.onScaled(this.scale);

	return this;
}

TView.prototype.zoomIn = function() {
	return this.zoomTo(this.scale * 1.2);
}

TView.prototype.zoomOut = function() {
	return this.zoomTo(this.scale * 0.8);
}

TView.prototype.getWmRect = function() {
	var r = this.wmRect;
	var wm = this.getWindowManager();
	if(wm) {
		var w = this.getWidth();
		var h = this.getHeight();
		r.w = wm.w * this.scale;
		r.h = wm.h * this.scale;
		r.x = (w - r.w) >> 1;
		r.y = (h - r.h) >> 1;
	}
	else {
		r.x = 0;
		r.y = 0;
		r.w = 0;
		r.h = 0;
	}

	return r;
}

TView.prototype.paintSelf = function(canvas) {
	var w = this.getWidth();
	var h = this.getHeight();

	canvas.save();
	canvas.beginPath();
	canvas.rect(0, 0, w, h);
	canvas.clip();
	canvas.beginPath();	

	var wm = this.getWindowManager();
	if(wm) {
		var r = this.getWmRect();	
		canvas.translate(r.x, r.y);
		canvas.scale(this.scale, this.scale);
		wm.setLeftTop(0, 0);
		wm.paintSelf(canvas);
	}
	canvas.restore();

	return;
}

TView.prototype.translatePointToWm = function(point) {
	var r = this.getWmRect();
	var pos = this.translatePoint(point);
	var p = {x:pos.x-r.x, y:pos.y-r.y};
			
	p.x = p.x/this.scale;
	p.y = p.y/this.scale;

	return p;
}

TView.prototype.translatePointToView = function(point) {
    var p = {x:point.x, y:point.y};
    
    var wm = this.getWindowManager();
    p.x += wm.getX();
    p.y += wm.getY();

    return p;
}

TView.prototype.onDoubleClick = function(point) {
	this.updateLastPointerPoint(point, true);

	WWidget.prototype.onDoubleClick.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);

			wm.onDoubleClick(p);
		}
	}

	return;
}

TView.prototype.onPointerDown = function(point) {
	this.updateLastPointerPoint(point, true);

	WWidget.prototype.onPointerDown.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);

			wm.onPointerDown(p);
		}
	}

	return;
}

TView.prototype.onPointerMove = function(point) {
	this.updateLastPointerPoint(point);
	WWidget.prototype.onPointerMove.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);
			wm.onPointerMove(p);
		}
	}

	return;
}

TView.prototype.onPointerUp = function(point) {
	WWidget.prototype.onPointerUp.call(this, point);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			var p = this.translatePointToWm(point);
			wm.onPointerUp(p);
		}
	}

	return;
}

TView.prototype.onKeyDown = function(code) {
	WWidget.prototype.onKeyDown.call(this, code);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			wm.onKeyDown(code);
		}
	}

	return;
}

TView.prototype.onKeyUp = function(code) {
	WWidget.prototype.onKeyUp.call(this, code);
	if(!this.target) {
		var wm = this.getWindowManager();
		if(wm) {
			wm.onKeyUp(code);
		}
	}

	return;
}

TView.prototype.detectDeviceConfig = function() {
	return this.doc.detectDeviceConfig();
}
/*
 * File: document.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: document
 *
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 *
 */

function TDocument() {
}

TDocument.magic = "cantk";
TDocument.prototype.loadURL = function(url) {
	httpGetJSON(url, this.loadJson.bind(this));

	return this;
}

TDocument.prototype.loadString = function(str) {
	try {
		var json = JSON.parse(str);
		this.loadJson(json);
	}catch(e) {
		console.log("loadString:" + e.message);
	}

	return this;
}

TDocument.prototype.getEmptyDoc = function() {
	var doc = {};
	doc.version = 2;
	doc.magic = TDocument.magic;

	return doc;
}

TDocument.prototype.getLocales = function() {
	if(!this.doc.locales) {
		this.doc.locales = {
			"default":{},
			"en":{},
			"zh": {}
		};
	}

	return this.doc.locales;
}

TDocument.prototype.getAssetsConfig = function() {
	var meta = this.getMeta();

	return meta.assetsConfig || TDocument.getDefaultAssetsConfig();
}

TDocument.prototype.getAssetsConfigStr = function() {
	var config = this.getAssetsConfig();

	return JSON.stringify(config, null, "\t");
}

TDocument.prototype.setAssetsConfigStr = function(str) {
	try {
		var config = JSON.parse(str);
		this.setAssetsConfig(config);
	}catch(e) {
		console.log("setAssetsConfigStr:" + e.message);
	}

	return this;
}

TDocument.prototype.setAssetsConfig = function(config) {
	var meta = this.getMeta();
	meta.assetsConfig = config;

	return this;
}

TDocument.getDefaultAssetsConfig = function() {
	if(!TDocument.defaultAssetsConfig) {
		var c = {};
		c.assets = {};
		c.assets.sizes = ["1280x800", "480x800"];
		c.assets.densities = ["hdpi", "xhdpi"];
		c.assets.languages = ["en", "zh"]

		c.design = {};
		c.design.size = "480x800";
		c.design.density = "hdpi";
		c.design.language = "en";

		c.map = {}
		c.map.size = {
			"1280x720":"480x800",
			"480x800":"480x800"
		};
		c.map.density = {
			"ldpi":"hdpi",
			"mdpi":"hdpi",
			"xhdpi":"hdpi",
			"xxhdpi":"hdpi"
		};
		c.map.language = {
			"en":"en",
			"zh":"en"
		}

		TDocument.defaultAssetsConfig = c;
	}

	return TDocument.defaultAssetsConfig;
}

TDocument.prototype.setLocales = function(locales) {
	this.doc.locales = locales;

	return this;
}

TDocument.prototype.getMetaInfo = TDocument.prototype.getMeta = function() {
	return this.doc.meta;
}

TDocument.prototype.getDocID = function() {
	return this.doc.docid;
}

TDocument.prototype.getDeviceConfig = function() {
	return this.wm.deviceConfig;
}

TDocument.prototype.loadV1 = function(json) {
	if(!json.pages || !json.pages[0].shapes || !json.pages[0].shapes[0].children) {
		return this;
	}

	var doc = this.getEmptyDoc();
	doc.meta = json.meta;
	doc.docid = json.docid;

	var device = json.pages[0].shapes[0];
	function forEach(shape) {

		if(shape.type === "ui-window-manager") {
			doc.wm = shape;

			return;
		}

		if(shape.children) {
			var n = shape.children.length;
			for(var i = 0; i < n; i++) {
				var iter = shape.children[i];
				forEach(iter);
			}
		}
	}

	forEach(device);

	doc.deviceConfig = device.config;
	this.loadV2(doc);

	return ;
}

TDocument.prototype.createWindowManager = function(json) {
	var factory = ShapeFactory.getInstance();
	var wm = factory.createShapeByProgram(json.wm.type);

	wm.fromJson(json.wm);
	wm.deviceConfig = json.deviceConfig;

	return wm;
}

TDocument.prototype.onBeforeLoad = function(json) {
}

TDocument.prototype.loadV2 = function(json) {
	this.doc = json;

	this.onBeforeLoad(json);
	this.wm = this.createWindowManager(json);

	var meta = this.getMeta();
    if(meta && meta.general) {
        document.title = meta.general.appname;
    }
	if(meta && meta.extfonts) {
		ResLoader.loadFonts(meta.extfonts);
	}


    var keys = ["soundMusicAutoPlay", "soundMusicLoop", "soundMusicVolume",
        "soundMusicURLs", "soundEffectsEnalbe", "soundEffectVolume", "soundEffectURLs"];
    keys.forEach(function(it) {
        if(it in json.wm) {
            this.wm[it] = json.wm[it];
        }
    }, this);

    var wm = this.wm;
    if(meta && meta.soundConfig) {
        var keys = ["soundMusicAutoPlay", "soundMusicLoop", "soundMusicVolume", "soundMusicURLs", "soundEffectsEnalbe", "soundEffectVolume", "soundEffectURLs"];
        keys.forEach(function(key) {
            wm[key] = meta.soundConfig[key];
        })

        wm.setSoundMusicVolume(wm.soundMusicVolume);
        wm.setSoundEffectVolume(wm.soundEffectVolume);
    }

	this.onLoad();

	return;
}

TDocument.prototype.loadJson = function(json) {
	if(!json) return this;

	if(json.magic === "drawapps") {
		this.loadV1(json);
	}
	else if(json.magic === TDocument.magic) {
		this.loadV2(json);
	}
    else if(json.code === 302) {
        window.location.href = json.data;
    }
	else {
		console.log("invalid json");
	}

	return this;
}

TDocument.prototype.getWindowManager = function() {
	return this.wm;
}

TDocument.prototype.getCurrentWindow = function() {
	return this.wm ? this.wm.getCurrentWindow() : null;
}

TDocument.prototype.detectDeviceConfig = function() {
	if(this.detectedDeviceConfig) {
		return this.detectedDeviceConfig;
	}

	var deviceConfig = {version:4};

	if(isAndroid()) {
		deviceConfig.platform = "android";
	}
	else if(isIPhone () || isIPad()) {
		deviceConfig.platform = "iphone";
	}
	else if(isFirefoxOS()) {
		deviceConfig.platform = "firefox";
	}
	else if(isWinPhone()) {
		deviceConfig.platform = "winphone";
	}
	else if(isTizen()) {
		deviceConfig.platform = "tizen";
	}
	else {
		deviceConfig.platform = "android";
	}

	if(window.devicePixelRatio > 2.2) {
		deviceConfig.lcdDensity = "xxhdpi";
	}
	else if(window.devicePixelRatio > 1.5) {
		deviceConfig.lcdDensity = "xhdpi";
	}
	else if(window.devicePixelRatio > 1.1) {
		deviceConfig.lcdDensity = "hdpi";
	}
	else if(window.devicePixelRatio > 0.8) {
		deviceConfig.lcdDensity = "mdpi";
	}
	else if(!window.devicePixelRatio) {
		var minSize = Math.min(window.orgViewPort.width, window.orgViewPort.height);
		if(minSize > 600) {
			deviceConfig.lcdDensity = "xhdpi";
		}
		else {
			deviceConfig.lcdDensity = "hdpi";
		}
	}
	else {
		deviceConfig.lcdDensity = "ldpi";
	}

	if(isFirefoxOS()) {
		deviceConfig.lcdDensity = "mdpi";
	}

	if(!isMobile()) {
		deviceConfig.lcdDensity = "hdpi";
	}

	this.detectedDeviceConfig = deviceConfig;
//	console.log("deviceConfig.lcdDensity:" + deviceConfig.lcdDensity);
//	console.log("deviceConfig.platform:" + deviceConfig.platform);

	return deviceConfig;
}

/*
 * File: runtime_view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  runtime view 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TRuntimeView() {
}

TRuntimeView.prototype = new TView();
TRuntimeView.prototype.init = function(parent, x, y, w, h, app) {
	this.app = app;
	this.type = "app-view";
	TView.prototype.init.call(this, parent, x, y, w, h);
	
	this.preview = app.preview;
	this.setDoc(new TRuntimeDocument());

	this.doc.onLoad = this.onLoad.bind(this);
	WWindowManager.onMultiTouch = this.onMultiTouch.bind(this);
	WWindowManager.instance.drawWindows = this.paintSelf.bind(this);

	return this;
}

TRuntimeView.prototype.onMultiTouch = function(action, points, event) {
	var wm = this.getWindowManager();
	if(wm) {
		wm.onMultiTouch(action, points, event);
	}
}

TRuntimeView.prototype.resizeForFixWidth = function(wm) {
	var vp = cantkGetViewPort();
	var scale = wm.w/vp.width;
	var w = wm.w;
	var h = vp.height * scale;

	var styleW = vp.width;
	var styleH = vp.height;

	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.setSize(w, h);
	wm.relayout();
}

TRuntimeView.prototype.resizeForFixHeight = function(wm) {
	var vp = cantkGetViewPort();
	var scale = wm.h/vp.height;
	var h = wm.h;
	var w = vp.width * scale;

	var styleW = vp.width;
	var styleH = vp.height;

	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.setSize(w, h);
	wm.relayout();
}

TRuntimeView.prototype.resizeForFixResolution = function(wm) {
	var vp = cantkGetViewPort();
	var scalex = wm.w/vp.width;
	var scaley = wm.h/vp.height;
	var scale = Math.max(scalex, scaley);
	var w = scale * vp.width;
	var h = scale * vp.height;
	var styleW = vp.width;
	var styleH = vp.height;
	var x = (w - wm.w) >> 1;
	var y = (h - wm.h) >> 1;

	wm.setLeftTop(x, y);
	this.app.resizeWin(w,  h);
	this.app.resizeCanvas(w, h, 0, 0, styleW, styleH);
	WWindowManager.setInputScale(scale, scale);
	wm.relayout();
}

TRuntimeView.prototype.translatePointToWm = function(point) {
	return point;
}

TRuntimeView.prototype.resizeForAuto = function(wm) {
	var vp = cantkGetViewPort();
	wm.setSize(vp.width, vp.height);
	wm.relayout();
}

TRuntimeView.prototype.adjustWMSizePositionPreview = function(wm) {
	var vp = cantkGetViewPort();
	var w = wm.w;
	var h = wm.h;
	var scale = Math.min(1, Math.min(vp.width/w, vp.height/h));
	var styleW = w * scale;
	var styleH = h * scale;

	var x = (vp.width - styleW) >> 1;
	var y = (vp.height - styleH) >> 1;

	wm.setLeftTop(0, 0);
	this.app.resizeWin(w, h);
	this.app.resizeCanvas(w, h, x, y, styleW, styleH);
	WWindowManager.setInputOffset(x, y);
	WWindowManager.setInputScale(1/scale, 1/scale);

	wm.relayout();
}

TRuntimeView.prototype.adjustWMSizePositionRun = function(wm) {
	var meta = this.getMeta();
	var general = meta.general;
	var orientation = general.orientation;

	wm.forcePortrait = false;
	wm.forceLandscape = false;
	var designWidth = this.designWidth;
	var designHeight = this.designHeight;

	if(orientation === "landscape" && designWidth > designHeight) {
		wm.forceLandscape = true;
	}
	else if(orientation === "portrait" && designHeight > designWidth) {
		wm.forcePortrait = true;
	}
	wm.screenScaleMode = general.screenscale; 
	
	wm.setLeftTop(0, 0);
	switch(wm.screenScaleMode) {
		case "fix-width": {
			this.resizeForFixWidth(wm);
			break;
		}
		case "fix-height": {
			this.resizeForFixHeight(wm);
			break;
		}
		case "fix-resolution": {
			this.resizeForFixResolution(wm);
			break;
		}
		default: {
			this.resizeForAuto(wm);
			break;
		}
	}

	return;
}

TRuntimeView.prototype.adjustWMSizePosition = function() {
	var wm = this.getWindowManager();

	if(this.preview) {
		return this.adjustWMSizePositionPreview(wm);
	}
	else {
		return this.adjustWMSizePositionRun(wm);
	}
}

TRuntimeView.prototype.onLoad = function() {
	var wm = this.getWindowManager();
	var meta = this.getMeta();

	if(meta.general.useWebGL) {
		WWindowManager.setCanvasContextName("2d-webgl");
	}

	//for preview current window
	if(window.cantkInitWindow !== undefined) {
		wm.setInitWindow(window.cantkInitWindow);
		console.log("window.cantkInitWindow:" + window.cantkInitWindow);
	}

    wm.setView(this);
    wm.setApp(this.app);
	wm.setMode(Shape.MODE_RUNNING, true);

	this.designWidth = wm.w;
	this.designHeight = wm.h;
	this.adjustWMSizePosition();
	this.run();
}

TRuntimeView.prototype.paintLoading = function(canvas) {
}

TRuntimeView.prototype.getViewScale = function() {
	return 1;
}

TRuntimeView.prototype.paintSelf = function(canvas) {
	var wm = this.getWindowManager();
	if(!wm) {
		this.paintLoading(canvas);

		return;
	}

	canvas.save();
	wm.paint(canvas);
	canvas.restore();

	var sx = wm.x;
	var sy = wm.y;
	var sw = wm.w;
	var sh = wm.h;
	var w = this.rect.w;
	var h = this.rect.h;

	canvas.beginPath();
	if(sy > 0) {
		canvas.rect(0, 0, w, sy);
	}
	if(sx > 0) {
		canvas.rect(0, 0, sx, h);
	}
	var r = sx + sw;
	var rw = w - r;
	if(rw > 0) {
		canvas.rect(r, 0, rw, h);
	}
	var b = sy + sh;
	var bh = h - b;
	if(bh > 0) {
		canvas.rect(0, b, w, bh);
	}

	if(sy > 0 || sx > 0 || rw > 0 || bh > 0) {
		canvas.fillStyle = wm.style.fillColor;
		canvas.fill();
	}

	return;
}

TRuntimeView.prototype.onGesture = function(gesture) {
	var curWin = wm.getCurrentWindow();

	curWin.onGesture(gesture);

	return;
}

TRuntimeView.prototype.getAppInfo = function() {
	var metaInfo = this.getMetaInfo();

	return metaInfo.general;
}

TRuntimeView.prototype.onLoadUserScriptsDone = function() {
	var appInfo = this.getAppInfo();
	HolaSDK.init(appInfo.appid, false);
	console.log("TRuntimeView.prototype.onLoadUserScriptsDone.");
}

TRuntimeView.prototype.loadUserScripts = function(meta) {
	if(meta) {
		var scripts = meta.extlibs;
		var force = window.location.href.indexOf("appid=preview") > 0;
		
		if(!scripts) {
			scripts = [];
		}

//		scripts.push(HolaSDK.getSDKURL());

        if(scripts.length > 0) {
            //make a sort
            var userLibs = [];
            var extLibs = [];
            scripts.forEach(function(script) {
                if(script.indexOf("read.php?") > 0 && script.indexOf("/libs/") > 0) {
                    var t = meta.docSavedTime ? meta.docSavedTime : Date.now();
                    userLibs.push(script + "&timestamp=" + t);
                } else {
                    extLibs.push(script);
                }
            });
            userLibs.sort();
            scripts = extLibs.concat(userLibs);
        }
		
        if(scripts) {
			var arr = [];
			for(var i = 0; i < scripts.length; i++) {
				var iter = scripts[i];
				if(iter.indexOf("res.wx.qq.com") >= 0 && !isWeiXin()) {
					console.log("not weixin browser skip weixin jssdk");
					continue;
				}
				arr.push(iter);
			}

			if(arr.length) {
				ResLoader.loadScriptsSync(arr, this.onLoadUserScriptsDone.bind(this));
			}
		}
	}

	return;
}

TRuntimeView.prototype.paintBackground = function(canvas) {
}

TRuntimeView.prototype.startRedrawTimer = function(fps) {
	var fps = fps || 60;
	var dt = 1000/fps;
	var wm = WWindowManager.getInstance();

	setInterval(wm.postRedraw.bind(wm), dt);

	return;
}

TRuntimeView.prototype.run = function() {
	var meta = this.getMeta();
	var wm = this.getWindowManager();
	var runtimeConfig = this.detectDeviceConfig();

	if(this.preview) {
		runtimeConfig.lcdDensity = wm.deviceConfig.lcdDensity;
	}

	wm.setDeviceConfig(runtimeConfig);

	this.modifyTitle(meta);
	this.loadUserScripts(meta);
	this.startRedrawTimer(meta.general.fps);

	wm.systemInit();
	wm.postRedraw();

	return;
}

TRuntimeView.prototype.modifyTitle = function(meta) {
	if(meta && meta.general) {
		var appname = meta.general.appname;

		document.title = appname;
		if(isIPhone() || isIPad()) {
			var tags = document.getElementsByTagName("title");
			if(tags && tags.length) {
				var title = tags[0];
				title.innerHTML = appname;
            }
		}
	}
}

TRuntimeView.create = function(parent, x, y, w, h, app) {
	var view = new TRuntimeView();
	return view.init(parent, x, y, w, h, app);
}

function dappGetText(text) {
	return text;
}

function dappIsEditorApp() {
	return false;
}

/*
 * File: runtime_document.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: runtime document 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TRuntimeDocument() {
}

TRuntimeDocument.prototype = new TDocument();

TRuntimeDocument.prototype.updateAssetsMapRule = function(assetsConfig) {
	var key = null;
	var mapped = assetsConfig.mapped;
	var runtime = assetsConfig.runtime;
	var design = assetsConfig.design;

	var mapLanguage = assetsConfig.map.language;
	for(key in mapLanguage) {
		if(runtime.language.indexOf(key) >= 0) {
			mapped.language = mapLanguage[key];
			break;
		}
	}
	if(!mapped.language) {
		mapped.language = design.language;
	}

	var mapSize = assetsConfig.map.size;
	for(key  in mapSize) {
		if(key === runtime.size) {
			mapped.size = mapSize[key];
		}
	}
	if(!mapped.size) {
		mapped.size = design.size;
	}

	var mapDensity = assetsConfig.map.density;
	for(key  in mapDensity) {
		if(key === runtime.density) {
			mapped.density = mapDensity[key];
		}
	}
	if(!mapped.density) {
		mapped.density = design.density;
	}

	return this;
}

TRuntimeDocument.prototype.fixAssetsConfig = function(assetsConfig) {
	var runtime = {};
	var vp = cantkGetViewPort();
	var config = this.detectDeviceConfig();

	runtime.width = vp.width;
	runtime.height = vp.height;
	runtime.density = config.lcdDensity;
	runtime.language = Locales.getLang();
	runtime.size = runtime.width+"x"+runtime.height;

	assetsConfig.mapped = {};
	assetsConfig.runtime = runtime;

	this.updateAssetsMapRule(assetsConfig);

	return this;
}

TRuntimeDocument.prototype.createWindowManager = function(json) {
	var assetsConfig = this.getAssetsConfig();
	if(assetsConfig) {
		this.fixAssetsConfig(assetsConfig);
		ResLoader.setAssetsConfig(assetsConfig);
		ResLoader.mapImageURL = this.mapAssetURL.bind(this);
	}

	return TDocument.prototype.createWindowManager.call(this, json);
}

TRuntimeDocument.prototype.applyLocales = function(json) {
	var stringTable = null;
	var locales = json.locales;
	var name = Locales.getLang();

	if(!locales) return;

	for(var key in locales) {
		var keys = key.toLowerCase().split(";");
		for(var i = 0; i < keys.length; i++) {
			var iter = keys[i];
			if(iter === name || name.startWith(iter)) {
				stringTable = locales[key];
				console.log("Matched locale:" + name + " ==> " + key);
				break;
			}
		}
		if(stringTable) break;
	}

	if(!stringTable) {
		stringTable = locales["default"];
		if(stringTable) {
			console.log("Matched locale:" + name + " ==> default");
		}
	}

	if(stringTable) {
		webappSetLocaleStrings(stringTable);
	}

	return;
}

TRuntimeDocument.prototype.onBeforeLoad = function(json) {
	this.applyLocales(json);
}

TRuntimeDocument.prototype.mapAssetURL = function(url, assetsConfig) {
	if(!assetsConfig || !url || url.length > 1024) {
		return url;
	}

	var design = assetsConfig.design;
	var mapped = assetsConfig.mapped;
	
	if(design.language !== mapped.language && url.indexOf(design.language) >= 0) {
		url = url.replace(new RegExp(design.language, "g"), mapped.language);
	}

	if(design.density !== mapped.density && url.indexOf(design.density) >= 0) {
		url = url.replace(new RegExp(design.density, "g"), mapped.density);
	}

	if(design.size !== mapped.size && url.indexOf(design.size) >= 0) {
		url = url.replace(new RegExp(design.size, "g"), mapped.size);
	}

	return url;
}

/*
 * File: webapp.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  web app.
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function TWebApp(preview) {
	document.body.style.overflow = "hidden";
	this.viewPort = cantkGetViewPort();

	this.preview = !!preview; 
	this.init(preview);

	return this;
}

TWebApp.prototype.prepareCanvas = function() {
	this.canvas	 = CantkRT.getMainCanvas();

	var canvas = this.canvas;
	var vp = cantkGetViewPort();
	var w = vp.width;
	var h = vp.height;
	CantkRT.resizeMainCanvas(w, h, w, w);

	this.manager = WWindowManager.create(this, this.canvas, this.canvas);

	return;
}

TWebApp.prototype.init = function() {
	this.prepareCanvas();
	var w = this.canvas.width;
	var h = this.canvas.height;

	var app = this;
	this.win = WWindow.create(this.manager, 0, 0, w, h);
	this.view = TRuntimeView.create(this.win, 0, 0, w, h, this);
	
	var view = this.view;
	this.win.paintBackground = function(canvas) {
	};
	
	this.win.onGesture = function(gesture) {
		return view.onGesture(gesture);
	};

	window.onresize = function() {
		setTimeout(app.onSizeChanged.bind(app), 50);
	}

	return;
}


TWebApp.prototype.resizeWin = function(w, h) {
	this.win.resize(w, h);
	this.view.resize(w, h);
}

TWebApp.prototype.resizeCanvas = function(w, h, x, y, styleW, styleH) {
	var canvas = this.canvas;

	CantkRT.moveMainCanvas(x, y);
	CantkRT.resizeMainCanvas(w, h, styleW, styleH);

	return;
}

TWebApp.prototype.onSizeChanged = function() {
	var viewPort = cantkGetViewPort();

	if(EditorElement.imeOpen) {
		console.log("EditorElement.imeOpen is true.");
		return;
	}

	if(viewPort.width === this.viewPort.width && viewPort.height === this.viewPort.height) {
		console.log("onSizeChanged: size is not changed.");
		return;
	}

	var w = viewPort.width;
	var h = viewPort.height;
	this.viewPort = viewPort;
	this.manager.resize(w, h);
	this.view.adjustWMSizePosition();
	UIElement.getMainCanvasScale(true);
}

TWebApp.prototype.exitApp = function() {
	if(isTizen()) {
		tizen.application.getCurrentApplication().exit();
	}
	else if(navigator.app) {
		navigator.app.exitApp();
	}
	console.log("exitApp");
	return;
}

TWebApp.prototype.runWithURL = function(url) {
	this.view.loadURL(url);
	return this;
}

TWebApp.prototype.runWithData = function(json) {
	if(typeof json === "string") {
		this.view.loadString(json);
	}
	else {
		this.view.loadJson(json);
	}
	return this;
}

window.webappRunWithURL = function(url) {
	var app = new TWebApp();
	
	return app.runWithURL(url);
}

window.webappRunWithData = function(json) {
	var app = new TWebApp();
	
	return app.runWithData(json);
}

window.webappPreviewWithURL = function(url) {
	var app = new TWebApp(true);
	
	return app.runWithURL(url);
}

window.webappPreviewWithData = function(json) {
	var app = new TWebApp(true);
	
	return app.runWithData(json);
}

window.webappGetText = webappGetText;
window.webappSetLocaleStrings = webappSetLocaleStrings;

window.webappSnapshot = function() {
	var canvas = CantkRT.getMainCanvas();
	var dataURL = canvas.toDataURL();
	
	var image = {};
	image.src = dataURL;
	image.width = canvas.width;
	image.height = canvas.height;

	return image;
}

function dupDeviceConfig(config) {
	var o = {};

	o.name = config.name;
	o.bg = config.bg
	o.platform = config.platform;
	o.version = config.version;
	o.lcdDensity = config.lcdDensity;
	o.width = config.width;
	o.height = config.height;
	o.screenX = config.screenX;
	o.screenY = config.screenY;
	o.screenW = config.screenW;
	o.screenH = config.screenH;
	o.hasMenuBar = config.hasMenuBar;

	return o;
}
	
function cantkDetectDeviceConfig() {
	var deviceConfig = {version:4};
		
	if(isAndroid()) {
		deviceConfig.platform = "android";
	}
	else if(isIPhone () || isIPad()) {
		deviceConfig.platform = "iphone";
	}
	else if(isFirefoxOS()) {
		deviceConfig.platform = "firefox";
	}
	else if(isWinPhone()) {
		deviceConfig.platform = "winphone";
	}
	else if(isTizen()) {
		deviceConfig.platform = "tizen";
	}
	else {
		deviceConfig.platform = "android";
	}

	if(window.devicePixelRatio > 2.2) {
		deviceConfig.lcdDensity = "xxhdpi";
	}
	else if(window.devicePixelRatio > 1.5) {
		deviceConfig.lcdDensity = "xhdpi";
	}
	else if(window.devicePixelRatio > 1.1) {
		deviceConfig.lcdDensity = "hdpi";
	}
	else if(window.devicePixelRatio > 0.8) {
		deviceConfig.lcdDensity = "mdpi";
	}
	else if(!window.devicePixelRatio) {
		var minSize = Math.min(window.orgViewPort.width, window.orgViewPort.height);
		if(minSize > 600) {
			deviceConfig.lcdDensity = "xhdpi";
		}
		else {
			deviceConfig.lcdDensity = "hdpi";
		}
	}
	else {
		deviceConfig.lcdDensity = "ldpi";
	}

	if(isFirefoxOS()) {
		deviceConfig.lcdDensity = "mdpi";
	}

	if(!isMobile()) {
		deviceConfig.lcdDensity = "hdpi";
	}

	console.log("deviceConfig.lcdDensity:" + deviceConfig.lcdDensity);
	console.log("deviceConfig.platform:" + deviceConfig.platform);

	return deviceConfig;
}

function isDeviceConfigEqual(c1, c2) {
	var s1 = JSON.stringify(c1);
	var s2 = JSON.stringify(c2);

	return s1 === s2;
}

function cantkPreloadImage(src) {
	var image = new WImage(src);

	return image;
}
	
var gTempCanvas = null;
function cantkGetTempCanvas(width, height) {
	if(!gTempCanvas) {
		gTempCanvas = document.createElement("canvas");

		gTempCanvas.type = "backend_canvas";
		gTempCanvas.width = width;
		gTempCanvas.height = height;
	}

	if(gTempCanvas) {
		if(gTempCanvas.width != width) {
			gTempCanvas.width = width;
		}

		if(gTempCanvas.height != height) {
			gTempCanvas.height = height;
		}
	}

	return gTempCanvas;
}

//////////////////////////////////////////////////////////////////////////}-{

var gApp8LocaleStrings = {
	'Loading...':'正在努力加载...'
};

function webappGetText(text) {
	var str = null;
	if(!text) {
		return "";
	}

	if(gApp8LocaleStrings) {
		str = gApp8LocaleStrings[text];
	}

	if(!str) {
		str = text;
//		console.log("\""+text+"\":" + "\"" +text+ "\",");
	}

	return str;
}

function webappSetLocaleStrings(strs) {
	gApp8LocaleStrings = strs;

	return;
}

/*
 * File: ui_animation.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: ui animation.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

//////////////////////////////////////////////////

VelocityTracker.prototype.HISTORY_SIZE = 20;
VelocityTracker.prototype.HORIZON = 200 * 1000000;
VelocityTracker.prototype.MIN_DURATION = 10 * 1000000;

function Movement() {
	this.eventTime = 0;
	this.point = new Point(0, 0);

	this.getPoint = function() {
		return this.point;
	}

	return this;
}

function VelocityTracker() {
    this.clear();

    return this;
}

VelocityTracker.prototype.clear = function() {
    this.index = 0;
	
	var HISTORY_SIZE = this.HISTORY_SIZE;
    if(!this.movements) {
		this.movements = new Array();
		for(var i = 0; i < HISTORY_SIZE; i++) {
			this.movements.push(new Movement());
		}
    }

	for(var i = 0; i < HISTORY_SIZE; i++) {
		var iter = this.movements[i];
		iter.eventTime = 0;
		iter.point = {x:0, y:0};
	}

    return;
}

VelocityTracker.prototype.addMovement = function(eventTime, point) {
    if (++this.index == this.HISTORY_SIZE) {
        this.index = 0;
    }

    this.movements[this.index].eventTime = eventTime;
    this.movements[this.index].point = point;

    return;
}

VelocityTracker.prototype.getVelocity = function() {
	var velocity = {x:0, y:0};

	this.estimate();

	velocity.x = this.xVelocity;
	velocity.y = this.yVelocity;

	return velocity;
}

VelocityTracker.prototype.estimate = function() {
	var HORIZON = this.HORIZON;
	var MIN_DURATION = this.MIN_DURATION;
	var HISTORY_SIZE = this.HISTORY_SIZE;
    var newestMovement = this.movements[this.index];
    var minTime = newestMovement.eventTime - HORIZON;
    var oldestIndex = this.index;
    var numTouches = 1;

    do {
        var nextOldestIndex = (oldestIndex == 0 ? HISTORY_SIZE : oldestIndex) - 1;
        var nextOldestMovement = this.movements[nextOldestIndex];
        if (nextOldestMovement.eventTime < minTime) {
            break;
        }
        oldestIndex = nextOldestIndex;
    } while (++numTouches < HISTORY_SIZE);

    var accumVx = 0;
    var accumVy = 0;
    var index = oldestIndex;
    var samplesUsed = 0;
    var oldestMovement = this.movements[oldestIndex];
   	var oldestPosition = oldestMovement.getPoint();
    var lastDuration = 0;

    while (numTouches-- > 1) {
        if (++index == HISTORY_SIZE) {
            index = 0;
        }
        var movement = this.movements[index];
        var duration = movement.eventTime - oldestMovement.eventTime;

        if (duration >= MIN_DURATION) {
            var position = movement.getPoint();
            var scale = 1000000000.0 / duration; // one over time delta in seconds
            var vx = (position.x - oldestPosition.x) * scale;
            var vy = (position.y - oldestPosition.y) * scale;
            accumVx = (accumVx * lastDuration + vx * duration) / (duration + lastDuration);
            accumVy = (accumVy * lastDuration + vy * duration) / (duration + lastDuration);
            lastDuration = duration;
            samplesUsed += 1;
        }
    }

    // Report velocity.
    if (samplesUsed) {
		this.xVelocity = accumVx;
		this.yVelocity = accumVy;
    } else {
		this.xVelocity = 0;
		this.yVelocity = 0;
    }

    return true;
}

function testVelocityTracker() {
	var v = null;
	var vt = new VelocityTracker();
	function toNs(ms) {
		return ms * 1000000;
	}

	for(var i = 0; i < 20; i++) {
		vt.addMovement(toNs(10 * i), {x:10*i, y:10*i*i/2});
	}

	v = vt.getVelocity();

	console.log("xv: " + v.x + " yv: " + v.y);

	return;
}

//testVelocityTracker();

//////////////////////////////////////////////////////////////////////

/**
 * @class Interpolator 
 * 插值算法接口。它的基本功能就是将时间进度(0-1)变换成任务实际进度(0,1)，重而实现加速，减速，先加速再减速和回弹等效果。
 */
function Interpolator() {

/**
 * @method get 
 * 获取任务实际进度。
 * @param {Number} percent 时间进度(0-1)。
 * @return {Number} 返回任务实际进度。
 */
	this.get = function(percent) {
		return 0;
	}

	return this;
}

/**
 * @class Interpolator 
 * 插值算法接口。它的基本功能就是将时间进度(0-1)变换成任务实际进度(0,1)，重而实现加速，减速，先加速再减速和回弹等效果。
 */
function LinearInterpolator() {
	this.get = function(percent) {
		return percent;
	}

	return this;
}

/**
 * @method create 
 * 创建插值算法对象。
 * @param {String} name 插值算法的名称。
 * @return {Interpolator} 返回插值算法对象。
 *
 *     @example small frame
 *     //创建线形插值算法（l|linear):
 *     var interpolator = Interpolator.create('l');
 *     //创建回弹插值算法 (b|bounce)
 *     var interpolator = Interpolator.create('b');
 *     //创建加速插值算法 (a|accelerate)
 *     var interpolator = Interpolator.create('a');
 *     //创建先加速再加速插值算法(ad|accelerate-decelerate)
 *     var interpolator = Interpolator.create('ad');
 *     //创建减速插值算法(d|decelerate)
 *     var interpolator = Interpolator.create('d');
 */
Interpolator.create = function(name, args) { 
	return AnimationFactory.createInterpolator(name, args);	
}

function BounceInterpolator() {
	function bounce(percent) {
		return 8 * percent * percent;
	}

	this.get = function(percent) {
		percent *= 1.1226;
        if (percent < 0.3535) return bounce(percent);
        else if (percent < 0.7408) return bounce(percent - 0.54719) + 0.7;
        else if (percent < 0.9644) return bounce(percent - 0.8526) + 0.9;
        else return bounce(percent - 1.0435) + 0.95;
	}

	return this;
}

function AccelerateInterpolator() {
	this.get = function(percent) {
		return percent * percent;
	}

	return this;
}

function AccDecelerateInterpolator() {
	this.get = function(percent) {
		return ((Math.cos((percent + 1) * Math.PI) / 2.0) + 0.5);
	}

	return this;
}

function DecelerateInterpolator(factor) {
	this.factor = factor ? factor : 2;
	this.get = function(percent) {
		if(this.factor === 1) {
			return (1.0 - (1.0 - percent) * (1.0 - percent));
		}
		else {
			return (1.0 - Math.pow((1.0 - percent), 2 * this.factor));
		}
	}

	return this;
}

function SineAccelerateInterpolator() {
	this.get = function(percent) {
		return -Math.cos(percent * (Math.PI / 2)) + 1;
	}

	return this;
}

function SineAccDecelerateInterpolator() {
	this.get = function(percent) {
		return (-0.5 * (Math.cos(Math.PI * percent) - 1));
	}

	return this;
}

function SineDecelerateInterpolator() {
	this.get = function(percent) {
		return Math.sin(percent * (Math.PI / 2));
	}

	return this;
}

//////////////////////////////////////////////////////////////////////
function AnimationFactory() {
	this.createAnimation = function(name, duration) {
		UIElement.getMainCanvasScale(true);
		var defaultDuration = isIPhone() ? 400 : 600;
		duration = duration ? duration : defaultDuration;
		switch(name) {
			case "anim-forward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationHTranslate(true);
				animation.toLeft();
				animation.init(duration, interpolator);
				break;
			}
			case "anim-backward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationHTranslate(false);
				animation.toRight();
				animation.init(duration, interpolator);
				break;
			}
			case "anim-upward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationVTranslate(true);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-downward": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationVTranslate(false);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-show-win": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationScale(true);
				animation.setRange(0.9, 1.0);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-hide-win": {
				var interpolator =  new AccelerateInterpolator();
				animation = new AnimationScale(false);
				animation.setRange(1.0, 0.9);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-show-dialog": {
				duration = duration ? duration : 300;
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationScale(true);
				animation.setRange(0.9, 1.0);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-scale-hide-dialog": {
				duration = duration ? duration : 300;
				var interpolator =  new AccelerateInterpolator();
				animation = new AnimationScale(false);
				animation.setRange(1.0, 0.9);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-fade-in": {
				var interpolator =  new AccelerateInterpolator();
				animation = new AnimationAlpha(true);
				animation.setRange(0.1, 1.0);
				animation.init(800, interpolator);
				break;
			}
			case "anim-fade-out": {
				var interpolator =  new AccelerateInterpolator();
				animation = new AnimationAlpha(false);
				animation.setRange(1.0, 0.1);
				animation.init(300, interpolator);
				break;
			}
			case "anim-move-up": {
				var interpolator =  new DecelerateInterpolator();
				animation = new AnimationMove(true);
				animation.init(duration, interpolator);
				break;
			}
			case "anim-move-down": {
				var interpolator =  new AccelerateInterpolator();
				animation = new AnimationMove(false);
				animation.init(duration, interpolator);
				break;
			}
		}
		
		return animation;
	}

	return this;
}

AnimationFactory.createInterpolator = function(name, args) {
	switch(name) {
		case 'l': 
		case 'linear': {
			return new LinearInterpolator();
		}
		case 'b':
		case 'bounce': {
			return new BounceInterpolator();
		}
		case 'a':
		case 'accelerate': {
			return new AccelerateInterpolator();
		}
		case 'ad':
		case 'accelerate-decelerate': {
			return new AccDecelerateInterpolator();
		}
		case 'sa':
		case 'sine-accelerate': {
			return new SineAccelerateInterpolator();
		}
		case 'sd':
		case 'sine-decelerate': {
			return new SineDecelerateInterpolator();
		}
		case 'sad':
		case 'sine-accelerate-decelerate': {
			return new SineAccDecelerateInterpolator();
		}
		default: {
			return new DecelerateInterpolator();
		}
	}
}

AnimationFactory.create = function(name, duration) {
	if(!AnimationFactory.instance) {
		AnimationFactory.instance = new AnimationFactory();
	}

	return AnimationFactory.instance.createAnimation(name, duration);
}

Animation.getCanvas = function() {
    return UIElement.getMainCanvas();
}

function Animation(showWin) {
	this.scale = 1;
	this.visible = false;
	this.showWin = showWin;

	this.init = function(duration, interpolator) {
		this.duration = duration ? duration : 500;
		this.interpolator = interpolator;

		return;
	}

    this.setWins = function(oldWin, newWin) {
        this.oldWin = oldWin;
        this.newWin = newWin;
        this.wm = oldWin.getWindowManager();
    }

	this.setRectOfFront = function(x, y, w, h) {
		this.frontX = x;
		this.frontY = y;
		this.frontW = w;
		this.frontH = h;

		return;
	}

	this.setScale = function(scale) {
		this.scale = scale;

		return;
	}

	this.prepare = function(x, y, w, h, onFinish) {
		this.x = Math.round(x);
		this.y = Math.round(y);
		this.w = Math.round(w);
		this.h = Math.round(h);
		this.onFinish = onFinish;

		this.setRectOfFront(0, 0, w, h);

		this.show();

		return true;
	}

	this.show = function() {
		var w = this.w * this.scale;
		var h = this.h * this.scale;

		this.visible = true;
		this.canvasElement = Animation.getCanvas();

		return true;
	}

	this.hide = function() {
		this.visible = false;
		if(this.canvasElement && this.canvasElement.parentNode) {
			this.canvasElement = null;
		}

		return true;
	}

	this.getTimePercent = function() {
		var date = new Date();
		var elapsed = date.getTime() - this.startTime;

		return elapsed/this.duration;
	}

	this.getPercent = function(timePercent) {
		return this.interpolator.get(timePercent);	
	}

	this.step = function(percent) {
		/*Overwrite it*/
		return true;
	}
	
	this.beforeRun = function() {
		/*Optional Overwrite it*/
		return true;
	}
	
	this.afterRun = function() {
		/*Optional Overwrite it*/
		return true;
	}

	this.drawBackground = function(canvas) {
		return;
	}

	this.doStep = function(percent) {
		this.canvas.save();
		this.canvas.scale(this.scale, this.scale);
		this.step(percent);
		this.canvas.restore();

		return;
	}
	
	this.run = function() {
		var date = new Date();
		var animation = this;
		this.startTime = date.getTime();
		animation.isFirstStep = true;

		this.beforeRun();
		WWindowManager.getInstance().setPaintEnable(false); 
		this.wm.setEnable(false); 
		function animStep() {
			var percent = 0;
			var timePercent = animation.getTimePercent();

			if(timePercent < 1) {
				percent = animation.getPercent(timePercent);
				animation.doStep(percent);

				requestAnimationFrame(animStep);
			}
			else {
				animation.cleanup();
				animation.afterRun();
				WWindowManager.getInstance().setPaintEnable(true);
				console.log("Animation done.");
			}
			animation.isFirstStep = false;
		}
		
		animStep();

		return;
	}

	this.cleanup = function() {
		var animation = this;
		var onFinish = this.onFinish;

		setTimeout(function() {
			animation.hide();
		    animation.wm.setEnable(true); 
		}, 100);

		if(onFinish) {
			onFinish();
		}
	}

	this.hide();

	return this;
}

function setElementPosition(element, x, y) {
	var scale = UIElement.getMainCanvasScale();

	x = x/scale.x;
	y = y/scale.y;
	element.style.position = "absolute";
	element.style.left = Math.round(x) + "px";
	element.style.top = Math.round(y) + "px";
	element.style["opacity"] = 1.0;

	return;
}

function moveElement(element, x, y) {
	setElementPosition(element, x, y);

	return;
}

function alphaElement(element, opacity) {
	element.style["opacity"] = opacity;

	return;
}

function showElement(element) {
	element.style["opacity"] = 1;
}

function hideElement(element) {
	element.style["opacity"] = 0;
}

function scaleElement(element, scale, opacity, xOrigin, yOrigin) {
	var origin = (xOrigin && yOrigin) ? xOrigin + " " + yOrigin : "50% 50%";
	var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

	element.style['transform-style'] = "preserve-3d";
	for(var i = 0; i < transforms.length; i++) {
		var trans = transforms[i];
		element.style[trans + "-origin"] = origin;
		element.style[trans] = "scale("+scale+")";
	}
	element.style["opacity"] = opacity;

	return;
}

function rotateElement(element, deg) {
	var origin = "50% 50%";
	var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

	element.style['transform-style'] = "preserve-3d";
	for(var i = 0; i < transforms.length; i++) {
		var trans = transforms[i];
		element.style[trans + "-origin"] = origin;
		element.style[trans] = "rotate("+deg+"deg)";
	}

	return;
}

function AnimationVTranslate(showWin) {
	Animation.apply(this, arguments);

	this.beforeRun = function() {
		this.range = this.frontH;
		this.canvas = this.canvasElement.getContext("2d");

		return true;;
	}

	this.step = function(percent) {
 		var x = this.frontX;
		var y = this.frontY;
		var w = this.frontW;
		var dy = this.range * percent;
		var h = this.showWin ? dy : (this.range - dy);		
		var oy = this.showWin ? (this.frontY + this.range - dy) : (this.frontY + dy);

        var canvas = this.canvas;
        canvas.save();
        var wm = this.oldWin.getWindowManager();
        canvas.translate(wm.x, wm.y);
 
        if(this.showWin) {
            canvas.translate(0, oy - this.h);
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.oldWin.paintSelf(canvas);
            canvas.restore();

            canvas.translate(0, this.h);
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.newWin.paintSelf(canvas);
            canvas.restore();
        } else {
            canvas.translate(0, oy - this.h);
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.newWin.paintSelf(canvas);
            canvas.restore();
            
            canvas.translate(0, this.h);
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.oldWin.paintSelf(canvas);
            canvas.restore();
        }
        canvas.restore();
    
		return true;
	}
}

function AnimationHTranslate() {
	Animation.apply(this, arguments);
	
	this.leftToRight = true;

	this.beforeRun = function() {
		var range = this.newWin.w;
	
		this.range = range;

		this.start = range - this.range;
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.toLeft = function() {
		this.leftToRight = true;

		return;
	}
	
	this.toRight = function() {
		this.leftToRight = false;

		return;
	}

	this.step = function(percent) {
		var ox = 0;
        if(this.leftToRight) {
			ox = this.start + this.range * percent;
		}
		else {
			ox = this.w - this.range * percent - this.start;
		}

		if(this.lastOffset === ox) {
			return true;
		}
        var canvas = this.canvas;
        canvas.save();
        var wm = this.oldWin.getWindowManager();
        canvas.translate(wm.x, wm.y);

        if(this.leftToRight) {
            canvas.translate(-ox, 0); 
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.oldWin.paintSelf(canvas);
			canvas.restore();

            canvas.translate(this.w, 0); 
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.newWin.paintSelf(canvas);
			canvas.restore();
        } else {
            canvas.translate(-ox, 0); 
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.newWin.paintSelf(canvas);
			canvas.restore();

            canvas.translate(this.w, 0); 
            canvas.save();
        	canvas.clipRect(0, 0, this.w, this.h);
            this.oldWin.paintSelf(canvas);
			canvas.restore();
        }
        canvas.restore();
		this.lastOffset = ox;
		return true;
	}
}

function AnimationScale() {
	Animation.apply(this, arguments);

	this.to = 1.0;
	this.from = 0;
	this.frontX = 0;
	this.frontY = 0;
	this.frontW = 0;
	this.frontH = 0;

	this.setRange = function(from, to) {
		this.to = to;
		this.from = from;

		return;
	}

	this.beforeRun = function() {
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.step = function(percent) {
		var scale = this.from + percent * (this.to - this.from);
		var alpha = this.to > this.from ? percent : (1-percent);
		var canvas = this.canvas;
        var dx = (this.w >> 1);
        var dy = (this.h >> 1);
        
        canvas.save();
        var wm = this.oldWin.getWindowManager();
        canvas.translate(wm.x, wm.y);
        canvas.clipRect(0, 0, this.w, this.h);
        
        if(this.to > this.from) { 
            this.oldWin.paintSelf(canvas);

            canvas.globalAlpha = alpha; 
            canvas.translate(dx, dy);
            canvas.scale(scale, scale);
            canvas.translate(-dx, -dy);
            this.newWin.paintSelf(canvas);
        } else {
            this.newWin.paintSelf(canvas);

            canvas.globalAlpha = alpha; 
            canvas.translate(dx, dy);
            canvas.scale(scale, scale);
            canvas.translate(-dx, -dy);
            this.oldWin.paintSelf(canvas);
        }
        canvas.restore();
		//console.log("Step: " + percent + " alpha=" + alpha + " scale=" + scale);
		return true;
	}
}

function AnimationAlpha() {
	Animation.apply(this, arguments);

	this.to = 1.0;
	this.from = 0;
	this.frontX = 0;
	this.frontY = 0;
	this.frontW = 0;
	this.frontH = 0;

	this.setRange = function(from, to) {
		this.to = to;
		this.from = from;

		return;
	}

	this.beforeRun = function() {
		this.canvas = this.canvasElement.getContext("2d");
	}

	this.step = function(percent) {
		var alpha = this.from + percent * (this.to - this.from);

		var canvas = this.canvas;
		canvas.save();
        var wm = this.oldWin.getWindowManager();
        canvas.translate(wm.x, wm.y);
        canvas.clipRect(0, 0, this.w, this.h);
 
        if(this.to > this.from) {
            this.oldWin.paintSelf(canvas);
            canvas.globalAlpha = alpha;
            this.newWin.paintSelf(canvas);
        } else {
            this.newWin.paintSelf(canvas);
            canvas.globalAlpha = alpha;
            this.oldWin.paintSelf(canvas);
        }
        canvas.restore();
		return true;
	}
}

function AnimationMove(showWin) {
	Animation.apply(this, arguments);

	this.beforeRun = function() {
		this.range = this.frontH;
		this.canvas = this.canvasElement.getContext("2d");

		return true;;
	}

	this.step = function(percent) {
		var x = this.frontX;
		var y = this.frontY;
		var w = this.frontW;
		var dy = this.range * percent;
		var h = this.showWin ? dy : (this.range - dy);		
		var oy = this.showWin ? (this.frontY + this.range - dy) : (this.frontY + dy);
	
        var canvas = this.canvas;
        canvas.save();
        var wm = this.oldWin.getWindowManager();
        canvas.translate(wm.x, wm.y);
        canvas.clipRect(0, 0, this.w, this.h);
 
        if(showWin) {
            this.oldWin.paintSelf(canvas);
            canvas.translate(0, oy);
            this.newWin.paintSelf(canvas);
        } else {
            this.newWin.paintSelf(canvas);
            canvas.translate(0, oy);
            this.oldWin.paintSelf(canvas);
        }
        canvas.restore();    

		return true;
	}
}
/*
 * File: ui-element.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: UIElement
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIElement() {
	return;
}

UIElement.IMAGE_DISPLAY_CENTER = WImage.DISPLAY_CENTER;
UIElement.IMAGE_DISPLAY_TILE   = WImage.DISPLAY_TILE;
UIElement.IMAGE_DISPLAY_9PATCH = WImage.DISPLAY_9PATCH;
UIElement.IMAGE_DISPLAY_SCALE  = WImage.DISPLAY_SCALE;
UIElement.IMAGE_DISPLAY_AUTO = WImage.DISPLAY_AUTO;
UIElement.IMAGE_DISPLAY_DEFAULT = WImage.DISPLAY_DEFAULT;
UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO  = WImage.DISPLAY_SCALE_KEEP_RATIO;
UIElement.IMAGE_DISPLAY_TILE_V = WImage.DISPLAY_TILE_V;
UIElement.IMAGE_DISPLAY_TILE_H = WImage.DISPLAY_TILE_H;
UIElement.IMAGE_DISPLAY_AUTO_SIZE_DOWN = WImage.DISPLAY_AUTO_SIZE_DOWN;
UIElement.IMAGE_DISPLAY_FIT_WIDTH = WImage.DISPLAY_FIT_WIDTH;
UIElement.IMAGE_DISPLAY_FIT_HEIGHT = WImage.DISPLAY_FIT_HEIGHT;
UIElement.IMAGE_DISPLAY_3PATCH_V = WImage.DISPLAY_3PATCH_V;
UIElement.IMAGE_DISPLAY_3PATCH_H = WImage.DISPLAY_3PATCH_H;

UIElement.HTEXT_ALIGNS = ["left", "center", "right"];
UIElement.VTEXT_ALIGNS = ["top", "middle", "bottom"];

UIElement.IMAGE_DISPLAY_NAMES = ["incenter", "tile", "9patch", "scale", "auto", "default", "scale(keep ratio)", "vtile", "htile", "auto-size-down", "fit-width","fit-height"];

UIElement.X_FIX_LEFT = 0;
UIElement.X_FIX_RIGHT = 1;
UIElement.X_SCALE = 2;
UIElement.X_CENTER_IN_PARENT = 3;
UIElement.X_LEFT_IN_PARENT	 = 4;
UIElement.X_RIGHT_IN_PARENT  = 5;
UIElement.X_AFTER_PREV       = 6;
//UIElement.X_LAYOUT_NAMES = ["fix_left", "fix_right", "scale", "center_in_parent", "left_in_parent", "right_in_parent", "after_prev"];
UIElement.X_LAYOUT_NAMES = ["fix_left", "fix_right", "scale", "center_in_parent", "left_in_parent", "right_in_parent"];

UIElement.Y_FIX_TOP = 0;
UIElement.Y_FIX_BOTTOM = 1;
UIElement.Y_SCALE = 2;
UIElement.Y_MIDDLE_IN_PARENT = 3;
UIElement.Y_TOP_IN_PARENT	 = 4;
UIElement.Y_BOTTOM_IN_PARENT = 5;
UIElement.Y_AFTER_PREV       = 6;
//UIElement.Y_LAYOUT_NAMES = ["fix_top", "fix_bottom", "scale", "middle_in_parent", "top_in_parent", "bottom_in_parent", "after_prev"];
UIElement.Y_LAYOUT_NAMES = ["fix_top", "fix_bottom", "scale", "middle_in_parent", "top_in_parent", "bottom_in_parent"];

UIElement.WIDTH_FIX = 0;
UIElement.WIDTH_SCALE = 1;
UIElement.WIDTH_FILL_PARENT = 2;
UIElement.WIDTH_FILL_AVAILABLE = 3;
UIElement.WIDTH_FILL_TO_PARENT_RIGHT = 4;

UIElement.HEIGHT_FIX = 0;
UIElement.HEIGHT_SCALE = 1;
UIElement.HEIGHT_FILL_PARENT = 2;
UIElement.HEIGHT_FILL_AVAILABLE = 3;
UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH = 4;
UIElement.HEIGHT_FILL_TO_PARENT_BOTTOM = 5;

UIElement.WIDTH_LAYOUT_NAMES = ["fix", "scale", "fill_parent"];
UIElement.HEIGHT_LAYOUT_NAMES = ["fix", "scale", "fill_parent"];
//UIElement.WIDTH_LAYOUT_NAMES = ["fix", "scale", "fill_parent", "fill_avaible", "fill_to_parent_right"];
//UIElement.HEIGHT_LAYOUT_NAMES = ["fix", "scale", "fill_parent", "fill_avaible", "keep_ratio_with_width", "fill_to_parent_bottom"];

UIElement.IMAGE_DEFAULT	   = "default_bg";
UIElement.IMAGE_MASK	   = "mask_fg";
UIElement.IMAGE_NORMAL	   = "normal_bg";
UIElement.IMAGE_NORMAL_BG  = "normal_bg";
UIElement.IMAGE_FOCUSED	   = "focused_bg";
UIElement.IMAGE_ACTIVE	   = "active_bg";
UIElement.IMAGE_POINTER_OVER = "pointer_over_bg";
UIElement.IMAGE_DISABLE	   = "disable_bg";
UIElement.IMAGE_DISABLE_FG = "disable_fg";
UIElement.IMAGE_NORMAL_FG  = "normal_fg";
UIElement.IMAGE_ACTIVE_FG  = "active_fg";
UIElement.IMAGE_CURRENT_PAGE_BG  = "current_page_bg";
UIElement.IMAGE_CURRENT_PAGE_FG  = "current_page_fg";
UIElement.IMAGE_NOT_CURRENT_PAGE_BG  = "not_current_page_bg";
UIElement.IMAGE_NOT_CURRENT_PAGE_FG  = "not_current_page_fg";
UIElement.IMAGE_ON_FG	   = "on_fg";
UIElement.IMAGE_OFF_FG	   = "off_fg";
UIElement.IMAGE_ON_BG	   = "on_bg";
UIElement.IMAGE_OFF_BG	   = "off_bg";
UIElement.IMAGE_CHECKED_BG	   = "checked_bg";
UIElement.IMAGE_UNCHECK_BG	   = "unchecked_bg";
UIElement.IMAGE_CHECKED_FG	   = "checked_fg";
UIElement.IMAGE_UNCHECK_FG	   = "unchecked_fg";
UIElement.IMAGE_ON_FOCUSED	   = "focused_on_bg";
UIElement.IMAGE_ON_ACTIVE	   = "active_on_bg";
UIElement.IMAGE_OFF_FOCUSED	   = "focused_off_bg";
UIElement.IMAGE_OFF_ACTIVE	   = "active_off_bg";
UIElement.IMAGE_NORMAL_DRAG    = "normal_drag";
UIElement.IMAGE_DELETE_ITEM    = "delete_item_icon";
UIElement.IMAGE_CHECKED_ITEM   = "checked_item_icon";
UIElement.IMAGE_POINT          = "point_img";
UIElement.IMAGE_POINT1         = "point1_img";
UIElement.IMAGE_POINT2         = "point2_img";
UIElement.IMAGE_POINT3         = "point3_img";
UIElement.IMAGE_POINT4         = "point4_img";
UIElement.IMAGE_TIPS1          = "tips_img_1";
UIElement.IMAGE_TIPS2          = "tips_img_2";
UIElement.IMAGE_TIPS3          = "tips_img_3";
UIElement.IMAGE_TIPS4          = "tips_img_4";
UIElement.IMAGE_TIPS5          = "tips_img_5";

UIElement.IMAGE_V_SCROLL_BAR_BG = "v-scroll-bar-bg";
UIElement.IMAGE_V_SCROLL_BAR_FG = "v-scroll-bar-fg";
UIElement.IMAGE_H_SCROLL_BAR_BG = "h-scroll-bar-bg";
UIElement.IMAGE_H_SCROLL_BAR_FG = "h-scroll-bar-fg";

UIElement.ITEM_BG_NORMAL  = "item_bg_normal";
UIElement.ITEM_BG_ACTIVE  = "item_bg_active";
UIElement.ITEM_BG_CURRENT_NORMAL = "item_bg_current_normal";
UIElement.ITEM_BG_CURRENT_ACTIVE = "item_bg_current_active";

UIElement.TEXT_ALIGN_CENTER = 0;
UIElement.TEXT_ALIGN_LEFT	= 0;
UIElement.TEXT_ALIGN_RIGHT = 0;
UIElement.TEXT_ALIGN_NAMES = ["center", "left", "right"];

UIElement.ORIGIN_UP = 1;
UIElement.ORIGIN_DOWN = 2;
UIElement.ORIGIN_LEFT = 3;
UIElement.ORIGIN_RIGHT = 4;
UIElement.ORIGIN_UP_LEFT = 5;
UIElement.ORIGIN_UP_RIGHT = 6;
UIElement.ORIGIN_DOWN_LEFT = 7;
UIElement.ORIGIN_DOWN_RIGHT = 8;
UIElement.ORIGIN_MIDDLE_CENTER = 9;

UIElement.STATE_STOP = 1;
UIElement.STATE_RUNNING = 2;
UIElement.STATE_PAUSED = 3;

UIElement.prototype = new RShape();
TEventTarget.apply(UIElement.prototype);

UIElement.Style = function() {
	this.lineWidth = 2;
	this.lineColor = "Orange";
	this.fillColor = "White";
	this.textColor = "Blue";
	this.fontSize = 24;

	return;
}

UIElement.Style.prototype = new ShapeStyle();

UIElement.prototype.isUIElement = true;
UIElement.prototype.hasChildren = true;
UIElement.prototype.isContainer = true;

UIElement.disableGetRelativePathOfURL = false;

UIElement.prototype.addResource = function(url) {
	if(!this.resources) {
		this.resources = [];
	}

	if(this.resources.indexOf(url) < 0) {
		this.resources.push(url);
	}

	return;
}

UIElement.prototype.setDefaultStyle = function() {
	this.style = new UIElement.Style();

	return;
}

UIElement.prototype.clone = function() {
	var obj = null;
	
	UIElement.disableGetRelativePathOfURL = true;
	obj = this.dup();
	UIElement.disableGetRelativePathOfURL = false;

	obj.setVisible(true);
	obj.xAttr = UIElement.X_FIX_LEFT;
	obj.yAttr = UIElement.Y_FIX_TOP;
	obj.widthAttr = UIElement.WIDTH_FIX;
	obj.heightAttr = UIElement.HEIGHT_FIX;
	obj.uid = UIElement.uidStart++;

	if(this.anchor) {
		obj.setAnchor(this.anchor.x, this.anchor.y);
	}

	return obj;
}

UIElement.prototype.getRelativePathOfURL = function(url) {
	if(UIElement.disableGetRelativePathOfURL || !url) {
		return url;
	}

	return url.toRelativeURL();
}

UIElement.prototype.setFreePosition = function(value) {
	this.freePosition = value;

	return;
}

UIElement.prototype.fixChildPosition = function(child) {
	return;
}

UIElement.prototype.setFreeSize = function(value) {
	this.freeSize = value;
	
	return;
}

UIElement.prototype.fixChildSize = function(child) {
	return;
}

UIElement.prototype.onInit = function() {
	this.callOnInitHandler();

	if(this.dataSourceUrl && this.dataSourceUrl.length > 5) {
		this.bindDataUrl(this.dataSourceUrl);
	}

	return;
}

UIElement.prototype.onDeinit = function() {
	if(this.animatingInfo) {
		this.stopAnimation(true);
	}

	return;
}

UIElement.prototype.onWindowOpen = function() {
	if(this.animations && this.defaultAnimationName) {
		var config = this.animations[this.defaultAnimationName];
		if(config) {
			this.animate(config);
		}
	}

	return;
}

UIElement.prototype.initChildren = function() {
	var children = this.children;
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var iter = children[i];
		iter.init();
	}

	return;
}

UIElement.prototype.init = function() {
	try {
		this.onInit();
	}catch(e) {
		console.log("onInit Failed:" + e.message  + "\n" + e.stack);
	}
	this.initChildren();

	return;
}

UIElement.prototype.deinit = function() {
	var i = 0;
	var iter = null;
	var children = this.children;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		iter = children[i];
		iter.deinit();
	}
	
	this.onDeinit();

	return;
}

UIElement.prototype.onModeChanged = function() {
	return;
}

UIElement.prototype.userRemovable = function() {
	return this.isInDesignMode();
}

UIElement.prototype.postRedraw = function() {
	if(this.view) {
		this.view.postRedrawAll();
	}

	return this;
}

UIElement.prototype.requestRedraw = UIElement.prototype.postRedraw; 

UIElement.prototype.setMode = function(mode, recursive) {
	this.mode = mode;

	if(this.type !== "ui-menu-bar") {
		if(this.isInDesignMode()) {
			this.setVisible(true);
		}
	}

	if(recursive) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child.isContainer) {
				child.setMode(mode, true);
			}
		}
	}
	this.onModeChanged();

	return this;
}

UIElement.prototype.calcChildrenRange = function() {
	return this.calcShapesRange(this.children);
}

UIElement.prototype.calcShapesRange = function(shapes) {
	var x = 0;
	var y = 0;
	var w = 0;
	var h = 0;

	var r = 0;
	var b = 0;
	var t = 10000;
	var l = 10000;
	var range = {};

	if(shapes.length > 0) {
		for(var i = 0; i < shapes.length; i++) {
			var iter = shapes[i];
			
			x = iter.getX();
			y = iter.getY();
			w = iter.getWidth();
			h = iter.getHeight();

			if(x < l) l = x;
			if(y < t) t = y;
			if((x + w) > r) r = x + w;
			if((y + h) > b) b = y + h;
		}

		range.l = l;
		range.r = r;
		range.t = t;
		range.b = b;
	}
	else {
		range.l = 0;
		range.r = 0;
		range.t = 0;
		range.b = 0;
	}

	return range;
}

UIElement.prototype.relayoutChildren = function() {
}

UIElement.prototype.onSized = function() {
	this.updateLayoutParams();

	return;
}

UIElement.prototype.findSelectedShapes = function(shapes) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child.selected) {
			shapes.push(child);
			continue;
		}
	
		if(child.isContainer) {
			child.findSelectedShapes(shapes);
		}
	}

	return;
}

UIElement.onSelected = function(shape) {
}

UIElement.prototype.onSelectChanged = function() {
	if(this.selected) {
		UIElement.onSelected(this);
	}

	return;
}

UIElement.prototype.setSelected = function(selected) {
	if(!selected) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			child.setSelected(false);
		}
	}
	
	if(selected) {
		this.selectedTime = Date.now();
	}

	if(this.selected === selected) {
		return;
	}

	this.targetShape = null;
	this.selected = selected;
	this.onSelectChanged();

	return;
}

UIElement.prototype.setPointerEventTarget = function(shape) {
	this.pointerEventTarget = shape;

	return;
}

UIElement.prototype.getPointerEventTarget = function() {
	return this.pointerEventTarget ? this.pointerEventTarget : this.targetShape;
}

UIElement.prototype.foreachImage = function(onVisit) {
	for(var key in this.images) {
		if(key !== "display") {
			var src = this.getImageSrcByType(key);
			onVisit(key, src);
		}
	}

	return;
}

UIElement.prototype.forEach = function(onVisit) {
	if(onVisit(this)) {
		return true;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.forEach(onVisit);
	}

	return false;
}

UIElement.prototype.getAllTabStopElements = function() {
	var arr = [];
	var win = this.getWindow();

	if(win) {
		win.forEach(function(el) {
			if(el.isUIButton || el.isUIEdit) {
				arr.push(el);
			}
		});
	}

	return arr;
}

UIElement.prototype.findNextTabStop = function() {
	var arr = this.getAllTabStopElements();
	if(!arr.length) {
		return;
	}

	var index = arr.indexOf(this);
	if(index >= 0 && (index + 1) < arr.length) {
		return arr[index+1];
	}
	else {
		return arr[0];
	}
}

UIElement.prototype.moveToNextStop = function() {
	var el = this.findNextTabStop();


	return;
}

UIElement.prototype.isPointerOverShape = function() {
	return this.parentShape && this.parentShape.pointerOverShape === this;
}

UIElement.prototype.setPointerOverShape = function(shape) {
	if(this.pointerOverShape !== shape) {
		if(this.pointerOverShape) {
			this.pointerOverShape.setPointerOverShape(null);
		}

		this.pointerOverShape = shape;
		this.postRedraw();
	}

	return;
}

UIElement.prototype.setTarget = function(shape) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child !== shape) {
			child.setSelected(false);
		}
	}

	this.targetShape = shape;
	this.selected = !shape;
	this.onSelectChanged();

	return this;
}

UIElement.prototype.getTarget = function() {
	return this.targetShape;
}

UIElement.prototype.initContainerShape = function(type) {
	this.children = new Array();

	RShapeInit(this, type);
	
	this.mode = Shape.MODE_EDITING;
	this.rectSelectable = true;

	return this;
}

UIElement.prototype.defaultDispatchPointerDownToChildren = function(p) {
	var targetShape = this.targetShape;
	if(targetShape && targetShape.isInDesignMode()) {
		var hitTestResult = this.hitTest(p);

		if(hitTestResult != Shape.HIT_TEST_MM && hitTestResult != Shape.HIT_TEST_NONE) {
			if(this.selected) {
				this.setTarget(null);
				return true;
			}
			if(this.targetShape.onPointerDown(p)) {
				return true;
			}
		}
	}

	var arr = this.children;
	var n = arr.length;

	for(var i = n; i > 0; i--) {
		var child = arr[i-1];
		if(child.visible && child.onPointerDown(p)) {
			this.setTarget(child);
			
			if(!child.shouldPropagatePointerEvent()) {
				return true;
			}
		}
	}

	return false;
}

UIElement.prototype.dispatchPointerDownToChildren = function(p) {
	return this.defaultDispatchPointerDownToChildren(p);
}

UIElement.prototype.onPointerDownEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(!this.pointerDown) {
		return;
	}

	return this.callOnPointerDownHandler(point, beforeChild);
}

UIElement.prototype.onPointerMoveEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerMoveRunning = function(point, beforeChild) {
	return this.callOnPointerMoveHandler(point, beforeChild);
}

UIElement.prototype.onPointerUpEditing = function(point, beforeChild) {
	return;
}

UIElement.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(!this.pointerDown) {
		return;
	}

	return this.callOnPointerUpHandler(point, beforeChild);
}

UIElement.prototype.onDoubleClick = function(point) {
	if(this.targetShape) {
		var p = this.translatePoint(point);
		return this.targetShape.onDoubleClick(p);
	}
	else {
		return this.callOnDoubleClickHandler(point);
	}
}

UIElement.prototype.onGesture = function(gesture) {
	if(this.popupWindow) {
		return;
	}

	if(this.targetShape) {
		return this.targetShape.onGesture(gesture);
	}

	return;
}

UIElement.prototype.onLongPress = function(point) {
	if(!this.pointerDown) {
		return;
	}

	this.longPressed = true;
	this.callOnLongPressHandler(point);
	if(this.targetShape) {
		var p = this.translatePoint(point);
		return this.targetShape.onLongPress(p);
	}

	return;
}

UIElement.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || !this.pointerDown) {
		return;
	}

	return this.callOnClickHandler(point);
}

UIElement.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left), y : (point.y - this.top)};

	return p;
}

UIElement.prototype.setCanRectSelectable = function(rectSelectable, recursive) {
	this.rectSelectable = rectSelectable;

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setCanRectSelectable(rectSelectable, recursive);
	}

	return;
}

UIElement.prototype.canRectSelectable = function() {
	return this.isUIWindow || this.isUIPage;
}

UIElement.prototype.setDraggable = function(value) {
	if(this.draggable === value) {
		return;
	}

	this.draggable = value;

	if(value) {
		this.addEventNames(["onDragStart", "onDragging", "onDragEnd"]);
	}
	else {
		this.removeEventNames(["onDragStart", "onDragging", "onDragEnd"]);
	}

	return;
}

UIElement.prototype.onDragStart = function() {
	console.log("Drag Start");
	this.callOnDragStartHandler();
	return;
}

UIElement.prototype.onDragging = function() {
	console.log("Dragging");
	this.callOnDragingHandler();

	return;
}

UIElement.prototype.onDragEnd = function() {
	console.log("Drag End");
	this.callOnDragEndHandler();

	return;
}

UIElement.prototype.dragMove = function(dx, dy, point) {
	this.left = this.left + dx;
	this.top = this.top + dy;
	
	this.onDragging(point);

	return;
}

UIElement.prototype.handleDragMove = function(point) {
	var dx = this.getMoveDeltaX();
	var dy = this.getMoveDeltaY();

	if(!this.dragging) {
		var absdx = this.getMoveAbsDeltaX();
		var absdy = this.getMoveAbsDeltaY();
		if(Math.abs(absdx) > 5 || Math.abs(absdy) > 5) {
			this.dragging = true;
			this.onDragStart();
			dx = absdx;
			dy = absdy;
		}
	}

	if(this.dragging) {
		this.dragMove(dx, dy, point);
		if(this.parentShape) {
			this.parentShape.onChildDragging(this, point);
		}
	}

	return;
}

UIElement.prototype.onChildDragging = function(child, point) {

	return;
}

UIElement.prototype.onChildDragged = function(child, point) {
	this.sortChildren();
	this.relayoutChildren("default");

	return;
}

UIElement.prototype.handleDragUp = function(point) {
	this.onDragEnd();
	delete this.dragging;

	if(this.parentShape) {
		this.parentShape.onChildDragged(this, point);
	}

	return;
}

UIElement.prototype.animMove = function(x, y) {
	if(!this.dragging) {
		this.animate({x:x, y:y});
	}
	return;
}

UIElement.getIntFromConfig = function(config, name, defValue) {
	var value = config[name];

	if(!value && value !== 0) {
		return defValue;
	}
	
	if(typeof value === "string") {
		if(value[1] === '+' || value[1] === '-') {
			value = defValue + parseInt(value.substr(1));
		} else {
			value = parseInt(value);
		}
	}

	return value;
}

UIElement.prototype.stopAnimation = function(callOnDone) {
	if(!this.animatingInfo) {
		return this;
	}

	if(callOnDone) {
		this.stepAnimation({needRedraw:0}, Date.now() + 100000000);
	}
	this.animatingInfo = null;

	return this;
}


UIElement.prototype.animate = function(config, onAnimationDone, onAnimationStep, actionWhenBusy) {
	var me = this;
	var deferred = Deferred();
	var onAnimationStep = onAnimationStep || config.onStep;
	var onAnimationDone = onAnimationDone || config.onDone;

	this.doAnimate(config, function() {
		if(typeof onAnimationDone === 'function') {
			onAnimationDone.apply(me, arguments);
		}
		deferred.resolve();
	}, function() {
		if(typeof onAnimationStep === 'function') {
			return onAnimationStep.apply(me, arguments);
		}
		return true;
	}, actionWhenBusy);

	return deferred.promise;
}

UIElement.prototype.doAnimate = function(config, onAnimationDone, onAnimationStep, actionWhenBusy) {
	if(typeof config === "string") {
		config = this.animations[config];
	}

	if(!this.parentShape) {
		UIElement.logWarning("animate error - parentShape is null.");
		return false;
	}

	if(this.dragging) {
		UIElement.logWarning("animate error - busy.");
		return false;
	}

	var animatingInfo = this.animatingInfo;
	if(animatingInfo) {
		var busyAction = actionWhenBusy || config.actionWhenBusy || "replace";

		if(busyAction === "replace") {
			this.callOnAnimateDone(animatingInfo);
//			UIElement.logNotice("busy action - replace current animation.");
		}
		else if(busyAction === "append") {
			var c = 0;
			for(var iter = animatingInfo; iter; iter = iter.next) {
				if(iter === config) {
					UIElement.logWarning("animate error - already appended.");
					return false;
				}
			
				if(!iter.next || c > 30) {
					iter.next = config;
					break;
				}
				c++;
			}
			UIElement.logNotice("busy action - append animation.");
			return true;
		}
		else {
			UIElement.logWarning("animate error - busy.");
			return false;
		}
	}

	if(!config) {
		UIElement.logWarning("animate error - config is null.");
		return false;
	}

	var x = this.getX();
	var y = this.getY();
	var w = this.w;
	var h = this.h;

	var duration = config.duration || 800;
	var xStart = UIElement.getIntFromConfig(config, "xStart", x);
	var xEnd = UIElement.getIntFromConfig(config, "xEnd", x);
	var yStart = UIElement.getIntFromConfig(config, "yStart", y);
	var yEnd = UIElement.getIntFromConfig(config, "yEnd", y);

	var wStart = UIElement.getIntFromConfig(config, "wStart", w);
	var wEnd = UIElement.getIntFromConfig(config, "wEnd", w);
	var hStart = UIElement.getIntFromConfig(config, "hStart", h);
	var hEnd = UIElement.getIntFromConfig(config, "hEnd", h);

	var valueStart = config.valueStart || 0;
	var valueEnd   = config.valueEnd   || 0;

	var opacityStart = (config.opacityStart || config.opacityStart === 0) ? config.opacityStart : this.opacity;
	var opacityEnd = (config.opacityEnd || config.opacityEnd === 0) ? config.opacityEnd : this.opacity;
	var rotationStart = (config.rotationStart || config.rotationStart === 0) ? config.rotationStart : this.rotation;
	var rotationEnd = (config.rotationEnd || config.rotationEnd === 0) ? config.rotationEnd : this.rotation;
	var scaleXStart = (config.scaleXStart || config.scaleXStart === 0) ? config.scaleXStart : this.getScaleX();
	var scaleXEnd = (config.scaleXEnd || config.scaleXEnd === 0) ? config.scaleXEnd : this.getScaleX();
	var scaleYStart = (config.scaleYStart || config.scaleYStart === 0) ? config.scaleYStart : this.getScaleY();
	var scaleYEnd = (config.scaleYEnd || config.scaleYEnd === 0) ? config.scaleYEnd : this.getScaleY();

	if(config.scaleEnd !== undefined) {
		scaleXEnd = config.scaleEnd;
		scaleYEnd = config.scaleEnd;
	}

	if(config.scaleStart !== undefined) {
		scaleXStart = config.scaleStart;
		scaleYStart = config.scaleStart;
	}
	
	if(config.scale !== undefined) {
		scaleXEnd = config.scale;
		scaleYEnd = config.scale;
	}
	
	if(config.scaleX !== undefined) {
		scaleXEnd = config.scaleX;
	}
	
	if(config.scaleY !== undefined) {
		scaleYEnd = config.scaleY;
	}

	if(config.x !== undefined) {
		xEnd = config.x;	
	}
	
	if(config.y !== undefined) {
		yEnd = config.y;	
	}

	if(config.opacity !== undefined) {
		opacityEnd = config.opacity;
	}

	if(config.rotation !== undefined) {
		rotationEnd = config.rotation;
	}

	var onDone = onAnimationDone || config.onDone;
	var onStep = onAnimationStep || config.onStep;

	var xRange = xEnd - xStart;
	var yRange = yEnd - yStart;
	var scaleXRange = scaleXEnd - scaleXStart;
	var scaleYRange = scaleYEnd - scaleYStart;
	var opacityRange = opacityEnd - opacityStart;
	var rotationRange = rotationEnd - rotationStart;
	var valueRange = valueEnd - valueStart;

	var interpolator =  null;
	if(typeof config.interpolator === "string") {
		interpolator = AnimationFactory.createInterpolator(config.interpolator);
	}
	else {
		interpolator = config.interpolator ? config.interpolator : new DecelerateInterpolator();
	}

	if(!xRange) {
		this.setX(xStart);
		xEnd = xStart;
	}

	if(!yRange) {
		this.setY(yStart);
		yEnd = yStart;
	}

    if(!scaleXRange) {
        this.setScaleX(scaleXStart);
        scaleXEnd = scaleXStart;
    }

    if(!scaleYRange) {
        this.setScaleY(scaleYStart);
        scaleYEnd = scaleYStart;
    }

    if(!opacityRange && opacityStart) {
        this.setOpacity(opacityStart);
        opacityEnd = opacityStart;
    }

    if(!rotationRange) {
        this.setRotation(rotationStart);
        rotationEnd = rotationStart;
    }

	var c = {};

	c.xRange = xRange;
	c.yRange = yRange;
	c.scaleXRange = scaleXRange;
	c.scaleYRange = scaleYRange;
	c.opacityRange= opacityRange;
	c.rotationRange = rotationRange;
	c.valueRange = valueRange;
	
	c.wStart = wStart;
	c.hStart = hStart;
	c.xStart = xStart;
	c.yStart = yStart;
	c.scaleXStart = scaleXStart;
	c.scaleYStart = scaleYStart;
	c.opacityStart= opacityStart;
	c.rotationStart = rotationStart;
	c.valueStart = valueStart;

	c.startTime = Date.now();
	c.duration = duration;
	c.onDone = onDone;
	c.onStep = onStep;
	c.interpolator = interpolator;
	c.next = config.next;
	c.name = config.name;
	c.now = c.startTime;

	if(config.delay) {
		c.startTime += config.delay;
	}

	this.animatingInfo = c;
	this.postRedraw();

	return true;
}

UIElement.prototype.callOnAnimateDone = function(config) {
	this.animating = false;
	this.animatingInfo = null;

	var onDone = config.onDone;
	if(onDone) {
		onDone.call(this, config.name);
	}
	
	if(!this.parentShape) return false;

	this.callOnAnimateDoneHandler(config.name);

	if(!this.parentShape) return false;

	var next = config.next;

	if(next) {
		if(typeof next === "string") {
			if(!this.animations[next]) {
				return false;
			}
		}

		//this.animate(next, next.onDone || config.onDone || '', 
		//	next.onStep || config.onStep || '', next.actionWhenBusy || '');
		this.animate(next);

		return true;
	}

	return false;
}

UIElement.prototype.isAnimating = function() {
	return this.animatingInfo && this.parentShape;
}

UIElement.prototype.stepAnimation = function(canvas, now) {
	var c = this.animatingInfo;
	
	if(!c || !this.parentShape) return;

	c.now += canvas.timeStep;
	if(!now) {
		now = c.now;
	}
	
	canvas.needRedraw++;
	if(c.startTime > now) {
		return;
	}

	if(!this.visible) {
		this.visible = true;
	}

	var xRange = c.xRange;
	var yRange = c.yRange;
	var valueRange 	  = c.valueRange;
	var scaleXRange   = c.scaleXRange;
	var scaleYRange   = c.scaleYRange;
	var opacityRange  = c.opacityRange;
	var rotationRange = c.rotationRange;
	
	var wStart = c.wStart;
	var hStart = c.hStart;
	var xStart = c.xStart;
	var yStart = c.yStart;
	var scaleXStart   = c.scaleXStart;
	var scaleYStart   = c.scaleYStart;
	var opacityStart  = c.opacityStart;
	var rotationStart = c.rotationStart;
	var valueStart 	  = c.valueStart;

	var onStep = c.onStep;
	var duration = c.duration;
	var startTime = c.startTime;
	var interpolator = c.interpolator;

	var timePercent = (now - startTime)/duration;
	var percent = interpolator.get(timePercent);

	if(valueRange) {
		c.value = valueStart + percent * valueRange;
	}

	if(timePercent >= 1) {
		percent = 1;
	}

	if(xRange || yRange) {
		var x = Math.floor(xStart + percent * xRange);
		var y = Math.floor(yStart + percent * yRange);
		this.setPosition(x, y);
	}

	if(opacityRange) {
		this.opacity = opacityStart + percent * opacityRange;	
	}

	if(rotationRange) {
		this.setRotation(rotationStart + percent * rotationRange);
	}

	if(scaleXRange) {
		this.setScaleX(scaleXStart + percent * scaleXRange);
	}

	if(scaleYRange) {
		this.setScaleY(scaleYStart + percent * scaleYRange);
	}

	if(onStep && !onStep(this, timePercent, c)) {
		this.callOnAnimateDone(c);
		return;
	}

	if(percent < 1) {
		this.animating = true;
	}
	else {
		this.callOnAnimateDone(c);
	}

	return;
}

UIElement.prototype.isHitWorkArea = function() {
	return this.hitTestResult === Shape.HIT_TEST_MM && this.children.length > 1 && this.canRectSelectable();
}

UIElement.prototype.setPropagatePointerEvent = function(value) {
	this.propagatePointerEvent = value;

	return this;
}

UIElement.prototype.getPropagatePointerEvent = function() {
	return this.propagatePointerEvent;
}

UIElement.prototype.shouldPropagatePointerEvent = function() {
	return this.propagatePointerEvent 
		&& !this.isInDesignMode() 
		&& (!this.targetShape || this.targetShape.shouldPropagatePointerEvent());
}

UIElement.prototype.onPointerDownNormal = function(point) {
	var p = this.translatePoint(point);
	
	this.hitTestResult = this.hitTest(point);

	if(!this.hitTestResult) {
		if(this.isUIScrollView && !this.isInDesignMode()) {
			return false;
		}

		if(this.dispatchPointerDownToChildren(p)) {
			this.setPointerEventTarget(this.targetShape);
			return true;
		}
		return false;
	}

	this.pointerDown = true;
	this.pointerDownTime = Date.now();
	this.childrenRange = this.calcChildrenRange();

	if(this.isInDesignMode()) {
		this.onPointerDownEditing(point, true);
	}
	else if(this.enable) {
		this.onPointerDownRunning(p, true);
	}

	this.setPointerEventTarget(null);
	if(this.hitTestResult === Shape.HIT_TEST_MM || !this.selected) {
		if(this.dispatchPointerDownToChildren(p)) {
			if(this.isInDesignMode()) {
				this.onPointerDownEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerDownRunning(p, false);
			}
			
			this.lastPosition.x = point.x;
			this.lastPosition.y = point.y;
			this.setPointerEventTarget(this.targetShape);

			return true;
		}
	}

	if(this.isHitWorkArea()) {
		this.hitTestResult = Shape.HIT_TEST_WORKAREA;
	}

	this.setTarget(null);
	this.setSelected(true);
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;
	if(this.isInDesignMode()) {
		this.handlePointerEvent(point, 1);
	}
	
	if(this.isInDesignMode()) {
		this.onPointerDownEditing(point, false);
	}
	else if(this.enable) {
		this.onPointerDownRunning(p, false);
	}

	this.postRedraw();

	return true;
}

UIElement.prototype.getPointerPosition = function() {
	var win = this.getWindow();

	return win.lastPosition;
}

UIElement.prototype.onPointerMoveNormal = function(point) {
	if(!this.isInDesignMode() && !this.isUIWindowManager && !this.isUIWindow) {
		if(!this.win.pointerDown) {
			return;
		}
	}

	var p = this.translatePoint(point);
	if(this.draggable && this.pointerDown) {
		if(!this.isInDesignMode()) {
			this.handleDragMove(point);
			return;
		}
		else {
			delete this.dragging;
		}
	}

	if(this.hitTestResult) {
		if(this.isInDesignMode()) {
			this.onPointerMoveEditing(point, true);
		}
		else if(this.enable) {
			this.onPointerMoveRunning(p, true);
		}

		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerMove(p);
			if(this.isInDesignMode()) {
				this.onPointerMoveEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, false);
			}
		}
		else {
			if(this.isInDesignMode()) {
				this.onPointerMoveEditing(point, false);
				if(this.hitTestResult === Shape.HIT_TEST_WORKAREA && this.isUIWindow) {
					var p = {x:0, y:0};
					var w = point.x - this.pointerDownPosition.x;
					var h = point.y - this.pointerDownPosition.y;
					var x = this.pointerDownPosition.x - this.left;
					var y = this.pointerDownPosition.y - this.top;
					var r = {x:x, y:y, w:w, h:h};

					if(Math.abs(w) > 5 && Math.abs(h) > 5) {
						r = fixRect(r);
						this.setSelected(false);
						for(var i = this.children.length - 1; i >= 0; i--) {
							var iter = this.children[i];
							p.x = iter.left + iter.w/2;
							p.y = iter.top + iter.h/2;
							iter.setSelected(isPointInRect(p, r));
						}
					}
				}
				else {	
					this.handlePointerEvent(point, 0);
				}
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, false);
			}
		}

		this.lastPosition.x = point.x;
		this.lastPosition.y = point.y;

		return true;
	}
	else {
		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerMove(p);
		}

		if(target || this.isUIWindow) {
			if(this.isInDesignMode()) {
				this.onPointerMoveEditing(point, false);
			}
			else if(this.enable) {
				this.onPointerMoveRunning(p, true);
				this.onPointerMoveRunning(p, false);
			}
		}
	}
		
	this.lastPosition.x = point.x;
	this.lastPosition.y = point.y;

	return false;
}

UIElement.prototype.onPointerUpNormal = function(point) {
	if(this.hitTestResult) {
		var p = this.translatePoint(point);
		var isClick = this.isClicked();
		
		if(this.isInDesignMode()) {
			this.onPointerUpEditing(point, true);
		}
		else if(this.enable) {
			this.onPointerUpRunning(p, true);
		}

		if(isClick && this.enable) {
			this.onClick(p, true);
		}

		var target = this.getPointerEventTarget();
		if(target) {
			target.onPointerUp(p);
		}
		else {
			if(this.isInDesignMode()) {
				this.handlePointerEvent(point, -1);
			}
		}

		if(this.isInDesignMode()) {
			this.onPointerUpEditing(point, false);
		}
		else {
			if(this.dragging) {
				this.handleDragUp(point);
			}
			else if(this.enable) {
				this.onPointerUpRunning(p, false);
			}
		}

		if(isClick && this.enable) {
			this.onClick(p, false);
		}
		
		this.hitTestResult = Shape.HIT_TEST_NONE;

		if(this.longPressed) {
			this.longPressed = false;
		}

		if(this.isUIWindow) {
			UIElement.hScrollHandledBy = null;
			UIElement.vScrollHandledBy = null;
		}

		return true;
	}
	else {
		this.targetShape = null;

		if(!this.isInDesignMode() && this.enable) {
			this.onPointerUpRunning(p, false);
			if(isClick) {
				this.onClick(p, false);
			}
		}

		if(this.longPressed) {
			this.longPressed = false;
		}
		
		var target = this.getPointerEventTarget();
		if(target) {
			var p = this.translatePoint(point);
			target.onPointerUp(p);
		}

		if(this.isUIWindow) {
			UIElement.hScrollHandledBy = null;
			UIElement.vScrollHandledBy = null;
		}
	}

	return false;
}

UIElement.prototype.needDrawTextTips = function(point) {
	return this.isInDesignMode() && !this.children.length;	
}

UIElement.prototype.textEditable = function(point) {
	return this.isInDesignMode();	
}

UIElement.prototype.isClicked = function() {
	if(!this.view) {
		return false;
	}

	if(this.longPressed && this.events["onLongPress"]) {
		console.log("Long Pressed, Ignore Click Event.");
		return false;
	}

	return this.view.isClicked();
}


UIElement.prototype.onKeyDownRunning = function(code) {
	if(!this.handleKeyDown || this.mode === Shape.MODE_PREVIEW) {
		var sourceCode = this.events["onKeyDown"];
		if(sourceCode) {
			sourceCode = "this.handleKeyDown = function(code) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleKeyDown) {
		try {
			this.handleKeyDown(code);
		}catch(e) {
			console.log("this.handleKeyDown:" + e.message);
		}
	}

	return true;
}

UIElement.prototype.onKeyDownEditing = function(code) {
}

UIElement.prototype.onKeyDown = function(code) {
	if(this.targetShape) {
		this.targetShape.onKeyDown(code);
	}

	if(this.isInDesignMode()) {
		this.onKeyDownEditing(code);
	}
	else {
		this.onKeyDownRunning(code);
	}

	return;
}

UIElement.prototype.onKeyUpRunning = function(code) {
	if(!this.handleKeyUp || this.mode === Shape.MODE_PREVIEW) {
		var sourceCode = this.events["onKeyUp"];
		if(sourceCode) {
			sourceCode = "this.handleKeyUp = function(code) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleKeyUp) {
		try {
			this.handleKeyUp(code);
		}catch(e) {
			console.log("this.handleKeyUp:" + e.message);
		}
	}else if(this.isUIWindow && code == KeyEvent.DOM_VK_BACK_BUTTON && !cantkIsEditorActive()) {
		console.log("Back Key Pressed On: " + this.name);
		if(this.isMainWindow()) {
			var app = this.getApp();
			var wm = this.getWindowManager();

			if(this.mode === Shape.MODE_RUNNING) {
				wm.systemExit();
				app.exitApp();
				console.log("Back Key Pressed, Exit App.");
			}
		}
		else {
			this.closeWindow(0);
			console.log("Back Key Pressed, Close Current Window.");
		}
	}

	return true;
}

UIElement.prototype.onKeyUpEditing = function(code) {
}

UIElement.prototype.onKeyUp = function(code) {
	if(code === KeyEvent.DOM_VK_BACK && this.isUIWindow) {
		this.closeWindow(0);

		return;
	}

	if(this.targetShape) {
		this.targetShape.onKeyUp(code);
	}

	if(this.isInDesignMode()) {
		this.onKeyUpEditing(code);
	}
	else {
		this.onKeyUpRunning(code);
	}

	return;
}

UIElement.prototype.afterSetView = function() {

	return true;
}

UIElement.prototype.setView = function(view) {
	this.view = view;

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setView(view);
	}

	this.afterSetView(view);

	return;
}

UIElement.prototype.setApp = function(app) {
	this.app = app;
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.setApp(app);
	}

	return;
}

UIElement.prototype.shapeCanBeChild = function(shape) {
	return true;
}

UIElement.prototype.onAppendedInParent = function() {
	if(this._win) {
		delete this._win;
	}

}

UIElement.prototype.setParent = function(parentShape) {
	if(!parentShape) {
		this.detachNameFromParent();
	}

	this.parentShape = parentShape;

	return this;
}

Object.defineProperty(UIElement.prototype, "name", {
    set: function(name) {
        this.detachNameFromParent();
		this._name = name;
		this.attachNameToParent();
    },
    get: function() {
        return this._name;
    }
});

UIElement.prototype.setName = function(name) {
	if(this.name !== name) {
		this.name = name;
	}

	return this;
}

UIElement.prototype.detachFromParent = function() {
	var parent = this.getParent();
	if(parent) {
		if(parent.targetShape === this) {
			parent.targetShape = null;
		}
		if(parent.pointerEventTarget === this) {
			parent.pointerEventTarget = null;
		}

		this.detachNameFromParent();
	}

	this.parentShape = null;
}

UIElement.prototype.attachNameToParent = function() {
	var parent = this.getParent();
	if(parent) {
		if(!this.isInDesignMode()) {
			var name = this.name;
			if(parent[name] === undefined) {
				parent[name] = this;
			}else{
				UIElement.logWarning("skip duplicated name:" + name);
			}
		}
	}

	return this;
}

UIElement.prototype.detachNameFromParent = function() {
	var parent = this.getParent();
	if(parent) {
		if(!this.isInDesignMode()) {
			var name = this.name;
			var obj = parent[name];
			if(obj === this) {
				delete parent[name];
			}
		}
	}
	
	return this;
}

UIElement.prototype.afterChildAppended = function(shape) {
	if(this.isUILayout) {
		this.relayoutChildren();
	}

	return true;
}

UIElement.prototype.beforeAddShapeIntoChildren = function(shape) {
	return true;
}

UIElement.prototype.addShapeIntoChildren = function(shape, p) {
	var r = {x:0, y:0, w:0, h:0};
	for(var i = this.children.length - 1; i >= 0; i--) {
		var iter = this.children[i];

		if(iter === shape) continue;

		if(iter.isContainer && iter.visible) {
			r.x = iter.left;
			r.y = iter.top;
			r.w = iter.w;
			r.h = iter.h;

			if(isPointInRect(p, r)) {
				return iter.addShape(shape, true, p);
			}
		}
	}

	return false;
}

UIElement.prototype.addChildWithJson = function(jsShape, index) {
	var type = jsShape.type ? jsShape.type : jsShape.id;
	var shape = ShapeFactoryGet().createShape(type, C_CREATE_FOR_USER);

	if(shape) {
		shape.fromJson(jsShape);
		this.addShape(shape, false, null, index || shape.z);
		shape.setVisible(true);
		shape.attachNameToParent();
	}

	return shape;
}

UIElement.prototype.setAlwaysOnTop = function(value) {
	this.alwaysOnTop = value;

	return;
}

UIElement.onAddShape = function(shape, addByUser) {
}

UIElement.prototype.fixName = function() {
	var shape = this;
	var parentShape = this.getParent();

	if(!shape.name) {
		shape.name = shape.type;
	}

	var name = shape.name;
    
    if(!this.isInDesignMode()) {
        shape.name = shape.name + "_" + Date.now() + "_" + Math.round(Math.random() * 10000);
        return;
    }

    name = name.replaceAll("-", "_");
	var prefix = name;
    var split = name.lastIndexOf('_');
	var indStr = name.substring(split + 1);
    var i = Math.abs(parseInt(indStr));
    var index;   
 
	if(!isNaN(i)) {
		prefix = name.slice(0, split)
	    index = i;
    }
	else {
		index = 1;
	}

	for(var i = index; i < 1000; i++) {
		if(parentShape.find(name)) {
			if(prefix[prefix.length-1] === '_') {
				name = prefix + i; 
			}
			else {
				name = prefix +"_"+ i;
			}
		}
		else {
			break;
		}
	}

	shape.name = name;

	return this;
}


UIElement.prototype.addShape = function(shape, offsetIt, point, index) {
	if(!shape.isUIElement) {
		return false;
	}

	if(shape.parentShape) {
		UIElement.logWarning("child has a parent, cannot call addChild again.");
		return false;	
	}

	if(offsetIt) {
		shape.moveDelta(-this.left, -this.top);
	}

	if(this.beforeAddShapeIntoChildren(shape) && point) {
		var p = this.translatePoint(point);
		if(this.addShapeIntoChildren(shape, p)) {
			return true;
		}
		shape.setLeftTop(p.x, p.y);	
	}

	if(!this.shapeCanBeChild(shape)) {
		return false;
	}

	shape.setParent(this);
	shape.setView(this.view);
	shape.setApp(this.app);

	var children = this.children;
	var n = children.length;

	if(index === undefined) {
		if(n) {
			index = this.children[n-1].z + 1;
		}
		else {
			index = 0;	
		}
	}
	
	children.push(shape);
	shape.setZIndex(index);
	n = children.length;

	if(shape.isUIElement) {
		shape.setMode(this.mode, true);
		if(!this.isInDesignMode()) {
			shape.init();
		}
	}

	for(var i = 0; i < children.length; i++) {
		var iter = children[i];

		if(iter.alwaysOnTop) {
			children.remove(iter);
			children.push(iter);
			break;
		}
	}

	if(shape.isCreatingElement()) {
		shape.callOnBirthedHandler(true);
	}

	shape.onAppendedInParent();
	this.afterChildAppended(shape);
	UIElement.onAddShape(shape, offsetIt);

	return true;
}

UIElement.prototype.appendChild = function(shape) {
	var arr = this.children;
	var n = arr.length;
	
	if(shape.z === undefined) {
		shape.z = n;
	}

	if(!n) {
		arr.push(shape);
		return;
	}

	for(var i = n-1; i >= 0; i--) {
		var iter = arr[i];
		if(iter.z <= shape.z) {
			arr.splice(i+1, 0, shape);
			return;
		}
	}
	arr.splice(0, 0, shape);

	return;
}

UIElement.prototype.addShapeDirectly = function(shape) {
	if(!this.shapeCanBeChild(shape)) {
		return false;
	}

	this.setDisableRelayout(true);
	shape.setDisableRelayout(true);

	shape.setParent(this);
	shape.setView(this.view);
	shape.setApp(this.app);
	this.appendChild(shape);
	if(shape.isUIElement) {
		shape.mode = this.mode;
	}
	this.afterChildAppended(shape);
	shape.onAppendedInParent();

	this.setDisableRelayout(false);
	shape.setDisableRelayout(false);

	return true;
}

UIElement.prototype.addChild = function(child, zIndex) {
	if(this.addShape(child, false, null, zIndex || child.z)) {
		child.attachNameToParent();
		return child;
	}
	else {
		return null;
	}
}
	
UIElement.prototype.shapeCanBeRemove = function(shape) {
	return true;
}

UIElement.prototype.afterChildRemoved = function(shape) {
	return true;
}

UIElement.prototype.remove = function(destroyIt, sync) {
	var parentShape = this.getParent();

	if(parentShape) {
		parentShape.removeChild(this, destroyIt, sync);	
	}

	return this;
}

UIElement.prototype.removeAll = function() {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[0];
		this.removeShape(iter);
	}

	return;
}

UIElement.prototype.removeChildren = function(destroyThem) {
	this.targetShape = null;
	this.pointerEventTarget = null;

	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];

		if(iter.getParent() === this) {
			iter.onRemoved(this);
			iter.setParent(null);
			iter.setView(null);
			iter.setApp(null);
		}
	}

	if(destroyThem) {
		this.children.clear();
	}else{
		this.children.length = 0;
	}

	return this;
}

UIElement.prototype.removeChild = function(child, destroyIt, sync) {
	var me = this;

	if(child.animatingInfo) {
		UIElement.logWarning("removing animating element.");
	}

	if(sync) {
		this.removeShape(child, destroyIt);
	}
	else {
		child.removed = true;
		setTimeout(function() {
			me.removeShape(child, destroyIt);
			child = null;
			me = null;
		}, 0);
	}
	
	if(this.targetShape === child) {
		this.targetShape = null;
	}

	if(this.pointerEventTarget === child) {
		this.pointerEventTarget = null;
	}

	return this;
}

UIElement.onRemoveShape = function(parentShape, shape) {
}

UIElement.prototype.removeShape = function(shape, destroyIt) {
	if(!this.shapeCanBeRemove(shape) || !shape.parentShape) {
		return false;
	}

	if(shape.animatingInfo) {
		UIElement.logWarning("removing animating element.");
	}

	this.children.remove(shape);
	
	shape.callOnRemovedHandler();
	this.afterChildRemoved(shape);

	if(shape.getParent() === this) {
		shape.setParent(null);
		shape.setView(null);
		shape.setApp(null);
	}

	if(this.isUILayout) {
		this.relayoutChildren();
	}

	UIElement.onRemoveShape(this, shape);
	shape.onRemoved(this);

	if(destroyIt) {
		shape.destroy();
	}

	return;
}

UIElement.prototype.reparent = function(newParent, keepAbsPosition) {
	var parent = this.getParent();
	if(newParent === parent) {
		return;
	}

	if(!newParent || !parent) {
		return;
	}

	if(keepAbsPosition) {
		var parentPos = parent.getPositionInWindow();
		var newParentPos = newParent.getPositionInWindow();
		var dx = parentPos.x - newParentPos.x;
		var dy = parentPos.y - newParentPos.y;

		this.left += dx;
		this.top += dy;
	}

	parent.children.remove(this);
	newParent.addShapeDirectly(this);

	return;
}

UIElement.prototype.afterPropertyChanged = function() {
	if(this.parentShape) {
		this.parentShape.relayoutChildren();
	}
	else {
		this.relayout();
	}

	return;
}

UIElement.prototype.getIndexOfChild = function(child) {
	return this.children.indexOf(child);
}

UIElement.prototype.getIndex = function() {
	if(this.parentShape) {
		return this.parentShape.getIndexOfChild(this);
	}
	else {
		return -1;
	}
}

UIElement.prototype.getZIndex = function() {
	return this.z;
}

UIElement.prototype.onRestack = function() {
}

UIElement.prototype.setZIndex = function(index) {
	this.z = index;

	var parentShape = this.parentShape;
	if(parentShape) {
		var arr = parentShape.children;
		var n = arr.length;
		for(var i = 0; i < n; i++) {
			var iter = arr[i];
			if(iter.z === undefined) {
				iter.z = i;	
			}
		}

		arr.stableSort(function(a, b) {
			return a.z - b.z;
		});
	}

	this.onRestack();

	return this;
}

UIElement.prototype.findChildByType = function(type, recursive) {
	var i = 0;
	var s = null;
	var shape = null;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		shape = this.children[i];
		if(shape.type === type) {
			return shape;
		}
	}

	if(recursive) {
		for(i = 0; i < n; i++) {
			shape = this.children[i];
			s = shape.findChildByType(type, recursive);
			if(s) {
				return s;
			}
		}
	}

	return null;
}

UIElement.prototype.findChildByPath = function(names) {
	var name = names.shift();
	var child = this.findChildByName(name);

	if(names.length) {
		return child.findChildByPath(names);
	}

	return child;
}

UIElement.prototype.findChildByName = function(name, recursive) {
	var i = 0;
	var s = null;
	var shape = null;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		shape = this.children[i];
		if(shape.name === name) {
			return shape;
		}
	}

	if(recursive) {
		for(i = 0; i < n; i++) {
			shape = this.children[i];
			s = shape.findChildByName(name, recursive);
			if(s) {
				return s;
			}
		}
	}

	return null;
}

UIElement.prototype.find = function(name, recursive) {
	if(!name) {
		return this;
	}

	if(name.indexOf("/") >= 0) {
		var names = name.split("/");
		names.remove("");

		return this.findChildByPath(names);
	}
	else {
		return this.findChildByName(name, recursive);
	}
}

UIElement.prototype.setValueOf = function(name, value) {
	var child = this.findChildByName(name, true);
	
	return child ? child.setValue(value) : null;
}

UIElement.prototype.getValueOf = function(name) {
	var child = this.findChildByName(name, true);
	
	return child ? child.getValue() : null;
}

UIElement.prototype.beforePaintChild = function(child, canvas) {
	return;
}

UIElement.prototype.afterPaintChild = function(child, canvas) {
	return;
}

UIElement.prototype.paintTargetShape = function(canvas) {
	var targetShape = this.targetShape;
	if(targetShape && ((this.isUIList && this.isInDesignMode()) || this.isUIGrid)) {
		shape = targetShape;
		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}

	return;
}

UIElement.prototype.defaultPaintChildren = function(canvas) {
	canvas.save();
	canvas.beginPath();
	var shape = null;
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		shape = this.children[i];
		if(!shape) {
			continue;
		}

		if(shape.visible) {
			this.beforePaintChild(shape, canvas);
			shape.paintSelf(canvas);
			this.afterPaintChild(shape, canvas);
		}
		else if(shape.isAnimating()){
			shape.stepAnimation(canvas);
		}
	}
	
	this.paintTargetShape(canvas);

	canvas.restore();
	
	return;
}

UIElement.prototype.beforePaintChildren = function(canvas) {
	if(!this.rotateChildren && this.rotation) {
		var hw = this.w >> 1;
		var hh = this.h >> 1;
		canvas.translate(hw, hh);
		canvas.rotate(-this.rotation);
		canvas.translate(-hw, -hh);
	}

	return;
}

UIElement.prototype.afterPaintChildren = function(canvas) {
	return;
}

UIElement.prototype.paintChildren = function(canvas) {
	this.defaultPaintChildren(canvas);

	return;
}

UIElement.prototype.paintSelfOnly =function(canvas) {
	return;
}

UIElement.prototype.drawImageAtCenter = function(ctx, image, x, y, w, h, keepRatio) {

	if(image && image.width > 0) {
		var imageW = image.width;
		var imageH = image.height;

		if(keepRatio) {
			var scale = Math.min(1, Math.min(h/imageH, w/imageW));
			var dw = imageW * scale;
			var dh = imageH * scale;
			var dx = ((w - dw)>>1) + x;
			var dy = ((h - dh)>>1) + y;
			
			dx = Math.max(dx, x);
			dy = Math.max(dy, y);
		}
		else {
			dx = x;
			dy = y;
			dw = w;
			dh = h;
		}

		ctx.drawImage(image, 0, 0, imageW, imageH, dx, dy, dw, dh);
	}

	return;
}


UIElement.prototype.drawImage =function(canvas) {
	this.drawFgImage(canvas);

	return;
}

UIElement.prototype.drawFgImage =function(canvas) {
	return;
}

UIElement.prototype.getBgHtmlImage =function() {
	var image = this.getBgImage();

	return image ? image.getImage() : null;
}

UIElement.prototype.getBgImage =function() {
	var image = null;
	
	if(this.enable) {
		if(this.pointerDown && !this.isClicked()) {
			image = this.images.normal_bg;
		}
		else {
			if(this.pointerDown) {
				image = this.images.active_bg;
			}
			else {
				if(this.isPointerOverShape() && this.getHtmlImageByType(UIElement.IMAGE_POINTER_OVER)) {
					image = this.images.pointer_over_bg;
				}
				else if(this.isFocused()) {
					image = this.images.focused_bg;
				}
				else {
					image = this.images.normal_bg;
				}
			}
		}
	}
	else {
		image = this.images.disable_bg;
	}

	if(!image || !image.getImage()) {
		image = this.images.default_bg;
	}
	
	if(!image || !image.getImage()) {
		image = this.images.normal_bg;
	}

	if(!image || !image.getImage()) {
		return;
	}

//	image = image.getImage();

	return image;
}

UIElement.prototype.drawImageAt = function(canvas, image, display, x, y, dw, dh, srcRect) {
	UIElement.drawImageAt(canvas, image, display, x, y, dw, dh, srcRect);
}

UIElement.drawImageAt = function(canvas, image, display, x, y, dw, dh, srcRect) {
	return WImage.draw(canvas, image, display, x, y, dw, dh, srcRect);
}

UIElement.drawImageLine = function(canvas, image, display, p0, p1, srcRect) {
	var angle = Math.lineAngle(p0, p1);
	var distance = Math.round(Math.distanceBetween(p0, p1));

	canvas.save();
	canvas.translate(p0.x, p0.y);
	canvas.rotate(angle);
	canvas.translate(0, -image.height>> 1);
	UIElement.drawImageAt(canvas, image, display, 0, 0, distance, image.height, srcRect);
	canvas.restore();

	return;
}

UIElement.prototype.setImageScale = function(imageScaleX, imageScaleY) {
	this.imageScaleX = imageScaleX;
	this.imageScaleY = imageScaleY;
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	return this;
}

UIElement.prototype.drawBgImageScale =function(canvas, image, rect, sx, sy) {
	var w = this._w;
	var h = this._h;
	var hw = w >> 1;
	var hh = h >> 1;

	canvas.save();
	canvas.translate(hw, hh);
	canvas.scale(sx, sy);
	canvas.translate(-hw, -hh);

	WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, w, h, rect);
	canvas.restore();
}

UIElement.prototype.drawBgImage =function(canvas) {
	var wImage = this.getBgImage();
		
	if(wImage) {
		var image = wImage.image;
		var srcRect = wImage.rect;
		var display = this.images.display;
		var scaleX = this.imageScaleX;
		var scaleY = this.imageScaleY;

		if((scaleX === 1 && scaleY === 1) || (!scaleX && !scaleY) || display !== UIElement.IMAGE_DISPLAY_SCALE) {
			WImage.draw(canvas, image, display, 0, 0, this.w, this.h, srcRect);
		}else{
			this.drawBgImageScale(canvas, image, srcRect, scaleX, scaleY);
		}
	}

	return;
}

UIElement.prototype.beforeDrawIcon = function(canvas) {
	return false;
}

UIElement.prototype.afterDrawIcon = function(canvas) {
	return false;
}

UIElement.prototype.prepareStyle = function(canvas) {
	var style = this.style;

	canvas.beginPath();
	if(canvas.lineWidth !== style.lineWidth) {
		canvas.lineWidth = style.lineWidth;	
	}

	if(canvas.strokeStyle != style.lineColor) {
		canvas.strokeStyle = style.lineColor;
	}
	
	if(canvas.fillStyle != style.fillColor) {
		canvas.fillStyle = style.fillColor;
	}

	return;
}

UIElement.prototype.updateTransform = function(canvas) {
	if(this.events["onUpdateTransform"] || this.hasEventListener("updatetransform")) {
		if(!this.isInDesignMode()) {
			this.callOnUpdateTransformHandler(canvas);
		}
	}
	
	return;
}

//
//Example:
//==========================================
//var config = {};
//config.rotationFrom = -0.2;
//config.rotationTo = 0.2;
//
//config.scaleFrom =  0.9;
//config.scaleTo = 1.1;
//
//config.opacityFrom =  0.1;
//config.opacityTo = 1.0;
//config.frequency = 0.5;
//
//var image = this.getWindow().findChildByName("ui-image", true);
//image.setHighlightConfig(config);
//

UIElement.prototype.saveTransform = function() {
	this.savedTransform = {};
	this.savedTransform.opacity = this.opacity;
	this.savedTransform.scale = this.scale;
	this.savedTransform.scaleX = this.scaleX;
	this.savedTransform.scaleY = this.scaleY;
	this.savedTransform.rotation = this.rotation;
	this.savedTransform.offsetX = this.offsetX;
	this.savedTransform.offsetY = this.offsetY;

	return;
}

UIElement.prototype.restoreTransform = function() {
	if(this.savedTransform) {
		this.opacity = this.savedTransform.opacity;
		this.scale = this.savedTransform.scale;
		this.scaleX = this.savedTransform.scaleX;
		this.scaleY = this.savedTransform.scaleY;
		this.rotation = this.savedTransform.rotation;
		this.offsetX = this.savedTransform.offsetX;
		this.offsetY = this.savedTransform.offsetY;
	}

	return;
}

UIElement.prototype.setHighlightConfig = function(highlightConfig) {
	if(highlightConfig) {
		//this.restoreTransform();
		var c = JSON.parse(JSON.stringify(highlightConfig));

		c.startTime = 0;
		this.saveTransform();
		this.removeHighlightConfig = false;
		this.highlightConfig = c;

		if(c.rotationFrom !== undefined && c.rotationTo !== undefined) {
			c.rotationRange = c.rotationTo - c.rotationFrom;
			c.rotationMiddle = (c.rotationTo + c.rotationFrom)/2;
		}
		else {
			c.rotationRange = 0;
		}

		if(c.opacityFrom !== undefined && c.opacityTo !== undefined) {
			c.opacityRange = c.opacityTo - c.opacityFrom;
			c.opacityMiddle = (c.opacityTo + c.opacityFrom)/2;
		}
		else {
			c.opacityRange = 0;
		}

		if(c.scaleFrom !== undefined && c.scaleTo !== undefined) {
			c.scaleRange = c.scaleTo - c.scaleFrom;
			c.scaleMiddle = (c.scaleTo + c.scaleFrom)/2;
		}
		else {
			c.scaleRange = 0;
		}

		if(c.scaleXFrom !== undefined && c.scaleXTo !== undefined) {
			c.scaleXRange = c.scaleXTo - c.scaleXFrom;
			c.scaleXMiddle = (c.scaleXTo + c.scaleXFrom)/2;
		}
		else {
			c.scaleXRange = 0;
		}

		if(c.scaleYFrom !== undefined && c.scaleYTo !== undefined) {
			c.scaleYRange = c.scaleYTo - c.scaleYFrom;
			c.scaleYMiddle = (c.scaleYTo + c.scaleYFrom)/2;
		}
		else {
			c.scaleYRange = 0;
		}

		if(c.offsetXFrom !== undefined && c.offsetXTo !== undefined) {
			c.offsetXRange = c.offsetXTo - c.offsetXFrom;
			c.offsetXMiddle = (c.offsetXTo + c.offsetXFrom)/2;
		}
		else {
			c.offsetXRange = 0;
		}

		if(c.offsetYFrom !== undefined && c.offsetYTo !== undefined) {
			c.offsetYRange = c.offsetYTo - c.offsetYFrom;
			c.offsetYMiddle = (c.offsetYTo + c.offsetYFrom)/2;
		}
		else {
			c.offsetYRange = 0;
		}
	}
	else {
		this.removeHighlightConfig = true;
	}

	return;
}

UIElement.prototype.updateHighlightTransform = function(canvas) {
	var paused = this.timeScaleIsZero() || (this.isInDesignMode() && this.disablePreview);

	if(this.highlightConfig && !paused) {
		var c = this.highlightConfig;
		
		if(c.paused) return;

		var me = this;
		var tOffset = 0;
		var random = c.random ? c.random/1000 : 0;	
		var frequency = c.frequency ? c.frequency : 4;

		if(c.startTime) {
			tOffset = (canvas.now - c.startTime)/1000;
		}
		else {
			c.startTime = Date.now();
		}
		tOffset += 1/(frequency*4) + random;
		var womiga = frequency * Math.PI * 2;
        var factor = this.scaleTime(Math.cos(womiga*tOffset) * 0.5);

		if(this.removeHighlightConfig && Math.abs(factor) < 0.1) {
			this.removeHighlightConfig = false;
			this.highlightConfig = null;
			this.restoreTransform();

			return;
		}

		if(c.rotationRange) {
			this.rotation = c.rotationMiddle + c.rotationRange * factor;
		}
		if(c.opacityRange) {
			this.opacity = c.opacityMiddle + c.opacityRange * factor;
		}
		if(c.scaleRange) {
			var scale = c.scaleMiddle + c.scaleRange * factor;
			this.scaleX = scale;
			this.scaleY = scale;
		}
		if(c.scaleXRange) {
			this.scaleX = c.scaleXMiddle + c.scaleXRange * factor;
		}
		if(c.scaleYRange) {
			this.scaleY = c.scaleYMiddle + c.scaleYRange * factor;
		}
		if(c.offsetXRange) {
			this.offsetX = c.offsetXMiddle + c.offsetXRange * factor;
		}
		if(c.offsetYRange) {
			this.offsetY = c.offsetYMiddle + c.offsetYRange * factor;
		}

		canvas.needRedraw++;
	}

	return;
}

UIElement.prototype.paintSelf = function(canvas) {
	this.stepAnimation(canvas);

	if(!this.visible) return;

	var animating = this.animating;

	canvas.save();
	this.translate(canvas);

	if(!animating) {
		this.updateTransform(canvas);
	}

	if(this.highlightConfig) {
		this.updateHighlightTransform(canvas);
	}
	
	this.applyTransform(canvas);
	this.onClip(canvas);

	canvas.save();

	var flipX = this.flipX ? -1 : 1;
	var flipY = this.flipY ? -1 : 1;
	if(flipX < 0 || flipY < 0) {
		canvas.save();
		
		var hw = this.w >> 1;
		var hh = this.h >> 1;
		canvas.translate(hw, hh);
		canvas.scale(flipX, flipY);
		canvas.translate(-hw, -hh);
	}

	if(this.beforePaint) {
		this.beforePaint(canvas);
	}
	this.drawBgImage(canvas);
	this.paintSelfOnly(canvas);
	this.drawImage(canvas);

	if(flipX < 0 || flipY < 0) {
		canvas.restore();
	}

	canvas.restore();

	if(this.children.length || this.isInDesignMode()) {
		canvas.save();
		if(animating) {
			canvas.animating++;
		}
		this.beforePaintChildren(canvas);
		this.paintChildren(canvas);
		this.afterPaintChildren(canvas);
		if(animating) {
			canvas.animating--;
		}
		canvas.restore();
	}

	if(this.drawText && this.textType !== Shape.TEXT_NONE) {
		this.drawText(canvas);
		this.drawTextTips(canvas);
	}

	if(this.afterPaint) {
		this.afterPaint(canvas);
	}

	canvas.restore();
	
	return;
}

UIElement.prototype.saveProps = [];
UIElement.prototype.urlProps = ["dataURL"];
UIElement.saveProps = ["xAttr", "yAttr", "widthAttr", "heightAttr", "xParam", "yParam", "widthParam", "heightParam", "sticky", "flipX", "flipY", "rotateChildren", "defaultAnimationName", "dataURL", "disablePreview", "dataSourceUrl", "imageScaleX", "imageScaleY", "propagatePointerEvent"];

UIElement.prototype.doToJsonCustom = function(o) {
	o.propertySheetDesc = this.propertySheetDesc;
	for(var key in o.propertySheetDesc) {
		var value = this[key];
		if(value !== undefined) {
			o[key] = value;
		}
	}

	return this;
}

UIElement.prototype.doToJson = function(o) {
	this.updateLayoutParams();

	RShape.prototype.doToJson.call(this, o);
	
	o.runtimeVisible = this.runtimeVisible;
	if(this.isUILoadingWindow) {
		o.isUILoadingWindow = true;
	}

	if(this.value !== undefined) {
		o.value = this.value;
	}

	this.propsToJson(o, this.saveProps);
	this.propsToJson(o, UIElement.saveProps);

    if(this.urlProps) {
        for(var i = 0; i < this.urlProps.length; i++) {
            var prop = this.urlProps[i];
            var url = o[prop];
            if(url) {
            	o[prop] = this.getRelativePathOfURL(url);
            }
        }
    }

	this.imagesToJson(o);
	o.events = this.events;
	
	if(this.animations) {
		o.animations = JSON.parse(JSON.stringify(this.animations));
	}
	
	if(this.handle) {
		o.handle = {};
		o.handle.x = this.handle.x;
		o.handle.y = this.handle.y;
	}

	if(this.settings) {
		o.settings = this.settings;
	}

	if(this.propertySheetDesc) {
		this.doToJsonCustom(o);
	}

	this.childrenToJson(o);

	return o;
}

UIElement.prototype.childToJson = function(child) {
	return child.toJson();
}

UIElement.prototype.childrenToJson = function(o) {
	var n = this.children.length;
	var children = this.children;
	
	o.children = [];
	for(var i = 0; i < n; i++) {
		var iter = children[i];
		o.children.push(this.childToJson(iter));
	}

	return this;
}

UIElement.prototype.childrenFromJson = function(js) {
	if(js.children) {
		var n = js.children.length;
		var factory = ShapeFactoryGet();
		this.children.clear(true);
		for(var i = 0; i < n; i++) {
			var jsShape = js.children[i];

			if(!jsShape) {
				console.log("Warning: child is null.");
				continue;
			}

			var type = jsShape.type ? jsShape.type : jsShape.id;
			var shape = factory.createShape(type, C_CREATE_FOR_USER);
			if(shape) {
				if(jsShape.z === undefined) {
					jsShape.z = i;
				}
				shape.z = jsShape.z;
				if(this.addShapeDirectly(shape)) {
					shape.fromJson(jsShape);
				}
			}
		}
	}

	this.targetShape = null;
	this.pointerEventTarget = null;

	return;
}

UIElement.prototype.doFromJsonCustom = function(js) {
	this.propertySheetDesc = js.propertySheetDesc;

	for(var key in js.propertySheetDesc) {
		var value = js[key];
		if(value !== undefined) {
			this[key] = value;
		}
	}
}

UIElement.prototype.doFromJson = function(js) {
	RShape.prototype.doFromJson.call(this, js);
	
	if(js.runtimeVisible === undefined) {
		this.runtimeVisible = true;
	}
	else {
		this.runtimeVisible = js.runtimeVisible;
	}

	if(js.isUILoadingWindow) {
		this.isUILoadingWindow = true;
	}

	this.propsFromJson(js, UIElement.saveProps);
	this.propsFromJson(js, this.saveProps);

    Object.keys(js.events).forEach(function(ev) {
        this.events[ev] = js.events[ev];
    }, this);
   
	this.imagesFromJson(js);

	if(js.animations) {
		this.animations = js.animations;
	} else if(this.animations) {
        delete this.animations;
    }

	if(js.handle) {
		this.handle = {};
		this.handle.x = js.handle.x;
		this.handle.y = js.handle.y;
	}

	if(js.settings) {
		this.settings = js.settings;
	}

	if(js.propertySheetDesc) {
		this.doFromJsonCustom(js);
	}
	
	if(js.value !== undefined) {
		this.value = js.value;
		this.setValue(this.getValue());
	}

	this.childrenFromJson(js);

	return this;
}
	
UIElement.prototype.afterApplyFormat = function() {
	if(this.parentShape) {
		this.parentShape.relayoutChildren();
	}
	else {
		this.relayout();
	}

	return;
}

UIElement.prototype.findChildByPoint = function(point, recursive, checkFunc) {
	var p = point;
	var n = this.children.length;

	for(var i = n; i > 0; i--) {
		var child = this.children[i-1];
		if(!child.visible) continue;

		if(child.hitTest(p)) {
			if(checkFunc && !checkFunc(child)) {
				continue;
			}

			if(recursive) {
				var tp = {};
				tp.x = p.x - child.left + (child.xOffset || 0);
				tp.y = p.y - child.top + (child.yOffset || 0);
				return child.findChildByPoint(tp, recursive, checkFunc);
			}
			else {
				return child;
			}
		}
		else {
			if(recursive) {
				var tp = {};
				tp.x = p.x - child.left + (child.xOffset || 0);
				tp.y = p.y - child.top + (child.yOffset || 0);
				var ret = child.findChildByPoint(tp, recursive, checkFunc);
				if(ret !== child) {
					return ret;
				}
			}
		}
	}

	return this;
}

UIElement.prototype.findShapeByPoint = UIElement.prototype.findChildByPoint;

UIElement.prototype.getChildren = function() {
	return this.children;
}

UIElement.prototype.getChildrenNr = function() {
	return this.children.length;
}

UIElement.prototype.getChild = function(index) {
	return (index < this.children.length && index >= 0) ? this.children[index] : null;
}

UIElement.prototype.canBindingData = function() {
	return (!this.isUIDevice && !this.isUIScreen && !this.isUIWindowManager && this.children.length > 0);
}

UIElement.prototype.onDataBindingTemplate = function(template) {
	//template.name = this.name;
	if(this.isUIImage) {
		var image = this.getImageByType(UIElement.IMAGE_DEFAULT);
		var src = image ? image.getImageSrc(): "";

		src = this.getRelativePathOfURL(src);

		template.image = src;
	}
	else {
		if(this.value !== undefined) {
			template.value = this.value;
		}
	}

	if(this.text || this.isUILabel) {
		template.text = this.text;
	}

	return template;
}

UIElement.prototype.getDataBindingTemplate = function() {
	var i = 0;
	var iter = null;
	var template = {};
	var children = this.children;
	var n = this.children.length;

	this.onDataBindingTemplate(template);

	if(n > 0) {
		template.children = [];

		for(i = 0; i < n; i++) {
			iter = children[i];
			if(!this.childIsBuiltin(iter)) {
				template.children.push(iter.getDataBindingTemplate());
			}
		}
	}

	return template;
}

UIElement.prototype.setUserData = function(userData) {
	this.userData = userData;

	return;
}

UIElement.prototype.getUserData = function() {
	return this.userData;
}

UIElement.prototype.onBindData = function(data) {
	var text = data.text;
	var image = data.image;
	var value = data.value;

	if(text !== undefined) {
		this.setText(text);
	}
	
	if(image !== undefined) {
		this.setImage(UIElement.IMAGE_DEFAULT, image);
	}

	if(value !== undefined) {
		this.setValue(value);
	}
	
	if(data.enable !== undefined) {
		this.setEnable(data.enable);
	}
	
	if(data.visible !== undefined) {
		this.setVisible(data.visible);
	}

	if(data.textColor) {
		this.style.setTextColor(data.textColor);
	}
	
	if(data.fillColor) {
		this.style.setFillColor(data.fillColor);
	}
	
	if(data.lineColor) {
		this.style.setLineColor(data.lineColor);
	}

	if(data.fontSize) {
		this.style.setFontSize(data.fontSize);
	}
	
	this.setUserData(data.userData);

	if(data.height) {
		this.h = data.height;
	}
	
	if(data.width) {
		this.w = data.width;
	}

	if(this.offset) {
		this.offset = 0;
	}

	var attrs = ["children", "text", "value", "image", "visible", "enable", "textColor", "fillColor", "lineColor", "fontSize", "userData"];
	for(var key in data) {
		if(attrs.indexOf(key) >= 0) continue;
		var value = data[key];
		var child = this.find(key, true);
		if(!child) continue;

		if(typeof value  === "object") {
			child.doBindData(value);
		}
		else {
			child.setValue(value);		
		}
	}

	return;
}

UIElement.prototype.moveMustBeLastItemToLast = function() {
	var last = null;
	var children = this.children;
	var n = this.children.length;
	
	for(var i = 0; i < n; i++) {
		var iter = children[i];
		if(iter.name === "ui-last") {
			last = iter;
			children[i] = children[n-1];
			children[n-1] = last;
			break;
		}
	}

	return;
}

UIElement.prototype.childIsBuiltin = function(child) {
	return false;
}

UIElement.makeImageURLToAbsOfJson = function(json) {
	if(!json) {
		return;
	}

	var images = json.images;
	var host = window.location.protocol + "//" + window.location.host + "/";

	for(var key in images) {
		var value = images[key];
		if(key !== "display") {
			if(value.indexOf("http://") < 0 && value.indexOf("https://") < 0) {
				value = host + value;
				images[key] = value;
			}
		}
	}

	if(!json.children) {
		return;
	}

	for(var i = 0; i < json.children.length; i++) {
		var iter = json.children[i];

		UIElement.makeImageURLToAbsOfJson(iter);
	}

	return;
}

UIElement.prototype.getTemplateChildJson = function() {
	if(!this.templateChildJson) {
		var child = this.getTemplateChild();
		this.templateChildJson = child ? child.toJson() : null;
		UIElement.makeImageURLToAbsOfJson(this.templateChildJson);

		if(this.templateChildJson) {
			delete this.templateChildJson.isTemplate;
		}
		else {
			console.log("No Template Child.");
		}
	}

	return this.templateChildJson;
}

UIElement.prototype.getTemplateChild = function() {
	if(!this.templateChild) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			if(iter.isTemplate) {
				this.children.remove(iter);
				this.templateChild = iter;
				break;
			}
		}
		
		if(!this.templateChild) {
			this.templateChild = this.getLastUserChild();
		}
	}
	
	return this.templateChild;
}

UIElement.prototype.dupTemplateChild = function() {
	var child = this.getTemplateChild().clone();
	
	delete child.isTemplate;

	return child;
}

UIElement.prototype.dupChild = function(name, zIndex) {
	var child = this.findChildByName(name);

	if(child) {
		var shape = child.clone();

		if(isNaN(zIndex)) {
			zIndex = child.z + 1;
		}

		this.addShape(shape, false, null, zIndex);
		shape.fixName();

		return shape;
	}
	else {
		return null;
	}
}

UIElement.prototype.getLastUserChild = function() {
	var children = this.children;
	var n = this.children.length;

	if(n > 0) {
		for(var i = n-1; i >= 0; i--) {
			var iter = children[i];
			if(!this.childIsBuiltin(iter)) {
				return iter;
			}
		}
	}

	return null;
}

UIElement.prototype.countUserChildren = function() {
	var nr = 0;
	var children = this.children;
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(!this.childIsBuiltin(iter)) {
			nr = nr + 1;
		}
	}

	return nr;
}

UIElement.prototype.setDisableRelayout = function(disableRelayout) {
	this.disableRelayout = disableRelayout;

	return this;
}

UIElement.prototype.bindData = function(data, animHint, clearOldData) {
	var shape = this;
	
	shape.setDisableRelayout(true);
	shape.doBindData(data, clearOldData);	
	shape.setDisableRelayout(false);
	shape.relayoutChildren(animHint);
	console.log("bindData: done");

	shape.postRedraw();

	return this;
}

UIElement.prototype.doBindData = function(data, clearOldData) {
	var i = 0;
	var k = 0;
	var iter = null;
	var templateJson = (this.isUIList || this.isUIGrid) ? this.getTemplateChildJson() : null;
	
	this.onBindData(data);

	var children = this.children;
	var n = this.countUserChildren();
	if((n < 1 && !templateJson) || !data.children) {
		return;
	}

	var m = data.children.length;
	if((this.isUIList || this.isUIGrid)) {
		if(m > n) {
			templateJson.y = 0;
			templateJson.visible = true;
			for(i = n; i < m; i++) {
				this.addChildWithJson(templateJson);
			}
		}
		else if(m < n && clearOldData) {
			var arr = [];

			k = n - m;
			for(i = (this.children.length-1); i>= 0; i--) {
				var iter = this.children[i];
				if(!this.childIsBuiltin(iter) && !iter.isTemplate) {
					arr.push(iter);
				}
			}

			for(var i = 0; i < arr.length; i++) {
				var iter = arr[i];
				
				if(i === k) {
					break;
				}
				this.children.remove(iter);
				iter.setParent(null);
				iter.setApp(null);
				iter.setView(null);
			}
		}

		n = this.children.length;
	}
	else {
		n = this.children.length;
	}

	for(i = 0, k = 0; k < n & i < m; k++) {
		iter = children[k];
		if(!this.childIsBuiltin(iter)) {
			iter.doBindData(data.children[i]);
			i = i + 1;
		}
	}

	return;
}

UIElement.prototype.bindDataUrl = function(dataUrl, doConvert, onBindDone) {
	var rInfo = {};
	var shape = this;

	httpGetJSON(dataUrl, function(js) {
		if(doConvert) {
			js = doConvert(js);
		}

		if(js) {
			shape.bindData(js, "default", true);
		}

		if(onBindDone) {
			onBindDone(js);
		}
	});

	return;
}

///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////

function UIElementCreator(type) {
	type = type ? type : "ui-element";

	var args = [type, "UI-Element", null, 1];
	
	ShapeCreator.apply(this, args);
	
	this.createShape = function(createReason) {
		var g = new UIElement();

		return g.initUIElement(this.type);
	}
	
	return;
}

UIElement.prototype.sortChildren = function() {
	return;
}

UIElement.prototype.shouldShowContextMenu = function() {
	return this.isInDesignMode();
}

UIElement.prototype.setText = function(text, notify) {
	if(this.text != text) {
		this.text = this.toText(text);

		if(notify) {
			this.callOnChangedHandler(text);
		}

		this.textNeedRelayout = true;
	}

	this.postRedraw();

	return this;
}

UIElement.prototype.getValue = function() {
	return this.getText();
}

UIElement.prototype.setValue = function(value, notify, animation) {
	var me = this;
	var oldValue = this.getText() || 0;

	value = String(value);
	if(value == String(oldValue)) return this;
	if(!!animation && !isNaN(+value) && !isNaN(+oldValue)) {
		var fixLen = value.indexOf('.') > -1 ? (value.length - value.indexOf('.') - 1) : 0;

		this.animate({
			duration: 300,
			valueEnd: +value,
			valueStart: +oldValue,
			onStep: function(ui, timePercent, config) {
				me.setText(config.value.toFixed(fixLen));
				return true;
			},
			onDone: function(ui, aniName) {
				me.setText(value);
				console.debug('element setValue onDone');
			}
		});
	}
	else {
		this.setText(value);
	}

	return this;
}

UIElement.prototype.addValue = function(delta, notify, animation) {
	var oldValue = this.getValue();
	var colonIdx = String(oldValue).indexOf(':');

	if(colonIdx == -1) {
		oldValue = +oldValue;
		var value = (isNaN(oldValue) ? 0 : oldValue) + (isNaN(+delta) ? 0 : +delta);
		var lenOld   = getFixlen(String(oldValue));
		var lenDelta = getFixlen(String(delta));
		var lenValue = getFixlen(String(value));
		var length = lenOld > lenDelta ? lenOld : lenDelta;
			length = length > lenValue ? lenValue : length;

		function getFixlen(str) {
			return str.indexOf('.') > -1 ? (str.length - str.indexOf('.') - 1) : 0;
		}

		return this.setValue(value.toFixed(length), notify, animation);
	}
	else {
		var min   = +oldValue.substr(0, colonIdx);
		var sec   = +oldValue.substr(colonIdx+1, 2);
		var total = (isNaN(min) ? 0 : min*60) + (isNaN(sec) ? 0 : sec);
		var dst = total + delta>>0;
		if(isNaN(+delta) || dst < 0) {
			return this;
		}
		else {
			var min = Math.floor(dst/60);
			var sec = dst%60;
			min = min < 10 ? ('0' + min) : min;
			sec = sec < 10 ? ('0' + sec) : sec;
			return this.setValue(min + ':' + sec);
		}
	}
}

UIElement.prototype.getPositionInView = function() {
	var x = this.getX();
	var y = this.getY();
	var point = {x:0, y:0};
	var iter = this.parentShape;

	while(iter != null) {
		x += iter.getX();
		y += iter.getY();
		if(iter.isUIVScrollView) {
			y = y - iter.offset;
		}
		else if(iter.isUIHScrollView) {
			x = x - iter.offset;
		}
		else if(iter.isUIScene || iter.isUIScrollViewX) {
			x = x - iter.xOffset;
			y = y - iter.yOffset;
		}
		iter = iter.parentShape;
	}

	point.x = x;
	point.y = y;

	return point;
}

UIElement.prototype.getLocaleText = function(text) {
	var str = webappGetText(text);

	if(!str) {
		return text;
	}

	if(!this.locale) {
		this.locale = {text:str};
		this.needRelayout = true;
	}

	return str;
}

UIElement.prototype.getLocaleInputTips = function(text) {
	var str = webappGetText(text);

	return str ? str : text;
}

UIElement.prototype.setBgImage = function(src) {
	return this.setImage(UIElement.IMAGE_DEFAULT, src);
}

UIElement.prototype.onImageLoad = function() {
	this.postRedraw();
}

UIElement.prototype.getDefaultImageType = function() {
	return UIElement.IMAGE_DEFAULT;
}

UIElement.prototype.setImage = function(type, src) {
	var me = this;
	var n = arguments.length;
	if(n < 2) {
		src = type;
		type = this.getDefaultImageType();
	}
	else {
		type = type ? type : this.getDefaultImageType();
	}

	var image = null;
	if(src === null || src === undefined) {
		image = WImage.create(null); 
	}else if(typeof src === "object") {
		if(src.image) {
			image = src;
		}
		else {
			image = WImage.createWithImage(src); 
		}
	}else if(typeof src === "number" || src.length < 4) {
		image = this.images["option_image_" + src];
	}else {
		image = WImage.create(src, this.onImageLoad.bind(this));
	}

	this.images[type] = image;

	return this;
}

UIElement.prototype.getHtmlImageByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}
	
	var image = this.images[type];
	return image ? image.getImage() : null;
}

UIElement.prototype.getImageByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}
	
	return this.images[type];
}

UIElement.prototype.getImageSrcByType = function(type) {
	if(typeof type === "number") {
		type = "option_image_" + type;
	}

	var image = this.images[type];
	return image ? image.getImageSrc() : "";
}

UIElement.prototype.getImageTypes = function() {
	var names = [];
	
	for(var key in this.images) {
		var value = this.images[key];
		if(key != "display") {
			names.push(key);
		}
	}

	return names;
}

UIElement.prototype.addEventNames = function(eventNames) {
	if(eventNames) {
		for(var i = 0; i < eventNames.length; i++) {
			var eName = eventNames[i];
			if(!this.events[eName]) {
				this.events[eName] = null;
			}
		}
	}

	return this;
}

UIElement.prototype.removeEventNames = function(eventNames) {
	if(eventNames) {
		for(var i = 0; i < eventNames.length; i++) {
			var eName = eventNames[i];
			delete this.events[eName];
		}
	}

	return this;
}

UIElement.prototype.getEventNames = function() {
	var eventNames = [];

	for(var key in this.events) {
		eventNames.push(key);
	}

	return eventNames;
}

UIElement.uidStart = 10000 + Math.floor(Math.random() * 10000);
UIElement.prototype.initUIElement= function(type) {
	this.initContainerShape(type);

	this.enable = true;
	this.visible = true;
	this.opacity = 1;
	this.vMargin = 0;
	this.hMargin = 0;
	this.xAttr		= UIElement.X_FIX_LEFT;
	this.yAttr		= UIElement.Y_FIX_TOP;
	this.widthAttr	= UIElement.WIDTH_FIX;
	this.heightAttr = UIElement.HEIGHT_FIX;
	this.name = type;
	this.events = {};
	this.uid = UIElement.uidStart++;
	this.runtimeVisible = true;

	this.images  = {};
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.addEventNames(["onClick"]);

	return this;
}

UIElement.prototype.updateLayoutParams = function() {
	var p = this.parentShape;

	if(!p) {
		return;
	}

	this.xParam = 1;
	this.yParam = 1;
	this.widthParam = 1;
	this.heightParam = 1;

	var wParent = p.getRelayoutWidth();
	var hParent = p.getRelayoutHeight();
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.xParam = this.left/wParent;
	}
	else if(this.xAttr === UIElement.X_FIX_RIGHT) {
		this.xParam = wParent - (this.left + this.w);
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.yParam = this.top/hParent;
	}
	else if(this.yAttr === UIElement.Y_FIX_BOTTOM) {
		this.yParam = hParent - (this.top + this.h);
	}

	if(this.widthAttr === UIElement.WIDTH_SCALE) {
		this.widthParam = this.w/wParent;
		this.widthScaleMin = this.w >> 1;
		this.widthScaleMax = this.w << 1;
	}

	if(this.heightAttr === UIElement.HEIGHT_SCALE) {
		this.heightParam = this.h/hParent;
		this.heightScaleMin = this.h >> 1;
		this.heightScaleMax = this.h << 1;
	}

	if(this.heightAttr === UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH) {
		this.heightParam = this.h/this.w;
	}

	return this;
}

UIElement.prototype.imagesToJson = function(o) {
	o.images = {};

	for(var key in this.images) {
		var value = this.images[key];
		if(key === "display") {
			o.images[key] = value;
		}
		else {
			var src = value.getImageSrc();
			src = this.getRelativePathOfURL(src);

			if(src) {
				o.images[key] = src;

				var sharpOffset = src.indexOf("#");
				if(sharpOffset > 0) {
					var realSrc = value.getRealImageSrc();
					realSrc = this.getRelativePathOfURL(realSrc);
				
					var url = src.substr(0, sharpOffset);	
					if(realSrc && realSrc.indexOf(src) < 0) {
						o.images["real-image-"+url] = decodeURI(realSrc);
					}
				}
			}
		}
	}

	return o;
}

UIElement.prototype.imagesFromJson = function(js) {
	if(js.images) {
		for(var key in js.images) {
			var value = js.images[key];
			if(key === "display") {
				this.images[key] = value;
			}
			else if(key.indexOf("real-image") !== 0) {
				this.setImage(key, value);
			}
		}
	}

	return;
}

UIElement.prototype.getEnable = function() {
	return this.enable;
}

UIElement.prototype.setEnable = function(enable) {
	this.enable = enable;

	return this;
}

UIElement.prototype.isEnable = function() {
	var iter = this;

	if(!this.isValid()) {
		return false;
	}

	while(iter != null) {
		if(!iter.enable) {
			return false;
		}

		iter = iter.parentShape;
	}

	return true;
}

UIElement.prototype.getVisible = function(visible) {
	return this.visible;
}

UIElement.prototype.setVisible = function(visible) {
	this.visible = visible;

	if(!visible) {
		if(this.animatingInfo) {
			UIElement.logWarning("hide animating element invisble.");
		}
	}

	return this;
}

UIElement.prototype.isVisible = function() {
	var iter = this;

	if(!this.isValid()) {
		return false;
	}

	while(iter != null) {
		if(!iter.visible) {
			return false;
		}

		iter = iter.parentShape;
	}

	return true;
}

UIElement.prototype.isFocused = function() {
	return this.parentShape && this.parentShape.targetShape == this;
}

UIElement.prototype.onShowHTML = function() {
	return;
}

UIElement.prototype.onHideHTML = function() {
	return;
}

UIElement.prototype.showHTML = function() {
	var i = 0;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		var child = this.children[i];
		child.showHTML();
	}

	this.onShowHTML();

	return;
}

UIElement.prototype.hideHTML = function() {
	var i = 0;
	var n = this.children.length;

	for(i = 0; i < n; i++) {
		var child = this.children[i];
		child.hideHTML();
	}

	this.onHideHTML();

	return;
}

UIElement.prototype.show = function() {
	return this.setVisible(true);
}

UIElement.prototype.hide = function() {
	return this.setVisible(false);
}

UIElement.prototype.beforeRelayout = function() {
}

UIElement.prototype.afterRelayout = function() {
}

UIElement.prototype.getPrevSibling = function() {
	if(!this.parentShape || this.parentShape.children.length < 2) {
		return null;
	}

	var i = 0;
	for(i = 0; i < this.parentShape.children.length; i++) {
		if(this.parentShape.children[i] === this) {
			break;
		}
	}

	return i > 0 ? this.parentShape.children[i-1] : null;
}

UIElement.prototype.setAutoScaleFontSize = function(value) {
	this.enableAutoScaleFontSize = value;

	return this;
}

UIElement.prototype.autoScaleFontSize = function(scale) {
	if(this.enableAutoScaleFontSize) {
		var fontSize = Math.round(this.style.fontSize * scale);
		
		fontSize = Math.min(fontSize, 36);
		fontSize = Math.max(fontSize, 12);
		this.style.setFontSize(fontSize);
	}

	return;
}


UIElement.prototype.getRelayoutWidth = function() {
	return this.getWidth();
}

UIElement.prototype.getRelayoutHeight = function() {
	return this.getHeight();
}

UIElement.prototype.relayout = function() {
	if(this.disableRelayout) {
		return;
	}
	
	var p = getParentShapeOfShape(this);
	if(!p || !p.isUIElement) {
		if(this.isInDesignMode()) {
			this.setUserMovable(true);
			this.setUserResizable(true);
		}
	}

	if(this.isUIDevice) {
		this.setUserResizable(false);
	}

	if(!p) {
		this.relayoutChildren();
		return;
	}

	var w = 0;
	var h = 0;
	var x = 0;
	var y = 0;
	var xAttr = this.xAttr;
	var yAttr = this.yAttr;
	var wParent = p.getRelayoutWidth();
	var hParent = p.getRelayoutHeight();
	var hMargin = p.getHMargin();
	var vMargin = p.getVMargin();
	var wParentClient = wParent - hMargin - hMargin;
	var hParentClient = hParent - vMargin - vMargin;

	var bottom = this.top + this.h;
	var right = this.left + this.w

	this.beforeRelayout();

	switch(this.widthAttr) {
		case UIElement.WIDTH_SCALE: {
			w = wParent * this.widthParam;
			if(this.widthScaleMin && w < this.widthScaleMin) {
				if(this.pointerDown) {
					this.widthScaleMin = w;
				}
				else {
					w = this.widthScaleMin;
				}
			}
			if(this.widthScaleMax && w > this.widthScaleMax) {
				if(this.pointerDown) {
					this.widthScaleMax = w;
				}
				else {
					w = this.widthScaleMax;
				}
			}

			break;
		}
		case UIElement.WIDTH_FILL_PARENT: {
			w = wParentClient;
			this.left = hMargin;
			xAttr = UIElement.X_FIX_LEFT;
			break;
		}
		default: {
			w = this.w;
			break;
		}
	}

	switch(this.heightAttr) {
		case UIElement.HEIGHT_SCALE: {
			h = hParent * this.heightParam;
			if(this.heightScaleMin && h < this.heightScaleMin) {
				if(this.pointerDown) {
					this.heightScaleMin = h;
				}
				else {
					h = this.heightScaleMin;
				}
			}
			if(this.heightScaleMax && h > this.heightScaleMax) {
				if(this.pointerDown) {
					this.heightScaleMax = h;
				}
				else {
					h = this.heightScaleMax;
				}
			}

			break;
		}
		case UIElement.HEIGHT_FILL_PARENT: {
			h = hParentClient;
			this.top = vMargin;
			yAttr = UIElement.Y_FIX_TOP;
			break;
		}
		default: {
			h = this.h;
			break;
		}
	}

	switch(xAttr) {
		case UIElement.X_SCALE: {
			x = wParent * this.xParam;
			break;
		}
		case UIElement.X_FIX_RIGHT: {
			x = wParent - this.xParam - this.w;
			break;
		}
		case UIElement.X_CENTER_IN_PARENT: {
			x = (wParent - w) >> 1;
			break;
		}
		case UIElement.X_LEFT_IN_PARENT: {
			x = hMargin;
			break;
		}
		case UIElement.X_RIGHT_IN_PARENT: {
			x = wParent - w - hMargin;
			break;
		}
		default: {
			x = this.left;
			break;
		}
	}
		
	switch(yAttr) {
		case UIElement.Y_SCALE: {
			y = hParent * this.yParam;
			break;
		}
		case UIElement.Y_FIX_BOTTOM: {
			y = hParent - this.yParam - this.h;
			break;
		}
		case UIElement.Y_MIDDLE_IN_PARENT: {
			y = (hParent - h) >> 1;
			break;
		}
		case UIElement.Y_TOP_IN_PARENT: {
			y = vMargin;
			break;
		}
		case UIElement.Y_BOTTOM_IN_PARENT: {
			y = hParent - h - vMargin;
			break;
		}
		default: {
			y = this.top;
			break;
		}
	}
	
	if(this.widthAttr === UIElement.WIDTH_FILL_TO_PARENT_RIGHT) {
		w = wParent - x  - hMargin;
	}
			
	if(this.heightAttr === UIElement.HEIGHT_FILL_TO_PARENT_BOTTOM) {
		h = hParent - y - vMargin;
	}
	
	if(this.heightAttr === UIElement.HEIGHT_KEEP_RATIO_WITH_WIDTH) {
		h = w * this.heightParam;	
	}

	var oldW = this.w;

	this.w	= Math.round(w);
	this.h	= Math.round(h);
	this.setLeftTop(x, y);

	if(p.isUIElement) {
		if(this.isInDesignMode()) {
			var win = this.getWindow();
			if(win && !win.isUIScene && !win.isUIDialog) {
				p.fixChildSize(this);
			}
		}
		p.fixChildPosition(this);
	}
	
	this.setSize(this.w, this.h);
	
	this.autoScaleFontSize(w/oldW);
	this.relayoutChildren();
	this.afterRelayout();
	this.setTextNeedRelayout(true);

	return;
}

UIElement.prototype.beforeRelayoutChild = function(shape) {
	return true;
}

UIElement.prototype.afterRelayoutChild = function(shape) {
	return true;
}

UIElement.prototype.relayoutChildren = function() {
	if(this.disableRelayout || !this.children) {
		return;
	}

	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE || child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE) {
			continue;
		}

		if(this.beforeRelayoutChild(child)) {
			child.relayout();
		}
		this.afterRelayoutChild(child);
	}
	
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(!(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE || child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE)) {
			continue;
		}

		if(this.beforeRelayoutChild(child)) {
			child.relayout();
		}
		this.afterRelayoutChild(child);
	}

	return;
}

UIElement.prototype.getWindowManager = function() {
	return UIWindowManager.getInstance();
}

UIElement.prototype.getDevice = function() {
	var iter = this;

	while(iter != null && !iter.isUIDevice) {
		iter = iter.parentShape;
	}

	return iter;
}

UIElement.prototype.getDeviceConfig = function() {
	var windowManager = this.getWindowManager();
	if(windowManager) {
		return windowManager.getDeviceConfig();
	}

	return null;
}

UIElement.prototype.getTopWindow = function() {
	var wm = this.getWindowManager();

	return wm.getCurrentWindow();
}

UIElement.prototype.setAssetsLoadingWindow = function(name) {
	var wm = this.getWindowManager();
	if(wm) {
		wm.setAssetsLoadingWindow(name);
	}

	return this;
}

UIElement.prototype.isTopWindow = function() {
	var win = this.getWindow();

	return win === this.getTopWindow();
}

UIElement.prototype.getWindow = function() {
	var iter = this;

	while(iter != null && !iter.isUIWindow) {
		iter = iter.parentShape;
	}

	return iter;
}

UIElement.prototype.getPositionInWindow = function() {
	var p = this.getAbsLeftTop();
	var anchor = this.anchor;

	if(anchor) {
		p.x += anchor.x * this.w;
		p.y += anchor.y * this.h;
	}

	return p;
}

UIElement.prototype.getAbsLeftTop = function() {
	var iter = this;
	var x = iter.left;
	var y = iter.top;

	while(iter != null && !iter.isUIWindow) {
		iter = iter.parentShape;
		if(iter.isUIWindow) {
			break;
		}

		x = x + iter.left;
		y = y + iter.top;
	}

	return {x:x, y:y};
}

UIElement.prototype.localToGlobal = function(point) {
	var p = this.getAbsLeftTop();

	p.x += point.x;
	p.y += point.y;

	return p;
}

UIElement.prototype.globalToLocal = function(point) {
	var p = this.getAbsLeftTop();

	p.x = point.x - p.x;
	p.y = point.y - p.y;

	return p;
}

UIElement.prototype.getWindowNames = function() {
	var wm = this.getWindowManager();
	if(wm) {
		return wm.getWindowNames();
	}

	return [];
}

UIElement.prototype.openScene = function(name, initData) {
	var wm = this.getWindowManager();
	setTimeout(function() {
		wm.openWindow(name, null, true, initData);
	}, 0);
}

UIElement.prototype.isWindowOpen = function(name) {
	var wm = this.getWindowManager();
	var win = wm.find(name);

	return win && win.isOpen();
}

UIElement.prototype.openWindow = function(name, onClose, closeCurrent, initData, options) {
	var wm = this.getWindowManager();
	if(wm) {
		return wm.openWindow(name, onClose, closeCurrent, initData, options);
	}

	return false;
}

UIElement.prototype.closeAllWindows = function() {
	var wm = this.getWindowManager();
	if(wm) {
		wm.closeAll();
	}

	return;
}

UIElement.prototype.backToHomeWin = function() {
	var wm = this.getWindowManager();
	if(wm) {
		wm.backToHomeWin();
	}

	return;
}

UIElement.prototype.closeWindow = function(retInfo, syncClose) {
	var win = this.getWindow();
	var wm = this.getWindowManager();

	if(wm && win) {
		if(win.isOpen()) {
			return wm.closeWindow(win, retInfo, syncClose);
		}
		else {
			console.log("Current Window Is Not Open.");
		}
	}

	return false;
}

UIElement.prototype.canBeComponent = function() {
	return true;
}

UIElement.prototype.isCreatingElement = function() {
	if(this.view && this.view.creatingShape === this) {
		return true;
	}

	return false;
}

UIElement.prototype.onScaleForDensityDone = function(sizeScale, lcdDensity) {
}

UIElement.prototype.setNotScaleForDensity = function(notScaleForDensity) {
	this.notScaleForDensity = notScaleForDensity;

	return;
}

UIElement.prototype.scaleForDensity = function(sizeScale, lcdDensity, recuresive) {
	if(!sizeScale || sizeScale === 1 || this.notScaleForDensity) {
		return;
	}

	if(this.widthAttr === UIElement.WIDTH_FIX) {
		this.w = Math.floor(this.w * sizeScale);
	}

	if(this.heightAttr === UIElement.HEIGHT_FIX) {
		this.h = this.h * sizeScale;
		if(this.h < 36 && (this.isUIButton || this.isUIProgressBar || this.isUIColorTile || this.isUIColorButton
			|| this.isUIEdit || this.isUIRadioBox || this.isUICheckBox || this.isUIWaitBar || this.isUISwitch)) {
			this.h = 40;
		}

		if(this.h < 50 && (this.isUIToolBar || this.isUIButtonGroup)) {
			this.h = 50;
		}

		if(this.hMin > this.h) {
			this.hMin = this.h;
		}
	}

	var isCreating = this.isCreatingElement();
	if(!isCreating && this.yAttr === UIElement.Y_FIX_TOP) {
		this.top = Math.floor(this.top * sizeScale);
	}

	if(!isCreating && this.xAttr === UIElement.X_FIX_LEFT) {
		this.left = Math.floor(this.left * sizeScale);
	}

	this.style.setFontSize(Math.floor(this.style.fontSize * sizeScale));

	if(this.itemHeight > 20) {
		this.itemHeight = Math.floor(this.itemHeight * sizeScale);
	}

	if(this.roundRadius) {
		this.roundRadius = Math.floor(this.roundRadius * sizeScale);
	}

	this.vMargin = Math.floor(this.vMargin * sizeScale);
	this.hMargin = Math.floor(this.hMargin * sizeScale);

	if(this.buttonHeight > 40) {
		this.buttonHeight = Math.floor(this.buttonHeight * sizeScale);
	}
	
	this.left = Math.floor(this.left);
	this.top = Math.floor(this.top);
	this.w = Math.round(this.w);
	this.h = Math.round(this.h);

	if(recuresive) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			iter.scaleForDensity(sizeScale, lcdDensity, true);
		}
	}

	if(this.isUIProgressBar) {
		var value = this.getValue();
		this.setValue(0);
		this.setValue(value);
	}

	this.onScaleForDensityDone(sizeScale, lcdDensity);

	return;
}

UIElement.prototype.onDeviceConfigChanged = function(oldConfig, newConfig) {
	return;
}

UIElement.prototype.fixImagePath = function(oldConfig, newConfig) {
	var oldVersion	= oldConfig.version;
	var oldPlatform = oldConfig.platform;
	var oldDensity	= oldConfig.lcdDensity;
	var newVersion	= newConfig.version;
	var newPlatform = newConfig.platform;
	var newDensity	= newConfig.lcdDensity;

	for(var key in this.images) {
		var value = this.images[key];
		if(key === "display") {
			continue;
		}
		
		var src = value.getImageSrc();
		if(src) {
//			src = src.replaceAll("/" + oldVersion + "/", "/" + newVersion + "/");
//			src = src.replaceAll("/" + oldPlatform + "/", "/" + newPlatform + "/");
			src = src.replaceAll("/" + oldDensity + "/", "/" + newDensity + "/");
			value.setImageSrc(src);
		}
	}

	return;
}

UIElement.prototype.scaleForCurrentDensity = function(value) {
	var config = this.getDeviceConfig();
	var lcdDensity = this.getDensitySizeByName(config ? config.lcdDensity : "hdpi");
	
	return value * (lcdDensity/160);
}

UIElement.prototype.getDensitySizeByName = function(density) {
	switch(density) {
		case "ldpi": {
			return 80;
		}
		case "mdpi": {
			return 160;
		}
		case "hdpi": {
			return 240;
		}
		case "xhdpi": {
			return 350;
		}
		case "xxhdpi": {
			return 450;
		}
		default: {
			console.log("not supported density: " + density);
		}
	}

	return 160;
}

UIElement.prototype.getSizeScale = function(oldDensity, newDensity) {
	var oldSize = this.getDensitySizeByName(oldDensity);
	var newSize = this.getDensitySizeByName(newDensity);

	var sizeScale = newSize/oldSize;

	return sizeScale;
}

UIElement.prototype.notifyDeviceConfigChanged = function(oldConfig, newConfig) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		child.notifyDeviceConfigChanged(oldConfig, newConfig);
	}

	this.fixImagePath(oldConfig, newConfig);
	this.onDeviceConfigChanged(oldConfig, newConfig);
	
	return;
}

UIElement.prototype.addMovementForVelocityTracker = function() {
	if(this.velocityTracker) {
		var p = {};
		p.x = this.getMoveAbsDeltaX();
		p.y = this.getMoveAbsDeltaY();

		var timeNs = Date.now() * 1000000;
		this.velocityTracker.addMovement(timeNs, p);
		delete date;
	}

	return;
}

UIElement.prototype.isUserMovable = function() {
	return this.userMovable && !this.isLocked();
}

UIElement.prototype.isUserResizable = function() {
	return this.userResizable;
}

UIElement.prototype.getEditorRect = function() {
	var rect = {};
	rect.x = this.left;
	rect.y = this.top;
	rect.w = this.w;
	rect.h = this.h;

	return rect;
}


UIElement.funcs = [];
UIElement.setAnimTimer = function(func, deltaTime) {
	return UIElement.setTimeout(func, deltaTime);	
}

UIElement.setTimeout = function(func, deltaTime) {
	deltaTime = deltaTime ? Math.max(deltaTime, 16) : 16;

	func.deltaTime = deltaTime;
	func.time = Date.now() + deltaTime;
	UIElement.funcs.push(func);

	function executeTimers() {
		var funcs = UIElement.funcs;

		var now = Date.now();
		var n = funcs.length;
		UIElement.funcs = [];

		for(var i = 0; i < n; i++) {
			var iter = funcs[i];
			if(iter.time <= now) {
				if(iter()) {
					iter.time = now + iter.deltaTime;
					UIElement.funcs.push(iter);
				}
			}
			else {
				UIElement.funcs.push(iter);
			}
		}

		funcs = null;
		if(UIElement.funcs.length) {
			UIElement.animTimerID = requestAnimFrame(executeTimers);
		}
		else {
			UIElement.animTimerID = 0;
		}
	}

	if(!UIElement.animTimerID) {
		UIElement.animTimerID = requestAnimFrame(executeTimers, 16);
	}

	return;
}

UIElement.getMainCanvas = function() {
    return CantkRT.getMainCanvas();
}

UIElement.getMainCanvasScale = function(force) {
	return CantkRT.getMainCanvasScale();
}

UIElement.prototype.isFullscreenMode = function() {
	return cantkIsFullscreen();
}

UIElement.prototype.setFlipX = function(flipX) {
	this.flipX = flipX;

	return this;
}

UIElement.prototype.setFlipY = function(flipY) {
	this.flipY = flipY;

	return this;
}

UIElement.prototype.getFlipX = function() {
	return this.flipX;
}

UIElement.prototype.getFlipY = function() {
	return this.flipY;
}

UIElement.prototype.requestFullscreen = function(onDone) {
	if(!isMobile()) {
		if(onDone) {
			onDone(false);
		}
		console.log("UIElement.requestFullScreen Rejected(not mobile)");
	}
	else {
		if(!cantkRequestFullscreen(onDone)) {
			onDone(false);
		}
		console.log("UIElement.requestFullScreen");
	}

	return;
}

UIElement.prototype.pickFiles = function(contentType, onDone) {
	return showFileDialog(contentType, true, false, onDone);
}

UIElement.prototype.pickFile = function(contentType, onDone) {
	if(!window.FileReader) {
		return false;
	}

	showFileDialog(contentType, false, true, function(files) {
		var file = files[0];
		if (file) {
			var reader  = new FileReader();
			reader.readAsDataURL(file);
			reader.onloadend = function () {
				if(onDone) {
					onDone(file, reader.result);
				}
				reader = null;
			}
		}
	});

	return true;
}

UIElement.prototype.pickAudio = function(onDone) {
	return this.pickFile("audio/*", onDone);
}

UIElement.prototype.pickImage = function(onDone) {
	return this.pickFile("image/*", onDone);
}

UIElement.fixArtTextStyle = function(style) {
	style.fontSize = style.fontSize ? style.fontSize : 16;
	style.imageBorder = style.imageBorder? style.imageBorder: 10;
	style.textAlignH = style.textAlignH ? style.textAlignH : "left";
	style.startColor = style.startColor ? style.startColor : "Green";
	style.endColor = style.endColor ? style.endColor : "Green";
	style.lineWidth = style.lineWidth ? style.lineWidth : 0;
	style.lineColor = style.lineColor ? style.lineColor : "Black";
	style.shadowColor = style.shadowColor ? style.shadowColor : "Black";
	style.shadowBlur = style.shadowBlur ? style.shadowBlur : 0;
	style.shadowOffsetX = style.shadowOffsetX ? style.shadowOffsetX : 0;
	style.shadowOffsetY = style.shadowOffsetY ? style.shadowOffsetY : 0;
	
	return style;
}

UIElement.createArtTextImage = function(text, style, bgColor) {
	UIElement.fixArtTextStyle(style);

	if(!text) {
		return null;
	}

	var w = 300;
	var h = 80;
	var border = style.imageBorder;
	var fontSize = style.fontSize;
	var fontFamily = style.fontFamily;
	var textAlign = style.textAlignH;
	var monospace = style.monospace;
	var tcanvas = cantkGetTempCanvas(w, h);
	var ctx = tcanvas.getContext("2d");
	ctx.clearRect(0, 0, w, h);

	var x = w >> 1;
	var y = h >> 1;
	var fontStr = "";
	var n = text.length;
	if(style.textB) {
		fontStr += "Bold ";
	}

	if(style.textI) {
		fontStr += "Italic ";
	}

	fontStr += fontSize + "pt '" + fontFamily + "'";
	ctx.font = fontStr;
	ctx.textBaseline = "middle";
	ctx.textAlign = "center";

	switch(textAlign) {
		case 'left': {
			x = border;
			ctx.textAlign = "left";
			break;
		}
		case 'right': {
			x = w-border;
			ctx.textAlign = "right";
			break;
		}
		default:break;
	}

	if(monospace) {
		var cw = 0;
		for(var i = 0; i < n; i++) {
			var c = text[i];
			var charW = ctx.measureText(c).width;
			if(charW > cw) {
				cw = charW;
			}
		}
		cw = cw + 4;
		w = n * cw;
	}
	else {
		var textW = ctx.measureText(text).width;
		w = textW + border * 2;
	}
	h = style.fontSize + 2*(Math.abs(style.shadowOffsetY) + style.shadowOffsetY + border);
	tcanvas.width = w;
	tcanvas.height = h;

	if(bgColor) {
		ctx.fillStyle = bgColor;
		ctx.fillRect(0, 0, w, h);
	}

	ctx.font = fontStr;
	ctx.textBaseline = "middle";
	ctx.textAlign = "center";
	if(style.useTexture && style.texture) {
		var wimage = WImage.create(style.texture);
		var image = wimage.getImage();
		if(image) {
			var pattern = ctx.createPattern(image, "repeat");
			ctx.fillStyle = pattern;
		}
	}
	else {
		if(style.startColor != style.endColor) {
			var grd = ctx.createLinearGradient(0,0,0,h);
			if(style.horizonalGradient) {
				grd = ctx.createLinearGradient(0,0,w,0);
			}
			grd.addColorStop(0, style.startColor);
			grd.addColorStop(1, style.endColor);
			ctx.fillStyle = grd;
		}
		else {
			ctx.fillStyle = style.startColor;
		}
	}

	if(style.shadowBlur) {
		ctx.shadowOffsetX = style.shadowOffsetX;
		ctx.shadowOffsetY = style.shadowOffsetY;
		ctx.shadowBlur = style.shadowBlur;
		ctx.shadowColor = style.shadowColor;
	}

	x = w >> 1;
	y = h >> 1;
	ctx.lineWidth = style.lineWidth;
	ctx.strokeStyle = style.lineColor;

	if(monospace) {
		x = 0;
		var hcw = cw >> 1;
		var n = text.length;
		ctx.textAlign = "center";
		for(var i = 0; i < n; i++) {
			x = i * cw + hcw;
			var c = text[i];
			ctx.fillText(c, x, y);
			ctx.strokeText(c, x, y);
		}
	}
	else {
		ctx.fillText(text, x, y);
		if(ctx.lineWidth) {
			ctx.strokeText(text, x, y);
		}
	}

	var url = tcanvas.toDataURL();

	return url;
}

ShapeFactoryGet().addShapeCreator(new UIGroupCreator(200, 200, null));

UIElement.prototype.timeScaleIsZero = function() {
	return Math.abs(this.getTimeScale()) < 0.00001;
}

UIElement.prototype.getTimeScale = function() {
	return this.win.getTimeScale();
}

UIElement.prototype.scaleTime = function(t) {
	return this.win.getTimeScale() * t;
}

UIElement.prototype.setTimeScale = function(timeScale) {
	this.win.setTimeScale(timeScale);

	return this;
}

UIElement.prototype.getAppInfo = function() {
	var metaInfo = this.view.getMetaInfo();

	return metaInfo.general;
}

UIElement.logNotice = function(str) {
	console.log("%cNotice: " + str, "color: green; font-weight: bold");
}

UIElement.logWarning = function(str) {
	console.log("%cWarning: " + str, "color: red; font-weight: bold");
}

UIElement.logError = function(str, e) {
	console.log("%cWarning: " + str + "(" + e.message + ")\n" + e.stack, "color: red; font-weight: bold");
}

UIElement.prototype.isPointIn = function(canvas, point) {
	var ret = false;

	if(canvas) {
		canvas.beginPath();
		canvas.rect(0, 0, this.w, this.h);
		canvas.closePath();

		ret = canvas.isPointInPath(point.x, point.y);
	}
	else {
		ret = isPointInRect(point, this);	
	}

	return ret;
}

UIElement.prototype.pInPolygon = function(points, testx, testy) {
	var c = false;

	for (var i = 0, j = points.length-1; i < points.length; j = i++) {
		if (((points[i].y > testy) != (points[j].y > testy)) &&
			(testx < (points[j].x-points[i].x) * (testy-points[i].y) / (points[j].y-points[i].y) + points[i].x))
			c = !c;
	}

	return c;
}

UIElement.prototype.isPointInMatrix = function(rect, point, applyTransform) {
	var x = rect.x,
		y = rect.y,
		w = rect.w,
		h = rect.h,
		p1 = {x: x, 	y: y},
		p2 = {x: x+w, 	y: y},
		p3 = {x: x+w, 	y: y+h},
		p4 = {x: x, 	y: y+h},
		matrix = Matrix2D.identity;

	matrix.beginPath = function() {};
	matrix.clip = function() {};
	matrix.rect = function() {};
	matrix.arc  = function() {};

	try {
		applyTransform.call(this, matrix);
	}
	catch(e) {
		console.debug('applyTransform catch err', err);
	}

	var p11 = matrix.transformPoint(p1.x, p1.y),
		p21 = matrix.transformPoint(p2.x, p2.y),
		p31 = matrix.transformPoint(p3.x, p3.y),
		p41 = matrix.transformPoint(p4.x, p4.y),
		pps = [p11, p21, p31, p41];

	matrix.identity();

	return this.pInPolygon(pps, point.x, point.y);
}

UIElement.prototype.setImageDisplay = function(display) {
	this.images.display = display;

	return this;
}

UIElement.prototype.getPointerDeviceType = function() {
	return WEventsManager.getInstance().getPointerDeviceType();
}

function UIElementCreator(type) {
	var args = [type, "ui-element", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIElement();
		return g.initUIElement(this.type);
	}
	
	return;
}

UIElement.prototype.clearAssetsCache = function(check) {
	this.getWindowManager().clearAssetsCache(check);

	return this;
}

UIElement.prototype.loadAssets = function(winList, onLoadProgress, onDownloadProgress) {
	ResLoader.reset();
	this.getWindowManager().loadAssets(winList, onLoadProgress, onDownloadProgress);

	return this;
}

UIElement.prototype.createElement = function(type) {
	return ShapeFactoryGet().createShape(type, C_CREATE_FOR_PROGRAM);
}

ShapeFactoryGet().addShapeCreator(new UIElementCreator("ui-element"));

UIElement.audioAssets = ["soundURL"];
UIElement.imagesAssets = ["textureURL"];
UIElement.jsonAssets = ["textureJsonURL", "skeletonJsonURL", "soundURL", "dataURL"];

UIElement.assets = UIElement.audioAssets.concat(UIElement.jsonAssets, UIElement.imagesAssets);


/**
 * @class UIElement 
 * 所有组件的基类，它通常是一个矩形区域，有一定的外观形状，并能处理用户事件。
 */

/**
 * @property {String} type
 * 控件的类型名称。如按钮的类型为"ui-button"，请不要修改。
 */

/**
 * @property {String} name
 * 控件的名称。
 */

/**
 * @property {Array} animations 
 * 在Studio的动画编辑器中为控件添加的动画列表，通过动画名字可以获取对应的动画参数。
 *
 *     @example small frame
 *     var fadeIn = this.animations["fade-in"];
 *     console.log(JSON.stringify(fadeIn));
 *
 */

/**
 * @property {UIElement} win
 * 控件所在的窗口或场景。
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */
Object.defineProperty(UIElement.prototype, "win", {
	get: function () {
		if(!this._win) {
			this._win = this.getWindow();
		}

		return this._win;
	},
	set: function (value) {
		console.log("Warning: can not set window.");
	},
	enumerable: false,
	configurable: true
});

/**
 * @property {Number} x
 * 在父控件中的X坐标。
 */

/**
 * @property {Number} y
 * 在父控件中的Y坐标。
 */

/**
 * @property {Number} anchorX
 * 控件的X锚点。
 */

/**
 * @property {Number} anchorY
 * 控件的Y锚点。
 */

/**
 * @property {Number} width
 * 控件的宽度。
 */

/**
 * @property {Number} height 
 * 控件的高度。
 */

/**
 * @property {Number} scaleX 
 * 控件的X方向的缩放系数。
 */

/**
 * @property {Number} scaleY
 * 控件的Y方向的缩放系数。
 */

/**
 * @property {Number} rotation 
 * 控件的旋转角度(弧度)。
 */

/**
 * @property {Number} opacity
 * 控件的不透明度(0-1)。
 */

/**
 * @property {Boolean} flipX 
 * 控件是否X方向翻转。
 */

/**
 * @property {Boolean} flipY 
 * 控件是否Y方向翻转。
 */

/**
 * @property {Boolean} visible
 * 控件是否对用户可见。
 */

/**
 * @property {Boolean} enable 
 * 控件是否接受用户事件（对于刚体来说，同时会决定刚体是否参与物理世界的运行）。
 */

/**
 * @property {Boolean} pointerDown
 * 指针是否按下。
 */
//==============================================================================

/**
 * @method setPosition
 * 设置控件的位置。
 * @param {Number} x 在父控件上的X坐标。
 * @param {Number} y 在父控件上的Y坐标。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */

/**
 * @method setAnchor
 * 设置控件的锚点。
 * @param {Number} x 0到1表示从控件左边到右边的位置。比如0.5表示中间。
 * @param {Number} y 0到1表示从控件顶部到底部的位置。比如0.5表示中间。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：把物体移动到场景的中间位置。
 *
 *     @example small frame
 *     var win = this.win;
 *     var ball = win.find("ball");
 *     ball.setAnchor(0.5, 0.5);
 *     ball.setPosition(win.width>>1, win.height>>1);
 */

/**
 * @method setPivot
 * 设置控件的旋转轴点(不适用于刚体)。
 * @param {Number} x 0到1表示从控件左边到右边的位置。比如0.5表示中间。
 * @param {Number} y 0到1表示从控件顶部到底部的位置。比如0.5表示中间。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setName
 * 设置控件的名称。
 * @param {String} name 名称。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setOpacity
 * 设置控件的不透明度。
 * @param {Number} opacity 透明度，取值范围(0~1)。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method forEach
 * 遍历所有子控件，callback返回true时停止遍历。
 * @param {Function} callback 函数原型 function(child) {}
 *
 */

/**
 * @method getTarget
 * 获取处理指针事件的子控件。通常用来判断玩家点击了哪个控件。
 * @return {UIElement} 处理指针事件的子控件。
 *
 */

/**
 * @method isWindowOpen 
 * @param {String} winName 窗口名称。
 * @return {Boolean} 指定窗口是否已经打开。
 *
 */

/**
 * @method getOpacity
 * 获取控件的不透明度。
 * @return {Number} 返回对象的不透明度。
 *
 */

/**
 * @method setValue
 * 设置控件的值，不同控件的值有不同的意义，如进度条的值时进度，按钮的值就是上面的文本。
 * @param {Number} value 新的值。
 * @param {Boolean} notify 是否触发onChanged事件。
 * @param {Boolean} animation 是否启用动画(只能用于数值的值)。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：设置进度条的进度。
 *
 *     @example small frame
 *     var win = this.win;
 *     var progressbar = win.find("progressbar");
 *     progressbar.setValue(80, false, true);
 */

/**
 * @method getValue
 * 获取控件的值。
 * @return {Number} 返回对象的值。
 *
 */


/**
 * @method addValue 
 * 在当前的数值上加上一个增量(只能用于数值的值)。
 * @param {Number} delta 增量，可以为负数。
 * @param {Boolean} notify 是否触发onChanged事件。
 * @param {Boolean} animation 是否启用动画。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：设置进度条的进度。
 *
 *     @example small frame
 *     var win = this.win;
 *     var progressbar = win.find("progressbar");
 *     progressbar.addValue(20, false, true);
 */

/**
 * @method setValueOf
 * 设置子控件的值。
 * @param {String} name 子控件的名字。
 * @param {Number} value 值。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getValueOf
 * 获取子控件的值。
 * @param {String} name 子控件的名字。
 * @return {Number} 返回对象的值。
 *
 */

/**
 * @method setScale
 * 设置控件的缩放比例。
 * @param {Number} x x方向的缩放比例。
 * @param {Number} y y方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 * 注意：缩放比例不改变控件额实际大小和刚体碰撞检测的区域。
 */

/**
 * @method setScaleX
 * 设置控件x方向的缩放比例。
 * @param {Number} scale x方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setScaleY
 * 设置控件y方向的缩放比例。
 * @param {Number} scale y方向的缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getScaleX
 * 获取控件x方向的缩放比例。
 * @return {Number} x方向的缩放比例。
 *
 */

/**
 * @method getScaleY
 * 获取控件y方向的缩放比例。
 * @return {Number} y方向的缩放比例。
 *
 */

/**
 * @method setSize
 * 设置控件的位置。
 * @param {Number} w 控件的宽度。
 * @param {Number} h 控件的高度。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setSize(100, 100);
 */

/**
 * @method setText
 * 设置控件的文本内容，如控件上的文字。
 * @param {String} text 文本内容
 * @param {Boolean} notify 是否触发onChanged事件。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setAssetsLoadingWindow 
 * 指定资源加载窗口。对于大型游戏，在初始时只加载部分场景/窗口的资源，其它场景/窗口有两种方式加载：
 *
 * 1.在主场景打开后，调用loadAssets在后台预加载其它场景/窗口。
 *
 * 2.在打开某个场景/窗口时，自动加载对应的资源，此时可以用setAssetsLoadingWindow指定一个显示加载进度的窗口。
 *
 * 该窗口上需要有一个UIProgressBar(用于显示进度)和一个UILabel(用于显示状态)。
 *
 * @param {String} name 资源加载窗口的名称。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getText
 * 获取控件的文本内容，如控件上的文字。
 * @return {String} 文本内容。
 */

/**
 * @method getParent
 * 获取控件的父控件。
 * @return {UIElement} 父控件。
 */

/**
 * @method find
 * 按名称查找子控件。
 * @param {String} name 子控件的名字。
 * @param {Boolean} recursive 是否递归查找。
 * @return {UIElement} 返回子控件。
 *
 *     @example small frame
 *     var ball = this.win.find("ball");
 *     ball.setPosition(100, 100);
 */

/**
 * @method findChildByPoint
 * 按点击位置查找子控件。
 * @param {Point} point 相对于当前控件左上角的坐标。
 * @param {Boolean} recursive 是否递归查找。
 * @param {Function} checkFunc 回调函数用于检查是否是需要的控件。
 * @return {UIElement} 如果找到子控件返回子控件，否者返回对象本身。
 *
 *     @example small frame
 *     var targetElement = this.findChildByPoint(point, true, function(child) {
 *         //Skip dragger self
 *         return child !== dragger;
 *     });
 */

/**
 * @method isAnimating
 * 判断animate是否完成。
 * @return {Boolean}
 */

/**
 * @method getPointerDeviceType
 * 获取指针输入设备的类型。
 * @return {String} "pointer"表示指针设备， "touch"表示触屏， "mouse"表示鼠标。
 */

/**
 * @method animate
 * 让控件动起来。
 * @param {AnimationConfig} config 动画配置信息或用动画编辑器创建的动画的名称。
 * @param {Function} onDone (可选) 完成时的回调函数。
 * @param {Function} onStep (可选) 每一步的回调函数。
 *
 * 让控件从x=100，移动到x=300：
 *
 *     @example small frame
 *     this.animate({xStart:100, xEnd:300});
 *
 * 让控件从当前位置移动到x=300：
 * 
 *     @example small frame
 *     this.animate({x:300});
 * 
 * 让控件在x=100和300之间往返运动：
 *     
 *     @example small frame
 *     var toLeft ={xStart:100, xEnd:300};
 *     var toRight = {xEnd:100, xStart:300}
 *     toLeft.next = toRight;
 *     toRight.next = toLeft;
 *     this.animate(toLeft);
 *
 * 完成时播放另外一个动画：
 *     
 *     @example small frame
 *     var me = this;
 *     var win = this.getWindow();
 *     var tree = win.find("tree");
 *     var config = {xStart:100, xEnd:300};
 *     config.onDone = function() {
 *         this.animate({xEnd:config.xStart, xStart:config.xEnd});
 *     }
 *     tree.animate(config);
 *
 * 如果需要从一个状态变化到另外一个状态，请用Start/End方式，如果从当前的状态变化到另外一个状态，直接指定它的值就行了。
 */

/**
 * @method stopAnimation
 * 停止animate开启的动画。
 * @param {Boolean} callOnDone 是否调用动画结束的回调函数。
 */

/**
 * @method postRedraw
 * 请求系统重画控件。
 * @param {Rect} rect 要求更新区域，一般为null。
 */

/**
 * @method addChildWithJson
 * 通过json数据创建一个控件，并作为子控件加入当前控件。(推荐使用dupChild来动态创建对象)。
 * @param {Object} json JSON数据
 * @param {Number} index zIndex
 * @return {UIElement} 返回子控件。
 * 
 *     @example small frame
 *     var win = this.getWindow();
 *     
 *     var json = {
 *         "type": "ui-button",
 *         "name": "ui-button2-general",
 *         "w": 200,
 *         "h": 69,
 *         "x": 209,
 *         "y": 155,
 *         "text": "ok",   
 *         "images": {
 *             "display": 2,
 *             "active_bg": "drawapp8/images/common/buttons/green_button_active.png",
 *             "normal_bg": "drawapp8/images/common/buttons/green_button.png",
 *             "disable_bg": "drawapp8/images/common/buttons/green_button.png"
 *         }
 *     }
 *     
 *     var button = win.addChildWithJson(json, 0);
 */

/**
 * @method addChild
 * 加入控件到当前控件中。配合clone函数使用。
 * @param {UIElement} child 要加入的控件。
 * @param {Number} index zIndex
 * @return {UIElement} 返回子控件。
 */

/**
 * @method clone
 * 克隆当前控件。clone的对象是游离的，需要调用addChild加入到某个控件中。
 * @return {UIElement} 返回新控件。
 */

/**
 * @method remove 
 * 移除从父控件中当前控件。
 * @param {Boolean} destroyIt 移除时是否销毁控件。如果后面还会把它加入其它控件就不要销毁，否则销毁。
 * @param {Boolean} syncExec 是否同步执行。如果在当前控件的事件中执行，请使用异步执行。
 */

/**
 * @method dupChild
 * 复制指定的子控件，并加入当前控件中。
 * @param {String} name 子控件的名称。
 * @param {Number} index 新控件的zIndex
 * @return {UIElement} 返回新控件。
 * 
 * 简单用法
 *
 *     @example small frame
 *     var newImage = this.dupChild("image");
 *     newImage.setPosition(10, 10);
 *
 *     复制子对象，然后移到其它控件中。
 *
 *     @example small frame
 *     var win = this.getWindow();
 *     
 *     var newImage = win.dupChild("image");
 *     newImage.remove(false, true);
 *     newImage.setPosition(0, 0);
 *     win.find("ball").addChild(newImage);
 */

/**
 * @method getWindow
 * 获取当前控件所在的窗口/场景。可以直接使用属性win代替。
 * 这是一个很常用的函数，你需要通过这个函数得到窗口对象，然后通过窗口的find函数去找窗口上的其它控件。
 * @return {UIWindow} 当前控件所在的窗口/场景。
 */

/**
 * @method getWindowManager
 * 获取窗口管理器。
 * @return {UIWindowManager} 窗口管理器。
 */

/**
 * @method getTopWindow
 * 获取当前最上层的窗口(普通窗口/对话框/场景)。
 * @return {UIWindow} 当前最上层的窗口。
 */

/**
 * @method openWindow 
 * 打开新窗口。目前有三种窗口：普通窗口，游戏场景和对话框。
 * @param {String} name 新窗口的名称。
 * @param {Function} onWindowClose onWindowClose(retInfo) (可选) 新窗口关闭时的回调函数。
 * @param {Boolean} closeCurrent (可选) 打开新窗口时是否关闭当前窗口。
 * @param {Object} initData (可选) 传递给新窗口的数据, 作为参数传递给新窗口的onOpen/onBeforeOpen事件。
 * @param {Object} options (可选) 其它参数。options.closeOldIfOpened 如果目标窗口已经打开，关闭它并重新打开。options.openNewIfOpened 如果目标窗口已经打开，打开新一个新窗口打开。
 *
 *     @example small frame
 *     this.openWindow("win-bonus",  function (retInfo) {console.log("window closed.");});
 */

/**
 * @method openScene
 * 本函数是对openWindow的包装。打开当前场景相当于重置当前场景，可以实现重玩的功能。
 * @param {String} name 新场景的名称。打开当前场景相当于重置当前场景，可以实现重玩的功能。
 * @param {Object} initData 传递给新窗口的数据, 作为参数传递给新窗口的onOpen/onBeforeOpen事件。
 */

/**
 * @method closeWindow
 * 关闭当前窗口。
 * @param {Object} retInfo 如果openWindow时指定了onWindowClose回调函数，retInfo会作为onWindowClose回调函数的参数。
 *
 *     @example small frame
 *     var retCode = 0;
 *     this.closeWindow(retCode);
 *
 */

/**
 * @method closeAllWindows 
 * 关闭所有打开的窗口。
 *
 */

/**
 * @method setFillColor
 * 设置控件的填充颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setLineColor
 * 设置控件的线条颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setTextColor
 * 设置控件的文本颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getFillColor
 * 获取控件的填充颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method getLineColor
 * 获取控件的线条颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method getTextColor
 * 获取控件的文本颜色。
 * @param {String} color 颜色。
 * @return {String} 颜色。
 */

/**
 * @method setImage
 * 设置控件的图片。
 * @param {String} type (可选, 缺省为背景图片)。不同的控件支持的type不一样，请参控具体的控件文档。
 * @param {Object} src 可以是图片的URL，Image对象，WImage对象或备用图片的索引。
 * @return {UIElement} 返回控件本身。
 *
 * 把图片1设置为当前的图片(请在IDE中预先设置控件的图片1)。
 *
 *     @example small frame
 *     this.win.find("image").setImage(1);
 *
 * 设置按钮的正常和指针按下的图片：
 *
 *     @example small frame
 *     this.setImage(UIElement.IMAGE_NORMAL, 0);
 *     this.setImage(UIElement.IMAGE_ACTIVE, 1);
 *
 */

/**
 * @method setImageScale
 * 设置图片按比例缩放显示。
 * @param {Number} imageScaleX 宽度缩放比例。
 * @param {Number} imageScaleY 高度缩放比例。
 *
 * 如果图片使用的缩放显示，你在程序中通过setSize调整大小后，或者为图片设置url之后，希望图片填充到控件大小，请按如下方式调用一下此方法。
 *
 *      @example small frame
 *      this.setImageScale(0, 0);
 */

/**
 * @method getImageByType
 * 获取控件的图片
 * @param {String} type 不同的控件支持的type不一样，请参控具体的控件文档。
 * @return {WImage} 图片
 *
 * 可以通过索引取到备用图片：
 *
 *     @example small frame
 *     var image = this.getImageByType(0);
 *
 */

/**
 * @method getImageSrcByType
 * 获取控件的图片
 * @param {String} type 不同的控件支持的type不一样，请参控具体的控件文档。
 * @return {String} 图片SRC
 * 可以通过索引取到备用图片：
 *
 *     @example small frame
 *     var src = this.getImageSrcByType(0);
 */

/**
 * @method setTimeScale
 * 设置时间缩放系数，让游戏时间变快或变慢。
 * @param {Number} timeScale 时间缩放系数，0暂停，(0-1)变慢，1正常，大于1表示变快。
 * @return {UIElement} 返回控件本身。
 *
 * 暂停游戏：
 *
 *     @example small frame
 *     this.setTimeScale(0);
 */

/**
 * @method playSoundEffect
 * 播放音效。请先放一个音效控件到场景中，在音效控件的特有属性中添加音频文件。
 * 建议使用代码产生器来产生播放音效的代码。
 * @param {String} name 音效文件名，不用包含路径。
 * @param {Function} onDone (可选) 播放音效完成后的回调函数。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method playSoundMusic
 * 播放背景音乐。请先放一个背景音乐控件到场景中，在背景音乐控件的特有属性中添加音频文件。
 * 建议使用代码产生器来产生播放背景音乐的代码。
 * @param {String} name 背景音乐文件名，不用包含路径。
 * @param {Function} onDone (可选) 播放背景音乐完成后的回调函数。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method stopSoundEffect
 * 停止播放音效。
 * @param {String} name (可选) 音效文件名，不用包含路径。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method stopSoundMusic
 * 停止播放背景音乐。
 * @param {String} name (可选) 音乐文件名，不用包含路径。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundEffectVolume
 * 设置音效的音量。
 * @param {Number} volume 音量，范围0到1。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundMusicVolume
 * 设置音乐的音量。
 * @param {Number} volume 音量，范围0到1。
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundEnable
 * 开启/禁止播放音效和背景音乐。
 * @param {Boolean} value 开启/禁止播放音效和背景音乐。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getSoundEnable
 * 获取处于音效和背景音乐是否开启的状态。
 * @return {Boolean} 音效和背景音乐是否开启。
 */

/**
 * @method getSoundMusicEnable
 * 获取背景音乐是否处于开启的状态。
 * @return {Boolean} 播放背景音乐是否开启。
 */

/**
 * @method getSoundEffectEnable
 * 获取音效是否处于开启的状态。
 * @return {Boolean} 播放音效是否开启。
 */

/**
 * @method getPointerPosition
 * 获取指针(Mouse/Touch)在窗口(场景)中的位置。
 * @return {Point} 指针(Mouse/Touch)的位置。 
 */

/**
 * @method setSoundEffectEnable
 * 开启/禁止播放音效。
 * @param {Boolean} value 开启/禁止播放音效。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setSoundMusicEnable
 * 开启/禁止播放背景音乐。
 * @param {Boolean} value 开启/禁止播放背景音乐。 
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method getAppInfo
 * 获取游戏APP的信息
 * @return {Object} APP信息
 *
 * APP信息示例： 
 *
 *     @example small frame
 *     {
 *       "appid":"com.tangide.demo",
 *       "appversion":"1.0.0",
 *       "appname":"Demo",
 *       "appdesc":"Demo",
 *       "gapversion":"1.0",
 *       "screenscale":"fix-width",
 *       "orientation":"portrait",
 *       "developer":"Unkown <unkown@tangide.com>",
 *       "appIcon":"/drawapp8/images/appicons/96.png",
 *       "screenShot1":"",
 *       "screenShot2":"",
 *       "screenShot3":""
 *     }
 */

/**
 * @method getChild
 * 获取指定位置的子控件。
 * @param {Number} index 子控件的索引。
 * @return {UIElement} 返回子控件。
 */

/**
 * @method getChildrenNr
 * 获取子控件的个数。
 * @return {Number} 返回子控件的个数。
 */

/**
 * @method setClipCircle
 * 设置控件的圆形裁剪区域。
 * @param {Number} x
 * @param {Number} y
 * @param {Number} r
 * @return {UIElement} 返回控件本身。
 */

/**
 * @method setClipRect
 * 设置控件的矩形裁剪区域。
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 * @return {UIElement} 返回控件本身。
 *
 * 任意形状裁剪请重载onClip：
 *
 *     @example small frame
 *     var el = this.getWindow().find("el");
 *     
 *     el.onClip = function(ctx2d) {
 *         ctx2d.beginPath();
 *         ctx2d.moveTo(0, 0);
 *         ctx2d.lineTo(100, 100);
 *         ctx2d.lineTo(100, 200);
 *         ctx2d.closePath();
 *         ctx2d.clip();
 *     }
 */

/**
 * @method setRotation
 * 设置控件的旋转角度。
 * @param {Number} rotation 旋转的角度，单位是弧度。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setFlipX
 * 设置是否水平翻转。
 * @param {Boolean} flipX 是否水平翻转。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setFlipY
 * 设置是否垂直翻转。
 * @param {Boolean} flipY 是否垂直翻转。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getPositionInWindow
 * 返回控件在窗口里的位置。
 * @return {Point} 位置信息。
 *
 */

/**
 * @method localToGlobal
 * 把控件内的坐标转换成窗口内的坐标。
 * @param {Point} point 控件内的坐标。
 * @return {Point} 窗口内的坐标。 
 *
 */

/**
 * @method globalToLocal 
 * 把窗口内的坐标换成控件内的坐标。
 * @param {Point} point 窗口内的坐标。
 * @return {Point} 控件内的坐标。 
 *
 */

/**
 * @method getVisible
 * 控件是否可见。
 * @return {Boolean} 是否可见
 *
 */

/**
 * @method setVisible
 * 显示/隐藏控件。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setAnchorX
 * 设置控件的横向锚点。
 * @param {Number} x （范围0-1）。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setAnchorY
 * 设置控件的纵向锚点。
 * @param {Number} y （范围0-1）。
 * @return {UIElement} 返回控件本身
 *
 */

/**
 * @method relayout
 * 重新布局控件及子控件。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method relayoutChildren
 * 重新布局子控件。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     this.relayoutChildren();
 */

/**
 * @method setDisableRelayout
 * @param {Boolean} value true禁止布局功能，false开启布局功能。
 * 禁止/开启布局功能。一般向布局控件中加入/删除子控件时会自动调用relayoutChildren，但是一下加入大量子控件时，每加一个就要调用一次relayoutChildren，这样可能有性能问题。此时可以先禁止布局功能，再添加控件，最后启用布局功能并调用relayoutChildren。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     var n = 200;
 *     var gridView = this.win.find("grid-view-x");
 *     
 *     gridView.setDisableRelayout(true);
 *     for(var i = 0; i < n; i++) {
 *         gridView.dupChild("image");
 *     }
 *     gridView.setDisableRelayout(false).relayoutChildren();
 *     
 */


/**
 * @method removeChild
 * 删除指定的子控件，如果destroyIt为真，同时销毁它。
 * @param {UIElement} child 子控件对象。
 * @param {Boolean} destroyIt 是否同时销毁child对象。
 * @param {Boolean} sync 是否同步执行，缺省异步执行。
 * @return {UIElement} 返回控件本身。
 * 
 */

/**
 * @method removeChildren
 * 删除全部子控件。
 * @return {UIElement} 返回控件本身。
 * 
 */

/**
 * @method setEnable
 * 启用/禁用控件，不同的控件的表现有不同的意义，如UITimer被禁用时不触发onTimer事件，UIGSensor被禁用时不上报重力感应信息。
 * @param {Boolean} enable 是否启用控件。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method setZIndex
 * 设置控件在父控件中的位置序数。
 * @param {Number} z 位置序数。
 * @return {UIElement} 返回控件本身。
 *
 */

/**
 * @method getZIndex
 * 获取控件在父控件中的位置序数。
 * @return {Number} 返回位置序数。
 *
 */

/**
 * @method pickImage 
 * 从当前系统中选择一张图片，返回file对象和DataURL。
 * @param {Function} onDone(file, dataURL) 选图成功后的回调函数。
 * @return {Boolean} 是否支持从本地读取图片。
 *
 * 选取图片:
 *
 *     @example small frame
 *     var image = this.getWindow().find("image");
 *     this.pickImage(function(name, url) {
 *         image.setValue(url);
 *         image.postRedraw();
 *     });
 *
 */

/**
 * @event onClick
 * 点击事件。事件处理函数返回true时事件终止传播(父控件不再处理)。
 * @param {Point} point 点击的位置。
 */

/**
 * @event onUpdateTransform
 * 绘制前事件。
 * @param {Object} canvas HTMLCanvasContext2d
 *
 * 实现按下时放大的效果：
 *
 *     @example small frame
 *     this.setScale(this.pointerDown ? 1.1 : 1);
 */

/**
 * @event onInit
 * 初始化事件。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 */

/**
 * @event onPointerDown
 * Pointer Down事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */

/**
 * @event onPointerMove
 * Pointer Move事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */

/**
 * @event onPointerUp
 * Pointer Up事件。在子控件处理前会触发一次，在子控件处理后会触发一次。
 * 
 * 需要在自定义组件时添加，才会出现在IDE的事件列表中。
 *
 * 事件处理函数返回true时本事件终止传播。
 *
 * @param {Point} point 位置。
 * @param {Boolean} beforeChild 为true表示本次触发是在子控件处理前，false表示本次触发是在子控件处理后。
 */


/**
 * @method beforePaint
 *
 * 本函数在控件绘制前执行(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var ball = this.find("ball");
 *     
 *     ball.beforePaint = function(canvas2dCtx) {
 *         canvas2dCtx.beginPath();
 *         canvas2dCtx.moveTo(0, 0);
 *         canvas2dCtx.lineTo(this.w, this.h);
 *         canvas2dCtx.lineWidth = 2;
 *         canvas2dCtx.strokeStyle = "red";
 *         canvas2dCtx.stroke();
 *     }
 *     
 *
 */

/**
 * @method afterPaint
 *
 * 本函数在控件绘制后执行(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var ball = this.find("ball");
 *     
 *     ball.afterPaint = function(canvas2dCtx) {
 *         canvas2dCtx.beginPath();
 *         canvas2dCtx.moveTo(0, this.h);
 *         canvas2dCtx.lineTo(this.w, 0);
 *         canvas2dCtx.lineWidth = 2;
 *         canvas2dCtx.strokeStyle = "red";
 *         canvas2dCtx.stroke();
 *     }
 *
 *
 */

/**
 * @method drawBgImage
 *
 * 本函数用于绘制控件的背景图片(不能直接调用)，可以重载此函数实现一些特殊效果。
 * @param {Object} canvas2dCtx HTMLCanvasContext2D 
 *
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 * 如下面的代码放到onBeforeOpen中，实现动态背景效果。 
 *  
 *     @example small frame
 *      var win = this.win;
 *      win.bgOffsetX = 0;
 *      win.bgOffsetY = 0;
 *      win.bgInc = true;
 *      
 *      win.drawBgImage = function(canvas2dCtx) {
 *          var image = this.getBgImage();
 *          if(!image) return;
 *  
 *          var imageRect = image.getImageRect();
 *          var htmlImage = image.getImage();
 *  
 *          if (this.bgInc) {
 *              this.bgOffsetX++;
 *              if ((this.bgOffsetX + this.w) >= imageRect.w) {
 *                  this.bgInc = false;
 *              }
 *          } else {
 *              this.bgOffsetX--;
 *              if (this.bgOffsetX < 1) {
 *                  this.bgInc = true;
 *              }
 *          }
 *          this.bgOffsetY++;
 *          this.bgOffsetY = this.bgOffsetY % imageRect.h;
 *  
 *          var oy = imageRect.h - this.bgOffsetY;
 *          var rect = {
 *              x: this.bgOffsetX,
 *              y: this.bgOffsetY,
 *              w: this.w,
 *              h: this.h
 *          };
 *  
 *          rect.h = Math.min(this.h, oy);
 *          this.drawImageAt(canvas2dCtx, htmlImage, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, rect.h, rect);
 *  
 *          if (oy < this.h) {
 *              rect.y = 0;
 *              rect.h = this.h - oy;
 *              this.drawImageAt(canvas2dCtx, htmlImage, UIElement.IMAGE_DISPLAY_SCALE, 0, oy, this.w, rect.h, rect);
 *          }
 *  
 *          return;
 *      }
 *
 *
 */

/**
 * @method createEvent
 * 
 * 创建事件。
 * @param {String} type 事件类型。
 * @return {Event} 返回事件对象。
 *      @example small frame
 *      //创建并分发一个自定义事件。
 *      var e = this.createEvent("customevent");
 *      e.num = Math.round(Math.random() * 1000);
 *      e.str = "abs";
 *      e.obj = {"key":"value"};
 *      this.dispatchEvent(e);
 */

/**
 * @method dispatchEvent
 *
 * 分发事件，如果你调用过这个对象的addEventListener方法监听了此事件类型，事件回调函数将会被调用。
 * @param {Event} event 事件对象。
 * @return {Boolean} 事件是否要继续分发。
 *
 *      @example small frame      
 *      //创建并分发一个自定义事件。
 *      var e = this.createEvent("customevent");
 *      e.num = Math.round(Math.random() * 1000);
 *      e.str = "abs";
 *      e.obj = {"key":"value"};
 *      this.dispatchEvent(e);
 *
 */

/**
 * @method hasEventListener
 *
 * 判断是否有对应事件的监听者。
 * @param {String} type 事件类型。
 * @return {Boolean} 是否有监听者。
 *
 */

/**
 * @method addEventListener
 *
 * 注册事件的回调函数。
 * @param {String} type 事件的类型。目前支持"animatedone","beforeopen","begincontact","postsolve","presolve","swipeleft","swiperight","swipeup","swipedown","changed","changing","becomezero","becomefull","click","doubleclick","close","timeout","dragend","dragging","dragstart","endcontact","focusin","focusout","init","keydown","keyup","load","moved","open","paint","pointerdown","pointermove","multitouch","pointerup","removed","scrolling","scrolldone","switchtoback","switchtofront","deviceorientation","updatetransform"，具体请查看控件支持的事件。
 * @param {Function} callback 回调函数。原型为callback(event)。callback中的this为对应的控件, event的成员变量与对应事件的参数一致。
 *
 *
 * 注意：回调函数返回true时终止后续回调函数的处理。
 *
 *     @example small frame
 *     function initDialog(win) {
 *         function onButtonClicked(event) {
 *             var button = event.target;
 *             this.closeWindow(1);
 *             console.log(button.name + " clicked at:" + JSON.stringify(event.point));
 *         }
 *         win.find("button").addEventListener("click", onButtonClicked);
 *         
 *         function onOpen(event) {
 *             console.log("dialog open:" + JSON.stringify(event.initData));
 *         }
 *         win.addEventListener("open", onOpen);
 *         
 *         function onClose(event) {
 *             console.log("dialog closed with:" + JSON.stringify(event.retInfo));
 *         }
 *         win.addEventListener("close", onClose);
 *     }
 *
 * addEventListener也可以用on代替，如：
 *
 *     @example small frame
 *         function onClose(event) {
 *             console.log("dialog closed with:" + JSON.stringify(event.retInfo));
 *         }
 *         win.on("close", onClose);
 *
 * 一个用户自定义事件的示例：
 *
 *      @example
 *      //在场景中有两个控件"label"、"button"。 "button"用于触发"customevent"事件，"label"监听"customevent"事件。
 *
 *      //1.在button的onClick事件中创建并分发事件。
 *      var e = this.createEvent("customevent");
 *      e.num = Math.round(Math.random() * 1000);
 *      e.str = "abs";
 *      e.obj = {"key":"value"};
 *      this.dispatchEvent(e);
 *
 *      //2.在场景的onOpen事件中为"label"注册监听"button"的"customevent"事件，提供事件回调函数。
 *      var me = this;
 *      var win = this.win;
 *      var label = win.find("label");
 *      var button = win.find("button");
 *      button.addEventListener("customevent", function(event) {
 *          var num = event.num;
 *          var str = event.str;
 *          var obj = event.obj;
 *          this.setText("Receive customevent\n" + "num:" + num + "\nstr:" + str + "\nobj:" + JSON.stringify(obj));
 *      }.bind(label));
 *
 */

/**
 * @method removeEventListener
 *
 * 注销事件的回调函数。
 * @param {String} type 事件的类型。参考addEventListener。
 * @param {Function} callback 回调函数。
 *
 *
 *     @example small frame
 *         button.addEventListener("click", onClick);
 *
 * removeEventListener也可以用off代替，如：
 *
 *     @example small frame
 *         button.off("click", onClick);
 */

/**
 * @method loadAssets
 * 加载指定场景的资源。在缺省资源加载窗口中，可以指定预先加载部分场景的资源，其它资源可以通过本函数在需要时加载。
 * @param {Array} scenesNameList 要加载资源的场景名称数组。
 * @param {Function} onProgress(percent, finished, total) 加载进度的回调函数。
 * @param {Function} onDownloadProgress(percent, finished, total) 下载进度的回调函数。
 * @return {UIElement} 返回控件本身。
 *
 *
 * 示例：
 *
 *     @example small frame
 *     var progressbar = this.win.findChildByType("ui-progressbar");
 *     function onProgress(percent, finished, total) {
 *         progressbar.setPercent(percent);
 *         console.log("finished=" + finished + " total=" + total);
 *     }
 *     this.loadAssets(["scene", "scene-1"], onProgress);
 *
 */

/**
 * @method clearAssetsCache
 *
 * @param {Function} check(url) (可选) 本函数对资源进行检查，返回false的资源的缓存将被清除。
 *
 *     @example small frame
 *     var progressbar = this.win.findChildByType("ui-progressbar");
 *     function onProgress(percent, finished, total) {
 *         progressbar.setPercent(percent);
 *         console.log("finished=" + finished + " total=" + total);
 *     }
 *     this.clearAssetsCache();
 *     this.loadAssets(["scene", "scene-1"], onProgress);
 */

/**
 * @method setImageDisplay
 *
 * 设置图片的显示方式。
 * @param {Number} display 显示方式:
 *
 * * UIElement.IMAGE_DISPLAY_DEFAULT 缺省显示
 * * UIElement.IMAGE_DISPLAY_CENTER 居中显示 
 * * UIElement.IMAGE_DISPLAY_TILE   平铺显示
 * * UIElement.IMAGE_DISPLAY_9PATCH 9宫格显示
 * * UIElement.IMAGE_DISPLAY_SCALE  缩放显示
 * * UIElement.IMAGE_DISPLAY_AUTO   自动缩放显示
 * * UIElement.IMAGE_DISPLAY_TILE_V 垂直平铺显示
 * * UIElement.IMAGE_DISPLAY_TILE_H 水平平铺显示
 * * UIElement.IMAGE_DISPLAY_AUTO_SIZE_DOWN 自动缩小显示
 * * UIElement.IMAGE_DISPLAY_FIT_WIDTH 适应宽度
 * * UIElement.IMAGE_DISPLAY_FIT_HEIGHT 适应高度
 *
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     this.setImageDisplay(UIElement.IMAGE_DISPLAY_9PATCH);
 */

/**
 * @method createElement
 *
 * 动态创建控件。这是最原始的创建控件的方法，你需要手工去设置控件的各种属性，推荐使用dupChild或clone+addChild来动态创建控件。
 *
 * 除非想运行时使用在线的资源，不要直接使用资源的URL，而是通过UIAssets加载资源，用assets.getAssetURL获取资源的URL，再设置到控件中，否者导出时无法导出相应的资源。
 *
 * @param {String} type 控件的类型。可以再Hola Studio中用右键生成组件，进入高级里查看控件的type。
 * @return {UIElement} 返回对应的控件。
 *
 *
 *     @example small frame
 *     var assets = this.find("assets");
 *     var image = this.createElement("ui-image").setValue(assets.getAssetURL("1.jpg")).setPosition(100, 200).setSize(200, 40);
 *     this.addChild(image);
 *
 *     var label = this.createElement("ui-label").setText("Hello").setPosition(100, 100).setSize(200, 40);
 *     label.style.setFontSize(16);
 *     label.style.setTextColor("Green");
 *     this.addChild(label);
 *
 */

/**
 * @method bindData
 *
 * 绑定数据。
 * @param {Object} data 数据。
 * @param {String} animHint 动画提示(仅适用于UIListView)。
 * @param {Boolean} clearOldData 是否清除老的数据(仅适用于UIListView)。
 *
 *
 * @return {UIElement} 返回控件本身。
 *
 * 按名称绑定
 *
 *     @example small frame
 *     var data = {"ui-name":"张三丰", "ui-gender":"男", "ui-age":"108"};
 *     this.getWindow().find("ui-list-view").bindData(data);
 *     
 * 按顺序绑定
 *
 *     @example small frame
 *     var data = {
 *         "children": [
 *     		{
 *     			"children": [
 *     				{"image": "/images/mimetypes/folder.png"},
 *     				{"text": "Folder"},
 *     				{}
 *     			]
 *     		},
 *     		{
 *     			"children": [
 *     				{"image": "/images/mimetypes/mimetype_img.png"},
 *     				{"text": "test.jpg"},
 *     				{}
 *     			]
 *     		},
 *     		{
 *     			"children": [
 *     				{"image": "/images/mimetypes/mimetype_sound.png"},
 *     				{"text": "music.mp3"},
 *     				{}
 *     			]
 *     		}
 *     	]
 *     }
 *     
 *     this.getWindow().find("ui-list-view").bindData(data, "default", true);
 */

/*
 * File:   ui-group.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Group
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGroup
 * @extends UIElement
 * 分组控件。可以拖放分组控件来创建，也可以把几个控件组合起来。
 *
 * 可以在属性页中设置背景和边框的颜色，如果不需要背景和边框的颜色，把相应的颜色删除就行了。
 *
 */
function UIGroup() {
	return;
}

UIGroup.prototype = new UIElement();
UIGroup.prototype.isUIGroup = true;

UIGroup.prototype.initUIGroup = function(type, w, h, img) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	this.setCanRectSelectable(false, false);
	this.addEventNames(["onInit"]);
	this.style.lineColor = "rgba(0,0,0,0)";
	this.style.fillColor = "rgba(0,0,0,0)";
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UIGroup.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar || shape.isUIWindow || shape.isUIListItem) {
		return false;
	}

	return true;
}

UIGroup.prototype.onPointerUpEditing = function(point, beforeChild) {

	return;
}

UIGroup.prototype.fixChildPosition = function(child) {
}

UIGroup.prototype.fixChildSize = function(child) {
}

UIGroup.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		canvas.beginPath();
		drawRoundRect(canvas, this.w, this.h, this.roundRadius);
		
		if(!this.isFillColorTransparent()) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fill();
		}

		if(!this.isStrokeColorTransparent()) {
			canvas.lineWidth = this.style.lineWidth;
			canvas.strokeStyle = this.style.lineColor;
			canvas.stroke();	
		}
	}

	return;
}

UIGroup.prototype.onPositionChanged = function() {
	var children = this.children;
	var n = children.length;

	for(var i = 0; i < n; i++) {
		var iter = children[i];
		if(iter.isUIBody || iter.isUIGroup || iter.isUIEdge){
			iter.onPositionChanged();
		}
	}

	return;
}


function UIGroupCreator(w, h, img) {
	var args = ["ui-group", "ui-group", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGroup();

		return g.initUIGroup(this.type, w, h, img);
	}
	
	return;
}

UIGroup.create = function() {
	var g = new UIGroup();
	
	g.initUIGroup("ui-group", 200, 200, null);
	g.state = Shape.STAT_NORMAL;

	return g;
}

/*
 * File:   ui-window.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Window
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWindow
 * @extends UIElement
 * 窗口是普通窗口和对话框的基类。
 *
 */
function UIWindow() {
	return;
}

/**
 * @event onLoad 
 * 此事件在第一批资源加载完成时触发。发生在onSystemInit事件之后，onBeforeOpen事件之前。
 *
 * 注意：由于窗口并未打开，请不要使用界面上的控件。
 */

/**
 * @event onSystemInit
 * 系统初始化事件，UI数据加载完成，但其它资源尚未加载。
 *
 * 注意：由于窗口并未打开，请不要使用界面上的控件。
 */

/**
 * @event onBeforeOpen
 * 窗口已经创建，但是还没有显示出来。
 *
 * 注意：请不要在onBeforeOpen事件再打开另外一个窗口，否则可能出现不可预料的错误。
 *
 * @param {Object} initData 初始化参数，此参数是从openWindow方法传过来的。
 *
 */

/**
 * @event onOpen
 * 窗口打开事件。
 * @param {Object} initData 初始化参数，此参数是从openWindow方法传过来的。
 *
 * 打开窗口：
 *
 *     @example small frame
 *     var initData = "abcd";
 *     this.openWindow("win-test", function (retCode) {console.log("window closed.");}, false, initData);
 *
 * onOpen事件处理代码：
 *
 *     @example small frame
 *     console.log(initData);
 *
 */

/**
 * @event onClose
 * 窗口关闭。
 * @param {Object} retInfo 由closeWindow函数传递过来。
 *
 */

/**
 * @event onSwitchToBack
 * 打开新窗口，当前窗口切换到后台时，当前窗口触发本事件。
 *
 */

/**
 * @event onSwitchToFront
 * 关闭当前窗口，前一个窗口切换到前台时，前一个窗口触发本事件。
 */

/**
 * @event onSwipeLeft
 * 手势向左滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeRight
 * 手势向右滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeUp
 * 手势向上滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */

/**
 * @event onSwipeDown
 * 手势向下滑动事件。
 * @param {Point} start 起始点。
 * @param {Point} end 结束点。
 */


/**
 * @event onKeyDown
 * Key Down事件。
 * @param {Number} code 按键的代码。
 *
 * 代码影射表：
 *
 *     @example small frame
 *
 *     var KeyEvent = {
 *        DOM_VK_CANCEL: 3,
 *        DOM_VK_HELP: 6,
 *        DOM_VK_BACK_SPACE: 8,
 *        DOM_VK_TAB: 9,
 *        DOM_VK_CLEAR: 12,
 *        DOM_VK_RETURN: 13,
 *        DOM_VK_ENTER: 14,
 *        DOM_VK_SHIFT: 16,
 *        DOM_VK_CONTROL: 17,
 *        DOM_VK_ALT: 18,
 *        DOM_VK_PAUSE: 19,
 *        DOM_VK_CAPS_LOCK: 20,
 *        DOM_VK_ESCAPE: 27,
 *        DOM_VK_SPACE: 32,
 *        DOM_VK_PAGE_UP: 33,
 *        DOM_VK_PAGE_DOWN: 34,
 *        DOM_VK_END: 35,
 *        DOM_VK_HOME: 36,
 *        DOM_VK_LEFT: 37,
 *        DOM_VK_UP: 38,
 *        DOM_VK_RIGHT: 39,
 *        DOM_VK_DOWN: 40,
 *        DOM_VK_PRINTSCREEN: 44,
 *        DOM_VK_INSERT: 45,
 *        DOM_VK_DELETE: 46,
 *        DOM_VK_0: 48,
 *        DOM_VK_1: 49,
 *        DOM_VK_2: 50,
 *        DOM_VK_3: 51,
 *        DOM_VK_4: 52,
 *        DOM_VK_5: 53,
 *        DOM_VK_6: 54,
 *        DOM_VK_7: 55,
 *        DOM_VK_8: 56,
 *        DOM_VK_9: 57,
 *        DOM_VK_SEMICOLON: 59,
 *        DOM_VK_EQUALS: 61,
 *        DOM_VK_A: 65,
 *        DOM_VK_B: 66,
 *        DOM_VK_C: 67,
 *        DOM_VK_D: 68,
 *        DOM_VK_E: 69,
 *        DOM_VK_F: 70,
 *        DOM_VK_G: 71,
 *        DOM_VK_H: 72,
 *        DOM_VK_I: 73,
 *        DOM_VK_J: 74,
 *        DOM_VK_K: 75,
 *        DOM_VK_L: 76,
 *        DOM_VK_M: 77,
 *        DOM_VK_N: 78,
 *        DOM_VK_O: 79,
 *        DOM_VK_P: 80,
 *        DOM_VK_Q: 81,
 *        DOM_VK_R: 82,
 *        DOM_VK_S: 83,
 *        DOM_VK_T: 84,
 *        DOM_VK_U: 85,
 *        DOM_VK_V: 86,
 *        DOM_VK_W: 87,
 *        DOM_VK_X: 88,
 *        DOM_VK_Y: 89,
 *        DOM_VK_Z: 90,
 *        DOM_VK_CONTEXT_MENU: 93,
 *        DOM_VK_NUMPAD0: 96,
 *        DOM_VK_NUMPAD1: 97,
 *        DOM_VK_NUMPAD2: 98,
 *        DOM_VK_NUMPAD3: 99,
 *        DOM_VK_NUMPAD4: 100,
 *        DOM_VK_NUMPAD5: 101,
 *        DOM_VK_NUMPAD6: 102,
 *        DOM_VK_NUMPAD7: 103,
 *        DOM_VK_NUMPAD8: 104,
 *        DOM_VK_NUMPAD9: 105,
 *        DOM_VK_MULTIPLY: 106,
 *        DOM_VK_ADD: 107,
 *        DOM_VK_SEPARATOR: 108,
 *        DOM_VK_SUBTRACT: 109,
 *        DOM_VK_DECIMAL: 110,
 *        DOM_VK_DIVIDE: 111,
 *        DOM_VK_BACK_BUTTON: 115, 
 *        DOM_VK_MENU_BUTTON: 118, 
 *        DOM_VK_SEARCH_BUTTON: 120, 
 *        DOM_VK_F1: 112,
 *        DOM_VK_F2: 113,
 *        DOM_VK_F3: 114,
 *        DOM_VK_F4: 115,
 *        DOM_VK_F5: 116,
 *        DOM_VK_F6: 117,
 *        DOM_VK_F7: 118,
 *        DOM_VK_F8: 119,
 *        DOM_VK_F9: 120,
 *        DOM_VK_F10: 121,
 *        DOM_VK_F11: 122,
 *        DOM_VK_F12: 123,
 *        DOM_VK_F13: 124,
 *        DOM_VK_F14: 125,
 *        DOM_VK_F15: 126,
 *        DOM_VK_F16: 127,
 *        DOM_VK_F17: 128,
 *        DOM_VK_F18: 129,
 *        DOM_VK_F19: 130,
 *        DOM_VK_F20: 131,
 *        DOM_VK_F21: 132,
 *        DOM_VK_F22: 133,
 *        DOM_VK_F23: 134,
 *        DOM_VK_F24: 135,
 *        DOM_VK_NUM_LOCK: 144,
 *        DOM_VK_SCROLL_LOCK: 145,
 *        DOM_VK_COMMA: 188,
 *        DOM_VK_PERIOD: 190,
 *        DOM_VK_SLASH: 191,
 *        DOM_VK_BACK_QUOTE: 192,
 *        DOM_VK_OPEN_BRACKET: 219,
 *        DOM_VK_BACK_SLASH: 220,
 *        DOM_VK_CLOSE_BRACKET: 221,
 *        DOM_VK_QUOTE: 222,
 *        DOM_VK_META: 224,
 *        DOM_VK_BACK: 225
 *      }
 *
 * 用法示例：
 *
 *     @example small frame
 *     var win = this.getWindow();
 *     var image = win.find("image");
 *     switch (code) {
 *         case KeyEvent.DOM_VK_UP:
 *             image.y -= 5;
 *             break;
 *         case KeyEvent.DOM_VK_DOWN:
 *             image.y += 5;
 *             break;
 *         case KeyEvent.DOM_VK_LEFT:
 *             image.x -= 5;
 *             break;
 *         case KeyEvent.DOM_VK_RIGHT:
 *             image.x += 5;
 *             break;
 *         default:
 *             break;
 *     }
 */

/**
 * @event onKeyUp
 * Key Up事件。
 * @param {Number} code 按键的代码。
 */

/**
 * @event onMultiTouch
 * 多点触摸事件。
 * @param {String} action "touchstart", "touchmove", "touchend"
 * @param {Array} points 点的数组。坐标是根据Canvas的缩放比例转换过的，相对当前窗口的坐标。
 * @param {Object} event 原始Touch事件。
 */

UIWindow.serialNo = 0;
UIWindow.prototype = new UIElement();
UIWindow.prototype.isUIWindow = true;
UIWindow.prototype.saveProps = ["openAnimationDuration", "closeAnimationDuration", "animHint", "windowType",
"closeWhenPointerUpOutside", "refLinesV", "refLinesH", "windowNameToBeOpen", "preloadWindows", "isUILoadingWindowV2", "isUILoadingWindow", "sceneId"];

UIWindow.prototype.fromJson = function(json) {
	this.jsonData = json;
	this.name = json.name;

	if(json.isUILoadingWindow) {
		RShape.prototype.fromJson.call(this, json);
	}
	else {
        Object.keys(json.events).forEach(function(ev) {
            this.events[ev] = json.events[ev];
        }, this);
	}

	return this;
}

UIWindow.prototype.fromJsonNow = function(json) {
	RShape.prototype.fromJson.call(this, json);
	this.relayout();

	return this;
}

UIWindow.prototype.onGesture = function(gesture) {
	if(!this.isInDesignMode()) {
		this.callOnGestureHandler(gesture);
	}

	return;
}

UIWindow.prototype.onMultiTouch = function(action, points, event) {
	this.callOnMultiTouchHandler(action, points, event);
}

UIWindow.prototype.isMainWindow = function() {
	var wm = this.getWindowManager();
	var index = wm.history[0];
	var firstWin = wm.children[index];

	return firstWin === this;
}

UIWindow.prototype.getTimeScale = function() {
	return this.timeScale;
}

UIWindow.prototype.setTimeScale = function(timeScale) {
	this.timeScale = timeScale;

	return this;
}

UIWindow.prototype.initUIWindow = function(type, x, y, w, h, bg) {
	this.initUIElement(type);	

	this.timeScale = 1;
	this.setLeftTop(x, y);
	this.settings = {};
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setName("window-" + UIWindow.serialNo++);

	if(!bg) {
		this.style.setFillColor("White");
	}

	this.addEventNames(["onSystemInit", "onLoad", "onOpen", "onBeforeOpen",
			"onClose", "onSwitchToBack", "onSwitchToFront", "onGesture", "onKeyDown", "onKeyUp"]);

	this.setAnimHint("htranslate");
	this.oldHitTest = this.hitTest;

	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.intervals = [];
	this.timeouts = [];

	return this;
}

UIWindow.prototype.setAnimHint = function(animHint) {
	this.animHint = animHint;

	return true;
}

UIWindow.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar || shape.isUIWindow) {
		return false;
	}

	return true;
}

UIWindow.prototype.onModeChanged = function() {
	if(this.isInDesignMode()) {
		this.popupWindow = null;
	}

	return;
}

UIWindow.prototype.removePopupWindow = function(popup) {
	if(this.popupWindow) {
		if(this.popupWindow === popup) {
			this.popupWindow = popup.popupWindow;
			if(this.popupWindow) {
				this.popupWindow.parentWindow = this;
			}

			popup.parentWindow = null;
			popup.popupWindow = null;

			return true;
		}

		return this.popupWindow.removePopupWindow(popup);
	}

	return false;
}

UIWindow.prototype.setPopupWindow = function(popup) {
	if(this === popup) {
		return false;
	}

	if(this.popupWindow) {
		return this.popupWindow.setPopupWindow(popup);
	}
	else {
		this.popupWindow = popup;
		if(popup) {
			popup.parentWindow = this;
		}
	}

	return true;
}

UIWindow.prototype.getPopupWindow =function() {
	if(this.popupWindow) {
		return this.popupWindow.getPopupWindow();
	}

	return this.isUIPopupWindow ? this : null;
}

UIWindow.prototype.isGrabElement = function(el) {
	return this.grabElement === el;
}

UIWindow.prototype.grab = function(el) {
	this.grabElement = el;

	return;
}

UIWindow.prototype.ungrab = function(el) {
	this.grabElement = null;

	return;
}

UIWindow.prototype.dispatchPointerDownToChildren = function(p) {
	if(this.grabElement) {
		this.grabElement.onPointerDown(p)
		this.setTarget(this.grabElement);
		return true;
	}
	
	return this.defaultDispatchPointerDownToChildren(p);
}

UIWindow.prototype.onPointerDownNormal = function(point) {
	this.pointerDownPosition.x = point.x;
	this.pointerDownPosition.y = point.y;

	if(this.popupWindow) {
		this.popupWindow.onPointerDownNormal(point)
		this.setTarget(this.popupWindow);
		this.pointerDown = false;

		if(!this.popupWindow || !this.popupWindow.shouldPropagatePointerEvent()) {
			return true;
		}
	}

	return UIElement.prototype.onPointerDownNormal.call(this, point);
}

UIWindow.prototype.onDoubleClick = function(point) {
	if(this.popupWindow) {
		this.popupWindow.onDoubleClick(point)
		if(!this.popupWindow || !this.popupWindow.shouldPropagatePointerEvent()) {
			return true;
		}
	}

	return UIElement.prototype.onDoubleClick.call(this, point);
}

UIWindow.prototype.onPointerMoveNormal = function(point) {
	if(this.popupWindow) {
		this.popupWindow.onPointerMoveNormal(point)
		if(!this.popupWindow || !this.popupWindow.shouldPropagatePointerEvent()) {
			return true;
		}
	}

	return UIElement.prototype.onPointerMoveNormal.call(this, point);
}

UIWindow.prototype.onPointerUpNormal = function(point) {
	if(this.popupWindow) {
		this.popupWindow.onPointerUpNormal(point)
		if(!this.popupWindow || !this.popupWindow.shouldPropagatePointerEvent()) {
			return true;
		}
	}

	if(!this.pointerDown) {
		return true;
	}

	if(!this.isInDesignMode() && this.enable) {
		var dx = this.lastPosition.x - this.pointerDownPosition.x;
		var dy = this.lastPosition.y - this.pointerDownPosition.y;
		var adx = Math.abs(dx);
		var ady = Math.abs(dy);
		var end = this.lastPosition;
		var start = this.pointerDownPosition;

		if(adx > 20 || ady > 20) {
			if((adx >> 1) > ady) {
				if(dx < 0) {
					this.callOnSwipeLeftHandler(start, end);
				}
				else {
					this.callOnSwipeRightHandler(start, end);
				}
			}
			if((ady >> 1) > adx) {
				if(dy < 0) {
					this.callOnSwipeUpHandler(start, end);
				}
				else {
					this.callOnSwipeDownHandler(start, end);
				}
			}
		}
	}

	return UIElement.prototype.onPointerUpNormal.call(this, point);
}

UIWindow.prototype.paintSelfOnly =function(canvas) {
	var opacity = this.opacity;
	if(opacity !== 1) {
		canvas.globalAlpha *= opacity;
	}

	this.clearBackground(canvas);
	this.drawBgImage(canvas);

	return;
}

UIWindow.prototype.beforePaintChildren = function(canvas) {
	canvas.globalAlpha = 1;
}

UIWindow.prototype.paintSelf = function(canvas) {
	var timeStep = canvas.timeStep;

	canvas.timeStep = this.scaleTime(timeStep);
	if(this.isInDesignMode()) {
		UIElement.prototype.paintSelf.call(this, canvas);
	}
	else {
		canvas.save();
		this.translate(canvas);
        this.updateTransform(canvas);
		this.paintSelfOnly(canvas);
		
		this.beforePaintChildren(canvas);
		this.paintChildren(canvas);
		this.afterPaintChildren(canvas);
		canvas.restore();
	}

	if(this.popupWindow && !this.popupWindow.closePending) {
		canvas.timeStep = this.popupWindow.scaleTime(timeStep);
		this.popupWindow.paintSelf(canvas);
	}
	canvas.timeStep = timeStep;

	return;
}

UIWindow.prototype.show = function() {
	this.setVisible(true);
	this.showHTML();

	return;
}

UIWindow.prototype.hide = function() {
	this.setVisible(false);
	this.hideHTML();
	cantkHideAllInput();

	return;
}

UIWindow.prototype.setCloseWhenPointerUpOutside = function(closeWhenPointerUpOutside) {
	if(closeWhenPointerUpOutside) {
		this.hitTest = function(point) {
			var ret = this.oldHitTest(point);
			if(!ret) {
				if(!this.isInDesignMode()) {
					ret = Shape.HIT_TEST_MM;
				}
			}

			return ret;
		}
	}
	else {
		this.hitTest = this.oldHitTest;
	}
	this.closeWhenPointerUpOutside = closeWhenPointerUpOutside;

	return;
}

UIWindow.prototype.isAnimationEnabled = function() {
	//if(CantkRT.isNative()) return false;

	return this.animHint && this.animHint !== "none";
}

UIWindow.prototype.getAnimationDuration = function(toShow) {
	return toShow ? this.openAnimationDuration : this.closeAnimationDuration;
}

UIWindow.prototype.getAnimationName = function(toShow) {
	var anim = "";
	switch(this.animHint) {
		case "fade": {
			anim = toShow ? "anim-fade-in" : "anim-fade-out";
			break;
		}
		case "scale": {
			if(this.isUIDialog) {
				anim = toShow ? "anim-scale-show-dialog" : "anim-scale-hide-dialog";
			}
			else {
				anim = toShow ? "anim-scale-show-win" : "anim-scale-hide-win";
			}
			break;
		}
		case "popup": {
			anim = toShow ? "anim-move-up" : "anim-move-down";
			break;
		}
		case "htranslate": {
			anim = toShow ? "anim-forward" : "anim-backward";
			break;
		}
		case "vtranslate": {
			anim = toShow ? "anim-upward" : "anim-downward";
			break;
		}
		default: {
			if(this.isUIDialog) {
				anim = toShow ? "anim-scale-show-dialog" : "anim-scale-hide-dialog";
			}
			else {
				if(isAndroid() || isFirefoxMobile()) {
					anim = toShow ? "anim-scale-show-win" : "anim-scale-hide-win";
				}
				else {
					anim = toShow ? "anim-forward" : "anim-backward";
				}
			}
			break;
		}
	}

	return anim;
}

UIWindow.prototype.isSplashWindow = function() {
	return this.isUINormalWindow && this.windowType === "splash";
}

UIWindow.prototype.getSupportedAnimations = function() {
	var animations = ["none", "default", "scale", "fade", "popup"];
	if(!this.isUIDialog) {
        animations = animations.concat(["htranslate", "vtranslate"]);
    }

	return animations;
}

UIWindow.prototype.clearBackground =function(canvas) {
	var display = this.images.display;
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(image) {
		switch(display) {
			case UIElement.IMAGE_DISPLAY_TILE:
			case UIElement.IMAGE_DISPLAY_TILE_V:
			case UIElement.IMAGE_DISPLAY_TILE_H:
			case UIElement.IMAGE_DISPLAY_SCALE:
			case UIElement.IMAGE_DISPLAY_9PATCH:
			case UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO: return;
			default:break;
		}

		if(image.width >= this.w && image.height >= this.h) {
			return;
		}
	}

	if(!this.isFillColorTransparent()) {
		canvas.beginPath();
        canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

UIWindow.prototype.defaultChildrenFromJson = UIElement.prototype.childrenFromJson;

UIWindow.prototype.loadChildren = function() {
	if(this.childrenJson) {
		this.defaultChildrenFromJson(this.childrenJson);
		delete this.childrenJson;
		delete this.pendingLoadChildren;
		console.log("Now To Load Children Of " + this.name);

		if(this.scaleInfo) {
			this.scaleForDensity(this.scaleInfo.sizeScale, this.scaleInfo.lcdDensity, true);
		}

		var wm = this.getWindowManager();
		var oldConfig = wm.oldConfig;
		var deviceConfig = wm.deviceConfig;

		if(oldConfig && deviceConfig) {
			this.notifyDeviceConfigChanged(oldConfig, deviceConfig);
		}

	}

	return;
}

UIWindow.prototype.childrenFromJson = function(js) {
	if(js.lazyLoad && !dappIsEditorApp()) {
		this.childrenJson = js;
		this.pendingLoadChildren = true;
		console.log("Delay To Load Children Of " + this.name);
	}
	else {
		delete this.pendingLoadChildren;
		this.defaultChildrenFromJson(js);	
	}

	return;
}

UIWindow.prototype.initStageOne = function() {
	this.callOnInitHandler();
	this.clearAllTimeouts();
	this.clearAllIntervals();
	this.enablePhysics = false;

	var win = this;
	this.forEach(function(iter) {
		if(iter.offset) {
			iter.offset = 0;
		}
		iter.visible = iter.runtimeVisible;

		if(iter.animatingInfo) {
			iter.animatingInfo = null;
			iter.animating = false;
		}

		if(iter.animations && iter.animations[iter.defaultAnimationName]) {
			console.log(iter.name + " has default animation, set it invisible initially.");
			iter.visible = false;
		}

		if(iter.isUIBody || iter.isUIEdge) {
			win.enablePhysics = true;
		}
	});

	return;
}

UIWindow.prototype.onInit = function() {
	this.initStageOne();

	return;
}

UIWindow.prototype.prepareForOpen = function() {
	if((!this.isUILoadingWindow || this.children.length < 1) && this.jsonData) {
		this.fromJsonNow(this.jsonData);
	}

	this.setMode(Shape.MODE_RUNNING, true);
	this.relayout();

	return this;
}

UIWindow.prototype.callOnBeforeOpen = function(initData) {
	this._open = true;
	var wm = this.getParent();
	if(wm && wm.hasEventListener("windowopen")) {
		var event = wm.createEvent("windowopen");
		event.win = this;
		wm.dispatchEvent(event);
	}

	this.show();
	this.init();
	return this.callOnBeforeOpenHandler(initData);
}

UIWindow.prototype.callOnOpen = function(initData) {
	delete this.openPending;
	this.getParent().pointerEventTarget = this;

	if(this.onOpen) {
		try {
			this.onOpen(initData);
		}catch(e) {
			console.log("onOpen" + e.message);
		}
	}

	this.callOnOpenHandler(initData);

	if(this.isSplashWindow()) {
		var win = this;
		var duration = win.duration ? win.duration : 3000;

		if(window.splashWinTimeID) {
			clearTimeout(window.splashWinTimeID);
			delete window.splashWinTimeID;
		}

		window.splashWinTimeID = setTimeout(function() {
			if(win.visible) {
				win.openWindow(null, null, true);
			}
		}, duration);
	}

	this.forEach(function(el) {
		el.onWindowOpen();
	});

	return true;
}

UIWindow.prototype.callOnClose = function(retInfo) {
	this._open = false;
    delete this.closePending;

	var wm = this.getParent();
	if(wm && wm.hasEventListener("windowclose")) {
		var event = wm.createEvent("windowclose");
		event.win = this;
		wm.dispatchEvent(event);
	}

	if(this.onClose) {
		try {
			this.onClose(retInfo);
		}
		catch(e) {
			console.log("onClose: " + e.message);
		}
	}
			
	this.callOnCloseHandler(retInfo);

	this.deinit();
	this.hide();

	if(this.destroyWhenClose) {
		this.getWindowManager().removeChild(this, true);
	}
	
	this.resetEvents();
	this.clearAllTimeouts();
	this.clearAllIntervals();

	var arr = this.children;
	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		iter.detachNameFromParent();
	}

	this.children = [];

	if(this.parentWindow) {
		this.parentWindow.popupWindow = this.popupWindow;
	}
	if(this.popupWindow) {
		this.popupWindow.parentWindow = this.parentWindow;
	}

	this.popupWindow = null;
	this.parentWindow = null;

	setTimeout(function() {
		arr.clear(true);
	}, 100);

	return true;
}

UIWindow.prototype.callOnSwitchToBack = function(topIsPopup) {
	this.callOnSwitchToBackHandler();
	if(!topIsPopup) {
		this.hide();
	}

	return true;
}

UIWindow.prototype.callOnSwitchToFront = function(topIsPopup) {
	if(this.isUINormalWindow && (this.w != this.parentShape.w || this.h != this.parentShape.h)) {
		this.relayout();
		console.log("WindowManager Size Changed, Relayout Current Window.");
	}

	this.show();
	this.callOnSwitchToFrontHandler();

	return true;
}

UIWindow.prototype.isOpen = function() {
	return !!this._open;
}

/**
 * @method setTimeout
 * 是对系统setTimeout的包装，保证窗口关闭时，定时器被销毁。
 * @param {Function} func 定时器回调函数。 
 * @param {Number} dt 时长(毫秒) 
 * @return {Number} 返回timerID
 *
 */
UIWindow.prototype.setTimeout = function(func, dt) {
	if(this.isInDesignMode()) {
		console.log("Can not UIWindow.prototype.setTimeout in edit mode.");
		return;
	}

	if(typeof(func) !== "function") {
		console.log("invalid func for UIWindow.prototype.setTimeout");
		return;
	}

	function callback() {
		this.timeouts.remove(id);
		func();
	}

	var id = window.setTimeout(callback.bind(this), dt);
	this.timeouts.push(id);

	return id;
}

/**
 * @method clearTimeout
 * 清除定时器。
 * @param {Number} id timerID
 *
 */
UIWindow.prototype.clearTimeout = function(id) {
	window.clearTimeout(id);
	this.timeouts.remove(id);
}

/**
 * @method setInterval
 * 是对系统setInterval的包装，保证窗口关闭时，定时器被销毁。
 * @param {Function} func 定时器回调函数。 
 * @param {Number} dt 时长(毫秒) 
 * @return {Number} 返回timerID
 *
 */
UIWindow.prototype.setInterval = function(func, dt) {
	if(this.isInDesignMode()) {
		console.log("Can not UIWindow.prototype.setInterval in edit mode.");
		return;
	}
	
	if(typeof(func) !== "function") {
		console.log("invalid func for UIWindow.prototype.setInterval");
		return;
	}

	function callback() {
		func();
	}

	var id = window.setInterval(callback.bind(this), dt);
	this.intervals.push(id);

	return id;
}

/**
 * @method clearInterval
 * 清除定时器。
 * @param {Number} id timerID
 *
 */
UIWindow.prototype.clearInterval = function(id) {
	window.clearInterval(id);
	this.intervals.remove(id);
}

UIWindow.prototype.clearAllIntervals = function() {
	var arr = this.intervals;
	for(var i = 0; i < arr.length; i++) {
		var id = arr[i];
		window.clearInterval(id);
	}
	this.intervals.length = 0;
}

UIWindow.prototype.clearAllTimeouts = function() {
	var arr = this.timeouts;
	for(var i = 0; i < arr.length; i++) {
		var id = arr[i];
		window.clearTimeout(id);
	}
	this.timeouts.length = 0;
}

UIWindow.prototype.loadInitAssets = function(bar, preloadWindows, label) {
	var win = this;

	function doLoadInitAssets(evt) {
		if(evt.percent > 99.9) {
			win.doLoadInitAssets(bar, preloadWindows, label);
			ResLoader.off(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, doLoadInitAssets);
		}
	}

	if(ResLoader.isLoadCompleted()) {
		win.doLoadInitAssets(bar, preloadWindows, label);
	}else{
		ResLoader.on(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, doLoadInitAssets);
	}
}

UIWindow.prototype.doLoadInitAssets = function(bar, preloadWindows, label) {
	var win = this;
	var wm = win.getParent();
	
	if(!bar) {
		bar = win.findChildByType("ui-progressbar");
	}
	
	if(!label) {
		label = win.findChildByType("ui-label");
	}
	
	if(!preloadWindows) {
		preloadWindows = win.preloadWindows;
	}
	
	function onLoadProgress(percent, loadedNr, totalNr) {
		if(label) {
			label.setText("Loading...");
		}

		if(bar) {
			bar.setPercent(percent, true);
		}
		
        var initWin = wm.getInitWindow();
		if(loadedNr >= totalNr && initWin != win) {
			wm.showInitWindow(win.windowNameToBeOpen);	
		}
		
		win.postRedraw();
	}

	function onDownloadProgress(percent, loadedNr, totalNr) {
		if(label) {
			if(percent >= 100) {
				label.setText("Loading...");
			}else{
				label.setText("Downloading...");
			}
		}

		if(bar) {
			if(percent >= 100) {
				if(AssetsDownloader.isAvailable()) {
					wm.loadAudios();
					wm.loadFonts();
				}

				bar.setPercent(0, true);
			}else {
				bar.setPercent(percent, true);
			}
		}
	}

	var winNamesArr = preloadWindows ? preloadWindows.split(",") : wm.getWindowNames(this);
	if(AssetsDownloader.isAvailable()) {
		winNamesArr.push("__audios__");
		winNamesArr.push("__fonts__");
	}else{
		wm.loadAudios();
		wm.loadFonts();
	}

	wm.loadAssets(winNamesArr, onLoadProgress, onDownloadProgress);

	this.loadInitAssets = function() {}

	return this;
}

UIWindow.prototype.relayout = function() {
	if(!this.getWindowManager().isDeviceDirectionOK()) {
		console.log("UIWindow.prototype.relayout Reject Relayout");
		return;
	}

	UIElement.prototype.relayout.call(this);

	return this;
}

ShapeFactoryGet().addShapeCreator(new UINormalWindowCreator(null));

//////////////////////////////////////////////////////////////////////}-{

/**
 * @class UINormalWindow
 * @extends UIWindow
 * 普通窗口是全屏的窗口。
 *
 */
function UINormalWindow() {
	return;
}

UINormalWindow.prototype = new UIWindow();
UINormalWindow.prototype.isUINormalWindow = true;

function UINormalWindowCreator(bg) {
	var args = ["ui-window", "ui-window", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UINormalWindow();
		
		g.initUIWindow(this.type, 0, 0, 100, 100, bg);
		g.widthAttr = UIElement.WIDTH_FILL_PARENT;
		g.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		g.addEventNames(["onSwipeLeft", "onSwipeRight", "onSwipeUp", "onSwipeDown"]);

		return g;
	}
	
	return;
}

/*
 * File:   ui-dialog.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Dialog
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIDialog
 * @extends UIWindow
 * 通常用对话框提示信息和确认问题等。
 *
 */
function UIDialog() {
	return;
}

UIDialog.prototype = new UIWindow();
UIDialog.prototype.isUIDialog = true;
UIDialog.prototype.isUIPopupWindow = true;

UIDialog.prototype.fixChildSize = function(shape) {
	return;
}

UIDialog.prototype.fixChildPosition = function(shape) {
	return;
}

function UIDialogCreator(w, h, bg) {
	var args = ["ui-dialog", "ui-dialog", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDialog();
		g.initUIWindow(this.type, 0, 0, w, h, bg);
		
		g.setMargin(8, 8);
		g.xAttr = UIElement.X_CENTER_IN_PARENT;
		g.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
		g.images.display = UIElement.IMAGE_DISPLAY_SCALE;
		g.setAnimHint("scale");

		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDialogCreator(600, 400, null));

/*
 * File:   ui-edit.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Single Line Editor
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIEdit
 * @extends UIElement
 * 单行编辑器。
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onChanging
 * 文本正在变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onFocusIn
 * 得到输入焦点事件。
 */

/**
 * @event onFocusOut
 * 失去输入焦点事件。
 */
function UIEdit() {
	return;
}

UIEdit.prototype = new UIElement();
UIEdit.prototype.isUIEdit = true;

UIEdit.prototype.saveProps = ["leftMargin", "rightMargin", "inputType", "inputTips", "maxLength"];
UIEdit.prototype.initUIEdit = function(type, w, h, leftMargin, rightMargin, initText, bg, focusedBg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setText(initText);
	this.leftMargin = leftMargin;
	this.rightMargin = rightMargin;
	this.setSizeLimit(60, 30, 1000, 80);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setImage(UIElement.IMAGE_FOCUSED, focusedBg);
	this.setMargin(5, 5);
	this.setInputType("text");
	this.addEventNames(["onChanged", "onChanging", "onFocusIn", "onFocusOut"]);
	this.setTextAlignV("middle");
	this.setTextAlignH("left");
	this.maxLength = 1024;

	return this;
}

UIEdit.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIButton) {
		return true;
	}

	return false;
}

UIEdit.prototype.textEditable = function(point) {
	return true;
}

UIEdit.prototype.getLocaleText = function(text) {
	if(text === " ") {
		return text;
	}

	if(this.inputType === "password" && text && text === this.text) {
		var str = "";
		var n = text.length;
		for(var i = 0; i < n; i++) {
			str = str + "*";
		}

		return str;
	}
	else {
		return text;
	}
}

UIEdit.prototype.drawText = function(canvas) {
	var y = this.h >> 1;
	var x = this.leftMargin;
	var text = this.getLocaleText(this.text);
	var width = this.w - x - this.rightMargin;
	var inputTips = this.inputTips;

	if((!text && !inputTips) || this.editing) {
		return;
	}
	
	canvas.save();
	canvas.font = this.style.getFont();
	if(text) {
		canvas.fillStyle = this.style.textColor;	
	}
	else {
		text = inputTips;
		canvas.fillStyle = "#E0E0E0";
	}

	canvas.beginPath();
	canvas.rect(0, 0, this.w - this.rightMargin, this.h);
	canvas.clip();

	canvas.textAlign = "left";
	canvas.textBaseline = "middle";
	canvas.fillText(text, x, y);

	canvas.restore();

	return;
}

UIEdit.prototype.isFocused = function() {
	return this.editing;
}

UIEdit.prototype.paintSelfOnly = function(canvas) {
	var image = this.getBgImage();

	if(image) {
		return;
	}

	canvas.beginPath();
	drawRoundRect(canvas, this.w, this.h, 8);
	canvas.fillStyle = this.style.fillColor;
	canvas.fill();
	canvas.strokeStyle = this.style.lineColor;
	canvas.lineWidth = this.isFocused() ? 4 : 2;
	canvas.stroke();

	return;
}

UIEdit.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	if(!this.isInDesignMode()) {
		this.editText();
	}

    return this.callOnClickHandler(point);
}

UIEdit.prototype.getWidth = function(withoutBorder) {
	var w = this.w;
	if(withoutBorder) {
		w = w - this.leftMargin - this.rightMargin;
	}

	return w;
}

UIEdit.prototype.getEditorRect = function() {
	var leftMargin = this.leftMargin || 0;
	var p = this.getPositionInView();
	var cp = CantkRT.getMainCanvasPosition();
	var vp = this.view.getAbsPosition();
	var scale = this.view.getViewScale();

	var canvasScale = UIElement.getMainCanvasScale();
	var x = (vp.x + (p.x + leftMargin) * scale)/canvasScale.x + cp.x;
	var y = (vp.y + p.y * scale)/canvasScale.y + cp.y;
	var w = (this.getWidth(true) * scale)/canvasScale.x;
	var h = (this.getHeight() * scale)/canvasScale.y;
	
	var rect = {x:x, y:y, w:w, h:h};
	if(this.isInDesignMode()) {
		var radtio = window.devicePixelRatio || 1;
		rect.x *= radtio;
		rect.y *= radtio;
		rect.w *= radtio;
		rect.h *= radtio;
	}

	return rect;
}

UIEdit.prototype.editText = function(point) {
	var me = this;
	if(this.textEditable(point)) {
		var shape = this;
		var text = this.getText();
		var rect = this.getEditorRect();
		var scale = this.getRealScale() / UIElement.getMainCanvasScale().y;
		var inputType = this.inputType ? this.inputType : "text";
		var fontSize = this.style.fontSize * scale;
		var editor = cantkShowInput(inputType, fontSize, text, rect.x, rect.y, rect.w, rect.h);

		shape.editing = true;
		editor.setTextColor(this.style.textColor);
		editor.showBorder(this.isInDesignMode());
        editor.show();

		function onChanged(text) {
			if(text !== shape.text) {
				shape.setText(text, true);
				shape.postRedraw();
			}
			else {
				shape.text = text;
			}
			
			editor.setOnChangedHandler(null);
	        editor.setOnChangeHandler(null);
			editor.hide();
			delete shape.editing;
			shape.callOnFocusOutHandler();

			return;
		}

		function onChange(text) {
			shape.callOnChangingHandler(text);
		}

		editor.setMaxLength(me.maxLength || 1024);
		editor.setOnChangedHandler(onChanged);
		editor.setOnChangeHandler(onChange);

		this.callOnFocusInHandler();
	}

	return;
}

UIEdit.prototype.drawTextTips = function(canvas) {
}

function UIEditCreator(w, h, leftMargin, rightMargin, bg, focusedBg) {
	var args = ["ui-edit", "ui-edit", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIEdit();
		return g.initUIEdit(this.type, w, h, leftMargin, rightMargin, dappGetText("Edit"), bg, focusedBg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIEditCreator(120, 50, 12, 12, null, null));

/*
 * File:   ui-gauge.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Gauge
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */
function UIGauge() {
	return;
}

UIGauge.prototype = new UIElement();
UIGauge.prototype.isUIGauge = true;
UIGauge.IMAGE_POINTER = "pointer-image";

UIGauge.prototype.initUIGauge = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onInit"]);

	return this;
}

UIGauge.prototype.shapeCanBeChild = function(shape) {
	return shape.isUILedDigits || shape.isUILabel || shape.isUIGaugePointer;
}

UIGauge.prototype.afterChildAppended = function(shape) {
	var size = 20;
	var pointerNr = 0;

	if(shape.isUIGaugePointer) {
		shape.xAttr = UIElement.X_CENTER_IN_PARENT;
		shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		if(!iter.isUIGaugePointer) {
			continue;
		}

		switch(pointerNr) {
			case 0: {
				size = 100;
				break;
			}
			case 1: {
				size = 70;
				break;
			}
			case 2: {
				size = 40;
				break;
			}
		}
		pointerNr = pointerNr + 1;

		iter.setSizeLimit(size, size, size, size, 1);
		iter.setSize(size, size);
	}

	this.setSizeLimit(100, 100, 1000, 1000, 1);

	return;
}

UIGauge.prototype.paintSelfOnly = function(canvas) {

	return;
}

function UIGaugeCreator() {
	var args = ["ui-gauge", "ui-gauge", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGauge();
		return g.initUIGauge(this.type, 200, 200);
	}
	
	return;
}

///////////////////////////////////////////////////////////////////}-{

function UIGaugePointer() {
	return;
}

UIGaugePointer.prototype = new UIElement();
UIGaugePointer.prototype.isUIGaugePointer = true;

UIGaugePointer.prototype.saveProps = ["minAngle", "maxAngle", "minValue", "maxValue"];
UIGaugePointer.prototype.initUIGaugePointer = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIGauge.IMAGE_POINTER, null);
	
	this.value = 0;
	this.minAngle = 0;
	this.maxAngle = 360;
	this.minValue = 0;
	this.maxValue = 60;

	return this;
}

UIGaugePointer.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIGaugePointer.prototype.setText = function(text) {
	text = this.toText(text ? text : 0);
	try {
		this.setValue(parseInt(text));
	}catch(e) {
		console.log("UIGaugePointer.prototype.setText:" + e.message);
	}

	return this;
}

UIGaugePointer.prototype.getText = function() {
	return this.getValue() + "";
}

UIGaugePointer.prototype.setValue = function(value) {
	if(value >= this.minValue && value <= this.maxValue) {
		this.value = value;
	}
	else {
		console.log("UIGaugePointer.prototype.setValue: Out Of Range.");
	}

	return this;
}

UIGaugePointer.prototype.getValue = function() {
	return this.value;
}

UIGaugePointer.prototype.animSetValue = function(value, animHint) {
	return this.animSetValue(value, animHint);
}

UIGaugePointer.prototype.animateSetValue = function(value, animHint) {
	if(value < this.minValue) {
		value = this.minValue;
	}

	if(value > this.maxValue) {
		value = this.maxValue;
	}
	
	var pointer = this;
	var endValue = value;
	var startValue = this.getValue();
	var changeDelta = value - startValue;
	var changeAngle = Math.abs(changeDelta * (this.maxAngle - this.minAngle)/(this.maxValue - this.minValue));
	
	if(changeAngle < 5) {
		this.setValue(value);

		return;
	}

	var startTime = (new Date()).getTime();
	var duration = (animHint && animHint == "slow") ? 1000 : 500;

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;

		if(percent < 1) {
			var newValue = startValue + changeDelta * percent;	
			pointer.setValue(newValue);

			setTimeout(animStep, 10);
		}
		else {
			delete startTime;
			pointer.setValue(endValue);
		}

		delete now;
		pointer.postRedraw();
	}

	animStep();

	return;
}

UIGaugePointer.prototype.getAngle = function(canvas) {
	var rangeAngle = this.maxAngle - this.minAngle;
	var rangeValue = this.maxValue - this.minValue;
	var angle = (this.value/rangeValue) * rangeAngle + this.minAngle;

	angle = Math.PI * (angle / 180);

	return angle;
}

UIGaugePointer.prototype.paintSelfOnly = function(canvas) {
	var x = 0;
	var y = 0;
	var w = this.w;
	var h = this.h;
	var angle = this.getAngle();

	var image = this.getHtmlImageByType(UIGauge.IMAGE_POINTER);
	if(image && image.width) {
		var imageW = image.width;
		var imageH = image.height;

		canvas.translate(w/2, h/2);
		canvas.rotate(angle);
		canvas.translate(-w/2, -h/2);
		x = (w - imageW)/2;
		y = (h - imageH)/2;

		canvas.drawImage(image, x, y);
	}
	else {
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIGaugePointerCreator() {
	var args = ["ui-gauge-pointer", "ui-gauge-pointer", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGaugePointer();
		return g.initUIGaugePointer(this.type, 20, 200);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIGaugePointerCreator());
ShapeFactoryGet().addShapeCreator(new UIGaugeCreator());

/*
 * File:   ui-html.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  HTML 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIHtml
 * @extends UIElement
 * 主要用于在特殊情况下嵌入HTML代码。比如长按识别二维码，给HTML内容指定一张图片, 如：
 *
 *     @example small frame
 *
 *     <img src="http://studio.holaverse.cn/assets/controls/studio_qrcode.png" width="100%" height="100%" />
 *
 * 注意：CanTK Runtime不支持HTML，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 */
function UIHtml() {
	return;
}

UIHtml.prototype = new UIElement();
UIHtml.prototype.isUIHtml = true;

UIHtml.prototype.saveProps = ["htmlContent"];
UIHtml.prototype.initUIHtml = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);

	return this;
}

UIHtml.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIHtml.prototype.drawBgImage =function(canvas) {
	if(this.isInDesignMode() || this.isIcon) {
		var image = this.getBgImage();

		if(image) {
			var htmlImage = image.getImage();
			var srcRect = image.getImageRect();
			this.drawImageAt(canvas, htmlImage, this.images.display, 0, 0, this.w, this.h, srcRect);
		}
		else {
			canvas.beginPath();
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}
	}

	return;
}

UIHtml.prototype.scaleElement = function(element, scaleX, scaleY, xOrigin, yOrigin) {
    var origin = (xOrigin && yOrigin) ? xOrigin + " " + yOrigin : "50% 50%";
    var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

    element.style['transform-style'] = "preserve-3d";
    for(var i = 0; i < transforms.length; i++) {
        var trans = transforms[i];
        element.style[trans + "-origin"] = origin;
        element.style[trans] = "scale("+scaleX+","+scaleY+")";
    }

    return;
}

UIHtml.prototype.rotateElement = function(element, deg) {
    var origin = "50% 50%";
    var transforms = ["transform", "-ms-transform", "-webkit-transform", "-o-transform", "-moz-transform"];

    element.style['transform-style'] = "preserve-3d";
    for(var i = 0; i < transforms.length; i++) {
        var trans = transforms[i];
        element.style[trans + "-origin"] = origin;
        element.style[trans] = "rotate("+deg+"deg)";
    }

    return;
}

UIHtml.prototype.setRotation = function(rotation) {
	this.rotation = rotation;
	if(this.element) {
		this.rotateElement(this.element, (rotation * 180/Math.PI));
	}

	return this;
}

UIHtml.prototype.setOpacity = function(opacity) {
	this.opacity = opacity;
	if(this.element) {
 	   this.element.style["opacity"] = opacity;
	}

	return this;
}

UIHtml.prototype.setScale = function(scaleX, scaleY) {
	this.scaleX = scaleX;
	this.scaleY = scaleY;

	if(this.element) {
		this.scaleElement(this.element, scaleX, scaleY);
	}

	return this;
}

UIHtml.prototype.setScaleX = function(scaleX) {
	this.setScale(scaleX, this.scaleY);

	return this;
}

UIHtml.prototype.setScaleY = function(scaleY) {
	this.setScale(this.scaleX, scaleY);

	return this;
}

UIHtml.prototype.setVisible = function(value) {
	if(this.element) {
		this.element.style.display = value ? "block" : "none";
	}

	return this;
}

UIHtml.prototype.setPosition = function(x, y) {
	if(this.element) {
		this.element.style.left = x + "px";
		this.element.style.top = y + "px";
    }

	return this;
}

UIHtml.prototype.showHTMLElement = function() {
	var el = this.element;
	if(el) {
		var p = this.getPositionInView();
		var cp = CantkRT.getMainCanvasPosition();
		var vp = this.view.getAbsPosition();
		var scale = this.view.getViewScale();

		var canvasScale = UIElement.getMainCanvasScale();
		var x = (vp.x + p.x * scale)/canvasScale.x + cp.x;
		var y = (vp.y + p.y * scale)/canvasScale.y + cp.y;
		var w = (this.getWidth() * scale)/canvasScale.x;
		var h = (this.getHeight() * scale)/canvasScale.y;
		
		el.style.position = "absolute";
		el.style.left = x + "px";
		el.style.top = y + "px";
		el.style.width = w + "px";
		el.style.height = h + "px";
		el.style.visibility = 'visible';
		
		this.htmlVisible = true;
	}

	return;
}

UIHtml.prototype.createHTMLElement = function(name) {
	var element = null;
	if(!this.element) {
		element = document.createElement(name);
		element.id = this.type + this.name;
		document.body.appendChild(element);
		this.element = element;
	}

	return this.element;
}

UIHtml.prototype.beforeShowHTML = function() {
}

UIHtml.prototype.setScrollable = function(scrollable) {
	this.scrollable = scrollable;

	return;
}

UIHtml.prototype.onSetElementStyle = function() {
	var fontSize = Math.floor(this.scaleForCurrentDensity(14));

	this.element.style.fontSize = fontSize + "px";
	this.element.style.marginLeft = "0px";
	this.element.style.marginTop = "0px";
	this.element.style.marginBottom = "0px";
	this.element.style.marginRight = "0px";

	return;
}

UIHtml.prototype.onShowHTML = function() {
	this.reload();
}

UIHtml.prototype.reload = function() {
	if(!this.isInDesignMode()) {
		this.createHTMLElement("div");
		this.element.innerHTML = this.getHtmlContent();
		this.element.style.overflow = this.scrollable ? "scroll" : "hidden";
		this.element.style.zIndex = 5;
		this.element.style["-ms-touch-action"] = "auto";

		this.onSetElementStyle();

		this.beforeShowHTML();
		this.showHTMLElement();
	}

	return;
}

UIHtml.prototype.beforeHideHTML = function() {
}

UIHtml.prototype.onHideHTML = function() {
	this.htmlVisible = false;
	if(this.element) {
		this.beforeHideHTML();
		this.element.style.visibility = 'hidden';
	}

	return;
}

UIHtml.prototype.getValue = function() {
	return this.value;
}

UIHtml.prototype.setValue = function(value) {
	this.value = value;

	return this;
}

UIHtml.prototype.setHtmlContent = function(htmlContent) {
	this.htmlContent = htmlContent;

	if(this.element) {
		this.element.innerHTML = htmlContent;
	}

	return this;
}

UIHtml.prototype.getHtmlContent = function() {
	return this.htmlContent;
}

/**
 * @property {String} innerHTML
 * html content。
 *
 *     @example small frame
 *     this.win.find("html").innerHTML = "hello";
 */
Object.defineProperty(UIElement.prototype, "innerHTML", {
	get: function () {
		return this.getHtmlContent();
	},
	set: function (value) {
		this.setHtmlContent(value);
		this.reload();
	},
	enumerable: false,
	configurable: true
});

function UIHtmlCreator(w, h) {
	var args = ["ui-html", "ui-html", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtml();
		return g.initUIHtml(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlCreator());
/*
 * File:   ui-vedio.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vedio 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIVideo
 * @extends UIElement
 * 主要用于嵌入视频。运行时可以通过setValue设置视频的URL。
 *
 * 注意：CanTK Runtime不支持视频，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 *     @example small frame
 *     var video = win.find("ui-video-general")
 *     video.setValue("http://www.w3school.com.cn/i/movie.ogg");
 *     video.reload();
 */
function UIVideo() {
	return;
}

UIVideo.prototype = new UIHtml();
UIVideo.prototype.isUIVideo = true;

UIVideo.prototype.getHtmlContent = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var src = this.value ? this.value : "";
	var loop = this.loop ? 'loop="loop" ' : "";
	var autoPlay = this.autoPlay ? 'autoplay="true" ' : "";
	var showControls = this.showControls ? 'controls="controls" ' :"";

	var html = '<video width="'+w+'" height="'+h+'" preload="true" '+ showControls + loop + autoPlay + 'src="'+src+'"></video>';

	return html;
}

UIVideo.prototype.beforeHideHTML = function() {
	video = this.getVideoElement();
	if(video.src && !video.puased) {
		video.pause();
	}

	return;
}

UIVideo.prototype.getVideoElement = function() {
	if(this.element) {
		var video = this.element.getElementsByTagName("video");
		return video.length ? video[0] : null;
	}

	return null;
}

UIVideo.prototype.setShowControls = function(value) {
	this.showControls = value;

	return;
}

UIVideo.prototype.isShowControls = function() {
	return this.showControls;
}

UIVideo.prototype.setLoop = function(value) {
	this.loop = value;

	return;
}

UIVideo.prototype.isLoop = function() {
	return this.loop;
}

UIVideo.prototype.setAutoPlay = function(value) {
	this.autoPlay = value;

	return;
}

UIVideo.prototype.isAutoPlay = function() {
	return this.autoPlay;
}

UIVideo.prototype.initUIVideo = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("http://www.w3school.com.cn/i/movie.ogg");
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIVideoCreator() {
	var args = ["ui-video", "ui-video", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVideo();
		return g.initUIVideo(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVideoCreator());

/*
 * File:   ui-flash.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Flash 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIFlash
 * @extends UIElement
 * 主要用于嵌入Flash。运行时可以通过setValue设置Flash的URL。
 *
 * 注意：CanTK Runtime不支持Flash，如果开发在runtime上运行的游戏，请不要使用本控件。
 *
 */
function UIFlash() {
	return;
}

UIFlash.prototype = new UIHtml();
UIFlash.prototype.isUIFlash = true;

UIFlash.prototype.getHtmlContent = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var src = this.value ? this.value : "";

	var html = '<object type="application/x-shockwave-flash" width="'+w+'" height="'+h+'"> <param name="movie" value="'+src+'" /> <param name="quality" value="high" /></object>';

	return html;
}

UIFlash.prototype.initUIFlash = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("test/5.swf");
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIFlashCreator() {
	var args = ["ui-flash", "ui-flash", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFlash();
		return g.initUIFlash(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIFlashCreator());

/*
 * File:   ui-html-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Html Image
 * 
 * Copyright (c) 2015 Tangram HD Inc.
 * 
 */

function UIHtmlImage() {
	return;
}

UIHtmlImage.prototype = new UIHtml();
UIHtmlImage.prototype.isUIHtmlImage = true;

UIHtmlImage.prototype.getHtmlContent = function() {
	var scale = this.getRealScale();
	var w = Math.round(scale * this.w);
	var h = Math.round(scale * this.h);
	var src = this.getImageSrcByType(UIElement.IMAGE_DEFAULT); 
	var str = '<img src="' + src + '" width=' + w + ' height=' + h + '>';

	return str;
}

UIHtmlImage.prototype.initUIHtmlImage = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

function UIHtmlImageCreator() {
	var args = ["ui-html-image", "ui-html-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtmlImage();
		return g.initUIHtmlImage(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlImageCreator());

/*
 * File:   ui-image-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief: Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageView() {
	return;
}

UIImageView.prototype = new UIElement();
UIImageView.prototype.isUIImageView = true;

UIImageView.cachedImages = {};
UIImageView.IMAGE_STATE_PENDING = 0;
UIImageView.IMAGE_STATE_ERROR   = 1;
UIImageView.IMAGE_STATE_DONE    = 2;

imageViewInitCustomProp = function(me) {
}

imageThumbViewInitCustomProp = function(me) {
}

imageAnimationInitCustomProp = function(me) {
}

imageSlideViewInitCustomProp = function(me) {
}


UIImageView.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);
	o.userImages = this.getImages();

	return o;
}

UIImageView.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.cacheInvalid = true;

	if(js.userImages) {
		this.userImages = [];
		var arr = js.userImages.split("\n");

		var n = arr.length;
		for(var i = 0; i < n; i++) {
			var type = "image_" + (i+1);	
			var src = this.getImageSrcByType(type);
			if(src && src.length > 4) {
				this.userImages.push(src);
			}
		}
	}

	return;
}

UIImageView.prototype.initUIImageView = function(w, h) {
	this.setDefSize(w, h);
	this.userImages = [];
	
	this.onSized               = UIImageView.prototype.onSized;
	this.afterRelayout         = UIImageView.prototype.afterRelayout;
	this.setImages             = UIImageView.prototype.setImages;
	this.getImages             = UIImageView.prototype.getImages;
	this.setValue              = UIImageView.prototype.setValue;
	this.getValue              = UIImageView.prototype.getValue;
	this.ensureImages          = UIImageView.prototype.ensureImages;
	this.addUserImage          = UIImageView.prototype.addUserImage;
	this.doToJson              = UIImageView.prototype.doToJson;
	this.doFromJson            = UIImageView.prototype.doFromJson;
	this.onScaleForDensityDone = UIImageView.prototype.onScaleForDensityDone;

	imageViewInitCustomProp(this);

	return this;
}

UIImageView.createImage = function(src, onLoadDone) {
	var image = UIImageView.cachedImages[src];
	
	if(!image) {
		image = new Image();

		image.src = src;
		image.onLoadDoneListeners = [];

		function notifyImageLoadDone(image, result) {
			if(!image || !image.onLoadDoneListeners) {
				return;
			}

			for(var i = 0; i < image.onLoadDoneListeners.length; i++) {
				var onLoad = image.onLoadDoneListeners[i];
			
				onLoad(image, result);
			}

			image.onLoadDoneListeners.clear();

			return;
		}

		image.onload = function(e) {
			notifyImageLoadDone(this, true);
			this.loaded = true;
		}
		
		image.onabort = function(e) {
			notifyImageLoadDone(this, false);	
			this.failed = true;
			console.log("load " + this.src + " failed.");
		}
		
		image.onerror = function(e) {
			notifyImageLoadDone(this, false);	
			this.failed = true;
			console.log("load " + this.src + " failed.");
		}
	}
	else {
		console.log("Create Image From Cache: " + src);
	}

	if(onLoadDone) {
		if(image.loaded) {
			onLoadDone(image, true);
		}
		else if(image.failed) {
			onLoadDone(image, false);
		}
		else {
			image.onLoadDoneListeners.push(onLoadDone);
		}
	}

	return image;
}

UIImageView.drawImageAtCenter = function(ctx, image, x, y, w, h, keepRatio, clearColor) {
	if(clearColor) {
		ctx.fillStyle = clearColor;
		ctx.fillRect(x, y, w, h);
	}
	else {
		ctx.clearRect(x, y, w, h);
	}

	if(image && image.width > 0) {
		var dw = w;
		var dh = h;
		var sw = image.width;
		var sh = image.height;
		var imageW = image.width;
		var imageH = image.height;

		if(keepRatio) {
			var scaleX = dw/imageW;
			var scaleY = dh/imageH;
		
			if(scaleX < scaleY) {
				sw = Math.min(imageW, dw/scaleY);
			}
			else {
				sh = Math.min(imageH, dh/scaleX);
			}
		}

		ctx.drawImage(image, 0, 0, sw, sh, x, y, dw, dh);
	}

	return;
}

UIImageView.prototype.ensureImages = function() {
	if(!this.cacheInvalid) {
		return;
	}

	var imageview = this;
	function onLoadDone(image, result) {
		imageview.postRedraw();

		return;
	}

	this.cachedImages = [];
	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		var image = UIImageView.createImage(src, onLoadDone);

		this.cachedImages.push(image);
	}

	delete this.cacheInvalid;

	return;
}

UIImageView.prototype.afterRelayout = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.onSized = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.onScaleForDensityDone = function() {
	this.cacheInvalid = true;

	return;
}

UIImageView.prototype.addUserImage = function(src) {
	this.cacheInvalid = true;
	this.userImages.push(src);

	var key = "image_" + this.userImages.length;

	this.setImage(key, src);

	return;
}

UIImageView.prototype.getCurrentImage = function() {
	return this.curentImage;
}

UIImageView.prototype.getValue = function() {
	var image = this.getCurrentImage();

	return image ? image.src : null;
}

UIImageView.prototype.setValue = function(value) {
	//TODO
	return this;
}

UIImageView.prototype.setImages = function(srcs) {
	var display = this.images.display;
	var arr = srcs.split("\n");

	this.userImages = [];
	this.images = {};
	this.images.display = display;

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.addUserImage(iter);
		}
	}

	return;
}

UIImageView.prototype.getImages = function() {
	var srcs = "";
	var hostname = location.protocol + "//" + location.host + "/";

	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		src = src.replace(hostname, "");
		srcs = srcs + src + "\n";	
	}

	return srcs;
}
/*
 * File:   ui-scrollview.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

function UIScrollView() {
	return this;
}

UIScrollView.prototype = new UIElement();
UIScrollView.prototype.isUIScrollView = true;

UIScrollView.prototype.afterChildAppended = function(shape) {
	shape.setCanRectSelectable(false, true);

	return true;
}

UIScrollView.prototype.initUIScrollView = function(type, border, bg) {
	this.initUIElement(type);	

	this.offset = 0;
	this.scrollBarOpacity = 0;
	this.setMargin(border, border);
	this.setSizeLimit(100, 100, 2000, 2000);
	this.setDefSize(300 + 2 * border, 300 + 2 * border);

	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator(2);

	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setScrollable("always");

	if(!bg) {
		this.style.setFillColor("#f0f0f0");
	}
	this.setCanRectSelectable(false, true);

	return this;
}

UIScrollView.prototype.setScrollable = function(scrollable) {
	this.scrollable = scrollable;

	return;
}

UIScrollView.prototype.fixChildSize = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.w = this.getWidth(true);
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.h = this.getHeight(true);
	}

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
		child.setUserResizable(false);
	}

	return;
}

UIScrollView.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage 
		|| shape.isUIList || shape.isUIGrid || shape.isUIProgressBar 
		|| shape.isUICheckBox || shape.isUIRadioBox || shape.isUIWaitBar 
		|| shape.isUIButtonGroup || shape.isUITips || shape.isUIGroup) {

		return true;
	}

	return false;
}

UIScrollView.prototype.onModeChanged = function() {
	this.offset = 0;

	return;
}

UIScrollView.prototype.scrollToEnd = function() {
	var range = this.getScrollRange();

	this.offset = range - this.h;

	return this;
}

UIScrollView.prototype.scrollTo = function(offset) {
	this.offset = Math.round(offset);
	
	return;
}

UIScrollView.prototype.scrollDelta = function(delta) {
	var offset = this.offset + delta;
	
	this.scrollTo(offset);

	return;
}

UIScrollView.prototype.scrollToPageDelta = function(pageOffset) {
	var pageIndex = Math.floor(this.offset/this.w) + pageOffset;
	
	this.scrollToPage(pageIndex);

	return;
}

UIScrollView.prototype.scrollToPage = function(pageIndex) {
	if(pageIndex < 0) {
		pageIndex = 0;
	}

	var offset = this.w * pageIndex;
	var distance = this.offset - offset;
	
	this.animScrollTo(distance, 300);

	return;
}

UIScrollView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	this.velocityTracker.clear();

	return;
}

UIScrollView.prototype.onDrag = function(offset) {
	return;
}

UIScrollView.prototype.isScrollable = function() {
	if(this.scrollable === "always") {
		return true;
	}
	else if(this.scrollable === "never") {
		return false;
	}
	else {
		var range = this.getScrollRange();
		var pageSize = this.getPageSize();

		return range > pageSize;
	}
}

UIScrollView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || !this.isScrollable()) {
		return;
	}

	this.scrollBarOpacity = 0;
	var delta = this.getScrollDelta(point);
	if(this.pointerDown && this.needScroll(point)) {
		this.scrollBarOpacity = 1.0;
		this.scrollDelta(-delta);
	}

	this.addMovementForVelocityTracker();
	this.onDrag(this.offset);

	return ;
}

UIScrollView.prototype.animScrollTo = function(distance, duration) {
	var scrollview = this;
	var date  = new Date();
	var startTime = date.getTime();
	var startOffset = this.offset;
	var endOffset = startOffset - distance;
	var range = this.getScrollRange();
	var pageSize = this.getPageSize();

	duration = duration < 400 ? 400 : duration;

	if(endOffset < 0) {
		duration = 600;
		distance = startOffset;
	}

	if(!this.isInDesignMode()) {
		if(endOffset > (range - pageSize)) {
			distance = startOffset - (range - pageSize);
		}
	}
	
	if(range <= pageSize) {
		endOffset = 0;
		distance = startOffset;
	}
	
	function scrollIt() {
		var now = new Date();
		var nowTime = now.getTime();
		var timePercent = (nowTime - startTime)/duration;
		var percent = scrollview.interpolator.get(timePercent);
		var offset = startOffset - distance * Math.min(percent, 1.0);

		if(timePercent < 1 && !scrollview.pointerDown) {
			setTimeout(scrollIt, 5);
			scrollview.scrollTo(offset);
			scrollview.scrollBarOpacity = 1 - percent;
		
		}
		else {
			var offset = startOffset - distance;
			scrollview.scrollBarOpacity = 0;
			scrollview.scrollTo(offset);
		}
		scrollview.postRedraw();

		return;
	}

	setTimeout(scrollIt, 5);

	return;
}

UIScrollView.prototype.whenScrollOutOfRange = function(offset) {
	return;
}

UIScrollView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || !this.isScrollable()) {
		return;
	}

	var delta = this.getScrolledSize();

	if(!this.needScroll(point)) {
		this.scrollBarOpacity = 0;

		return;
	}

	var duration = 0;
	var distance = 0;
	var velocity = this.getVelocity();

	var a = this.getPageSize();
	var t = velocity/a;
	var d = 0.5 * a * t * t;

	distance = Math.abs(d);
	duration = 2*distance/velocity;

	distance = delta < 0 ? -distance : distance;
	duration = Math.abs(duration);

	if(duration > 3) {
		duration = 3;
	}

	var startOffset = this.offset;
	var endOffset = startOffset - distance;
	
	var offset = this.offset;
	var bottom = offset + this.h;
	var range = this.getScrollRange();
	if(offset < 0) {
		this.whenScrollOutOfRange(offset);
	}
	else if(bottom > range) {
		this.whenScrollOutOfRange(bottom-range);
	}

	this.animScrollTo(distance, duration * 1000);

	return true;
}

UIScrollView.prototype.paintSelfOnly =function(canvas) {

	return;
}

/*
 * File:   ui-h-scroll-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Horizonal ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIHScrollView() {
	return;
}

UIHScrollView.prototype = new UIScrollView();
UIHScrollView.prototype.isUIHScrollView = true;

UIHScrollView.prototype.initUIHScrollView = function(type, border, bg) {
	this.initUIScrollView(type, border, bg);	
	this.setSizeLimit(100, 40, 2000, 2000);

	return this;
}

UIHScrollView.prototype.needScroll = function(point) {
	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	return (dx > 20 && dx > dy)  || (dx > 20 && !this.isInDesignMode());
}

UIHScrollView.prototype.getScrolledSize = function() {
	return Math.floor(this.getMoveAbsDeltaX()); 
}

UIHScrollView.prototype.getScrollDelta = function(point) {
	return Math.floor(this.getMoveDeltaX()); 
}

UIHScrollView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().x;
}

UIHScrollView.prototype.getPageSize = function() {
	return this.w;
}

UIHScrollView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	var pageOffset = 0;
	var velocity = this.getVelocity();
	var delta = this.getScrolledSize();
	var absDelta = Math.abs(delta);

	if(absDelta > this.w/4 || velocity > this.w) {
		if(delta < 0) {
			pageOffset = 1;
		}
		else {
			pageOffset = -1;
		}
	}
	
	this.scrollToPageDelta(pageOffset);

	return true;
}

UIHScrollView.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left + this.offset), y : (point.y - this.top)};

	return p;
}

UIHScrollView.prototype.getScrollRange = function() {
	var range = 0;
	var r = this.calcChildrenRange();

	range = r.r - r.l;
	if(range < this.w) {
		 range = this.w;
	}
	range = Math.ceil(range/this.w) * this.w;

	return range;
}

UIHScrollView.prototype.fixChildPosition = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = this.offset + this.hMargin;	
		child.widthAttr = UIElement.WIDTH_SCALE;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = this.vMargin;
	}

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
	}

	return;
}

UIHScrollView.prototype.paintChildren = function(canvas) {
	var shape = null;
	var leftClip = this.offset;
	var rightClip = this.offset + this.w;

	canvas.save();
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.closePath();
	canvas.clip();

	canvas.beginPath();
	canvas.translate(-this.offset, 0);

	for(var i = 0; i < this.children.length; i++) {
		shape = this.children[i];
		if(!shape.visible) {
			continue;
		}
		if((shape.left + shape.w) < leftClip || shape.left > rightClip) {
			continue;
		}
		
		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}
	
	this.paintTargetShape(canvas);
	
	canvas.restore();
	
	return;
}

function UIHScrollViewCreator(border, bg) {
	var args = ["ui-h-scroll-view", "ui-h-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHScrollView();
		return g.initUIHScrollView(this.type, border, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHScrollViewCreator(0, null));

/*
 * File:   ui-v-scroll-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vertical ScrollView
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollView() {
	return;
}

UIVScrollView.prototype = new UIScrollView();
UIVScrollView.prototype.isUIVScrollView = true;

UIVScrollView.prototype.initUIVScrollView = function(type, border, bg, scrollBarImg) {
	this.initUIScrollView(type, border, bg);	
	this.setSizeLimit(40, 100, 2000, 2000);
	this.setImage("scrollBarImg", scrollBarImg);
	this.rectSelectable = false;

	return this;
}


UIVScrollView.prototype.needScroll = function(point) {
	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	return (dy > 50 && dy > dx) || (dy > 50 && !this.isInDesignMode());
}

UIVScrollView.prototype.getScrolledSize = function() {
	return Math.floor(this.getMoveAbsDeltaY()); 
}

UIVScrollView.prototype.getScrollDelta = function(point) {
	return Math.floor(this.getMoveDeltaY());
}

UIVScrollView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().y;
}

UIVScrollView.prototype.getPageSize = function() {
	return this.h;
}

UIVScrollView.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left), y : (point.y - this.top + this.offset)};

	return p;
}

UIVScrollView.prototype.getScrollRange = function() {
	var range = 0;
	var r = this.calcChildrenRange();

	range = r.b;
	if(range < this.h) {
		 range = this.h;
	}

	var n = (this.isInDesignMode()) ? this.h : 10;

	range = Math.ceil(range/n) * n;

	return range;
}

UIVScrollView.prototype.fixChildPosition = function(child) {
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = this.hMargin;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = this.offset + this.vMargin;
		child.heightAttr = UIElement.HEIGHT_SCALE;
	}
	
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT && child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.setUserMovable(false);
	}

	return;
}

UIVScrollView.prototype.paintChildren = function(canvas) {
	var shape = null;
	var upClip = this.offset;
	var downClip = this.offset + this.h;

	canvas.save();
	canvas.beginPath();
	canvas.rect(this.getHMargin(), this.getVMargin(), this.getWidth(true), this.getHeight(true));
	canvas.closePath();
	canvas.clip();

	canvas.beginPath();
	canvas.translate(0, -this.offset);

	for(var i = 0; i < this.children.length; i++) {
		shape = this.children[i];
		if(!shape.visible) {
			continue;
		}
		if((shape.top + shape.h) < upClip || shape.top > downClip) {
			continue;
		}

		this.beforePaintChild(shape, canvas);
		shape.paintSelf(canvas);
		this.afterPaintChild(shape, canvas);
	}
	
	this.paintTargetShape(canvas);

	canvas.restore();
	
	return;
}

UIVScrollView.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);

	return;
}

UIVScrollView.prototype.drawScrollBar = function(canvas) {
	var image = this.getHtmlImageByType("scrollBarImg");

	if(!this.scrollBarOpacity || !image) {
		return;
	}

	var range = this.getScrollRange();
	var x = this.w - image.width - 2;
	var w = image.width;
	var h = this.h * this.h/range;
	var y = (this.offset / range) * this.h;

	if((y + h) > this.h) {
		h = this.h - y;
		y = this.h - h;
	}
	
	if(y < 0) {
		h = h + y;
		y = 0;
	}

	canvas.save();
	canvas.globalAlpha = this.scrollBarOpacity;
	drawNinePatchEx(canvas, image, 0, 0, image.width, image.height, x, y, w, h);
	canvas.restore();

	return;
}

function UIVScrollViewCreator(border, bg, scrollBarImg) {
	var args = ["ui-v-scroll-view", "ui-v-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollView();
		return g.initUIVScrollView(this.type, border, bg, scrollBarImg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVScrollViewCreator(0, null, null));

/*
 * File:   ui-list-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List View (Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollViewGeneral() {
	return;
}

UIVScrollViewGeneral.prototype = new UIVScrollView();
UIVScrollViewGeneral.prototype.isUIList = true;
UIVScrollViewGeneral.prototype.isUILayout = true;
UIVScrollViewGeneral.prototype.isUIVScrollViewGeneral = true;
UIVScrollViewGeneral.prototype.sortChildren = UIList.prototype.sortChildren;

UIVScrollViewGeneral.prototype.initUIVScrollViewGeneral = function(type) {
	this.initUIVScrollView(type, 0, null, null);	
	this.setTextType(Shape.TEXT_NONE);

	return this;
}

UIVScrollViewGeneral.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}
	var border = this.getVMargin();
	var n = this.children.length;
	
	var y = border;
	for(var i = 0; i < n; i++) {
		var child = this.children[i];
		if(!child.visible) {
			continue;
		}
		
		child.yAttr = UIElement.Y_FIX_TOP;
		child.heightAttr = UIElement.HEIGHT_FIX;
		child.relayout();
		child.top = y;
		
		y += child.h;
	}

	return;
}

UIVScrollViewGeneral.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);
	
	if(this.isInDesignMode()) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIVScrollViewGeneralCreator() {
	var args = ["ui-g-scroll-view", "ui-g-scroll-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollViewGeneral();
		return g.initUIVScrollViewGeneral(this.type);
	}
	
	return;
}

/*
 * File:   ui-scroll-view-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scroll View X 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIScrollViewX
 * @extends UIElement
 * 滚动视图。使用时先设置虚拟高度和宽度，虚拟高度小于实际高度时，上下不滚动，虚拟宽度小于实际宽度时，左右不滚动。
 *
 * 在IDE中，拖动滚动视图是改变滚动视图的可视区，要拖动滚动视图本身请使用滚动视图下方的拖动手柄，或者使用方向键，或者直接修改它的坐标。
 *
 * 往滚动视图中添加子控件时，先将控件放到滚动视图的可视区，然后拖动到其它区域。
 */
function UIScrollViewX() {
	return;
}

UIScrollViewX.prototype = new UIElement();
UIScrollViewX.prototype.isUIScrollViewX = true;
UIScrollViewX.prototype.isUIScrollView = true;
UIScrollViewX.prototype.saveProps = ["virtualWidth", "virtualHeight", "showOutside", "maxAnimationDuration", "scrollBgImage"];

UIScrollViewX.prototype.initUIScrollViewX = function(type) {
	this.initUIElement(type);

	this.ox = 0;
	this.oy = 0;
	this.xDragLimit = 0.3;
	this.yDragLimit = 0.3;
	this.scrollBarOpacity = 0;
	this.maxAnimationDuration = 10000;
	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator(2);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_V_SCROLL_BAR_BG, null);
	this.setImage(UIElement.IMAGE_V_SCROLL_BAR_FG, null);
	this.setImage(UIElement.IMAGE_H_SCROLL_BAR_BG, null);
	this.setImage(UIElement.IMAGE_H_SCROLL_BAR_FG, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.addEventNames(["onScrolling", "onScrollDone"]);

	return this;
}

UIScrollViewX.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

/**
 * @property {Number} virtualWidth 
 * 虚拟宽度。  
 */

/**
 * @property {Number} virtualHeight
 * 虚拟高度。  
 */

/**
 * @property {Number} xOffset 
 * X方向偏移量。  
 */

/**
 * @property {Number} yOffset 
 * X方向偏移量。  
 */

UIScrollViewX.prototype.setVirtualWidth = function(virtualWidth) {
	this.vw = virtualWidth;
	return this; 
}

UIScrollViewX.prototype.setVirtualHeight = function(virtualHeight) {
	this.vh = virtualHeight;
	return this;
}

UIScrollViewX.prototype.getVirtualWidth = function() {
	return Math.max(this.vw, this.w);
}

UIScrollViewX.prototype.getVirtualHeight = function() {
	return Math.max(this.vh, this.h);
}

UIScrollViewX.prototype.getXOffset = function() {
	return this.ox;
}

UIScrollViewX.prototype.getYOffset = function() {
	return this.oy;
}

UIScrollViewX.prototype.fixXOffset = function(xOffset) {
	return Math.min(Math.max(0, xOffset), this.getVirtualWidth()-this.w) >> 0;
}

UIScrollViewX.prototype.fixYOffset = function(yOffset) {
	return Math.min(Math.max(0, yOffset), this.getVirtualHeight()-this.h) >> 0;
}

UIScrollViewX.prototype.setXOffset = function(xOffset) {
	this.ox = this.fixXOffset(xOffset);

	return this;
}

UIScrollViewX.prototype.setYOffset = function(yOffset) {
	this.oy = this.fixYOffset(yOffset);

	return this;
}

UIScrollViewX.prototype.setDragLimit = function(xDragLimit, yDragLimit) {
	this.xDragLimit = xDragLimit;
	this.yDragLimit = yDragLimit;

	return this;
}

UIScrollViewX.prototype.setOffset = function(xOffset, yOffset, noCheck) {
	if(noCheck) {
		var factor = 0;
		var ox = xOffset >> 0;
		var oy = yOffset >> 0;
		var xDragLimit = this.xDragLimit > 1 ? this.xDragLimit : this.xDragLimit * this.w;
		var yDragLimit = this.yDragLimit > 1 ? this.yDragLimit : this.yDragLimit * this.h; 

		if(ox < -xDragLimit) {
			ox = -xDragLimit;
		}else if((this.vw - ox) < (this.w - xDragLimit)) {
			ox = Math.max(0, this.vw - (this.w - xDragLimit));
		}
	
		if(oy < -yDragLimit) {
			oy = -yDragLimit;
		}else if((this.vh - oy) < (this.h - yDragLimit)) {
			oy = Math.max(0, this.vh - (this.h - yDragLimit));
		}
		this.ox = ox;
		this.oy = oy;
	}else{
		this.setXOffset(xOffset);
		this.setYOffset(yOffset);
	}
	this.callOnScrollingHandler(this.ox, this.oy);

	return this;
}

Object.defineProperty(UIScrollViewX.prototype, "xOffset", {get:UIScrollViewX.prototype.getXOffset, set:UIScrollViewX.prototype.setXOffset});
Object.defineProperty(UIScrollViewX.prototype, "yOffset", {get:UIScrollViewX.prototype.getYOffset, set:UIScrollViewX.prototype.setYOffset});
Object.defineProperty(UIScrollViewX.prototype, "virtualWidth", 
	{get:UIScrollViewX.prototype.getVirtualWidth, set:UIScrollViewX.prototype.setVirtualWidth});
Object.defineProperty(UIScrollViewX.prototype, "virtualHeight", 
	{get:UIScrollViewX.prototype.getVirtualHeight, set:UIScrollViewX.prototype.setVirtualHeight});

UIScrollViewX.prototype.dragStart = function() {
	this.saveOX = this.ox;
	this.saveOY = this.oy;

	this.velocityTracker.clear();
}

UIScrollViewX.prototype.drag = function() {
	this.addMovementForVelocityTracker();
	var ox = this.saveOX - this.getMoveAbsDeltaX();
	var oy = this.saveOY - this.getMoveAbsDeltaY();

	if(this.getVirtualWidth() <= this.w) {
		ox = 0;
	}
	else if(!UIElement.hScrollHandledBy){
		UIElement.hScrollHandledBy = this;
	}

	if(UIElement.hScrollHandledBy !== this) {
		ox = 0;
	}

	if(this.getVirtualHeight() <= this.h) {
		oy = 0;
	}
	else if(!UIElement.vScrollHandledBy) {
		UIElement.vScrollHandledBy = this;
	}
	
	if(UIElement.vScrollHandledBy !== this) {
		oy = 0;
	}

	if(ox || oy) {
		this.setOffset(ox, oy, true);
	}

	return;
}

UIScrollViewX.prototype.getScrollDuration = function(velocity) {
    //t = 2*v / a 
    var duration = Math.max(Math.abs(velocity.x), Math.abs(velocity.y)) * 2 / 2;
    
    return Math.min(duration, this.maxAnimationDuration);
}

UIScrollViewX.prototype.dragEnd = function() {
	var velocity = this.velocityTracker.getVelocity();
   	
    var duration = this.getScrollDuration(velocity);

    if(!duration || duration < 10) {
		return;
	}

	var t = duration/1000;
	var vx = velocity.x;
	var vy = velocity.y;

	if(UIElement.hScrollHandledBy && UIElement.hScrollHandledBy !== this) {
		vx = 0;
	}
	if(UIElement.hScrollHandledBy && UIElement.vScrollHandledBy !== this) {
		vy = 0;
	}

	var xd = 0.5 * vx * t;
	var yd = 0.5 * vy * t;
	var xs = this.ox;
	var ys = this.oy;
	var xe = Math.min(Math.max(0, xs - xd), this.virtualWidth  - this.w);
	var ye = Math.min(Math.max(0, ys - yd), this.virtualHeight - this.h);

    var cross = this.ox < 0 || this.oy < 0 
        || this.ox + this.w > this.virtualWidth 
        || this.oy + this.h > this.virtualHeight;
	
    if(!cross && Math.abs(xd) < 10 && Math.abs(yd) < 10) {
		this.callOnScrollDoneHandler(this.ox, this.oy);
		return;
	}

	this.scrollTo(xe, ye, duration);

	return;
}

/**
 * @method scrollToPercent
 * 滚动到指定位置。
 * @param {Number} xOffsetPercent X方向偏移量百分比(0,100)。
 * @param {Number} yOffsetPercent Y方向偏移量百分比(0,100)。
 * @param {Number} duration 滚动时间(毫秒)。
 * @return {UIElement} 返回控件本身。
 */
UIScrollViewX.prototype.scrollToPercent = function(xOffsetPercent, yOffsetPercent, duration) {
	var xOffset = (this.virtualWidth - this.w) * (xOffsetPercent/100);
	var yOffset = (this.virtualHeight - this.h) * (yOffsetPercent/100);

	return this.scrollTo(xOffset, yOffset, duration);
}

/**
 * @event onScrolling
 * 滚动事件。
 * @param {Number} xOffset x偏移量。
 * @param {Number} yOffset y偏移量。
 */

/**
 * @event onScrollDone
 * 滚动完成事件。
 * @param {Number} xOffset x偏移量。
 * @param {Number} yOffset y偏移量。
 */

/**
 * @method scrollTo
 * 滚动到指定位置。
 * @param {Number} xOffset X方向偏移量。
 * @param {Number} yOffset Y方向偏移量。
 * @param {Number} duration 滚动时间(毫秒)。
 * @return {UIElement} 返回控件本身。
 */
UIScrollViewX.prototype.scrollTo = function(xOffset, yOffset, duration) {
	var xs = this.ox;
	var ys = this.oy;
	var xe = this.fixXOffset(xOffset);
	var ye = this.fixYOffset(yOffset);
	
	var xd = xe - xs;
	var yd = ye - ys;
	if(!duration || (!xd && !yd)) {
		this.setOffset(xOffset, yOffset);
		this.callOnScrollDoneHandler(this.ox, this.oy);

		return this;
	}

	var startTime = Date.now();
	function step(now) {
		var tPercent = (now - startTime)/duration;
		if(tPercent >= 1) {
			tPercent = 1;
			this.setStepScroll(null);
		}
		if(this.pointerDown) {
			this.setStepScroll(null);
		}

		var percent = this.interpolator.get(tPercent);
		var ox = xs + xd * percent;
		var oy = ys + yd * percent;
		this.setOffset(ox, oy, true);
		this.scrollBarOpacity = 1 - percent;

		if(tPercent >= 1) {
			this.callOnScrollDoneHandler(this.ox, this.oy);
		}
	}

	this.setStepScroll(step);

	return this;
}

UIScrollViewX.prototype.setStepScroll = function(stepScroll) {
	this.stepScroll = stepScroll;

	return this;
}

UIScrollViewX.prototype.stepAnimation = function(canvas, now) {
	UIElement.prototype.stepAnimation.call(this, canvas, now);
	if(this.stepScroll) {
		this.stepScroll(now || canvas.now || Date.now());
		this.postRedraw();
	}

	return this;
}

UIScrollViewX.prototype.isDraggable = function() {
	if(this.isInDesignMode()) {
		if(this.hitTestResult !== UIElement.HIT_TEST_MM) {
			return false;
		}

		return !this.getTarget() || this.view.isAltDown();
	}
	else {
		return true;
	}
}

UIScrollViewX.prototype.onPointerDownRunning = UIScrollViewX.prototype.onPointerDownEditing = function(point, beforeChild) {
	this.scrollBarOpacity = 1;
	if(!beforeChild && this.isDraggable()) {
		this.dragStart();
		return true;
	}
	return false;
}

UIScrollViewX.prototype.onPointerMoveRunning = UIScrollViewX.prototype.onPointerMoveEditing = function(point, beforeChild) {
	if(!beforeChild && this.pointerDown && this.isDraggable()){ 
		this.drag();
		return true;
	}
	return false;
}

UIScrollViewX.prototype.onPointerUpRunning = UIScrollViewX.prototype.onPointerUpEditing = function(point, beforeChild) {
	if(!beforeChild && this.pointerDown && this.isDraggable()) {
		this.dragEnd();
		return true;
	}
	this.scrollBarOpacity = 0;

	return false;
}

UIScrollViewX.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left + this.xOffset), y : (point.y - this.top + this.yOffset)};

	return p;
}

UIScrollViewX.prototype.onClip = function(canvas) {
	if(this.showOutside && this.isInDesignMode()) {
		return this;
	}

	canvas.clipRect(0, 0, this.w, this.h);

	return this;
}

UIScrollViewX.prototype.isChildVisibleRecursive = function(child) {
	if(child.children && child.children.length) {
		return true;
	}

	return false;
}

UIScrollViewX.prototype.isChildVisible = function(canvas, child) {
	var l = this.ox;
	var r = l + this.w;
	var t = this.oy;
	var b = t + this.h;

	if(!child.visible) {
		return false;
	}
	
	if(this.showOutside && this.isInDesignMode()) {
		return true;
	}

	if(this.isChildVisibleRecursive(child)) {
		return true;
	}

	if((child.top + child.h) < t || child.top > b || (child.left + child.w) < l || child.left > r) {
		return false;
	}

	return true;
}

UIScrollViewX.prototype.paintChildren = function(canvas) {
	var l = this.ox;
	var t = this.oy;
	var children = this.children;
	var n = children.length;

	canvas.save();
	canvas.translate(-l, -t);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(this.isChildVisible(canvas, iter)) {
			this.beforePaintChild(iter, canvas);
			iter.paintSelf(canvas);
			this.afterPaintChild(iter, canvas);
		}
	}
	canvas.restore();
	this.drawScrollBar(canvas);
	
	return;
}

UIScrollViewX.prototype.dispatchPointerDownToChildren = function(p) {
	if(!this.hitTestResult && !this.showOutside) {
		return false;
	}

	if(this.isInDesignMode() && this.view.isAltDown()) {
		return false;
	}

	return this.defaultDispatchPointerDownToChildren(p);
}

function UIScrollViewXCreator() {
	var args = ["ui-scroll-view-x", "ui-scroll-view-x", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScrollViewX();
		return g.initUIScrollViewX(this.type);
	}
	
	return;
}

UIScrollViewX.prototype.drawBgImageScroll = function(canvas, display, image, rect) {
	switch(display) {
		case WImage.DISPLAY_SCALE: {
			var scaleX = rect.w/this.virtualWidth;
			var scaleY = rect.h/this.virtualHeight;
			var sx = this.xOffset * scaleX;
			var sy = this.yOffset * scaleY;
			var sw = this.w * scaleX;
			var sh = this.h * scaleY;
		
			canvas.drawImage(image, sx, sy, sw, sh, 0, 0, this.w, this.h);
			break;
		}
		case WImage.DISPLAY_TILE: {
			var dx = Math.floor(this.xOffset/rect.w) * rect.w - this.xOffset;
			var dy = Math.floor(this.yOffset/rect.h) * rect.h - this.yOffset
			var dw = Math.ceil((this.w - dx)/rect.w) * rect.w;
			var dh = Math.ceil((this.h - dy)/rect.h) * rect.h;
			
			canvas.save();
			canvas.clipRect(0, 0, this.w, this.h);
			WImage.draw(canvas, image, display, dx, dy, dw, dh, rect);
			canvas.restore();
			break;
		}
		default:break;
	}

	return this;
}

UIScrollViewX.prototype.afterChildAppended = function(shape) {
	shape.xAttr		= UIElement.X_FIX_LEFT;
	shape.yAttr		= UIElement.Y_FIX_TOP;
	shape.widthAttr	= UIElement.WIDTH_FIX;
	shape.heightAttr= UIElement.HEIGHT_FIX;

	if(this.isUILayout) {
		this.relayoutChildren();
	}

	return true;
}

UIScrollViewX.prototype.drawBgImage = function(canvas) {
	if(this.scrollBgImage) {
		var wImage = this.getBgImage();
		if(wImage) {
			var image = wImage.getImage();
			var rect = wImage.getImageRect();
			if(image && rect) {
				this.drawBgImageScroll(canvas, this.images.display, image, rect);
			}
		}
	}
	else {
		UIElement.prototype.drawBgImage.call(this, canvas);
	}
}

UIScrollViewX.prototype.drawVScrollBar = function(canvas) {
	var x = 0;
	var y = 0;
	var w = 0;
	var h = 0;
	var rect = null;
	var image = null;
	
	var bg = this.getImageByType(UIElement.IMAGE_V_SCROLL_BAR_BG);
	var image = bg ? bg.getImage() : null;
	if(image) {
		rect = bg.getImageRect();
		w = rect.rw || rect.w;
		x = this.w - w;
		y = 0;
		h = this.h;

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_3PATCH_V, x, y, w, h);
	}

	var fg = this.getImageByType(UIElement.IMAGE_V_SCROLL_BAR_FG);
	var image = fg ? fg.getImage() : null;
	if(image) {
		rect = fg.getImageRect();
		w = rect.rw || rect.w;
		x = this.w - w;
		y = this.h * (this.yOffset/this.virtualHeight);
		h = this.h * (this.h/this.virtualHeight);
		if(y < 0) {
			h = Math.max(10, h + y);
			y = 0;
		}

		if((y + h) > this.h) {
			h = Math.max(10, this.h - y);
			y = this.h - h;
		}

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_3PATCH_V, x, y, w, h);
	}

	return;
}

UIScrollViewX.prototype.drawHScrollBar = function(canvas) {
	var x = 0;
	var y = 0;
	var w = 0;
	var h = 0;
	var rect = null;
	var image = null;
	
	var bg = this.getImageByType(UIElement.IMAGE_H_SCROLL_BAR_BG);
	var image = bg ? bg.getImage() : null;
	if(image) {
		rect = bg.getImageRect();
		x = 0;
		w = this.w;
		h = rect.rh || rect.h;
		y = this.h - h;

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_3PATCH_H, x, y, w, h);
	}

	var fg = this.getImageByType(UIElement.IMAGE_H_SCROLL_BAR_FG);
	var image = fg ? fg.getImage() : null;
	if(image) {
		rect = fg.getImageRect();
		h = rect.rh || rect.h;
		y = this.h - h;
		x = this.w * (this.xOffset/this.virtualWidth);
		w = this.w * (this.w/this.virtualWidth);
		if(x < 0) {
			w = Math.max(10, w + x);
			x = 0;
		}

		if((x + w) > this.w) {
			w = Math.max(10, this.w - x);
			x = this.w - w;
		}

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_3PATCH_H, x, y, w, h);
	}
}

UIScrollViewX.prototype.drawScrollBar = function(canvas) {
	if(this.scrollBarOpacity < 0.0001) {
		return this;
	}
	
	canvas.save();
	canvas.globalAlpha = this.scrollBarOpacity;
	if(this.w < this.virtualWidth) {
		this.drawHScrollBar(canvas);
	}
	
	if(this.h < this.virtualHeight) {
		this.drawVScrollBar(canvas);
	}
	canvas.restore();

	return this;
}

ShapeFactoryGet().addShapeCreator(new UIScrollViewXCreator());

/*
 * File:   ui-grid-view-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  GridView
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGridViewX
 * @extends UIScrollViewX
 * 网格视图，里面的子控件按行列排列，每个子控件大小相同。可以水平滚动，也可以垂直滚动。
 * 
 * 设计时按住Alt可以拖动可视区，调节子控件的zIndex可以设置子控件的顺序。
 *
 */
function UIGridViewX() {
	return;
}

UIGridViewX.prototype = new UIScrollViewX();
UIGridViewX.prototype.isUILayout = true;
UIGridViewX.prototype.isUIGridViewX = true;
UIGridViewX.prototype.saveProps = UIScrollViewX.prototype.saveProps.concat(["cols","rows","isVertical"]);

UIGridViewX.prototype.initUIGridViewX = function(type) {
	this.initUIScrollViewX(type);	

	this.rows = 3;
	this.cols = 3;
	this.setMargin(0, 0);
	this.setDefSize(200, 200);

	return this;
}

/**
 * @method setVertical
 * 设置网格视图的滚动方向。
 * @param {Boolean} value true表示垂直滚动，false表示水平滚动。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setVertical = function(value) {
	this.isVertical = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getVertical
 * 获取网格视图的滚动方向。
 * @return {Boolean} 滚动方向。true表示垂直滚动，false表示水平滚动。
 *
 */
UIGridViewX.prototype.getVertical = function() {
	return this.isVertical;
}

/**
 * @method setRows
 * 设置可视区行数，主要用于控制行高。对于水平滚动的网格视图，这个行数与实际行数一致，对于垂直滚动的网格视图，这个行数与实际行数无关。
 * @param {Number} value 行数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setRows = function(value) {
	this.rows = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getRows
 * 获取行数。
 * @return {Number} 返回行数。
 *
 */
UIGridViewX.prototype.getRows = function() {
	return this.rows;
}

/**
 * @method setCols
 * 设置可视区列数，主要用于控制列宽。对于垂直滚动的网格视图，这个列数与实际列数一致，对于水平滚动的网格视图，这个列数与实际列数无关。
 * @param {Number} value 列数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGridViewX.prototype.setCols = function(value) {
	this.cols = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getCols
 * 获取列数。
 * @return {Number} 返回列数。
 *
 */
UIGridViewX.prototype.getCols = function() {
	return this.cols;
}

UIGridViewX.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

UIGridViewX.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var cols = this.cols;
	var rows = this.rows;
	var iw = this.w/cols;
	var ih = this.h/rows;

	var r = 0;
	var c = 0;
	var arr = this.children;
	var n = arr.length;
	var spacer = this.spacer;
	var iws = iw + spacer;
	var ihs = ih + spacer;

	var vi = 0;
	for(var i = 0; i < n; i++) {
		var iter = arr[i];
		if(!iter.visible) {
			continue;
		}

		if(this.isVertical) {
			c = vi%cols;
			r = Math.floor(vi/cols);
		}
		else {
			r = vi%rows;
			c = Math.floor(vi/rows);
		}
		iter.left = c * iws;
		iter.top = r * ihs;
		iter.w = iw;
		iter.h = ih;
		iter.setUserMovable(false);
		iter.setUserResizable(false);

		vi++;
	}

	if(this.isVertical) {
		this.vw = this.w;
		this.vh = Math.ceil(n/this.cols) * ihs;
		if(this.isInDesignMode()) {
			this.vh += ihs;
		}
	}
	else {
		this.vh = this.h;
		this.vw = Math.ceil(n/this.rows) * iws;
		if(this.isInDesignMode()) {
			this.vw += iws;
		}
	}
    if(this.xOffset + this.w > this.vw) {
        this.xOffset = this.vw - this.w;
    }
    if(this.yOffset + this.h > this.vh) {
        this.yOffset = this.vh - this.h;
    }
	
    return;
}

UIGridViewX.prototype.isChildVisibleRecursive = function(child) {
	return false;
}

UIGridViewX.prototype.isDraggable = function() {
	if(this.isInDesignMode()) {
		if(this.hitTestResult !== Shape.HIT_TEST_MM) {
			return false;
		}

		var target = this.getTarget();
		return !target || !target.getTarget() || this.view.isAltDown();
	}
	else {
		return true;
	}
}

function UIGridViewXCreator(border) {
	var args = ["ui-grid-view-x", "ui-grid-view-x", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGridViewX();
		return g.initUIGridViewX(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridViewXCreator());

/*
 * File:   ui-list-view-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  ListView
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIListViewX
 * @extends UIScrollViewX
 * 列表视图，可以水平滚动，也可以垂直滚动。
 *
 * 垂直的列表视图和只有一列垂直的网格视图相似，只是列表视图的单项itemSize为0时，里面的子控件可以具有不同的高度。
 * 水平的列表视图和只有一行水平的网格视图相似，只是列表视图的单项itemSize为0时，里面的子控件可以具有不同的宽度。
 * 
 * 设计时按住Alt可以拖动可视区，调节子控件的zIndex可以设置子控件的顺序。
 *
 */
function UIListViewX() {
	return;
}

UIListViewX.prototype = new UIScrollViewX();
UIListViewX.prototype.isUILayout = true;
UIListViewX.prototype.isUIListViewX = true;
UIListViewX.prototype.saveProps = UIScrollViewX.prototype.saveProps.concat(["cols","rows","isVertical", "itemSize"]);

UIListViewX.prototype.initUIListViewX = function(type) {
	this.initUIScrollViewX(type);	

	this.itemSize = 100;
	this.setMargin(0, 0);
	this.setDefSize(200, 200);

	return this;
}

/**
 * @method setVertical
 * 设置网格视图的滚动方向。
 * @param {Boolean} value true表示垂直滚动，false表示水平滚动。
 * @return {UIElement} 返回控件本身。
 *
 */
UIListViewX.prototype.setVertical = function(value) {
	this.isVertical = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getVertical
 * 获取网格视图的滚动方向。
 * @return {Boolean} 滚动方向。true表示垂直滚动，false表示水平滚动。
 *
 */
UIListViewX.prototype.getVertical = function() {
	return this.isVertical;
}

/**
 * @method setItemSize
 * 设置子控件的大小。
 *
 * 列表视图为垂直方向时，指单项的高度，0表示使用子控件原来的高度，否则使用指定的高度。
 *
 * 列表视图为水平方向时，指单项的宽度，0表示使用子控件原来的宽度，否则使用指定的宽度。
 *
 * @param {Number} value 设置子控件的大小。
 * @return {UIElement} 返回控件本身。
 *
 */
UIListViewX.prototype.setItemSize = function(value) {
	this.itemSize = value;
	this.relayoutChildren();

	return this;
}

/**
 * @method getItemSize
 * 
 * @return {UIElement} 返回单项的高度(垂直)或宽度(水平)。
 *
 */
UIListViewX.prototype.getItemSize = function() {
	return this.itemSize;
}

UIListViewX.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;
UIListViewX.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var arr = this.children;
	var n = arr.length;
	var spacer = this.spacer || 0;
	var itemSize = this.itemSize;
	var x = 0;
	var y = 0;
	var w = this.w;
	var h = this.h;

	for(var i = 0; i < n; i++) {
		var iter = arr[i];
		if(!iter.visible) {
			continue;
		}

		if(this.isVertical) {
			iter.left = 0;
			iter.w = w;
			iter.h = itemSize || iter.h;
			iter.y = y;
			y += iter.h + spacer;
		}
		else {
			iter.top = 0;
			iter.h = h;
			iter.w = itemSize || iter.w;
			iter.x = x;
			x += iter.w + spacer;
		}
		iter.setUserMovable(false);
		iter.setUserResizable(false);
	}

	if(this.isVertical) {
		this.vw = this.w;
		this.vh = y;
		if(this.isInDesignMode()) {
			this.vh += itemSize || 80;
		}
	}
	else {
		this.vh = this.h;
		this.vw = x;
		if(this.isInDesignMode()) {
			this.vw += itemSize || 80;
		}
	}

	this.xOffset = 0;
	this.yOffset = 0;

	return;
}

UIListViewX.prototype.isChildVisibleRecursive = function(child) {
	return false;
}

UIListViewX.prototype.isDraggable = function() {
	if(this.isInDesignMode()) {
		if(this.hitTestResult !== Shape.HIT_TEST_MM) {
			return false;
		}

		var target = this.getTarget();
		return !target || !target.getTarget() || this.view.isAltDown();
	}
	else {
		return true;
	}
}

function UIListViewXCreator(border) {
	var args = ["ui-list-view-x", "ui-list-view-x", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListViewX();
		return g.initUIListViewX(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListViewXCreator());

/*
 * File:   ui-shortcut.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  ShortCut 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIShortcut() {
	return;
}

UIShortcut.prototype = new UIElement();
UIShortcut.prototype.isUIShortcut = true;

UIShortcut.prototype.initUIShortcut = function(type) {
	this.initUIElement(type);	

	this.setText("#ABCDEFGHIJKLMNOPQRSTUVYWXYZ");
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIShortcut.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIShortcut.prototype.drawText = function(canvas) {
	var text = this.text;
	var n = text.length;

	if(!n) {
		return;
	}

	canvas.textBaseline = "middle";
	canvas.textAlign = "center";
	canvas.font = this.style.getFont();

	var x = this.w >> 1;
	var y = this.vMargin;
	var w = this.getWidth(true);

	var ih = this.getHeight(true)/n;
	var ihh = ih >> 1;

	canvas.lineWidth = this.style.lineWidth;
	canvas.strokeStyle = this.style.lineColor;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];

		if(this.currentItem === i) {
			canvas.rect(0, y, this.w, ih);
			if(this.pointerDown) {
				canvas.fillStyle = this.style.fillColor;
				canvas.fill();
			}
			
			canvas.stroke();
		}

		canvas.fillStyle = this.style.textColor;
		canvas.fillText(c, x, y + ihh);

		y += ih;
	}

	return;
}

UIShortcut.prototype.findItemByPoint = function(point) {
	var text = this.text;
	var vMargin = this.vMargin;
	var h = this.getHeight(true);
	var index = Math.floor(text.length * (point.y-vMargin)/h);

	return index;
}

UIShortcut.prototype.changeItemByPoint = function(point) {
	var text = this.text;
	var index = this.findItemByPoint(point);

	if(index >= 0 && index < text.length) {
		var value = text[index];

		if(this.currentItem != index) {
			this.callOnChangedHandler(value);
			this.currentItem = index;
		}
	}

	return;
}

UIShortcut.prototype.setValue = function(value) {
	var index = this.text.indexOf(value);
	if(index >= 0) {
		if(this.currentItem != index) {
			this.currentItem = index;
			this.callOnChangedHandler(value);
		}
	}

	return;
}

UIShortcut.prototype.getValue = function() {
	if(this.text && this.currentItem >= 0 && this.currentItem < this.text.length) {
		return this.text[this.currentItem];
	}
	else {
		return "";
	}
}

UIShortcut.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || !this.text) {
		return;
	}

	this.changeItemByPoint(point);

	return;
}

UIShortcut.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || !this.text) {
		return;
	}

	if(this.pointerDown) {
		this.changeItemByPoint(point);
	}

	return;
}

function UIShortcutCreator() {
	var args = ["ui-shortcut", "ui-shortcut", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIShortcut();
		return g.initUIShortcut(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIShortcutCreator());

/*
 * File:   ui-scroll-text.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scroll Text
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIScrollText() {
	return;
}

UIScrollText.prototype = new UIElement();
UIScrollText.prototype.isUIScrollText = true;

UIScrollText.prototype.initUIScrollText = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onScrollDone"]);

	return this;
}

UIScrollText.prototype.onModeChanged = function() {
	this.offsetX = 0;
	this.offsetY = 0;

	return;
}

UIScrollText.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIScrollText.prototype.getAnimationDuration = function() {
	return this.animationDuration ? this.animationDuration : 1000;
}

UIScrollText.prototype.setAnimationDuration = function(animationDuration) {
	this.animationDuration = animationDuration;

	return;
}

UIScrollText.prototype.getPauseDuration = function() {
	return this.pauseDuration ? this.pauseDuration : 0;
}

UIScrollText.prototype.setPauseDuration = function(pauseDuration) {
	this.pauseDuration = pauseDuration;

	return;
}

UIScrollText.prototype.startVScroll = function() {
	var scrolltext = this;
	var textHeight = this.getTextHeight();
	var lineHeight = this.getLineHeight(true);

	if(textHeight <= this.h) {
		return;
	}

	this.offsetX = 0;
	this.offsetY = 0;
	var startTime = 0;
	var startOffset = 0;
	var duration = this.getAnimationDuration();
	var pauseDuration = this.getPauseDuration();
	this.h = Math.floor(this.h/lineHeight) * lineHeight;

	var range = -this.h;
	var firstTime = true;
	var interpolator =  new DecelerateInterpolator();

	function animStep() {
		if(firstTime) {
			firstTime = false;
			startTime = (new Date()).getTime();
		}

		if(!scrolltext.isVisible()) {
			return;
		}
	
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = pauseDuration > 0 ? interpolator.get(timePercent) : timePercent;
		delete now;

		if(timePercent < 1) {
			scrolltext.offsetY = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			scrolltext.offsetY = startOffset + range;

			if(Math.abs(scrolltext.offsetY) < (textHeight-scrolltext.h)) {
				firstTime = true;

				startOffset = scrolltext.offsetY;
				setTimeout(animStep, pauseDuration);
			}
			else {
				delete interpolator;
				scrolltext.callOnScrollDoneHandler();
			}

			delete startTime;
		}

		delete now;
		scrolltext.postRedraw();
	}

	setTimeout(animStep, pauseDuration);

	return;
}

UIScrollText.prototype.startHScroll = function() {
	var scrolltext = this;
	var textWidth = this.textWidth;

	if(textWidth <= this.w) {
		return;
	}

	this.offsetX = 0;
	this.offsetY = 0;
	var startTime = 0;
	var startOffset = 0;
	var duration = this.getAnimationDuration();
	var pauseDuration = this.getPauseDuration();

	var range = -this.w;
	var firstTime = true;
	var interpolator =  new DecelerateInterpolator();

	function animStep() {
		if(firstTime) {
			firstTime = false;
			startTime = (new Date()).getTime();
		}

		if(!scrolltext.isVisible()) {
			return;
		}
	
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = pauseDuration > 0 ? interpolator.get(timePercent) : timePercent;

		if(timePercent < 1) {
			scrolltext.offsetX = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			scrolltext.offsetX = startOffset + range;

			if(Math.abs(scrolltext.offsetX) < (textWidth-scrolltext.w)) {
				firstTime = true;

				startOffset = scrolltext.offsetX;
				setTimeout(animStep, pauseDuration);
			}
			else {
				delete startTime;
				scrolltext.callOnScrollDoneHandler();
			}
		}

		delete now;
		scrolltext.postRedraw();
	}

	setTimeout(animStep, pauseDuration);

	return;
}

UIScrollText.prototype.startScroll = function() {
	if(!this.isVisible()) {
		return;
	}

	if(this.type === "ui-vscroll-text") {
		this.startVScroll();
	}
	else {
		this.startHScroll();
	}

	return;
}

UIScrollText.prototype.onInit = function() {
	this.offsetX = 0;
	this.offsetY = 0;

	var scrolltext = this;
	setTimeout(function() {
			scrolltext.startScroll();
		}, 1000);

	return;
}

UIScrollText.prototype.drawText = function(canvas) {
	var offsetX = this.offsetX ? this.offsetX : 0;
	var offsetY = this.offsetY ? this.offsetY : 0;

	canvas.save();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.translate(offsetX, offsetY);
    canvas.beginPath();
    canvas.font = this.style.getFont();
    canvas.fillStyle = this.style.textColor;
    canvas.strokeStyle = this.style.lineColor;
    canvas.lineWidth = 1;

	if(this.type === "ui-vscroll-text") {
		this.drawMLText(canvas, false, true);
	}
	else {
		this.textWidth = this.draw1LText(canvas, true);
	}
	canvas.restore();

	return;
}

function UIScrollTextCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScrollText();
		
		return g.initUIScrollText(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIScrollTextCreator("ui-vscroll-text", 200, 200));
ShapeFactoryGet().addShapeCreator(new UIScrollTextCreator("ui-hscroll-text", 200, 50));

/*
 * File:   ui-list.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIList
 * @extends UIElement
 * 列表。每一行是一个UIListItem控件，UIListItem的高度可以固定也可以变化。
 *
 */
function UIList() {
	return;
}

UIList.prototype = new UIElement();
UIList.prototype.isUIList = true;
UIList.prototype.isUILayout = true;

UIList.prototype.saveProps = ["spacer", "itemHeightVariable", "itemDraggable", "itemHeight"];
UIList.prototype.initUIList = function(type, border, itemHeight, bg) {
	this.initUIElement(type);	

	this.setMargin(border, border);
	this.setSizeLimit(100, 100, 1000, 1000);
	this.setDefSize(400, itemHeight * 3 + 2 * border);

	this.spacer = 0;
	this.itemHeight = itemHeight;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.rectSelectable = false;
	this.itemHeightVariable = false;
	this.addEventNames(["onInit"]);

	if(!bg) {
		this.style.setFillColor("White");
	}

	return this;
}

UIList.prototype.getItemHeight = function() {
	return this.itemHeight;
}

UIList.prototype.setItemHeight = function(itemHeight) {
	this.itemHeight = itemHeight;

	return;
}

UIList.prototype.shapeCanBeChild = function(shape) {
	if(!shape.isUIListItem) {
		return false;
	}

	return true;
}

UIList.prototype.childIsBuiltin = function(child) {
	return child.name === "ui-list-item-update-status" 
		|| child.name === "ui-list-item-update-tips"
		|| child.name === "ui-last"
		|| child.name.indexOf("prebuild") >= 0
		|| child.name.indexOf("builtin") >= 0;
}

UIList.FIRST_ITEM = -1;
UIList.LAST_ITEM =   1;
UIList.MIDDLE_ITEM = 0;
UIList.SINGLE_ITEM = 2;

UIList.prototype.fixListItemImage = function(item, position) {
	var images = item.images;
	for(var key in images) {
		var value = images[key];
		if(key != "display") {
			var src = value.getImageSrc();
			if(!src) {
				continue;
			}

			switch(position) {
				case UIList.FIRST_ITEM: {
					src = src.replace(/\.single\./, ".first.");
					src = src.replace(/\.middle\./, ".first.");
					src = src.replace(/\.last\./, ".first.");
					break;
				}
				case UIList.MIDDLE_ITEM: {
					src = src.replace(/\.single\./, ".middle.");
					src = src.replace(/\.first\./, ".middle.");
					src = src.replace(/\.last\./, ".middle.");
					break;
				}
				case UIList.LAST_ITEM: {
					src = src.replace(/\.single\./, ".last.");
					src = src.replace(/\.first\./, ".last.");
					src = src.replace(/\.middle\./, ".last.");
					break;
				}
				case UIList.SINGLE_ITEM: {
					src = src.replace(/\.first\./, ".single.");
					src = src.replace(/\.middle\./, ".single.");
					src = src.replace(/\.last\./, ".single.");
					break;
				}
			}

			value.setImageSrc(src);
		}
	}

	return;
}

UIList.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var w = this.getWidth(true);
	var itemHeight = this.getItemHeight();
	var h = itemHeight;
	var itemHeightVariable = this.itemHeightVariable;

	var i = 0;
	var spacer = this.spacer;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];

		var config = {};
		var animatable = false;
		
		if(child.removed || !child.visible) continue;

		if(itemHeightVariable || child.isHeightVariable()) {
			h = child.measureHeight(itemHeight);
		}
		else {
			h = itemHeight;
		}

		if(n === 1) {
			this.fixListItemImage(child, UIList.SINGLE_ITEM);
		}
		else if(i === 0) {
			this.fixListItemImage(child, UIList.FIRST_ITEM);	
		}
		else if(i === (n - 1)) {
			this.fixListItemImage(child, UIList.LAST_ITEM);	
		}
		else {
			this.fixListItemImage(child, UIList.MIDDLE_ITEM);	
		}

		if(this.h <= (y + vMargin + h)) {
			this.h = y + vMargin + h;
		}

		
		animatable =  (y < this.h) && (animHint || this.isInDesignMode());
		if(animatable) {
			child.setSize(w, h);
			config.xStart = child.left;
			config.yStart = child.top;
			config.wStart = child.w;
			config.hStart = child.h;
			config.xEnd = x;
			config.yEnd = y;
			config.wEnd = w;
			config.hEnd = h;

			config.delay = 10;
			config.duration = 500;
			config.element = child;
			config.onDone = function (name) {
				this.relayoutChildren();
			}
			
			child.animate(config);
		}
		else {
			child.move(x, y);
			child.setSize(w, h);
			child.relayoutChildren();
		}

		child.setUserMovable(true);
	
		child.widthAttr = UIElement.WIDTH_FILL_PARENT;
		if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
			child.heightAttr = UIElement.HEIGHT_FIX;
		}
		child.setUserResizable(itemHeightVariable || child.isHeightVariable());
		if(!this.isUIScrollView) {
			child.setDraggable(this.itemDraggable);
		}

		y += h + spacer;
		i++;
	}

	return;
}

UIList.prototype.beforePaintChildren = function(canvas) {
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	return;
}

UIList.prototype.afterPaintChildren = function(canvas) {
	return;
}

UIList.prototype.afterChildAppended = function(shape) {
	if(shape.view && this.isInDesignMode() && shape.isCreatingElement()) {
		this.sortChildren();
	}
	this.moveMustBeLastItemToLast();
	shape.setUserMovable(true);
	shape.setUserResizable(false);
	shape.setCanRectSelectable(false, true);
	shape.autoAdjustHeight = this.itemHeightVariable;
	shape.setDraggable(this.itemDraggable);
	this.relayoutChildren();

	return true;
}

UIList.prototype.sortChildren = function() {}

UIList.prototype.onKeyUpRunning = function(code) {
	var targetShapeIndex = 0;

	if(!this.children.length) {
		return;
	}

	switch(code) {
		case KeyEvent.DOM_VK_UP: {
			targetShapeIndex = this.children.indexOf(this.targetShape) - 1;
			break;
		}
		case KeyEvent.DOM_VK_DOWN: {
			targetShapeIndex = this.children.indexOf(this.targetShape) + 1;
			break;
		}
		default: {
			return;
		}
	}

	var n = this.children.length;
	targetShapeIndex = (targetShapeIndex + this.children.length)%n;
	var targetShape = this.children[targetShapeIndex];

	this.setTarget(targetShape);
	this.postRedraw();

	if(this.isUIListView) {
		if(this.offset > targetShape.top) {
			this.offset = targetShape.top;
		}

		if((this.offset + this.h) < (targetShape.top + targetShape.h)) {
			this.offset = targetShape.top - (this.h - targetShape.h);
		}
	}

	return;
}

UIList.prototype.onKeyDownRunning = function(code) {
}

UIList.prototype.getValue = function() {
	var ret = null;
	var n = this.children.length;
	if(n < 1) return ret;
	
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(!iter.isUIListCheckableItem || !iter.value) continue;

		if(iter.isRadio) {
			return i;	
		}
		else {
			if(!ret) ret = [];
			ret.push(i);
		}
	}

	return ret;
}

UIList.prototype.setValue = function(value) {
	var arr = null;
	if(typeof value === "array") {
		arr = value;
	}
	else if(typeof value === "number") {
		arr = [value];
	}
	else {
		arr = [];
	}

	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var item = this.children[i];
		if(item.isUIListCheckableItem) {
			item.setValue(false);
		}
	}

	for(var i = 0; i < arr.length; i++) {
		var index = arr[i];
		if(index >= 0 && index < n) {
			var item = this.children[index];
			if(item.isUIListCheckableItem) {
				item.setChecked(true);
			}
		}
	}

	return this;
}

function UIListCreator(border, itemHeight, bg) {
	var args = ["ui-list", "ui-list", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIList();
		return g.initUIList(this.type, border, itemHeight, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListCreator(5, 114, null));

/*
 * File:   ui-list-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List View (Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIListView
 * @extends UIList
 * 列表视图。和UIList一样，只是可以滚动。建议使用UIListViewX。
 *
 */
function UIListView() {
	return;
}

UIListView.prototype = new UIVScrollView();
UIListView.prototype.isUIList = true;
UIListView.prototype.isUILayout = true;
UIListView.prototype.isUIListView = true;
UIListView.prototype.setItemHeight = UIList.prototype.setItemHeight;
UIListView.prototype.sortChildren = UIList.prototype.sortChildren;
UIListView.prototype.initUIList = UIList.prototype.initUIList;
UIListView.prototype.shapeCanBeChild = UIList.prototype.shapeCanBeChild;
UIListView.prototype.paintSelfOnly = UIList.prototype.paintSelfOnly;
UIListView.prototype.fixListItemImage = function(item, position) {};
UIListView.prototype.afterChildAppended = UIList.prototype.afterChildAppended;
UIListView.prototype.childIsBuiltin = UIList.prototype.childIsBuiltin;
UIListView.prototype.onKeyUpRunning = UIList.prototype.onKeyUpRunning;
UIListView.prototype.onKeyDownRunning = UIList.prototype.onKeyDownRunning;
UIListView.prototype.getValue = UIList.prototype.getValue;
UIListView.prototype.setValue = UIList.prototype.setValue;

UIListView.UPDATE_STATUS_NONE = 0;
UIListView.UPDATE_STATUS_TIPS = 1;
UIListView.UPDATE_STATUS_SYNC = 2;

UIListView.prototype.saveProps = UIList.prototype.saveProps;
UIListView.prototype.beginUpdate = function() {
	this.updateStatus = UIListView.UPDATE_STATUS_SYNC;
	var statusItem = this.findChildByName("ui-list-item-update-status");
	if(statusItem) {
		var waitBox = statusItem.findChildByName("ui-wait-box");
		if(waitBox) {
			waitBox.show();
		}

		var loading = statusItem.findChildByName("ui-label-loading");
		if(loading) {
			loading.setText(dappGetText("Loading..."));
		}
	}

	return;
}

UIListView.prototype.drawBgImage = function(canvas) {
	canvas.beginPath();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	UIElement.prototype.drawBgImage.call(this, canvas);

	return this;
}

UIListView.prototype.endUpdate = function() {
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;
	var statusItem = this.findChildByName("ui-list-item-update-status");
	if(statusItem) {
		this.setLastUpdateTime(new Date());
	}
	this.relayoutChildren(true);

	return;
}

UIListView.prototype.initUIListView = function(type, border, itemHeight, bg) {
	this.spacer = 0;
	this.initUIList(type, border, itemHeight, bg);
	this.initUIVScrollView(type, 0, bg, null);	
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;
	this.addEventNames(["onUpdateData", "onScrollOutOfRange"]);
	this.setTextType(Shape.TEXT_INPUT);

	return this;
}

UIListView.prototype.onModeChanged = function() {
	this.offset = 0;
	this.updateStatus = UIListView.UPDATE_STATUS_NONE;

	return;
}

UIListView.prototype.updateDone = function() {
	var list = this;

	list.endUpdate();
	setTimeout(function() {
		if(list.parentShape) {
			list.relayoutChildren();
			list.postRedraw();
		}
	}, 1000);

	return;
}

UIListView.prototype.callOnUpdateData = function() {
	this.callOnUpdateDataHandler();

	this.beginUpdate();
	var listView = this;
	setTimeout(function() {
		if(listView.parentShape) {
			listView.updateDone();
		}
	}, 10000);

	return true;
}

UIListView.prototype.setLastUpdateTime = function(lastUpdateTime) {
	var tipsItem = this.findChildByName("ui-list-item-update-tips");

	if(tipsItem && lastUpdateTime) {
		var str = "";
		var now = new Date();
		
		if(now.getFullYear() === lastUpdateTime.getFullYear() 
			&& now.getDate() === lastUpdateTime.getDate()
			&& now.getMonth() === lastUpdateTime.getMonth()) {
			
			str = dappGetText("Today");
		}
		else {
			str = lastUpdateTime.getMonth() + "-" + lastUpdateTime.getDate();
		}

		str = str + " " + lastUpdateTime.getHours() + ":" + lastUpdateTime.getMinutes();

		var updateTime = tipsItem.findChildByName("ui-label-update-time");
		if(updateTime) {
			updateTime.setText(str);
		}
		
		var updateTime = tipsItem.findChildByName("ui-label-update-time");
		if(updateTime) {
			updateTime.setText(str);
		}
		
		var updateTimeTips = tipsItem.findChildByName("ui-label-update-time-tips");
		if(updateTimeTips) {
			updateTimeTips.setText(dappGetText("Last Update:"));
		}
	}

	return;
}

UIListView.prototype.onDrag = function(offset) {
	var tipsItem = this.findChildByName("ui-list-item-update-tips");

	if(tipsItem) {
		var indicator = tipsItem.findChildByName("ui-image");
		var tips = tipsItem.findChildByName("ui-label-tips");

		if(indicator) {
			
			if(offset < -115) {
				if(indicator.rotation === 0) {
					function animationRotate() {
						var angle = indicator.rotation + 0.2 * Math.PI;
						if(angle > Math.PI) {
							angle = Math.PI;
						}
						indicator.setRotation(angle);
						if(angle < Math.PI) {
							setTimeout(animationRotate, 50);
						}
						indicator.postRedraw();

						return;
					}
					
					animationRotate();
					if(tips) {
						tips.setText(dappGetText("Release To Update."));
					}
				}
			}
			else {
				indicator.setRotation(0);
				if(tips) {
					tips.setText(dappGetText("Pull To Update."));
				}
			}
		}
	}

	return;
}

UIListView.prototype.whenScrollOutOfRange = function(offset) {

	if(offset < -115) {
		this.callOnUpdateData();
		this.relayoutChildren();
	}

	this.callOnScrollOutOfRangeHandler(offset);

	return;
}

UIListView.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var w = this.getWidth(true);
	var h = this.itemHeight;
	var itemHeightVariable = this.itemHeightVariable;
	var range = this.getScrollRange();
	var pageSize = this.getPageSize();
	var userMovable = true;

	
	var i = 0;
	var spacer = this.spacer || 0;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];
		
		var config = {};
		var isBuiltin = false;
		if(child.removed || !child.visible) continue;
		
		if(itemHeightVariable || child.isHeightVariable()) {
			h = child.measureHeight(this.itemHeight);
		}
		else {
			h = this.itemHeight;
		}

		if(child.name === "ui-list-item-update-tips") {
			if(!this.isInDesignMode()) {
				child.move(x, -h);
				child.left = x;
				child.top = -h;
				child.w = w;
				child.h = h;
				child.setUserMovable(false);
				child.setUserResizable(false);
				child.setVisible(this.updateStatus !== UIListView.UPDATE_STATUS_TIPS);

				continue;
			}
			else {
				child.setVisible(true);
			}
			isBuiltin = true;
		}
		else if(child.name === "ui-list-item-update-status") {
			if(!this.isInDesignMode()) {
				if(this.updateStatus !== UIListView.UPDATE_STATUS_SYNC) {
					child.setVisible(false);
				}else {
					child.setVisible(true);
				}
			}
			else {
				child.setVisible(true);
			}
			isBuiltin = true;
		}
		
		if(!child.visible) {
			continue;
		}

		animatable =  child.isVisible() && !isBuiltin && (y < this.h) && (animHint || this.isInDesignMode());
		if(animatable && (x != child.left || y != child.top || w != child.w || h != child.h)) {
			child.setSize(w, h);

			config.xStart = child.left;
			config.yStart = child.top;
			config.wStart = child.w;
			config.hStart = child.h;
			config.xEnd = x;
			config.yEnd = y;
			config.wEnd = w;
			config.hEnd = h;

			config.delay = 10;
			config.duration = 1000;
			config.element = child;
			config.onDone = function (name) {
				this.relayoutChildren();
			}
			child.animate(config);
		}
		else {
			child.move(x, y);
			child.setSize(w, h);
			child.relayoutChildren();
		}

		child.widthAttr = UIElement.WIDTH_FILL_PARENT;
		if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
			child.heightAttr = UIElement.HEIGHT_FIX;
		}
		child.setUserMovable(userMovable);
		child.setUserResizable(itemHeightVariable || child.isHeightVariable());

		y += h + spacer;
		i++;
	}

	return;
}

UIListView.prototype.drawText = UIList.prototype.drawText;

UIListView.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);
	
	if(this.isInDesignMode()) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIListViewCreator(border, itemHeight, bg) {
	var args = ["ui-list-view", "ui-list-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListView();
		return g.initUIListView(this.type, border, itemHeight, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListViewCreator(5, 114, null));

/*
 * File:   ui-list-item.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  List Item
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIListItem
 * @extends UIElement
 * UIListItem是一个简单的容器，它是UIList/UIListView唯一能容纳的子控件。
 *
 */
function UIListItem() {
	return;
}

UIListItem.prototype = new UIElement();
UIListItem.prototype.isUIListItem = true;

UIListItem.prototype.saveProps = ["heightVariable", "slideToRemove", "isTemplate", "roundRadius"];
UIListItem.prototype.initUIListItem = function(type) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(200, 120);
	this.setTextType(Shape.TEXT_NONE);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.setImage(UIElement.IMAGE_FOCUSED, null);
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.setImage(UIElement.IMAGE_POINTER_OVER, null);
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.addEventNames(["onLongPress", "onRemoved"]);

	return this;
}

UIListItem.prototype.dragMove = function(dx, dy) {
	this.top = this.top + dy;
	this.onDragging();

	return;
}

UIListItem.prototype.getDeleteItemIcon = function() {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DELETE_ITEM);

	return image;
}

UIListItem.prototype.shapeCanBeChild = function(shape) {

	if(shape.isUIMenu || shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar 
		|| shape.isUIWindow || shape.isUIPageManager || shape.isUIPage || shape.isUIListItem) {
		return false;
	}

	return true;
}

UIListItem.prototype.onUserResized = function() {
	var list = this.parentShape;
	if(list) {
		list.relayoutChildren();
	}

	return;
}

UIListItem.prototype.setSlideToRemove = function(value) {
	this.slideToRemove = value;

	return this;
}

UIListItem.prototype.setHeightVariable = function(value) {
	this.heightVariable = value;
	
	return this;
}

UIListItem.prototype.isHeightVariable = function() {
	return this.heightVariable;
}

UIListItem.prototype.measureHeight = function(height) {
	return this.h;
}

UIListItem.prototype.ANIM_DRAW_LINE = 1;
UIListItem.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || !this.slideToRemove) {
		return;
	}

	var dx = this.getMoveAbsDeltaX();
	var dy = this.getMoveAbsDeltaY();
	
	if(Math.abs(dx) < this.w/2 || (Math.abs(dy) > this.h)) {
		return;
	}

	var item = this;
	var duration = 300;
	var startTime = (new Date()).getTime();
	
	item.animateState = this.ANIM_DRAW_LINE;
	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.style.setTextColor("#C0C0C0");
	}

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;
	
		if(percent < 1) {
			item.animatePercent = percent;
			setTimeout(animStep, 10);
		}
		else {
			item.animatePercent = 1;

			setTimeout(function() {
				delete startTime;
				delete item.animatePercent;
				delete item.animateState;

				var parentShape = item.parentShape;
				parentShape.removeChild(item);
				parentShape.relayoutChildren("default");
				parentShape.postRedraw();
			}, 300);
		}

		delete now;
		item.postRedraw();
	}

	animStep();

	return;
}

UIListItem.prototype.getFillColor = function(canvas) {
	var fillColor;
	if(this.pointerDown) {
		var dy = Math.abs(this.getMoveAbsDeltaY());
		if(dy < 5) {
			var deltaTime = Date.now() - this.pointerDownTime;
			if(deltaTime < 50 && this.getParent().isUIListView) {
				fillColor = this.style.fillColor;
				this.postRedraw();
			}
			else {
				fillColor = this.style.textColor; 
			}
		}
		else {
			fillColor = this.style.fillColor;
		}
	}
	else if(this.isPointerOverShape()) {
		fillColor = this.style.overFillColor ? this.style.overFillColor : this.style.fillColor;
	}
	else if(this.isFocused()) {
		fillColor = this.style.focusedFillColor ? this.style.focusedFillColor : this.style.fillColor;
	}
	else {
		fillColor = this.style.fillColor;
	}

	return fillColor;
}

UIListItem.prototype.paintSelfOnly = function(canvas) {
	if(this.getBgHtmlImage()) {
		return;
	}

	var parentShape = this.parentShape;
	var fillColor = this.getFillColor();
	var lineColor = this.style.lineColor;
	var lineWidth = this.style.lineWidth;

	canvas.beginPath();
	if(!parentShape || parentShape.isUIListView || parentShape.isUIMenu) {
		if(!Shape.isTransparentColor(fillColor)) {
			canvas.fillStyle = fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}

		if(!Shape.isTransparentColor(lineColor)) {
			canvas.moveTo(0, this.h);
			canvas.lineTo(this.w, this.h);
			canvas.lineWidth = lineWidth;
			canvas.strokeStyle = lineColor;
			canvas.stroke();
		}

		return;
	}

	var r = this.roundRadius;
	var isFirst = (this === parentShape.children[0]);
	var isLast  = (this === parentShape.children[parentShape.children.length-1]);
	if(isFirst && isLast) {
		drawRoundRect(canvas, this.w, this.h, r);
	}
	else if(isFirst) {
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.TL | RoundRect.TR);
	}
	else if(isLast) {
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.BL | RoundRect.BR);
	}
	else {
		canvas.rect(0, 0, this.w, this.h);
	}

	if(!Shape.isTransparentColor(fillColor)) {
		canvas.fillStyle = fillColor;
		canvas.fill();
	}
	
	if(!Shape.isTransparentColor(lineColor)) {
		canvas.lineWidth = lineWidth;
		canvas.strokeStyle = lineColor;
		canvas.stroke();
	}

	return;
}

UIListItem.prototype.afterPaintChildren = function(canvas) {
	if(!this.animateState) {
		return;
	}

	var image = this.getDeleteItemIcon();
	if(this.animateState === this.ANIM_DRAW_LINE && image && image.width > 0) {
		var margin = 20;
		var percent = this.animatePercent;
		var w = (this.w - margin ) * percent - image.width;

		if(w > margin) {
			canvas.lineWidth = 1;
			canvas.strokeStyle = "#D0D0D0";
			canvas.moveTo(margin, this.h/2);
			canvas.lineTo(w, this.h/2);
			canvas.stroke();

			if(percent > 0.9) {
				var y = (this.h - image.height)/2;
				var x = this.w - image.width - margin;

				canvas.drawImage(image, x, y);
			}
		}
	}

	return;
}

UIListItem.prototype.afterChildAppended = function(shape) {
	if(shape.isUIButton || shape.isUICheckBox) {
		this.setImage(UIElement.IMAGE_ACTIVE, this.getImageByType(UIElement.IMAGE_NORMAL).getImageSrc());
		this.setImage(UIElement.IMAGE_FOCUSED, this.getImageByType(UIElement.IMAGE_NORMAL).getImageSrc());
	}

	return true;
}

function UIListItemCreator() {
	var args = ["ui-list-item", "ui-list-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListItem();
		g.initUIListItem(this.type);
	
		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListItemCreator(null, null, null, null));

/*
 * File:   ui-list-checkable-item.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Checkable List Item 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIListCheckableItem() {
	return;
}

UIListCheckableItem.prototype = new UIListItem();
UIListCheckableItem.prototype.isUIListCheckableItem = true;

UIListCheckableItem.prototype.initUIListCheckableItem = function(type) {
	this.initUIListItem(type);

	this.isUIListRadioBoxItem = (type === "ui-list-radiobox-item");
	this.isUIListCheckBoxItem = (type === "ui-list-checkbox-item");
	this.setImage(UIElement.IMAGE_CHECKED_FG, null);
	this.setImage(UIElement.IMAGE_UNCHECK_FG, null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIListCheckableItem.prototype.getValue = function() {
	return this.value;
}

UIListCheckableItem.prototype.setValue = function(value) {
	if(this.value != value) {
		this.value = value;
		this.callOnChangedHandler(this.value);
	}

	return;
}

UIListCheckableItem.prototype.setChecked = function() {
	var parentShape = this.parentShape;
	if(parentShape) {
		for(var i = 0; i < parentShape.children.length; i++) {
			var shape = parentShape.children[i];
			if(shape.isUIListCheckableItem) {
				shape.setValue(false);
			}
		}
	}

	this.setValue(true);

	return;
}

UIListCheckableItem.prototype.setParent = function(parentShape) {
	this.parentShape = parentShape;

	if(this.value) {
		this.setChecked();
	}

	return;
}

UIListCheckableItem.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	if(this.isUIListRadioBoxItem) {
		this.setChecked();
	}
	else {
		this.setValue(!this.value);
	}

	return;
}

UIListCheckableItem.prototype.drawFgImage = function(canvas) {
	var image = this.getHtmlImageByType(this.value ? UIElement.IMAGE_CHECKED_FG : UIElement.IMAGE_UNCHECK_FG);

	if(image) {
		var x = this.w - image.width - 20;
		var y = (this.h - image.height)/2;

		canvas.drawImage(image, 0, 0, image.width, image.height, x, y, image.width, image.height);
	}

	return;
}

function UIListCheckBoxItemCreator() {
	var args = ["ui-list-checkbox-item", "ui-list-checkbox-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListCheckableItem();
		g.initUIListCheckableItem(this.type);
		return g;
	}
	
	return;
}

function UIListRadioBoxItemCreator() {
	var args = ["ui-list-radiobox-item", "ui-list-radiobox-item", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIListCheckableItem();
		g.initUIListCheckableItem(this.type);
		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIListCheckBoxItemCreator());
ShapeFactoryGet().addShapeCreator(new UIListRadioBoxItemCreator());

/*
 * File:   ui-select.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Scrollable Select
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISelect
 * @extends UIElement
 * 提供多个选项给用户，让用户选择其中一个。可以用getValue来获取用户选择的值。
 *
 */

/**
 * @event onChanged
 * 用户选择选项时触发本事件。
 * @param {String} value 当前的选项。
 */

function UISelect() {
	return;
}

UISelect.prototype = new UIElement();
UISelect.prototype.isUISelect = true;

UISelect.prototype.saveProps = ["visibleItems", "isVertical"];
UISelect.prototype.initUISelect = function(type, w, h) {
	this.initUIElement(type);
	
	this.offset = 0;
	this.options = [];
	this.visibleItems = 5;	
	this.setDefSize(w, h);
	this.isVertical = true;
	this.addEventNames(["onChanged"]);
	this.setTextType(UIElement.TEXT_TEXTAREA);
	this.setCanRectSelectable(false, true);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UISelect.prototype.getItemSize = function() {
	var s = this.isVertical ? this.h : this.w;

	return Math.round(s/this.visibleItems);
}

UISelect.prototype.getVisibleItems = function() {
	return this.visibleItems;
}

UISelect.prototype.setVisibleItems = function(visibleItems) {
	if(visibleItems <= 3) {
		this.visibleItems = 3;
	}
	else {
		this.visibleItems = 5;
	}
}

UISelect.prototype.scrollTo = function(offsetEnd) {
	var itemSize = this.getItemSize();

	offsetEnd = Math.round(offsetEnd/itemSize) * itemSize;

	var me = this;
	var duration = 500;
	var offsetStart = this.offset;
	var range = offsetEnd - offsetStart;
	var startTime = (new Date()).getTime();
	var interpolator =  new DecelerateInterpolator();

	this.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);

		if(timePercent < 1) {
			me.setOffset(Math.floor(offsetStart + percent * range));
			setTimeout(animStep, 10);
		}
		else {
			me.setOffset(offsetStart + range, true);
			delete startTime;
			delete interpolator;
			delete me.animating;
		}

		delete now;
	}

	setTimeout(function() {
		animStep();
	}, 10);

	return;
}

UISelect.prototype.setOffset = function(offset, triggerOnChanged) {
	this.offset = offset;
	this.postRedraw();

	if(triggerOnChanged) {
		var value = this.getValue();
		this.callOnChangedHandler(value);
	}

	return;
}

UISelect.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	if(!this.velocityTracker) {
		this.velocityTracker = new VelocityTracker();
	}
	this.velocityTracker.clear();
	this.saveOffset = this.offset;

	return true;
}

UISelect.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}
	
	this.addMovementForVelocityTracker();

	var delta = this.isVertical ? this.getMoveAbsDeltaY() : this.getMoveAbsDeltaX();
	this.setOffset(this.saveOffset + delta);

	return;
}

UISelect.prototype.getMaxOffset = function() {
	var n = Math.floor(0.5 * this.visibleItems);

	return n * this.getItemSize();
}

UISelect.prototype.getMinOffset = function() {
	var itemSize = this.getItemSize();

	var n = Math.round(0.5 * this.visibleItems);

	if(this.options.length <= n) {
		return 0;
	}
	else {
		return -(this.options.length-n)  * itemSize;
	}
}
	
UISelect.prototype.handleClicked = function(point) {
	var itemSize = this.getItemSize();
	var s = this.isVertical ? this.h : this.w;
	var m = Math.floor((s/2 - this.offset)/itemSize);
	var i = Math.floor(((this.isVertical ? point.y : point.x) - this.offset)/itemSize);

	var d = (i - m) * itemSize;
	var offset = this.offset-d;
	var minOffset = this.getMinOffset();
	var maxOffset = this.getMaxOffset();

	if(offset < minOffset) {
		offset = minOffset;
	}

	if(offset > maxOffset) {
		offset = maxOffset;
	}
	
	this.scrollTo(offset);

	return;
}

UISelect.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	var v = this.velocityTracker.getVelocity();
	var velocity = this.isVertical ? v.y : v.x;
	var delta = this.isVertical ? this.getMoveAbsDeltaY() : this.getMoveAbsDeltaX();
	if((Date.now() - this.pointerDownTime) > 400) {
		velocity = 0;
	}

	var distance = delta + velocity/2;

	if(Math.abs(distance) < 10) {
		this.setOffset(this.saveOffset);
		this.handleClicked(point);

		return;
	}

	var minOffset = this.getMinOffset();
	var maxOffset = this.getMaxOffset();
	var offset = this.saveOffset + delta + velocity;

	if(offset < minOffset) {
		offset = minOffset;
	}

	if(offset > maxOffset) {
		offset = maxOffset;
	}

	this.scrollTo(offset);

	return;
}

UISelect.prototype.shapeCanBeChild = function(shape) {
	return false;
}
UISelect.prototype.createOptionsFromText = function(text) {
	if(text) {
		this.options = text.split("\n");
		this.options.remove("");
	}
	else {
		this.options = [];
	}
}


UISelect.prototype.setText =function(text) {
	text = this.toText(text);
    this.createOptionsFromText(text);
	this._text = text;

	return this;
}

/**
 * @method setOptions
 * 设置控件的可选项。
 * @param {Array} options 可选项(字符串数组)。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     var selector = this.win.find("select");
 *     selector.setOptions(["one", "two", "three"]);
 *
 */
UISelect.prototype.setOptions =function(options) {
	this.options = options || [];
	this.text = this.options.join("\n");

	return this;
}

/**
 * @method getOptions
 * 获取可选项。
 * @return {Array} 返回可选项(字符串数组)。
 */
UISelect.prototype.getOptions = function() {
	return this.options;
}


UISelect.prototype.drawText = function(canvas) {
	return;
}

UISelect.prototype.drawImage = function(canvas) {
	var w = this.w;
	var h = this.h;
	var itemSize = this.getItemSize();

	canvas.clipRect(0, 0, w, h);
	this.drawBgImage(canvas);

	var n = this.options.length;
	this.style.setTextB(false);
	var normalFont = this.style.getFont();
	var normalTxtColor = this.style.textColor;
	
	this.style.setTextB(true);
	var highlightFont = this.style.getFont();
	var highlightTextColor = this.style.textColorHighlight;

	canvas.textAlign = "center";
	canvas.textBaseline = "middle";

	var m = 0;
	var o = 0;
	var offset = this.offset;
	var isVertical = this.isVertical;
	var y = isVertical ? 0 : h >> 1;
	var x = isVertical ? w >> 1 : 0;
	var yOffset = isVertical ? offset : 0;
	var xOffset = isVertical ? 0 : offset;

	canvas.translate(xOffset, yOffset);
	if(isVertical) {
		m = Math.floor((0.5 * h - yOffset)/itemSize);
	}
	else {
		m = Math.floor((0.5 * w - xOffset)/itemSize);
	}

	var b = 0;
	var r = 0;
	for(var i = 0; i < n; i++) {
		var text = this.options[i];

		if(isVertical) {
			y = i * itemSize;
			b = y + itemSize;

			o = -offset;
			if(b < o && y < o) {
				continue;
			}

			o = -(offset - h);
			if(b > o && y > o) {
				continue;
			}
			y = y + (itemSize >> 1);
		}
		else {
			x = i * itemSize;
			r = x + itemSize;
			o = -offset;
			if(r < o && x < o) {
				continue;
			}

			o = -(offset - w);
			if(r > o && x > o) {
				continue;
			}
			x = x + (itemSize >> 1);
		}

		if(m == i) {
			canvas.font = highlightFont;
			canvas.fillStyle = highlightTextColor;
		}
		else {
			canvas.font = normalFont;
			canvas.fillStyle = normalTxtColor;
		}

		canvas.fillText(text, x, y, w);
	}

	return;
}

UISelect.prototype.getValue = function() {
	var offset = this.offset;
	var itemSize = this.getItemSize();
	var s = this.isVertical ? this.h : this.w;
	var i = Math.floor((0.5 * s - offset)/itemSize);

	var value = (i < this.options.length) ? this.options[i] : "";

	return value;
}

UISelect.prototype.setValueByIndex = function(index, animate) {
	var i = index;
	var itemSize = this.getItemSize();

	if(i >= 0) {
		var offset = -(i - (this.getVisibleItems()>> 1)) * itemSize;

		if(animate) {
			this.scrollTo(offset);
		}
		else {
			this.setOffset(offset, true);
		}
	}

	return this;
}

UISelect.prototype.setValue = function(value, notify, animate) {
	var i = this.options.indexOf(value.toString());

	this.setValueByIndex(i, animate);
	if(notify) {
		this.callOnChangedHandler(this.getValue());
	}

	return this;
}

Object.defineProperty(UISelect.prototype, "text", {
    set: function(txt) {
        txt = this.toText(txt);
        this.createOptionsFromText(txt);
        this._text = txt;
    },
    get: function() {
        return this._text;
    }
});

function UISelectCreator(w, h) {
	var args = ["ui-select", "ui-select", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISelect();
		return g.initUISelect(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISelectCreator("ui-select", 300, 50));

/*
 * File:   ui-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */


/**
 * @class UIImage
 * @extends UIElement
 * 用来显示一张图片。UIImage可以设置多张图片，但只有一张是当前显示的图片，其它图片是备用图片(目前为15张，可以增加)。可以用setValue把指定的备用图片设置为当前图片。
 *
 * 注意：getValue返回setValue设置的值，如果没有调用过setValue，getValue返回-1。
 *
 * 把第一张备用图片设置为当前图片(可以在UIImage的图片属性页中设置备用图片)：
 *
 *     @example small frame
 *     this.setImage(0);
 *
 * 或者：
 *
 *     @example small frame
 *     this.setValue(0);
 *
 */
function UIImage() {
	return;
}

UIImage.prototype = new UIElement();
UIImage.prototype.isUIImage = true;

UIImage.prototype.saveProps = ["keepSizeWithImage"];
UIImage.prototype.initUIImage = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onUpdateTransform"]);

	this.scaleX = 1;
	this.scaleY = 1;
	this.drawText = null;
	this.beforePaint = null;
	this.afterPaint = null;
	this.highlightConfig = null;

	return this;
}

UIImage.prototype.setValue = function(value) {
	this.v = value;
	return this.setImageSrc(value);
}

UIImage.prototype.getValue = function() {
	return (this.v !== undefined) ? this.v : -1;
}

UIImage.prototype.setImageSrc = function(value) {
	this.setImage(UIElement.IMAGE_DEFAULT, value);

	return this;
}

UIImage.prototype.getImageSrc = function(type) {
	return this.getImageSrcByType(type ? type : UIElement.IMAGE_DEFAULT);
}

UIImage.prototype.getHtmlImage = function(type) {
	return this.getHtmlImageByType(type ? type : UIElement.IMAGE_DEFAULT);
}

UIImage.prototype.getImageSrcRect = function() {
	var image = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(this.srcRect) {
		return this.srcRect;
	}
	else if(image) {
		return image.getImageRect();
	}
	else {
		return null;
	}
}

UIImage.prototype.setImageSrcRect = function(x, y, w, h) {
	this.srcRect = {};
	this.srcRect.x = x;
	this.srcRect.y = y;
	this.srcRect.w = w;
	this.srcRect.h = h;

	return;
}

UIImage.prototype.fitToImage = function() {
	var srcRect = this.getImageSrcRect();
	if(srcRect && srcRect.w && srcRect.h) {
		this.w = srcRect.rw || srcRect.w;
		this.h = srcRect.rh || srcRect.h;
	}

	return;
}

UIImage.prototype.fixChildSize = function() {
	return;
}

UIImage.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

function UIImageCreator(type) {
	var args = [type, "ui-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImage();
		return g.initUIImage(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageCreator("ui-image"));
ShapeFactoryGet().addShapeCreator(new UIImageCreator("ui-icon"));

//for compatible
UIImage.prototype.setBorderStyle = function(borderColor, borderWidth) {
	return;
}

UIImage.prototype.setClickedStyle = function(type, param) {

	return;
}

UIImage.prototype.getBgImage = function() {
	return this.images.default_bg;
}

UIImage.prototype.drawTextTips = function(canvas) {
}

UIImage.prototype.paintSelfFast = function(canvas) {
	var opacity = this.opacity;
	var px = this.w * this.pivotX;
	var py = this.h * this.pivotY;
	
	canvas.save();
	if(opacity !== 1) {
		canvas.globalAlpha *=  opacity;
	}

	canvas.translate(this._left, this._top);
	canvas.translate(px, py);
	canvas.scale(this.scaleX, this.scaleY);
	canvas.rotate(this.rotation);
	canvas.translate(-px, -py);

	this.drawBgImage(canvas);
	canvas.restore();
}

/*
 * File:   ui-label.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Label
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UILabel
 * @extends UIElement
 * 用来显示文字内容。
 *
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */
function UILabel() {
	return;
}

UILabel.prototype = new UIElement();
UILabel.prototype.isUILabel = true;

UILabel.prototype.saveProps = ["hTextAlign", "vTextAlign", "singleLineMode"];

UILabel.prototype.initUILabel = function(type) {
	this.initUIElement(type);	

	this.setText("");
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onChanged", "onUpdateTransform"]);


	return this;
}

/**
 * @method setTextAlign
 * 设置控件上文本水平对齐方式。
 * @param {String} textAlign 水平对齐方式。可选值有"left","center","right"。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.setTextAlign = function(textAlign) {
	this.hTextAlign = textAlign;

	return this;
}

/**
 * @method setTextBaseline
 * 设置控件上文本垂直对齐方式。
 * @param {String} textBaseline 垂直对齐方式。可选值有"top","middle","bottom"。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.setTextBaseline = function(textBaseline) {
	this.vTextAlign = textBaseline;

	return this;
}

/**
 * @method getTextAlign
 * 获取控件上文本水平对齐方式。
 * @return {String} 返回水平对齐方式。
 */
UILabel.prototype.getTextAlign = function() {
	return this.hTextAlign;
}

/**
 * @method getTextBaseline
 * 获取控件上文本垂直对齐方式。
 * @return {String} 返回垂直对齐方式。
 */
UILabel.prototype.getTextBaseline = function() {
	return this.vTextAlign;
}

UILabel.prototype.shapeCanBeChild = function(shape) {
	return shape.isUILabel || shape.isUIImage;
}

UILabel.prototype.setText = function(text) {
	this.text = this.toText(text);
	this.textNeedRelayout = true;
	this.callOnChangedHandler(text);
	this.postRedraw();

	return this;
}

UILabel.prototype.drawText = function(canvas) {
	this.layoutText(canvas);
	
	this.defaultDrawText(canvas);

	return;
}

UILabel.prototype.layoutText = function(canvas) {
	RShape.prototype.layoutText.call(this, canvas);
	
	if(this.singleLineMode && this.lines.length > 1) {
		this.lines.length = 1;
	}

	return this;
}

/**
 * @method setSingleLineMode
 * 设置文本为单行模式。
 * @param {Boolean} value true表示单行模式，false表示多行模式。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.setSingleLineMode = function(value) {
	this.singleLineMode = value;
	this.setTextNeedRelayout(true);

	return this;
}

/**
 * @method getSingleLineMode
 * 设置文本是否为单行模式。
 * @return {Boolean} true表示单行模式，false表示多行模式。
 */
UILabel.prototype.getSingleLineMode = function() {
	return this.singleLineMode;
}

/**
 * @method fitToTextContent
 * 让控件自动适应文本的高度。
 * @return {UIElement} 返回控件本身。
 */
UILabel.prototype.fitToTextContent = function() {
	if(!this.text) {
		this.w = 30;
		this.h = 30;

		return;
	}

	var canvas = this.getCanvasContext2D();
	this.layoutText(canvas);

	var n = this.lines.length;
	var w = this.w;
	var h = this.getTextHeight() + this.vMargin * 2;

	if(n === 1) {
		var str = this.lines[0];
		w = canvas.measureText(str).width + 2 * this.hMargin;
	}

	this.w = w;
	this.h = h;

	return this;
}

function UILabelCreator() {
	var args = ["ui-label", "ui-label", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILabel();
		return g.initUILabel(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UILabelCreator());

/*
 * File:   ui-tips.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Tips
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UITips() {
	return;
}

UITips.prototype = new UILabel();
UITips.prototype.isUITips = true;

UITips.prototype.saveProps = ["clickable", "triangleSize", "hTextAlign", "vTextAlign"];
UITips.prototype.initUITips = function(type) {
	this.initUILabel(type);	

	this.roundRadius = 8;
	this.triangleSize = 16;
	this.setMargin(20, 20);
	this.setClickable(true);
	this.setDefSize(200, 200);
	this.setSizeLimit(40, 40);
	this.handle = {x:-20, y:-20};

	return this;
}

UITips.prototype.getMoreSelectMark = function(type, point) {
	if(type === Shape.HIT_TEST_HANDLE) {
		point.x = this.handle.x;
		point.y = this.handle.y;

		return true;
	}

	return false;
}

UITips.prototype.getPointer = function() {
	return this.handle;
}

UITips.prototype.moveHandle = function(dx, dy) {
	return this.setPointer(this.handle.x + dx, this.handle.y + dy);
}

UITips.prototype.setPointer = function(x, y) {
	this.handle.x = x;
	this.handle.y = y;

	return this;
}

UITips.prototype.setClickable = function(clickable) {
	this.clickable = clickable;

	return this;
}

UITips.prototype.fitToTextContent = function() {
	UILabel.prototype.fitToTextContent.call(this);
	var r = this.roundRadius;
	var triangleSize = this.triangleSize;

	var minSize = r + r + triangleSize;
	this.w = Math.max(this.w, minSize);
	this.h = Math.max(this.h, minSize);

	return this;
}

UITips.prototype.drawPath = function(canvas) {
	var x = 0;
	var y = 0;
	var r = this.roundRadius;
	var triangleSize = this.triangleSize;
	var px = this.handle.x;
	var py = this.handle.y;
	var hMargin = this.hMargin;
	var vMargin = this.vMargin;
	var minSize = r + r + triangleSize;
	this.w = Math.max(this.w, minSize);
	this.h = Math.max(this.h, minSize);

	var w = this.w;
	var h = this.h;
	var delta =  triangleSize >> 1;
	
	canvas.beginPath();
	function drawToRight() {
		canvas.lineTo(w-r, 0);
		canvas.arc(w-r, r, r, 1.5 * Math.PI, 2*Math.PI, false);
	}
	
	function drawToBottom() {
		canvas.lineTo(w, h-r);	
		canvas.arc(w-r, h-r, r, 0, 0.5*Math.PI, false);
	}

	function drawToLeft() {
		canvas.lineTo(r, h);	
		canvas.arc(r, h-r, r, 0.5*Math.PI, Math.PI, false);
	}

	function drawToTop() {
		canvas.lineTo(0, r);
		canvas.arc(r, r, r, Math.PI, 1.5*Math.PI, false);
	}

	function drawTLArc() {
		canvas.arc(r, r, r, Math.PI, 1.5*Math.PI, false);
	}

	function drawTRArc() {
		canvas.arc(w-r, r, r, 1.5 * Math.PI, 2*Math.PI, false);
	}

	function drawBLArc() {
		canvas.arc(r, h-r, r, 0.5*Math.PI, Math.PI, false);
	}

	function drawBRArc() {
		canvas.arc(w-r, h-r, r, 0, 0.5*Math.PI, false);
	}

	canvas.moveTo(px, py);
	if(px < r) {
		if(py < (r + delta)) {
			canvas.lineTo(r, 0);
			drawToRight();
			drawToBottom();
			drawToLeft();
			canvas.lineTo(0, r);
		}else if(py > (h-r-delta)) {
			canvas.lineTo(0, h-r);
			drawToTop();
			drawToRight();
			drawToBottom();
			canvas.lineTo(r, h);	
		}else {
			canvas.lineTo(0, py-delta);
			drawToTop();
			drawToRight();
			drawToBottom();
			drawToLeft();
			canvas.lineTo(0, py+delta);	
		}
	} else if(px < (w - r)) {
		if(py < r) {
			canvas.lineTo(px+delta, 0);
			drawToRight();
			drawToBottom();
			drawToLeft();
			drawToTop();
			canvas.lineTo(px-delta, 0);
		}
		else {
			canvas.lineTo(px-delta, h);
			drawToLeft();
			drawToTop();
			drawToRight();
			drawToBottom();
			canvas.lineTo(px+delta, h);
		}
	}else{
		if(py < (r + delta)) {
			canvas.lineTo(w, r);
			drawToBottom();
			drawToLeft();
			drawToTop();
			canvas.lineTo(w-r, 0);
		}else if(py > (h-r-delta)) {
			canvas.lineTo(w-r, h);
			drawToLeft();
			drawToTop();
			drawToRight();
			canvas.lineTo(w, h-r);	
		}else {
			canvas.lineTo(w, py+delta);
			drawToBottom();
			drawToLeft();
			drawToTop();
			drawToRight();
			canvas.lineTo(w, py-delta);	
		}
	}
	canvas.closePath();

	return;
}

UITips.prototype.paintSelfOnlyByColor = function(canvas) {
	this.drawPath(canvas);

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(!this.isStrokeColorTransparent()) {
		canvas.strokeStyle = this.style.lineColor;
		canvas.lineWidth = (this.pointerDown && this.clickable) ? 4 : 2;
		canvas.stroke();
	}

	return;
}

UITips.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		this.paintSelfOnlyByColor(canvas);
	}

	return;
}

UITips.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage;
}

function UITipsCreator() {
	var args = ["ui-tips", "ui-tips", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITips();
		return g.initUITips(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITipsCreator());

/*
 * File:   ui-menu.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Menu
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIMenu
 * @extends UIElement
 * 菜单。菜单缺省时是隐藏的，只在特定情况才显示出来。菜单是一个容器，里面可以放按钮，列表项，文字和图片等控件。
 *
 * 菜单在显示或隐藏时，可以开启或关闭动画，动画可以是缺省的，也可以是自定义的。
 *
 * 对于自定义动画：显示动画名称必须是"show",隐藏动画名称必须是"hide"。
 *
 *     @example small frame
 *     this.win.find("menu").setVisible(true);
 */
function UIMenu() {
	return;
}

UIMenu.FREE_LAYOUT = 0;
UIMenu.ARC_LAYOUT = 1;
UIMenu.VLINEAR_LAYOUT = 2;
UIMenu.HLINEAR_LAYOUT = 3;

UIMenu.prototype = new UIElement();
UIMenu.prototype.isUIMenu = true;

UIMenu.prototype.saveProps = ["autoHideWhenClicked", "childrenAnimation", "enableShowAnimation", "enableHideAnimation", "spacer", "menuItemNr", "animDuration", "layoutType", "originPoint"];
UIMenu.prototype.initUIMenu = function(type) {
	this.initUIElement(type, null);

	this.spacer = 2;
	this.menuItemNr = 2;
	this.animDuration = 600;
	this.setTextType(Shape.TEXT_NONE);
	this.layoutType = UIMenu.FREE_LAYOUT;
	this.originPoint = UIElement.ORIGIN_RIGHT;
	this.setCanRectSelectable(false, false);
	this.enableHideAnimation = true;
	this.enableShowAnimation = true;

	return this;
}

UIMenu.prototype.relayoutChildrenHLL = function() {
	var n = this.children.length;
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var originPoint = this.originPoint;
	
	var nr = Math.max(n, this.menuItemNr);
	var itemW = Math.round((w - spacer * (nr - 1))/nr);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.h = h;
		iter.w = itemW;
		iter.left = x;
		iter.top = y;
		x += itemW + spacer;
		iter.relayoutChildren();
	}

	return this;
}

UIMenu.prototype.relayoutChildrenVLL = function() {
	var n = this.children.length;
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();

	var x = hMargin;
	var y = vMargin;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var originPoint = this.originPoint;

	var nr = Math.max(n, this.menuItemNr);
	var itemH = Math.round((h - spacer * (nr - 1))/nr);
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		iter.w = w;
		iter.h = itemH;
		iter.left = x;
		iter.top = y;
		y += itemH + spacer;
		iter.relayoutChildren();
	}

	return this;
}

UIMenu.prototype.getChildPositionOfArc = function(originInfo, r, index, n) {
	var p = {};
	var nr = originInfo.angleRange > (Math.PI * 1.9) ? n : n - 1;
	var angle = originInfo.angleStart + (originInfo.angleRange*index)/nr;

	p.x = originInfo.x + r * Math.cos(angle);
	p.y = originInfo.y + r * Math.sin(angle);

	return p;
}

UIMenu.prototype.relayoutChildrenARC = function() {
	var n = this.children.length;
	var originInfo = this.getOrigin();
	var r = originInfo.r;
	var w = this.w;
	var h = this.h;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		var p = this.getChildPositionOfArc(originInfo, r, i, n);
		iter.left = p.x - (iter.w >> 1);
		iter.top = p.y - (iter.h >> 1);
		iter.relayoutChildren();
	}

	return;
}

UIMenu.prototype.relayoutChildren = function() {
	var n = this.children.length;
	if(this.disableRelayout || !n) {
		return;
	}

	switch(this.layoutType) {
		case UIMenu.HLINEAR_LAYOUT: {
			this.relayoutChildrenHLL();
			break;
		}
		case UIMenu.VLINEAR_LAYOUT: {
			this.relayoutChildrenVLL();
			break;
		}
		case UIMenu.ARC_LAYOUT: {
			this.relayoutChildrenARC();
			break;
		}
		default: {
			for(var i = 0; i < n; i++) {
				this.children[i].relayout();
			}
			break;
		}
	}

	return;
}

UIMenu.prototype.prepareShowChildAnimation = function(child, origin) {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";
	config.xStart = origin.x - (child.w >> 1);
	config.xEnd = child.left;
	config.yStart = origin.y - (child.h >> 1);
	config.yEnd = child.top;
	config.scaleXStart = 0;
	config.scaleXEnd = 1;
	config.scaleYStart = 0;
	config.scaleYEnd = 1;
	config.opacityStart = 0;
	config.opacityEnd = 1;
	config.rotationStart = 0;
	config.rotationEnd = 2 * Math.PI;

	return config;
}

UIMenu.prototype.prepareHideChildAnimation = function(child, origin) {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";

	config.xStart = child.left;
	config.xEnd = origin.x - (child.w >> 1);
	config.yStart = child.top;
	config.yEnd = origin.y - (child.h >> 1);

	config.opacityStart = 1;
	config.opacityEnd = 0;
	config.scaleXStart = 1;
	config.scaleXEnd = 0;
	config.scaleYStart = 1;
	config.scaleYEnd = 0;
	config.rotationStart = Math.PI * 2;
	config.rotationEnd = 0;

	return config;
}

UIMenu.prototype.animateShowChildren = function() {
	var me = this;
	var n = this.children.length;
	var origin = this.getOrigin();

	this.busy = n;
	this.visible = true;
	for(var i = 0; i < n; i++) {
		var config = null;
		var iter = this.children[i];
		if(iter.animations) {
			config = iter.animations['show'];
		}
		if(!config) {
			config = this.prepareShowChildAnimation(iter, origin);
		}
		else {
			console.log("Use child show animation.");
		}

//		this.busy++;
		iter.animate(config, function() {
			me.busy--;
		});
	}

	return this;
}

UIMenu.prototype.animateHideChild = function(child, config) {
	var me = this;
	var x = child.left;
	var y = child.top;
	var w = child.w;
	var h = child.h;

//	this.busy++;
	child.animate(config, function() {
		child.left = x;
		child.top = y;
		child.w = w;
		child.h = h;
		
		child.opacity = 1;
		child.visible = false;

		me.busy--;
		if(!me.busy) {
			me.visible = false;
		}
	});

	return;
}

UIMenu.prototype.animateHideChildren = function() {
	var me = this;
	var n = this.children.length;
	var origin = this.getOrigin();

	this.busy = n;
	this.visible = true;
	for(var i = 0; i < n; i++) {
		var config = null;
		var iter = this.children[i];
		if(iter.animations) {
			config = iter.animations['hide'];
		}

		if(!config) {
			config = this.prepareHideChildAnimation(iter, origin);
		}
		else {
			console.log("Use child hide animation.");
		}

		this.animateHideChild(iter, config);
	}

	return this;
}

UIMenu.prototype.prepareShowAnimation = function() {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "d";

	config.scaleXStart = 0.5;
	config.scaleXEnd = 1;
	config.scaleYStart = 0.5;
	config.scaleYEnd = 1;
	config.opacityStart = 0;
	config.opacityEnd = 1;

	return config;
}

UIMenu.prototype.prepareHideAnimation = function() {
	var config = {};

	config.duration = this.animDuration;
	config.interpolator = "a";
	config.scaleXStart = 1;
	config.scaleXEnd = 0.5;
	config.scaleYStart = 1;
	config.scaleYEnd = 0.5;
	config.opacityStart = 1;
	config.opacityEnd = 0;

	return config;
}

UIMenu.prototype.animateShowSelf = function() {
	var me = this;
	me.busy = true;
	var config = null;
	if(this.animations) {
		config = this.animations["show"];
	}

	if(!config) {
		config = this.prepareShowAnimation();
	}

	this.animate(config, function() {
		me.visible = true;
		me.busy = false;
	});
}

UIMenu.prototype.animateHideSelf = function() {
	var me = this;
	me.busy = true;
	this.visible = true;
	var config = null;
	if(this.animations) {
		config = this.animations["hide"];
	}

	if(!config) {
		config = this.prepareHideAnimation();
	}

	this.animate(config, function() {
		me.visible = false;
		me.busy = false;
	});

	return this;
}

UIMenu.prototype.show = function() {
	if(this.busy) return;
	if(this.autoHideWhenClicked) {
		this.getWindow().grab(this);
	}

	if(!this.enableShowAnimation) {
		this.visible = true;
		return;
	}

	if(this.childrenAnimation) {
		this.animateShowChildren();
	}
	else {
		this.animateShowSelf();
	}
}

UIMenu.prototype.hide = function() {
	if(this.busy) return;
	if(this.autoHideWhenClicked) {
		this.getWindow().ungrab(this);
	}
	
	if(!this.enableHideAnimation) {
		this.visible = false;
		return;
	}

	if(this.childrenAnimation) {
		return this.animateHideChildren();
	}
	else {
		return this.animateHideSelf();
	}
}

UIMenu.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	if(this.autoHideWhenClicked) {
		this.hide();
	}

	return;
}

UIMenu.prototype.setVisible = function(visible) {
	if(this.visible === visible || this.busy) {
		return this;
	}

	return visible ? this.show() : this.hide();
}

UIMenu.prototype.getOrigin = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var hMargin = this.hMargin;
	var vMargin = this.vMargin;

	var p = {x:hMargin, y:vMargin};

	switch(this.originPoint) {
		case UIElement.ORIGIN_UP: {
			p.x = this.w >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = 0;
			p.r = w >> 1;
			break;
		}
		case UIElement.ORIGIN_DOWN: {
			p.x = this.w >> 1;
			p.y = this.h - vMargin;
			p.angleRange = Math.PI;		
			p.angleStart = Math.PI;
			p.r = w >> 1;
			break;
		}
		case UIElement.ORIGIN_LEFT: {
			p.x = hMargin;
			p.y = this.h >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = - Math.PI * 0.5;
			p.r = h >> 1;
			break;
		}
		case UIElement.ORIGIN_RIGHT: {
			p.x = this.w - hMargin;
			p.y = this.h >> 1;
			p.angleRange = Math.PI;		
			p.angleStart = Math.PI * 0.5;
			p.r = h >> 1;
			break;
		}
		case UIElement.ORIGIN_UP_LEFT: {
			p.angleRange = Math.PI * 0.5;
			p.angleStart = 0;
			p.r = Math.min(w,h);

			break;
		}
		case UIElement.ORIGIN_UP_RIGHT: {
			p.x = this.w - hMargin;
			p.angleStart = 0.5 * Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_DOWN_LEFT: {
			p.x = hMargin;
			p.y = this.h - vMargin;
			p.angleStart = - 0.5 * Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_DOWN_RIGHT: {
			p.x = this.w - hMargin;
			p.y = this.h - vMargin;
			p.angleStart = Math.PI;
			p.angleRange = Math.PI * 0.5;
			p.r = Math.min(w,h);
			break;
		}
		case UIElement.ORIGIN_MIDDLE_CENTER: {
			p.x = this.w >> 1;
			p.y = this.h >> 1;
			p.angleStart = -0.5 * Math.PI;
			p.angleRange = Math.PI * 2;
			p.r = Math.min(w,h) >> 1;
			break;
		}
		default:break;
	}

	return p;
}

UIMenu.prototype.applyTransform = function(canvas) {
	if(this.isInDesignMode()) return;

	var origin = this.getOrigin();

	if(canvas.globalAlpha != this.opacity) {
		canvas.globalAlpha =  this.opacity;
	}

	if(this.offsetX) {
		canvas.translate(this.offsetX, 0);
	}

	if(this.offsetY) {
		canvas.translate(0, this.offsetY);
	}

	var scaleX = this.getScaleX();
	var scaleY = this.getScaleY();
	if(this.rotation || (scaleX && scaleX !== 1) || (scaleY && scaleY !== 1)) {
		var hw = origin.x;
		var hh = origin.y;

		canvas.translate(hw, hh);
		if(scaleX && scaleY) {
			canvas.scale(scaleX, scaleY);
		}
		
		if(this.rotation) {
			canvas.rotate(this.rotation);
		}
		canvas.translate(-hw, -hh);
	}

	return;
}


UIMenu.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIListItem || shape.isUIButton || shape.isUIImage;
}

function UIMenuCreator() {
	var args = ["ui-menu", "ui-menu", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMenu();
		return g.initUIMenu(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMenuCreator());

/*
 * File:   ui-page.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  TabPage
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPage
 * @extends UIElement
 * 标签控件里的一个页面。
 *
 */
function UIPage() {
	return;
}

UIPage.prototype = new UIElement();
UIPage.prototype.isUIPage = true;

UIPage.prototype.initUIPage = function(type, bg) {
	this.initUIElement(type);	

	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;

	if(!bg) {
		this.style.setFillColor("Gold");
	}

	return this;
}

UIPage.prototype.show = function() {
	this.setVisible(true);
	this.showHTML();

	return;
}

UIPage.prototype.hide = function() {
	this.setVisible(false);
	this.hideHTML();
	cantkHideAllInput();

	return;
}

UIPage.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIDevice || shape.isUIScreen || shape.isUIStatusBar 
		|| shape.isUIWindow || shape.isUIPage) {
		return false;
	}

	if(shape.isUIPageIndicator && !this.isUIPageExt) {
		return false;
	}

	return true;
}

UIPage.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIPageCreator(bg) {
	var args = ["ui-page", "ui-page", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPage();

		return g.initUIPage(this.type, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPageCreator(null));

/*
 * File:   ui-circle-layout.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Circle Layout
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UICircleLayout() {
	return;
}

UICircleLayout.prototype = new UIElement();
UICircleLayout.prototype.isUILayout = true;
UICircleLayout.prototype.isUICircleLayout = true;
UICircleLayout.O_CENTER = "c";
UICircleLayout.O_TOP_LEFT = "tl";
UICircleLayout.O_TOP_MIDDLE = "tm";
UICircleLayout.O_TOP_RIGHT = "tr";
UICircleLayout.O_LEFT_MIDDLE = "lm";
UICircleLayout.O_RIGHT_MIDDLE = "rm";
UICircleLayout.O_BOTTOM_LEFT = "bl";
UICircleLayout.O_BOTTOM_MIDDLE = "bm";
UICircleLayout.O_BOTTOM_RIGHT = "br";

UICircleLayout.prototype.initUICircleLayout = function(type, w, h, img) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;
	this.setCanRectSelectable(false, false);
	this.addEventNames(["onInit"]);
	this.origin =  UICircleLayout.O_CENTER;
	this.setSizeLimit(120, 120, 1000, 1000, 1);

	return this;
}

UICircleLayout.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUIImage || shape.isUIButton) {
		return true;
	}

	return false;
}

UICircleLayout.prototype.paintSelfOnly = function(canvas) {
	if(this.isInDesignMode()) {
		canvas.lineWidth = this.style.lineWidth;

		switch(this.origin) {
			case UICircleLayout.O_CENTER: {
				var ox = this.w >> 1;
				var oy = this.h >> 1;
				var r = (this.w >> 1) - 30;
				var n = this.children.length ? this.children.length : 6;
				var angle = n > 1 ? (2 * Math.PI/(n-1)) : 0;

				canvas.beginPath();
				canvas.fillStyle = this.style.fillColor;
				canvas.strokeStyle = this.style.lineColor;
				canvas.arc(ox, oy, r, 0, Math.PI * 2);
				canvas.stroke();

				var deltaA = -0.5 * Math.PI;
				for(var i = 0; i < n; i++) {
					canvas.beginPath();

					if(i == 0) {
						canvas.arc(ox, oy, 10, 0, Math.PI * 2);
						canvas.stroke();
					}
					else {
						var a = angle * (i - 1) + deltaA;
						var x = ox + r * Math.cos(a);
						var y = oy + r * Math.sin(a);
						canvas.arc(x, y, 10, 0, Math.PI * 2);
						canvas.stroke();
					}
				}
				
				canvas.stroke();
				break;
			}
			default:break;
		}
	}

	return;
}


UICircleLayout.prototype.moveShapeToCenter = function(shape, x, y) {
	x = x - (shape.w >> 1);
	y = y - (shape.h >> 1);

	shape.move(x, y);

	return;
}

UICircleLayout.prototype.relayoutChildren = function() {
	if(this.disableRelayout) {
		return;
	}

	switch(this.origin) {
		case UICircleLayout.O_CENTER: {
			var ox = this.w >> 1;
			var oy = this.h >> 1;
			var r = (this.w >> 1) - 30;
			var n = this.children.length - 1;
			var angle = n > 0 ? (2 * Math.PI/n) : 0;

			var deltaA = -0.5 * Math.PI;
			for(var i = 0; i < this.children.length; i++) {
				var iter = this.children[i];
				if(i == 0) {
					this.moveShapeToCenter(iter, ox, oy);
				}
				else {
					var a = angle * (i - 1) + deltaA;
					var x = ox + r * Math.cos(a);
					var y = oy + r * Math.sin(a);
					this.moveShapeToCenter(iter, x, y);
				}
			}
			break;
		}
		default:break;
	}

	return;
}

UICircleLayout.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_FIX_TOP;
	shape.xAttr = UIElement.X_FIX_LEFT;
	shape.widthAttr = UIElement.WIDTH_SCALE;
	shape.heightAttr = UIElement.HEIGHT_SCALE;
	shape.setUserMovable(true);
	shape.setUserResizable(true);
	shape.setCanRectSelectable(false, true);
	this.relayoutChildren();

	return true;
}

function UICircleLayoutCreator(w, h, img) {
	var args = ["ui-circle-layout", "ui-circle-layout", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICircleLayout();

		return g.initUICircleLayout(this.type, w, h, img);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICircleLayoutCreator(400, 400));

/*
 * File:   ui-grid.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Grid
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGrid
 * @extends UIElement
 * 网格容器，里面的子控件按行列排列，每个子控件大小相同。
 *
 */
function UIGrid() {
	return;
}

UIGrid.prototype = new UIElement();
UIGrid.prototype.isUIGrid = true;
UIGrid.prototype.isUILayout = true;

UIGrid.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.cols = this.cols;
	o.rows = this.rows;
	o.spacer = this.spacer;
	o.scrollDirection = this.scrollDirection;

	return o;
}

UIGrid.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.cols = js.cols;
	this.rows = js.rows;
	this.spacer = js.spacer;
	this.scrollDirection = js.scrollDirection;

	return js;
}

UIGrid.prototype.initUIGrid = function(type) {
	this.initUIElement(type);	

	this.spacer = 0;
	this.offset = 0;
	this.setMargin(0, 0);
	this.setDefSize(200, 200);

	this.rows = 3;
	this.cols = 3;
	this.checkable = false;
	this.rectSelectable = false;
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.setImage(UIElement.IMAGE_CHECKED_ITEM, null);
	this.addEventNames(["onChildDragged", "onChildDragging", "onInit"]);

	return this;
}

/**
 * @method setRows
 * 设置行数。
 * @param {Number} value 行数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setRows = function(value) {
	this.rows = value;

	return this;
}

/**
 * @method getRows
 * 获取行数。
 * @return {Number} 返回行数。
 *
 */
UIGrid.prototype.getRows = function() {
	return this.rows;
}

/**
 * @method setCols
 * 设置列数。
 * @param {Number} value 列数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setCols = function(value) {
	this.cols = value;

	return this;
}

/**
 * @method getCols
 * 获取列数。
 * @return {Number} 返回列数。
 *
 */
UIGrid.prototype.getCols = function() {
	return this.cols;
}

/**
 * @method isCheckable
 * 检查是否进入勾选模式。
 * @return {Boolean} 是否进入勾选模式。
 *
 */
UIGrid.prototype.isCheckable = function(value) {
	return this.checkable;
}

/**
 * @method setCheckable
 * 设置是否进入勾选模式。进入勾选模式后可以勾选子控件。
 * (记得在IDE中设置网格的勾选子项的图标)
 * @param {Boolean} value 是否进入勾选模式。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setCheckable = function(value) {
	this.checkable = value;

	return this;
}

/**
 * @method setChildChecked
 * 勾选指定的子控件。
 * @param {Number} index 子控件的索引。
 * @param {Boolean} checked 是否勾选。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.setChildChecked = function(index, checked) {
	if(index >= 0 && index < this.children.length) {
		this.children[index].checked = checked; 
	}

	return this;
}

/**
 * @method isChildChecked
 * 检查指定的子控件是否勾选。
 * @param {Number} index 子控件的索引。
 * @return {Boolean} 返回子控件是否勾选。
 *
 */
UIGrid.prototype.isChildChecked = function(index) {
	if(index < this.children.length) {
		return this.children[index].checked; 
	}

	return false;
}

/**
 * @method getChildByRowCol
 * 通过行列数获取对应的子控件。
 * @param {Number} row 行数。
 * @param {Number} col 列数。
 * @return {UIElement} 返回子控件。
 *
 */
UIGrid.prototype.getChildByRowCol = function(row, col) {
	var cols = this.getCols();
	var index = row * cols + col;

	if(index < this.children.length) {
		return this.children[index];
	}
	else {
		return null;
	}
}

/**
 * @method getChildRow
 * 获取指定子控件所在的行数。
 * @param {UIElement} child 子控件。
 * @return {Number} 返回行数。
 *
 */
UIGrid.prototype.getChildRow = function(child) {
	var cols = this.getCols();
	var index = this.children.indexOf(child);

	return Math.floor(index/cols);
}

/**
 * @method getChildCol
 * 获取指定子控件所在的列数。
 * @param {UIElement} child 子控件。
 * @return {Number} 返回列数。
 *
 */
UIGrid.prototype.getChildCol = function(child) {
	var cols = this.getCols();
	var index = this.children.indexOf(child);

	return index%cols;
}

/**
 * @method exchangeTwoChildren
 * 交换两个子控件的位置。
 * @param {Number} child1Index 子控件1的索引。
 * @param {Number} child2Index 子控件2的索引。
 * @param {Boolean} enableAnimation 是否启用动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIGrid.prototype.exchangeTwoChildren = function(child1Index, child2Index, enableAnimation) {
	var n = this.children.length;
	if(child1Index < 0 || child1Index >= n || child2Index < 0 || child2Index >= n) {
		return this;
	}

	var child = this.children[child1Index];
	this.children[child1Index] = this.children[child2Index];
	this.children[child2Index] = child;

	this.relayoutChildren(enableAnimation);

	return this;
}

UIGrid.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

UIGrid.prototype.childIsBuiltin = function(child) {
	return child.name === "ui-last";
}

UIGrid.prototype.calcItemSize = function() {
	var w = this.getWidth(true);
	var h = this.getHeight(true);

	var iw = Math.floor(w/this.cols);
	var ih = Math.floor(h/this.rows);

	return {w:iw, h:ih, cols:this.cols, rows:this.rows};
}

UIGrid.prototype.sortChildren = function() {}

UIGrid.prototype.getChildIndexByPoint = function(point) {
	var border = this.getHMargin();
	var itemSize = this.calcItemSize();
	
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var itemW = itemSize.w + spacer;
	var itemH = itemSize.h + spacer;
	var cols = Math.floor(w/itemW);
	var rows = Math.floor(h/itemH);

	var r = Math.floor((point.y - border)/itemSize.h);
	var c = Math.floor((point.x - border)/itemSize.w);

	var index = r * cols + c;

	return index;
}

UIGrid.prototype.onChildDragging = function(child, point) {
	var targetChildIndex = this.getChildIndexByPoint(point);
	var sourceChildIndex = this.getIndexOfChild(child);
	
	this.callOnChildDraggingHandler(sourceChildIndex, targetChildIndex);

	return;
}

UIGrid.prototype.onChildDragged = function(child, point) {
	var targetChildIndex = this.getChildIndexByPoint(point);
	var sourceChildIndex = this.getIndexOfChild(child);
	
	this.callOnChildDraggedHandler(sourceChildIndex, targetChildIndex);
	
	this.relayoutChildren("default");

	return;
}

UIGrid.prototype.relayoutChildren = function(animHint) {
	if(this.disableRelayout) {
		return;
	}

	var r = 0;
	var c = 0;
	var x = 0;
	var y = 0;
	var cols = this.cols;
	var rows = this.rows;
	var spacer = this.spacer;
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var iw = Math.floor((w - (cols-1)*spacer)/cols);
	var ih = Math.floor((h - (rows-1)*spacer)/rows);
	var itemW = iw + spacer;
	var itemH = ih + spacer;

	var vMargin = (this.h - rows * itemH) >> 1;
	var hMargin = (this.w - cols * itemW) >> 1;

	var i = 0;
	var n = this.children.length;
	var children = this.children;
	for(var k = 0; k < n; k++) {
		var child = children[k];
		child.z = k;
		if(child.removed || !child.visible) continue;

		r = Math.floor(i/cols);
		c = Math.floor(i%cols);
	
		x = hMargin + c * itemW;
		y = vMargin + r * itemH;

		child.setSize(iw, ih);
		if(animHint || this.isInDesignMode()) {
			child.animMove(x, y, animHint);
		}
		else {
			child.move(x, y);
		}

		child.xAttr = UIElement.X_FIX_LEFT;
		child.yAttr = UIElement.Y_FIX_TOP;
		child.widthAttr = UIElement.WIDTH_FIX;
		child.heightAttr = UIElement.HEIGHT_FIX;
		child.setUserMovable(true);
		child.setUserResizable(false);
		child.relayoutChildren();
		if(!this.isUIScrollView) {
			child.setDraggable(this.itemDraggable);
		}

		i++;
	}

	return;
}

UIGrid.prototype.afterChildAppended = function(shape) {
	if(this.isInDesignMode() && !this.disableRelayout) {
		this.sortChildren();
	}

	this.moveMustBeLastItemToLast();
	shape.setUserMovable(true);
	shape.setUserResizable(false);
	shape.setCanRectSelectable(false, true);
	shape.setDraggable(this.itemDraggable);

	shape.xAttr = UIElement.X_FIX_LEFT;
	shape.yAttr = UIElement.Y_FIX_TOP;
	shape.widthAttr = UIElement.WIDTH_FIX;
	shape.heightAttr = UIElement.HEIGHT_FIX;

	if(this.isInDesignMode() && !this.disableRelayout) {
		this.relayoutChildren();
	}

	return true;
}

UIGrid.prototype.triggerDeleteMode = function() {
	if(this.isInDesignMode()) {
		return;
	}

	this.deleteMode = !this.deleteMode;

	var grid = this;
	function redrawGrid() {
		grid.postRedraw();

		if(grid.deleteMode) {
			setTimeout(redrawGrid, 20);
		}
	}

	redrawGrid();

	return;
}

UIGrid.prototype.isInDeleteMode = function() {
	return this.deleteMode && !this.isInDesignMode();
}

UIGrid.prototype.beforePaintChild = function(child, canvas) {
	if(this.isInDeleteMode()) {
		canvas.save();
		var cx = child.left + child.w/2;
		var cy = child.top + child.h/2;
		var t = canvas.now/1000;
		var angle = 0.03 * Math.cos(20*t);

		canvas.translate(cx, cy);
		canvas.rotate(angle);
		canvas.translate(-cx, -cy);
	}

	return;
}

UIGrid.prototype.afterPaintChild = function(child, canvas) {
	if(this.isInDeleteMode()) {
		var wImage = this.getImageByType(UIElement.IMAGE_DELETE_ITEM);
		if(WImage.isValid(wImage)) {
			var image = wImage.getImage();
			var srcRect = wImage.getImageRect();
			var y = child.top + child.vMargin;
			var x = child.left + child.w - srcRect.w - child.hMargin;

			canvas.drawImage(image, x, y);
			WImage.draw(canvas, image, WImage.DISPLAY_CENTER, x, y, srcRect.w, srcRect.h, srcRect);
		}

		canvas.restore();

		return;
	}

	if(this.checkable) {
		if(child.checked) {
			var wImage = this.getImageByType(UIElement.IMAGE_CHECKED_ITEM);
			if(WImage.isValid(wImage)) {
				var image = wImage.getImage();
				var srcRect = wImage.getImageRect();
				WImage.draw(canvas, image, WImage.DISPLAY_AUTO_SIZE_DOWN, child.left, child.top, child.w, child.h, srcRect);
			}
		}
	}

	return;
}

function UIGridCreator(border) {
	var args = ["ui-grid", "ui-grid", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGrid();
		return g.initUIGrid(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridCreator());

/*
 * File:   ui-grid-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Grid View(Scrollable)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIGridView
 * @extends UIGrid
 * UIGridView和UIGrid类似，只是它可以垂直滚动。建议使用UIGridViewX。
 *
 */
function UIGridView() {
	return;
}

UIGridView.prototype = new UIVScrollView();
UIGridView.prototype.isUIGrid = true;
UIGridView.prototype.isUILayout= true;
UIGridView.prototype.isUIGridView = true;
UIGridView.prototype.doToJson = UIGrid.prototype.doToJson;
UIGridView.prototype.doFromJson = UIGrid.prototype.doFromJson;
UIGridView.prototype.sortChildren = UIGrid.prototype.sortChildren;
UIGridView.prototype.initUIGrid = UIGrid.prototype.initUIGrid;
UIGridView.prototype.shapeCanBeChild = UIGrid.prototype.shapeCanBeChild;
UIGridView.prototype.childIsBuiltin = UIGrid.prototype.childIsBuiltin;
UIGridView.prototype.paintSelfOnly = UIGrid.prototype.paintSelfOnly;
UIGridView.prototype.calcItemSize = UIGrid.prototype.calcItemSize;
UIGridView.prototype.relayoutChildren = UIGrid.prototype.relayoutChildren;
UIGridView.prototype.afterChildAppended = UIGrid.prototype.afterChildAppended;
UIGridView.prototype.isInDeleteMode = UIGrid.prototype.isInDeleteMode;
UIGridView.prototype.beforePaintChild = UIGrid.prototype.beforePaintChild;
UIGridView.prototype.afterPaintChild = UIGrid.prototype.afterPaintChild;
UIGridView.prototype.triggerDeleteMode = UIGrid.prototype.triggerDeleteMode;
UIGridView.prototype.setCheckable = UIGrid.prototype.setCheckable;
UIGridView.prototype.setChildChecked = UIGrid.prototype.setChildChecked;
UIGridView.prototype.isChildChecked = UIGrid.prototype.isChildChecked;

UIGridView.prototype.initUIGridView = function(type) {
	this.initUIGrid(type);
	this.initUIVScrollView(type, 0, null, null);	
	this.setImage(UIElement.IMAGE_DELETE_ITEM, null);
	this.setImage(UIElement.IMAGE_CHECKED_ITEM, null);

	return this;
}

UIGridView.prototype.onModeChanged = function() {
	this.offset = 0;

	return;
}

function UIGridViewCreator() {
	var args = ["ui-grid-view", "ui-grid-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGridView();
		return g.initUIGridView(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGridViewCreator());

/*
 * File:   ui-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Use image to present a value, such as sound volume/battery status.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIImageValue
 * @extends UIElement
 * 用图片来表示数值。调用setValue来切换图片。
 */
function UIImageValue() {
	return;
}

UIImageValue.prototype = new UIImage();
UIImageValue.prototype.isUIImageValue = true;

UIImageValue.prototype.initUIImageValue = function(type, w, h) {
	this.initUIImage(type, w, h, null);	
	this.value = 0;

	return this;
}

UIImageValue.prototype.getImageSrcByValue = function(value) {
	var type = "option_image_" + value; 

	return this.getImageSrcByType(type);
}

UIImageValue.prototype.getValue = function() {
	return this.value;
}

UIImageValue.prototype.setValue = function(value) {
	var src = this.getImageSrcByValue(value);

	if(src) {
		this.value = value;
		this.setImage(UIElement.IMAGE_DEFAULT, src);
	}

	return this.value;
}

UIImageValue.prototype.inc = function() {
	var value = this.value + 1;

	return this.setValue(value);	
}

UIImageValue.prototype.dec = function() {
	var value = this.value - 1;

	return this.setValue(value);	
}

UIImageValue.prototype.getImages = function() {
	var str = "";
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter && iter.src) {
			str += iter.src + "\n";
		}
	}

	return str;
}

UIImageValue.prototype.setImages = function(value) {
	var display = this.images.display;
	this.images = {};
	this.images.display = display;

	if(value) {
		var i = 0;
		var k = 0;
		var arr = value.split("\n");

		for(var i = 0; i < arr.length; i++) {
			var iter = arr[i];
			if(!iter) continue;

			if(iter.indexOf("/") === 0) {
				iter = iter.substr(1);
			}

			var name = "option_image_" + (k++);
			this.setImage(name, iter);
		}

		this.setValue(this.value);
	}
	
	return this;
}

UIImageValue.prototype.shapeCanBeChild = function(shape) {
	return false;
}


function UIImageValueCreator(w, h, defaultImage) {
	var args = ["ui-image-value", "ui-image-value", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageValue();
		return g.initUIImageValue(this.type, w, h, defaultImage);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageValueCreator(200, 200, null));
/*
 * File:   ui-image-thumb-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Thumb Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageThumbView() {
	return;
}

UIImageThumbView.prototype = new UIImageView();
UIImageThumbView.prototype.isUIImageThumbView = true;

UIImageThumbView.prototype.saveProps = ["keepRatio", "itemSize"];
UIImageThumbView.prototype.initUIImageThumbView = function(w, h) {
	this.userImages = [];
	this.imageProxies = [];

	this.itemSize = 0;
	this.setDefSize(w, h);
	this.initUIImageView(w, h);

	this.setItemSize = UIImageThumbView.prototype.setItemSize;
	this.getCacheCanvas        = UIImageThumbView.prototype.getCacheCanvas;
	this.getCacheCanvasContext = UIImageThumbView.prototype.getCacheCanvasContext;
	this.setValue              = UIImageThumbView.prototype.setValue;
	this.getCurrentImage       = UIImageThumbView.prototype.getCurrentImage;
	this.getCurrentImageSrc    = UIImageThumbView.prototype.getCurrentImageSrc;

	imageThumbViewInitCustomProp(this);
	this.errorImage = UIImageView.createImage("drawapp8/images/common/failed.png", null);
	this.loadingImage = UIImageView.createImage("drawapp8/images/common/loading.png", null);
	this.addEventNames(["onChanged"]);

	return this;
}

UIImageThumbView.prototype.setItemSize = function(itemSize) {
	this.itemSize = itemSize ? itemSize : 100;

	if(itemSize) {
		this.setSizeLimit(100, itemSize + 10, 2000, 2000);
	}

	return;
}

UIImageThumbView.prototype.setKeepRatio = function(keepRatio) {
	if(this.keepRatio != keepRatio) {
		this.cacheInvalid = true;
	}

	this.keepRatio = keepRatio;

	return;
}

UIImageThumbView.prototype.getCacheCanvasContext = function(w, h) {
	if(!this.cacheImagesCanvas) {
		canvas = document.createElement("canvas");
		canvas.width = w;
		canvas.height = h;

		this.cacheImagesCanvas = canvas;
	}

	if(canvas.width != w) {
		canvas.width = w;
	}

	if(canvas.height != h) {
		canvas.height = h;
	}

	var ctx = canvas.getContext("2d");

	ctx.clearRect(0, 0, w, h);

	return ctx;
}

UIImageThumbView.prototype.getCurrentImageSrc = function() {
	return this.currentImageProxy ? this.currentImageProxy.src : null;
}

UIImageThumbView.prototype.getCurrentImage = function() {
	return this.currentImageProxy ? this.currentImageProxy.image : null;
}

UIImageThumbView.prototype.setValue = function(src) {
	for(var i = 0; i < this.imageProxies.length; i++) {
		var iter = this.imageProxies[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			this.currentImageProxy = iter;
			return this;
		}
	}

	return this;
}

UIImageThumbView.createImageProxy = function(thumbview, src, loadingImage, errorImage, ctxToDraw, x, y, w, h) {
	var imageProxy = {};

	imageProxy.x = x;
	imageProxy.y = y;
	imageProxy.w = w;
	imageProxy.h = h;
	imageProxy.src = src;
	imageProxy.imageState = UIImageView.IMAGE_STATE_PENDING;

	function onLoadDone(image, result) {
		var keepRatio = thumbview.keepRatio;

		if(result) {
			imageProxy.imageState = UIImageView.IMAGE_STATE_DONE;
			UIImageView.drawImageAtCenter(ctxToDraw, image, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
		}
		else {
			imageProxy.imageState = UIImageView.IMAGE_STATE_ERROR;
			UIImageView.drawImageAtCenter(ctxToDraw, errorImage, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
		}

		console.log("onLoadDone: " + image.src);
		thumbview.postRedraw();	
	}

	imageProxy.image = UIImageView.createImage(src, onLoadDone);

	if(imageProxy.imageState === UIImageView.IMAGE_STATE_PENDING) {
		var keepRatio = thumbview.keepRatio;	
		UIImageView.drawImageAtCenter(ctxToDraw, loadingImage, imageProxy.x, imageProxy.y, imageProxy.w, imageProxy.h, keepRatio);
	}

	return imageProxy;
}

UIImageThumbView.prototype.createCacheCanvas = function() {
	
}

UIImageThumbView.prototype.getCacheCanvas = function() {
	if(this.cacheInvalid || !this.cacheImagesCanvas) {
		this.createCacheCanvas();
	}

	return this.cacheImagesCanvas;
}

/////////////////////////////////////////////////////////////////////////}-{

function UIImageThumbViewTape() {
	return;
}

UIImageThumbViewTape.prototype = new UIHScrollView();

UIImageThumbViewTape.prototype.isUIImageView = true;
UIImageThumbViewTape.prototype.isUIImageThumbView = true;
UIImageThumbViewTape.prototype.isUIImageThumbViewTape = true;

UIImageThumbViewTape.prototype.initUIImageView = UIImageView.prototype.initUIImageView;
UIImageThumbViewTape.prototype.initUIImageThumbView = UIImageThumbView.prototype.initUIImageThumbView;

UIImageThumbViewTape.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIImageThumbViewTape.prototype.initUIImageThumbViewTape = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	
	this.initUIImageThumbView (w, h);

	this.heightAttr = UIElement.HEIGHT_FIX;

	return this;
}

UIImageThumbViewTape.prototype.getSpaceBetweenImages = function() {
	return this.spaceBetweenImages ? this.spaceBetweenImages : 2;
}

UIImageThumbViewTape.prototype.createCacheCanvas = function() {
	var space = this.getSpaceBetweenImages();
	var w = this.w;
	var h = this.h;
	var size = (this.itemSize > 0 && this.itemSize < h) ? this.itemSize : h;

	var canvas = this.cacheImagesCanvas;
	var n = this.userImages.length;
	
	delete this.cacheInvalid;
	this.imageProxies.clear();
	this.currentImageProxy = null;

	if(!n) {
		return;
	}

	w = n * (size + space);

	var x = 0; 
	var y = Math.floor((h - size)/2);
	var errorImage = this.errorImage;
	var loadingImage = this.loadingImage;
	var ctx = this.getCacheCanvasContext(w, h);

	for(var i = 0; i < this.userImages.length; i++) {
		var src = this.userImages[i];
		
		var imageProxy = UIImageThumbView.createImageProxy(this, src, loadingImage, errorImage, ctx, x, y, size, size);
		this.imageProxies.push(imageProxy);
		
		x = x + size + space;
	}

	return;
}

UIImageThumbViewTape.prototype.getScrollRange = function() {
	var size = this.h;
	var space = this.getSpaceBetweenImages();
	var range = this.userImages.length * (size + space) + space;

	return range;
}

UIImageThumbViewTape.prototype.paintChildren = function(canvas) {
	return;
}

UIImageThumbViewTape.prototype.getCacheCanvasOffset = function() {
	var offset = Math.max(0, (this.w - this.cacheImagesCanvas.width)/2);

	return offset;
}

UIImageThumbViewTape.prototype.onClick = function(point, beforeChild) {
	if(!this.imageProxies || !this.imageProxies.length || beforeChild) {
		return;
	}

	this.currentImageProxy = null;
	var x = point.x - this.getCacheCanvasOffset();

	for(var i = 0; i < this.imageProxies.length; i++) {
		var iter = this.imageProxies[i];
		if(x >= iter.x && x < (iter.x + iter.w)) {
			this.currentImageProxy = iter;	
		}
	}
	
	this.callOnClickHandler(point);
	this.callOnChangedHandler(this.getCurrentImageSrc());

	return;
}

UIImageThumbViewTape.prototype.paintSelfOnly = function(canvas) {
	if(!this.userImages || !this.userImages.length || !this.getCacheCanvas()) {
		canvas.rect(0, 0, this.w, this.h);
		canvas.stroke();

		return;
	}

	var w = 0;
	var y = 0;
	var h = this.h;
	var selfW = this.w;
	var cacheCanvas = this.getCacheCanvas();
	var cacheCanvasOffset = this.getCacheCanvasOffset();
	var x = cacheCanvasOffset;

	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();
	canvas.beginPath();

	if(this.offset >= 0) {
		if(x > this.offset) {
			x = x-this.offset;
			var w = cacheCanvas.width;
			canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, x, y, w, h);
			cacheCanvasOffset = x;
		}
		else {
			var offset = this.offset - x; 
			var w = Math.min(selfW, cacheCanvas.width-offset);
			canvas.drawImage(this.cacheImagesCanvas, offset, 0, w, h, 0, y, w, h);
			cacheCanvasOffset = -offset;
		}
	}
	else {
		x = x-this.offset;
		var w = Math.min(selfW+this.offset, cacheCanvas.width);
		canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, x, y, w, h);
		cacheCanvasOffset = x;
	}

	if(this.currentImageProxy) {
		x = cacheCanvasOffset + this.currentImageProxy.x;
		y = this.currentImageProxy.y;

		canvas.lineWidth = 3;
		canvas.rect(x, y, this.currentImageProxy.w, this.currentImageProxy.h);
		canvas.stroke();
	}

	return;
}

function UIImageThumbViewTapeCreator() {
	var args = ["ui-image-thumb-view-tape", "ui-image-thumb-view-tape", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageThumbViewTape();

		return g.initUIImageThumbViewTape(this.type, 300, 100);
	}
	
	return;
}

/////////////////////////////////////////////////////////////////////////}-{

function UIImageThumbViewGrid() {
	return;
}

UIImageThumbViewGrid.prototype = new UIHScrollView();

UIImageThumbViewGrid.prototype.isUIImageView = true;
UIImageThumbViewGrid.prototype.isUIImageThumbView = true;
UIImageThumbViewGrid.prototype.isUIImageThumbViewGrid = true;

UIImageThumbViewGrid.prototype.initUIImageView = UIImageView.prototype.initUIImageView;
UIImageThumbViewGrid.prototype.initUIImageThumbView = UIImageThumbView.prototype.initUIImageThumbView;

UIImageThumbViewGrid.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIImageThumbViewGrid.prototype.initUIImageThumbViewGrid = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	
	this.initUIImageThumbView (w, h);
	this.setSizeLimit(100, 40, 2000, 2000);

	this.rows = 4;
	this.cols = 3;
	this.pageNr = 1;
	this.itemSize = 100;

	return this;
}

UIImageThumbViewGrid.prototype.calcSize = function() {
	if(!this.userImages) {
		return;
	}

	if(this.isIcon) {
		this.cols = 3;
		this.rows = 4;
		this.pageNr = 1;

		return;
	}

	var n = this.userImages.length;
	var deviceConfig = this.getDeviceConfig();
	var density = deviceConfig ? deviceConfig.lcdDensity : "hdpi";
	var densityScale = this.getDensitySizeByName(density)/160;
	var w = this.w/densityScale;
	var h = this.h/densityScale;

	var cols = Math.round(w/this.itemSize);
	var rows = Math.round(h/this.itemSize);

	this.cols = cols;
	this.rows = rows;
	this.pageNr = Math.ceil(n/(rows*cols));

	return;
}

UIImageThumbViewGrid.prototype.getSpaceBetweenImages = function() {
	return this.spaceBetweenImages ? this.spaceBetweenImages : 2;
}

UIImageThumbViewGrid.prototype.createCacheCanvas = function() {
	var n = this.userImages.length;
	var space = this.getSpaceBetweenImages();

	delete this.cacheInvalid;
	this.imageProxies.clear();
	this.currentImageProxy = null;

	this.calcSize();

	if(!n) {
		return;
	}

	var x = 0;
	var y = 0;
	var k = 0;
	var h = this.h;
	var w = this.pageNr * this.w;
	var ctx = this.getCacheCanvasContext(w, h);
	var itemW = Math.floor((this.w-space)/this.cols) - space;
	var itemH = Math.floor((this.h-space)/this.rows) - space;

	var errorImage = this.errorImage;
	var loadingImage = this.loadingImage;

	for(var i = 0; i < this.pageNr; i++) {
		y = space;
		for(var r = 0; r < this.rows; r++) {
			x = i * this.w + space;
			for(var c = 0; c < this.cols; c++, k++) {
				if(k >= n) {
					break;
				}

				var src = this.userImages[k];
				var imageProxy = UIImageThumbView.createImageProxy(this, src, loadingImage, errorImage, ctx, x, y, itemW, itemH);

				this.imageProxies.push(imageProxy);

				x = x + itemW + space;
			}
			y = y + itemH + space;
		}
	}

	return;
}

UIImageThumbViewGrid.prototype.getScrollRange = function() {
	var range = this.pageNr * this.w;

	return range;
}

UIImageThumbViewGrid.prototype.paintChildren = function(canvas) {
	return;
}

UIImageThumbViewGrid.prototype.getCacheCanvasOffset = function() {
	return this.getSpaceBetweenImages();
}

UIImageThumbViewGrid.prototype.onClick = function(point, beforeChild) {
	if(!this.imageProxies || !this.imageProxies.length || beforeChild) {
		return;
	}

	var x = point.x;
	var y = point.y;
	var n = this.imageProxies.length;

	var page = Math.floor(x/this.w);
	var row = Math.floor(y*this.rows/this.h) ;
	var col = Math.floor((x%this.w) * this.cols/this.w);
	var i = page * this.rows * this.cols + row * this.cols + col;

	if(i < n) {
		this.currentImageProxy = this.imageProxies[i];
	}

	this.callOnClickHandler(point);
	this.callOnChangedHandler(this.getCurrentImageSrc());

	return this.callOnClickHandler(point);
}

UIImageThumbViewGrid.prototype.paintSelfOnly = function(canvas) {
	var space = this.getSpaceBetweenImages();
	if(!this.userImages || !this.userImages.length || !this.getCacheCanvas()) {
		canvas.rect(0, 0, this.w, this.h);
		canvas.stroke();

		return;
	}

	var w = 0;
	var selfW = this.w;
	var offset = this.offset;
	var cacheCanvas = this.getCacheCanvas();

	var h = cacheCanvas.height;
	var canvasWidth = cacheCanvas.width;

	if(offset >= 0) {
		var w = Math.min(selfW, canvasWidth-offset);
		canvas.drawImage(this.cacheImagesCanvas, offset, 0, w, h, 0, 0, w, h);
	}
	else {
		var w = Math.min(canvasWidth+offset, selfW);
		canvas.drawImage(this.cacheImagesCanvas, 0, 0, w, h, -offset, 0, w, h);
	}

	if(this.currentImageProxy) {
		y = this.currentImageProxy.y;
		x = this.currentImageProxy.x - offset;

		canvas.rect(x, y, this.currentImageProxy.w, this.currentImageProxy.h);
		canvas.lineWidth = 3;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();

	}

	return;
}

UIImageThumbViewGrid.prototype.saveProps = UIImageThumbView.prototype.saveProps;
UIImageThumbViewTape.prototype.saveProps = UIImageThumbView.prototype.saveProps;

function UIImageThumbViewGridCreator() {
	var args = ["ui-image-thumb-view-grid", "ui-image-thumb-view-grid", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageThumbViewGrid();

		return g.initUIImageThumbViewGrid(this.type, 300, 100);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIImageThumbViewTapeCreator());
ShapeFactoryGet().addShapeCreator(new UIImageThumbViewGridCreator());

/*
 * File:   ui-layout.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Layout
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

function UILayout() {
	return;
}

UILayout.prototype = new UIElement();
UILayout.prototype.isUILayout = true;

UILayout.prototype.initUILayout = function(type, w, h) {
	this.initUIElement(type);	

	this.spacer = 10;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);
	this.vLayout = (this.type === "ui-v-layout");
	this.addEventNames(["onInit"]);

	return this;
}

UILayout.prototype.relayoutChildren = function() {
	if(this.disableRelayout) {
		return;
	}

	var w = this.w;
	var h = this.h;
	var x = this.hMargin;
	var y = this.vMargin;
	var vLayout = this.vLayout;
	var spacer = this.spacer ? this.spacer : 0;

	var n = this.children.length;
	var children = this.children;
	for(var i = 0; i < n; i++) {
		var iter = children[i];

		if(!iter.isVisible()) {
			continue;
		}

		if(vLayout) {
			iter.top = y;
			iter.left = (w - iter.w) >> 1;

			if(iter.heightAttr === UIElement.HEIGHT_SCALE) {
				iter.h = iter.heightParam * h; 
			}
			y += iter.h + spacer;
		}
		else {
			iter.left = x;
			iter.top = (h - iter.h) >> 1;
			if(iter.widthAttr === UIElement.WIDTH_SCALE) {
				iter.w = iter.widthParam * w;
			}

			x += iter.w + spacer;
		}
		
		iter.relayoutChildren();
	}
	
	return;
}

function UILayoutCreator(type) {
	var args = [type, type, null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILayout();

		return g.initUILayout(this.type, 100, 100);
	}
	
	return;
}

UILayout.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

ShapeFactoryGet().addShapeCreator(new UILayoutCreator("ui-v-layout"));
ShapeFactoryGet().addShapeCreator(new UILayoutCreator("ui-h-layout"));

/*
 * File:   ui-frames.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Frames
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIFrames
 * @extends UIElement
 * 用来管理多个子控件，但是只有一个显示出来。
 *
 */
function UIFrames() {
	return;
}

UIFrames.prototype = new UIElement();
UIFrames.prototype.isUIFrames = true;
UIFrames.prototype.saveProps = ["current"];

UIFrames.prototype.initUIFrames = function(type) {
	this.initUIElement(type);	

	this.current = 0;
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.addEventNames(["onChanged"]);

	return this;
}

UIFrames.preparseBackendCanvas = function(leftWin, RightWin) {
	var w = leftWin.w;
	var h = leftWin.h;
	var backendCanvas = Animation.getBackendCanvas(2 * w, h);
	var context = backendCanvas.getContext("2d");
	context.now = Date.now();
	context.timeStep = 0;
	context.clearRect(0, 0, 2*w, h);
	context.save();
	leftWin.paint(context);
	context.translate(w, 0);
	RightWin.paint(context);
	context.restore();

	return backendCanvas;
}

UIFrames.prototype.getStatusString = function() {
	var str = "";
	var current = this.current + 1;
	var n = this.children.length;
	var frame = this.getCurrentFrame();

	current = current <= n ? current : n;
	if(frame && frame.name) {
		str = frame.name + "(" + current + "/" + n + ")";
	}
	else {
		str = current + "/" + n;
	}

	return str;
}

/**
 * @method getCurrent
 * 获取当前显示的子控件的索引。
 * @return {Number} 当前显示的子控件的索引。
 *
 */
UIFrames.prototype.getCurrent = function() {
	return this.current;
}


/**
 * @method setCurrent
 * 设置当前显示的子控件。
 * @param {Number} current 当前显示的子控件的索引。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrames.prototype.setCurrent = function(current) {
	if(this.current !== current) {
		this.current = current;
		
		if(!this.isInDesignMode()) {
			this.callOnChangedHandler(current);
		}
	}

	return this;
}

UIFrames.prototype.getCurrentFrame = function() {
	if(this.children.length < 1) {
		return null;
	}

	if(this.current < 0 || !this.current) {
		this.current = 0;
	}

	if(this.current >= this.children.length) {
		this.current = this.children.length - 1;
	}

	return this.children[this.current];
}

UIFrames.prototype.fixChildSize = function(child) {
	return;
}

UIFrames.prototype.fixChildPosition = function(child) {
	var x = child.left;
	var y = child.top;
	var h = child.h;
	var w = child.w;

	if(child.freePosition) {
		return;
	}
	
	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		x = this.getHMargin();
		w = this.getWidth(true);
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		y = this.getVMargin();
		h = this.getHeight(true);
	}
	
	child.left = x;
	child.top = y;
	child.h = h;
	child.w = w;

	return;
}

UIFrames.prototype.setTarget = function(shape) {
	for(var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		if(!shape) {
			child.setSelected(false);
			continue;
		}

		if(child != shape && child != shape.popupWindow) {
			child.setSelected(false);
		}
	}

	this.targetShape = shape;
	this.selected = !shape;

	return;
}
UIFrames.prototype.dispatchPointerDownToChildren = function(p) {
	var child = null;

	if(this.children.length < 1) {
		return false;
	}

	child = this.getCurrentFrame();

	if(child.onPointerDown(p)) {
		this.setTarget(child);

		return true;
	}

	return false;
}

UIFrames.prototype.addShapeIntoChildren = function(shape, p) {
	var child = null;

	if(this.children.length < 1) {
		return false;
	}

	child = this.getCurrentFrame();

	return child.addShape(shape, true, p);
}

UIFrames.prototype.paintChildren = function(canvas) {
	var child = this.getCurrentFrame();
	
	if(child) {
		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}
	
	return;
}

UIFrames.prototype.showNextFrame = function() {
	this.showFrame(this.current+1);
	this.relayoutChildren();

	return;
}

UIFrames.prototype.getFrame = function(index) {
	if(index < 0 || index >= this.children.length) {
		return null;
	}

	return this.children[index];
}

UIFrames.prototype.getFrameIndex = function(frame) {
	return this.getIndexOfChild(frame);
}

UIFrames.prototype.getFrames = function() {
	return this.children.length;
}

UIFrames.prototype.showPrevFrame = function() {
	this.showFrame(this.current-1);
	this.relayoutChildren();

	return;
}

UIFrames.prototype.showFrame = function(index) {
	var current = (index + this.children.length)%this.children.length;
	this.setCurrent(current);
	
	var currentFrame = this.children[this.current];
	if(currentFrame) {
		currentFrame.show(true);
	}

	return;
}

UIFrames.prototype.shapeCanBeChild = function(shape) {
	return true;
}

UIFrames.prototype.relayoutChildren = function() {

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];

		iter.left = 0;
		iter.top = 0;
		iter.w = this.w;
		iter.h = this.h;
		iter.widthAttr = UIElement.WIDTH_FILL_PARENT;
		iter.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		iter.relayoutChildren();
	}

	return;
}

UIFrames.prototype.afterChildAppended = function(shape) {
	this.current = this.children.length - 1;

	return;
}

UIFrames.prototype.onChildRemoved = function(shape) {
	return;
}

UIFrames.prototype.afterChildRemoved = function(shape) {
	if(this.children.length === 0) {
		this.current = 0;
	}
	else if(this.current >= this.children.length) {
		this.current--;
	}

	this.onChildRemoved(shape);

	return;
}

UIFrames.prototype.findChildByPoint = function(point, recursive) {
	var p = point;
	var curFrame = this.getCurrentFrame();

	if(curFrame) {
		var ret = curFrame.findChildByPoint(p, recursive);	
	    if(ret === curFrame && !curFrame.hitTest(p)) {
            return this;
        }
        return ret;
    }

	return this;
}


function UIFramesCreator() {
	var args = ["ui-frames", "ui-frames", null, 0];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFrames();

		return g.initUIFrames(this.type);
	}
	
	return;
}
/*
 * File:   ui-check-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Check Box
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICheckBox
 * @extends UIElement
 * 多选按钮。可以用setValue来勾选/去勾选，用getValue来判断是否勾选。
 *
 */

/**
 * @event onChanged
 * 勾选状态变化时触发本事件。
 * @param {Boolean} value true表示勾选，false表示未勾选。
 */
function UICheckBox() {
	return;
}

UICheckBox.prototype = new UIElement();
UICheckBox.prototype.isUICheckBox = true;

UICheckBox.prototype.initUICheckBox = function(type) {
	this.initUIElement(type);	

	this.setDefSize(100, 100);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	this.setImage(UIElement.IMAGE_CHECKED_FG, null);
	this.setImage(UIElement.IMAGE_UNCHECK_FG, null);

	this.addEventNames(["onChanged", "onUpdateTransform"]);
	this.value = false;

	return this;
}

UICheckBox.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIImage || shape.isUILabel;
}

UICheckBox.prototype.getValue = function() {
	return this.value;
}

UICheckBox.prototype.setValue = function(value, notify) {
	if(this.value != value) {
		this.value = value;
		if(notify) {
			this.callOnChangedHandler(this.value);
		}
	}

	return this;
}

UICheckBox.prototype.getBgImage = function() {
	return this.getImageByType(this.getValue() ? UIElement.IMAGE_CHECKED_FG : UIElement.IMAGE_UNCHECK_FG);
}

UICheckBox.prototype.getTextColor = function(canvas) {
	return this.getValue() ? this.style.textColorOn : this.style.textColor;
}

UICheckBox.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	this.setValue(!this.getValue(), true);
	this.callOnClickHandler(point);

	return;
}

function UICheckBoxCreator() {
	var args = ["ui-checkbox", "ui-checkbox", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICheckBox();
		return g.initUICheckBox(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICheckBoxCreator());

/*
 * File:   ui-switch.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Switch
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISwitch() {
	return;
}

UISwitch.prototype = new UICheckBox();
UISwitch.prototype.isUISwitch = true;

UISwitch.prototype.initUISwitch = function(type, w, h, maskWidth, img) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, img);
	
	this.value = true;
	this.imageWidth = 412;
	this.maskWidth = maskWidth;
	this.offsetImage = maskWidth;
	this.addEventNames(["onChanged"]);
	this.interpolator =  new DecelerateInterpolator(2);

	return this;
}

UISwitch.prototype.updateImageSize = function(imageWidth) {
	this.imageWidth = imageWidth;
	this.maskWidth = Math.floor(imageWidth * 0.373786);

	if(!this.animating) {
		this.offsetImage = this.value ? this.maskWidth : (this.imageWidth - this.maskWidth);
	}

	return;
}

UISwitch.prototype.animateChange = function() {
	var switcher = this;
	var date  = new Date();
	var startTime = date.getTime();
	var startOffset = this.offsetImage;
	var endOffset = this.value ? this.maskWidth : (this.imageWidth - this.maskWidth);
	var range = endOffset - startOffset;
	this.animating = true;
	var duration = 500;
	function offsetIt() {
		var now = new Date();
		var nowTime = now.getTime();
		var timePercent = (nowTime - startTime)/duration;
		var percent = switcher.interpolator.get(timePercent);
		var offset = startOffset + range * percent;	

		if(timePercent < 1) {
			switcher.offsetImage = offset;
			setTimeout(offsetIt, 10);
		}
		else {
			switcher.offsetImage = endOffset;
			delete this.animating;
		}
		switcher.postRedraw();
		delete now;

		return;
	}
	
	setTimeout(offsetIt, 30);

	return;
}

UISwitch.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || !this.isInDesignMode()) {
		return;
	}
	this.setValue(!this.value);

	return;
}

UISwitch.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.pointerDownPosition = point;

	return;
}

UISwitch.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	var dx = point.x - this.pointerDownPosition.x;
	if(Math.abs(dx) < 5) {
		this.setValue(!this.value);
	}
	else {
		this.setValue(dx > 0);
	}

	return;
}

UISwitch.prototype.setValue = function(value) {
	if(this.value != value) {
		this.value = value;
		this.callOnChangedHandler(this.value);
		this.animateChange();
	}

	return this;
}

UISwitch.prototype.drawBgImage =function(canvas) {
	return;
}

UISwitch.prototype.drawFgImage =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(image) {
		this.updateImageSize(image.width);
		var h = image.height;
		var w = this.maskWidth;
		var dx = (this.w - w)/2;
		var dy = (this.h - h)/2;

		this.imageWidth = image.width;
		canvas.drawImage(image, this.offsetImage, 0, w, h, dx, dy, w, h);

		/*draw mask Image*/
		canvas.drawImage(image, 0, 0, w, h, dx, dy, w, h);
	}

	return;
}

function UISwitchCreator(w, h, maskWidth, img) {
	var args = ["ui-switch", "ui-switch", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISwitch();
		return g.initUISwitch(this.type, w, h, maskWidth, img);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISwitchCreator(154, 54, 154, null));

/*
 * File:   ui-simple-html.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Simple HTML View
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISimpleHTML() {
	return;
}

UISimpleHTML.prototype = new UIVScrollView();
UISimpleHTML.prototype.isUISimpleHTML = true;

UISimpleHTML.prototype.saveProps = ["scrollable"];
UISimpleHTML.prototype.initUISimpleHTML = function(type, initText, bg) {
	this.initUIVScrollView(type, 10, bg, null);	

	this.setText(initText);
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);

	return this;
}

UISimpleHTML.prototype.extractHtmlElements = function(el, indexInParent) {
	var i = 0;
	var node = null;
	var simpleHtml = this;
	var tag = el.localName;
	var n = el.childNodes.length;
	var childNodes = el.childNodes;

	function createNode(type) {
		var newNode = {x:0, y:0};
		newNode.type = type;

		return newNode;
	}

	if(tag === "b") {
		this.bold = this.bold + 1;	
	}
	else if(tag === "i") {
		this.italic = this.italic + 1;	
	}
	else if(tag === "u") {
		this.underline = this.underline + 1;	
	}
	else if(tag === "a") {
		this.anchor = this.anchor + 1;	
	}
	else if(tag === "ol" || tag === "ul") {
		if(indexInParent > 0) {
			node = createNode("newline");
		}
	}
	else if(tag === "li") {
		node = createNode("text");
		if(el.parentNode.localName === "ol") {
			node.value = "    " + (indexInParent+1) + ". ";
		}
		else {
			node.value = "    o. ";
		}
		node.bold = true;
		node.color = "gray";
		node.fontStyle = "bold ";
	}

	var color = null;

	if(el.style && el.style.color) {
		color = el.style.color;
	}
	if(!color && el.getAttribute) {
		color = el.getAttribute("color");
	}
	if(!color && this.colors.length) {
		color = this.colors[this.colors.length - 1];
	}
	this.colors.push(color || "black");

	if(node) {
		node.tag = tag;
		this.elements.push(node);
		node = null;
	}

	for(var i = 0; i < n; i++) {
		var iter = childNodes[i];
		this.extractHtmlElements(iter, i);
	}
	
	if(tag === "img" && el.src) {
		var src = el.src;
		var image = new Image();
		
		image.onload = function (e) {
			node.imageLoaded = true;
			simpleHtml.textNeedRelayout = true;

			return;
		};
	
		image.onerror = function (e) {
			node.imageLoaded = false;
			if(src) {
				console.log("load " + src + " failed.");
			}
		};

		image.onabort = function (e) {
			node.imageLoaded = false;
			if(src) {
				console.log("load " + src + " failed(abort).");
			}
		};
		
		image.src = src;
		node = createNode("img");
		node.value = image;
		node.displayWidth = el.width;
		node.displayHeight = el.height;
	}
	else if(!n && el.textContent) {
		var str = el.textContent.replace(/(\t|\n|\r)+/g, '');		
		var text = str.replace(/ +/g, ' ');

		if(text) {
			node = createNode("text");
			node.value = text;
			node.bold = this.bold;
			node.italic = this.italic;
			node.underline = this.underline;
			node.anchor = this.anchor;
			node.fontStyle = "";
			if(this.colors.length) {
				node.color = this.colors[this.colors.length-1];
			}

			if(node.bold) {
				node.fontStyle = node.fontStyle + "bold ";
			}

			if(node.italic) {
				node.fontStyle = node.fontStyle + "italic ";
			}
		}
	}

	if(tag === "b") {
		this.bold = this.bold - 1;	
	}
	if(tag === "i") {
		this.italic = this.italic - 1;	
	}
	if(tag === "u") {
		this.underline = this.underline - 1;	
	}
	if(tag === "a") {
		node = createNode("a");
		node.href = el.href;
		this.anchor = this.anchor - 1;	
	}

	if(tag === "p" || (el.style != null && el.style.display === "block")) {
		node = createNode("newblock");
	}
	else if(tag === "li" || tag === "br" || tag === "hr" || tag === "dd") {
		node = createNode("newline");
	}

	this.colors.pop();

	if(node) {
		node.tag = tag;
		this.elements.push(node);
	}

	return;
}


UISimpleHTML.prototype.getNodeByPoint = function(point) {
	var i = 0;
	var x = point.x;
	var y = point.y;
	var node = null;
	var next = null;
	var rect = {};
	var n = this.elements.length;
	var elements = this.elements;
	
	for(i = 0; i < n; i++) {
		node = elements[i];
		next = ((i + 1) < n) ?  elements[i+1] : null;		
		
		if(y < node.y) {
			continue;
		}
		
		if(next && (y > next.y && node.y < next.y)) {
			continue;
		}

		if(node.type === "text") {
			var k = 0;
			var m = node.lines.length;

			rect.h = node.lineHeight;
			for(k = 0; k < m; k++) {
				rect.x = 0;
				rect.y = node.y + k * node.lineHeight;

				if(k === 0) {
					rect.x = node.x;
					rect.w = node.firstLineWidth;
				}
				else if((k + 1) === m) {
					rect.w = node.lastLineWidth;
				}
				else {
					rect.w = this.w;
				}

				if(isPointInRect(point, rect)) {
					return node;
				}
			}
		}
		else if(node.type === "img") {
			rect.x = node.x;
			rect.y = node.y;
			rect.w = node.w;
			rect.h = node.h;

			if(isPointInRect(point, rect)) {
				return node;
			}
		}
	}

	return node;
}

UISimpleHTML.prototype.layoutHtmlElements = function(canvas) {
	var i = 0;
	var offsetX = 0;
	var offsetY = 0;
	var node = null;
	var lineWidth = 0;
	var lineInfo = null;
	var n = this.elements.length;
	var elements = this.elements;
	var width = this.getWidth(true);
	var fontSize = this.style.fontSize;
	var textLayout = new TextLayout(canvas);
	var fontStr = fontSize + "pt " + this.style.fontFamily; 
	var lineGap = fontSize * 2;
	
	canvas.font = fontStr;

	for(i = 0; i < n; i++) {
		node = elements[i];
		
		if(node.type === "text") {
			node.lines = [];
			node.x = offsetX;
			node.y = offsetY;
			node.firstLineWidth = 0;
			canvas.font = node.fontStyle + fontStr;
			node.lineHeight = lineGap;
			textLayout.setText(node.value);

			while(true) {
				lineWidth = width - offsetX;
				
				if(textLayout.hasNext()) {
					lineInfo = textLayout.nextLine(lineWidth, fontSize);
					node.lines.push(lineInfo.text);
					if(node.lines.length === 1) {
						node.firstLineWidth = lineInfo.width;
					}

					if(textLayout.hasNext()) {
						offsetX = 0;
						offsetY = offsetY + lineGap;
					}
					else {
						offsetX = offsetX + lineInfo.width;
						node.lastLineWidth = lineInfo.width;
						break;
					}
				}
				else {
					break;
				}
			}
		}
		else if(node.type === "newline") {
			node.x = offsetX;
			node.y = offsetY; 
			
			offsetX = 0;
			offsetY = offsetY + lineGap;
		}
		else if(node.type === "newblock") {
			node.x = offsetX;
			node.y = offsetY; 
			
			offsetX = 0;
			offsetY = offsetY + lineGap * 1.5;
		}
		else if(node.type === "img") {
			if(node.imageLoaded) {
				var image = node.value;
				var ratio = image.height/image.width;
				var imageW = node.displayWidth ? node.displayWidth : image.width;
				var imageH = node.displayHeight ? node.displayHeight : image.height;

				node.y = offsetY + lineGap * 0.5;
				
				if(imageW < width) {
					node.w = imageW;
					node.x = Math.floor((width - imageW)/2);
					node.h = Math.floor(node.w * ratio);
				}
				else {
					node.x = 0;
					node.w = width;
					node.h = Math.floor(node.w * ratio);
				}
			
				offsetY = node.y + node.h;
				offsetY = offsetY + 0.5 * lineGap;
			}
			else {
				offsetY = offsetY + lineGap;
			}
			offsetX = 0;
		}

		this.scrollRange = offsetY;
	}

	return;
}

UISimpleHTML.prototype.getScrollRange = function() {
	return this.scrollRange ? this.scrollRange : this.h;	
}


UISimpleHTML.prototype.loadUrl = function(dataUrl, onLoadDone) {
	var rInfo = {};
	var shape = this;

	rInfo.method = "GET";
	rInfo.url = dataUrl;
	rInfo.headers = {"Cache-Control":"no-cache", "Pragma":"no-cache"};

	rInfo.onDone = function(result, xhr, respContent) {
		var success = (xhr.status === 200);
		if(xhr.status === 200) {
			var data = respContent;
			try {
				shape.setText(data);
				console.log("loadUrl: done");
			}
			catch(e) {
				success = false;
				console.log("loadUrl: failed" + e.message);
			}
		}
		
		if(onLoadDone) {
			onLoadDone(success);
		}

		return;
	}

	httpDoRequest(rInfo);

	return;
}

UISimpleHTML.prototype.setText = function(text) {
	this.text = this.toText(text);

	this.elements = [];
	var el = document.createElement("div");
	el.innerHTML = this.text;
	
	this.bold = 0;
	this.anchor = 0;
	this.italic = 0;
	this.underline = 0;
	this.strong = 0;
	this.colors = [];
	
	this.extractHtmlElements(el, 0);

	delete this.colors;
	delete this.anchor;
	delete this.bold;
	delete this.italic;
	delete this.underline;
	delete this.strong;

	this.textNeedRelayout = true;

	return;
}

UISimpleHTML.prototype.layoutHtml = function(canvas) {
	if(!this.textNeedRelayout) {
		return;
	}

	if(!this.text) {
		return;
	}

	this.layoutHtmlElements(canvas);

	this.textNeedRelayout = false;

	return;
}

UISimpleHTML.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UISimpleHTML.prototype.paintSelfOnly = function(canvas) {
	var i = 0;
	var x = 0;
	var y = 0;
	var b = 0;
	var h = this.h;
	var w = this.w;
	var node = null;
	var hMargin = this.hMargin;
	var width = this.getWidth(true);
	var fontSize = this.style.fontSize;	
	var lineGap = 2 * fontSize;
	var offsetX = this.hMargin;
	var offsetY = -this.offset + this.vMargin;
	var fontStr = fontSize + "pt " + this.style.fontFamily; 

	this.layoutHtml(canvas);

	canvas.save();
	canvas.rect(0, 0, w, h);
	canvas.clip();

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}
	canvas.beginPath();

	canvas.font = fontStr;
	canvas.textAlign = "left";
	canvas.textBaseline = "top";
	canvas.fillStyle = this.style.textColor;	

	var n = this.elements.length;
	var elements = this.elements;

	for(i = 0; i < n; i++) {
		node = elements[i];
		if(node.type === "text" && node.lines && node.lines.length) {
			var size = node.lines.length;
			canvas.font = node.fontStyle + fontStr;
			
			if(node.color) {
				canvas.fillStyle = node.color;
			}
			else if(node.anchor) {
				canvas.fillStyle = "Blue";
			}
			else {
				canvas.fillStyle = this.style.textColor;	
			}

			for(k = 0; k < size; k++) {
				if(k === 0) {
					x = node.x;
					y = node.y;
				}
				else {
					x = 0;
					y = node.y + k * (lineGap);
				}

				x = x + offsetX;
				y = y + offsetY;
				b = y + fontSize;
				if(y < h && b >=0) {
					width = w - x - hMargin;
					canvas.fillText(node.lines[k], x, y, width);
				}
			}
		}
		else if(node.type === "img" && node.imageLoaded) {
			var image = node.value;
			var imageW = image.width;
			var imageH = image.height;

			x = node.x + offsetX;
			y = node.y + offsetY;
			
			b = y + node.h;
			if(y < h && b >=0) {
				canvas.drawImage(image, 0, 0, imageW, imageH, x, y, node.w, node.h);
			}
		}
	}
	canvas.restore();

	return;
}

function UISimpleHTMLCreator() {
	var args = ["ui-simple-html", "ui-simple-html", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISimpleHTML();
		var initDoc = 'Simpe HTML';

		return g.initUISimpleHTML(this.type, initDoc, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISimpleHTMLCreator());

/*
 * File:   ui-html-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  HTML View
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIHtmlView() {
	return;
}

UIHtmlView.prototype = new UIHtml();
UIHtmlView.prototype.isUIHtmlView = true;

UIHtmlView.prototype.getHtmlContent = function() {
	var html = "<p>hello html view";
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	var url = this.getUrl();
	var content = this.getValue();

	if(url) {
		html = '<iframe seamless="seamless" scrolling="yes" width="'+w+'" height="'+h+'" src="'+url+'"></iframe>';
	}
	else if(content) {
		html = content;
	}

	return html;
}

UIHtmlView.prototype.setText = function(text) {
	this.text = text;

	return;
}


UIHtmlView.prototype.getValue = function() {
	return this.text ? this.text : "";
}

UIHtmlView.prototype.setValue = function(text) {
	this.text = text;

	return;
}

UIHtmlView.prototype.getUrl = function() {
	return this.url ? this.url : "";
}

UIHtmlView.prototype.setUrl = function(url) {
	this.url = url;

	return;
}

UIHtmlView.prototype.paintSelfOnly = function(canvas) {
	if(!this.htmlVisible) {
		var x = this.w >> 1;
		var y = this.h >> 1;
		var str = dappGetText("HtmlView");
		canvas.textBaseline = "middle";
		canvas.textAlign = "center";
		canvas.font = this.style.getFont();
		canvas.fillStyle = this.style.textColor;
		canvas.fillText(str, x, y);
	}

	return;
}

UIHtmlView.prototype.initUIHtmlView = function(type) {
	this.initUIHtml(type, 400, 300);
	this.setValue("<p>hello html view");
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setScrollable(true);

	return this;
}

function UIHtmlViewCreator() {
	var args = ["ui-html-view", "ui-html-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIHtmlView();
		return g.initUIHtmlView(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIHtmlViewCreator());


/*
 * File:   ui-button-group.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Button Group
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIButtonGroup() {
	return;
}

UIButtonGroup.prototype = new UIElement();
UIButtonGroup.prototype.isUIButtonGroup = true;

UIButtonGroup.prototype.initUIButtonGroup = function(type, border, buttonMaxWidth, bg) {
	this.initUIElement(type);	

	this.setMargin(border, border);
	this.setDefSize(300, 60);
	this.setSizeLimit(100, 40, 1000, 120);

	this.buttonMaxWidth = buttonMaxWidth;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT; 
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.rectSelectable = false;
	this.addEventNames(["onInit"]);

	if(!bg) {
		this.style.setFillColor("White");
	}

	return this;
}

UIButtonGroup.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton || shape.isUIGroup || shape.isUIRadioBox || shape.isUICheckBox) {
		return true;
	}

	return false;
}

UIButtonGroup.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

UIButtonGroup.prototype.relayoutChildren = function() {
	var hMargin = this.getHMargin();
	var vMargin = this.getVMargin();
	var n = this.children.length;

	if(n === 0 || this.disableRelayout) {
		return;
	}

	var x = hMargin;
	var y = vMargin;

	var h = this.h - 2 * vMargin;
	var maxWidth = this.buttonMaxWidth;
	var defaultWidth = Math.floor((this.w - 2 * hMargin)/n);
	var w = Math.min(defaultWidth, maxWidth);

	for(var i = 0; i < n; i++) {
		var child = this.children[i];
		
		x = i * defaultWidth + (defaultWidth - w)/2 + hMargin;

		child.setLeftTop(x, y);
		child.setSize(w, h);
		child.setUserMovable(false);
		child.setUserResizable(false);
		child.relayoutChildren();
	}
	
	this.w = defaultWidth * n + 2 * hMargin;

	return;
}

UIButtonGroup.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return true;
}

function UIButtonGroupCreator(border, buttonMaxWidth, bg) {
	var args = ["ui-button-group", "ui-button-group", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIButtonGroup();
		return g.initUIButtonGroup(this.type, border, buttonMaxWidth, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIButtonGroupCreator(5, 200, null));

/*
 * File:   ui-color-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Color Bar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIColorBar
 * @extends UIElement
 * 颜色线条，一般用于装饰。
 *
 */
function UIColorBar() {
	return;
}

UIColorBar.prototype = new UIElement();
UIColorBar.prototype.isUIButton = false;
UIColorBar.prototype.isUIColorBar = true;

UIColorBar.prototype.saveProps = ["barPosition"];
UIColorBar.prototype.initUIColorBar = function(type, w, h) {
	this.initUIElement(type);	

	this.setBarPosition(0);
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);
	this.barDierction = 0;

	return this;
}

UIColorBar.prototype.setBarDirection = function(direction) {
	this.barDirection = direction;

	return this;
}

UIColorBar.prototype.getBarDirection = function() {
	return this.barDirection;
}

UIColorBar.prototype.setBarPosition = function(position) {
	this.barPosition = position;

	return this;
}

UIColorBar.prototype.getBarPosition = function() {
	return this.barPosition;
}

UIColorBar.prototype.shapeCanBeChild = function(shape) {

	return shape.isUIImage || shape.isUIColorTile || shape.isUILabel;
}

UIColorBar.prototype.paintSelfOnly =function(canvas) {
	var ox = 0;
	var oy = 0;
	var v = this.barDirection;
	var n = this.style.lineWidth;
	
	canvas.beginPath();
	switch(this.barPosition) {
		case -1:	{
			break;
		}
		case 1:	{
			if(v) {
				ox = this.w - n;
			}
			else {
				oy = this.h - n;
			}
			break;
		}
		default: {
			if(v) {
				ox = Math.floor((this.w - n)>>1);
			}
			else {
				oy = Math.floor((this.h - n)>>1);
			}
		}
	}

	if(v) {
		canvas.moveTo(ox, 0);
		canvas.lineTo(ox, this.h);
	}
	else {
		canvas.moveTo(0, oy);
		canvas.lineTo(this.w, oy);
	}
	
	canvas.lineWidth = this.style.lineWidth;
	canvas.strokeStyle = this.style.lineColor;
	canvas.stroke();

	return;
}

function UIColorBarCreator(w, h) {
	var args = ["ui-color-bar", "ui-color-bar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorBar();

		return g.initUIColorBar(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIColorBarCreator(100, 10));

/*
 * File:   ui-image-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Animation.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageAnimation() {
	return;
}

UIImageAnimation.prototype = new UIImageView();
UIImageAnimation.prototype.isUIImageAnimation = true;

UIImageAnimation.prototype.saveProps = ["frameRate"];
UIImageAnimation.prototype.initUIImageAnimation = function(type, w, h) {
	this.initUIElement(type);	
	this.initUIImageView(w, h);
	
	this.addEventNames(["onChanged"]);
	this.setTextType(Shape.TEXT_NONE);
	imageAnimationInitCustomProp(this);

	return this;
}

UIImageAnimation.prototype.setCurrent = function(current) {
	if(this.userImages.length) {
		current = current%this.userImages.length;
	}

	if(this.currFrame != current) {
		this.callOnChangedHandler(current);
	}

	this.currFrame = current;

	return this;
}

UIImageAnimation.prototype.setValue = function(src) {
	for(var i = 0; i < this.cachedImages.length; i++) {
		var iter = this.cachedImages[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			return this.setCurrent(i);
		}
	}
	
	return this;
}

UIImageAnimation.prototype.getCurrentImage = function() {
	var image = this.cachedImages[this.currFrame];

	return image;
}

UIImageAnimation.prototype.onInit = function() {
	var imageAnim = this;

	this.currFrame = 0;

	function nextFrame() {
		if(imageAnim.isVisible()) {
			var duration = 1000/imageAnim.getFrameRate();
			
			imageAnim.postRedraw();
			setTimeout(nextFrame, duration);
			imageAnim.setCurrent(imageAnim.currFrame + 1);
		}
	}

	var duration = 1000/this.getFrameRate();
	setTimeout(nextFrame, duration);

	return;
}

UIImageAnimation.prototype.getFrameRate = function() {
	return this.frameRate ? this.frameRate : 5;
}

UIImageAnimation.prototype.setFrameRate = function(frameRate) {
	this.frameRate = Math.max(1, Math.min(frameRate, 30));

	return;
}

UIImageAnimation.prototype.drawImage = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currFrame = (this.currFrame ? this.currFrame : 0)%this.userImages.length;
	var image = this.cachedImages[currFrame];

	if(image && image.width > 0) {
		this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h);
	}

	return;
}


UIImageAnimation.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIImageAnimationCreator() {
	var args = [ "ui-image-animation", "ui-image-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageAnimation();
		return g.initUIImageAnimation(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageAnimationCreator());

/*
 * File: ui-call-events-handler.js
 * Author:	Li XianJing <xianjimli@hotmail.com>
 * Brief: call events handler 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

///////////////////////////////////////////////////////////////
UIElement.eventsStoped = {};
UIElement.prototype.callOnUpdateTransformHandler = function(canvas) {
	if(this.isInDesignMode() || !this.events) return true;

	if(!this.handleOnUpdateTransform) {
		var sourceCode = this.events["onUpdateTransform"];
		if(sourceCode) {
			sourceCode = "this.handleOnUpdateTransform = function(canvas) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUpdateTransform eval", e)
			}
		}
	}

	if(this.hasEventListener("updatetransform")) {
		var event = this.createEvent("updatetransform");
		event.canvas = canvas;

		this.dispatchEvent(event);
	}

	if(this.handleOnUpdateTransform) {
		try {
			this.handleOnUpdateTransform(canvas);
		}catch(e) {
			UIElement.logError("this.handleOnUpdateTransform", e)
		}
	}

	return;
}

UIElement.prototype.callOnPointerDownHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.click = false;
		UIElement.eventsStoped.pointerDown = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerDown) {
		return false;
	}
	
	if(this.hasEventListener("pointerdown")) {
		var event = this.createEvent("pointerdown");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerDown = true;
			return true;
		}
	}

	if(!this.handlePointerDown) {
		var sourceCode = this.events["onPointerDown"];
		if(sourceCode) {
			sourceCode = "this.handlePointerDown = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerDown eval", e)
			}
		}
	}

	if(this.handlePointerDown) {
		try {
			if(this.handlePointerDown(point, beforeChild)) {
				UIElement.eventsStoped.pointerDown = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerDown", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPointerMoveHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.pointerMove = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerMove) {
		return false;
	}

	if(this.hasEventListener("pointermove")) {
		var event = this.createEvent("pointermove");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerMove = true;
			return true;
		}
	}

	if(!this.handlePointerMove) {
		var sourceCode = this.events["onPointerMove"];
		if(sourceCode) {
			sourceCode = "this.handlePointerMove = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerMove eval", e)
			}
		}
	}

	if(this.handlePointerMove) {
		try {
			if(this.handlePointerMove(point, beforeChild)) {
				UIElement.eventsStoped.pointerMove = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerMove", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPointerUpHandler = function(point, beforeChild) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.pointerUp = false;
	}

	if(!this.enable || !this.events || UIElement.eventsStoped.pointerUp) {
		return false;
	}

	if(this.hasEventListener("pointerup")) {
		var event = this.createEvent("pointerup");
		event.point = point;
		event.beforeChild = beforeChild;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.pointerUp = true;
			return true;
		}
	}

	if(!this.handlePointerUp) {
		var sourceCode = this.events["onPointerUp"];
		if(sourceCode) {
			sourceCode = "this.handlePointerUp = function(point, beforeChild) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePointerUp eval", e)
			}
		}
	}

	if(this.handlePointerUp) {
		try{
			if(this.handlePointerUp(point, beforeChild)) {
				UIElement.eventsStoped.pointerUp = true;
			}
		}catch(e) {
			UIElement.logError("this.handlePointerUp", e)
		}
	}
	
	return true;
}

UIElement.prototype.callOnClickHandler = function(point) {
	if(!this.enable || !this.events || this.isInDesignMode()) {
		return false;
	}

	if(UIElement.eventsStoped.click) {
		return true;
	}

	if(this.hasEventListener("click")) {
		var event = this.createEvent("click");
		event.point = point;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.click = true;
			return true;
		}
	}

	if(!this.handleClick) {
		var sourceCode = this.events["onClick"];
		if(sourceCode) {
			sourceCode = "this.handleClick = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleClick eval", e)
			}
		}
	}

	if(this.handleClick) {
		try {
			if(this.handleClick(point)) {
				UIElement.eventsStoped.click = true;
			}
		}catch(e) {
			UIElement.logError("this.handleClick", e)
		}
	}

	return true;
}

UIElement.prototype.callOnDoubleClickHandler = function(point) {
	if(this.isUIWindow) {
		UIElement.eventsStoped.doubleClick = false;
	}

	if(!this.enable || !this.events || this.isInDesignMode()) {
		return false;
	}

	if(UIElement.eventsStoped.doubleClick) {
		return false;
	}
	
	if(this.hasEventListener("doubleclick")) {
		var event = this.createEvent("doubleclick");
		event.point = point;

		if(this.dispatchEvent(event)) {
			UIElement.eventsStoped.doubleClick = true;
			return true;
		}
	}

	if(!this.handleDoubleClick) {
		var sourceCode = this.events["onDoubleClick"];
		if(sourceCode) {
			sourceCode = "this.handleDoubleClick = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDoubleClick eval", e)
			}
		}
	}

	if(this.handleDoubleClick) {
		try {
			if(this.handleDoubleClick(point)) {
				UIElement.eventsStoped.doubleClick = true;
			}
		}catch(e) {
			UIElement.logError("this.handleDoubleClick", e)
		}
	}

	this.hitTestResult = 0;

	return true;
}

UIElement.prototype.callOnLongPressHandler = function(point) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleLongPress) {
		var sourceCode = this.events["onLongPress"];
		if(sourceCode) {
			sourceCode = "this.handleLongPress = function(point) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleLongPress eval", e)
			}
		}
	}
	
	if(this.hasEventListener("longpress")) {
		var event = this.createEvent("longpress");
		event.point = point;

		this.dispatchEvent(event);
	}

	if(this.handleLongPress) {
		try {
			this.handleLongPress(point);
		}catch(e) {
			UIElement.logError("this.handleLongPress", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPaintHandler = function(canvas2dCtx) {
	if(this.isInDesignMode()) {
		return true;
	}
	
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handlePaint) {
		var sourceCode = this.events["onPaint"];
		if(sourceCode) {
			sourceCode = "this.handlePaint = function(canvas2dCtx) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handlePaint eval", e)
			}
		}
	}
	
	if(this.hasEventListener("paint")) {
		var event = this.createEvent("paint");
		event.canvas2dCtx = canvas2dCtx;

		this.dispatchEvent(event);
	}

	if(this.handlePaint) {
		try {
			this.handlePaint(canvas2dCtx);
		}catch(e) {
			UIElement.logError("this.handlePaint", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollDoneHandler = function(xOffset, yOffset) {
	if(!this.enable || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("scrolldone")) {
		var event = this.createEvent("scrolldone");
		event.xOffset = xOffset;
		event.yOffset = yOffset;

		if(this.dispatchEvent(event)) {
			return true;
		}
	}

	if(!this.handleOnScrollDone) {
		var sourceCode = this.events["onScrollDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrollDone = function(xOffset, yOffset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrollDone eval", e)
			}
		}
	}

	if(this.handleOnScrollDone) {
		try {
			this.handleOnScrollDone(xOffset, yOffset);
		}catch(e) {
			UIElement.logError("this.handleOnScrollDone", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollingHandler = function(xOffset, yOffset) {
	if(!this.enable || !this.events || this.isInDesignMode()) {
		return false;
	}
	
	if(this.hasEventListener("scrolling")) {
		var event = this.createEvent("scrolling");
		event.xOffset = xOffset;
		event.yOffset = yOffset;

		if(this.dispatchEvent(event)) {
			return true;
		}
	}

	if(!this.handleOnScrolling) {
		var sourceCode = this.events["onScrolling"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrolling = function(xOffset, yOffset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrolling eval", e)
			}
		}
	}

	if(this.handleOnScrolling) {
		try {
			this.handleOnScrolling(xOffset, yOffset);
		}catch(e) {
			UIElement.logError("this.handleOnScrolling", e)
		}
	}

	return true;
}

UIElement.prototype.callOnRemovedHandler = function() {
	if(!this.enable || !this.events || this.isInDesignMode()) {
		return false;
	}

	if(!this.handleOnRemoved) {
		var sourceCode = this.events["onRemoved"];
		if(sourceCode) {
			sourceCode = "this.handleOnRemoved = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
				UIElement.logError("this.handleOnRemoved eval", e)
			}
		}
	}
	
	if(this.hasEventListener("removed")) {
		var event = this.createEvent("removed");

		this.dispatchEvent(event);
	}

	if(this.handleOnRemoved) {
		try {
			this.handleOnRemoved();
		}catch(e) {
			UIElement.logError("this.handleOnRemoved", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChildDraggingHandler = function(sourceChildIndex, targetChildIndex) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnChildDragging) {
		var sourceCode = this.events["onChildDragging"];
		if(sourceCode) {
			sourceCode = "this.handleOnChildDragging = function(sourceChildIndex, targetChildIndex) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChildDragging eval", e)
			}
		}
	}
	
	if(this.hasEventListener("childdragging")) {
		var event = this.createEvent("childdragging");
		event.sourceChildIndex = sourceChildIndex;
		event.targetChildIndex = targetChildIndex;
		this.dispatchEvent(event);
	}

	if(this.handleOnChildDragging) {
		try {
			this.handleOnChildDragging(sourceChildIndex, targetChildIndex);
		}catch(e) {
			UIElement.logError("this.handleOnChildDragging", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChildDraggedHandler = function(sourceChildIndex, targetChildIndex) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnChildDragged) {
		var sourceCode = this.events["onChildDragged"];
		if(sourceCode) {
			sourceCode = "this.handleOnChildDragged = function(sourceChildIndex, targetChildIndex) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChildDragged eval", e)
			}
		}
	}
	
	if(this.hasEventListener("childdragged")) {
		var event = this.createEvent("childdragged");
		event.sourceChildIndex = sourceChildIndex;
		event.targetChildIndex = targetChildIndex;
		this.dispatchEvent(event);
	}


	if(this.handleOnChildDragged) {
		try {
			this.handleOnChildDragged(sourceChildIndex, targetChildIndex);
		}catch(e) {
			UIElement.logError("this.handleOnChildDragged", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChangingHandler = function(value) {
	if(!this.enable || this.isInDesignMode() || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("changing")) {
		var event = this.createEvent("changing");
		event.value = value;
		this.dispatchEvent(event);
	}

	if(!this.handleOnChanging) {
		var sourceCode = this.events["onChanging"];
		if(sourceCode) {
			sourceCode = "this.handleOnChanging = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChanging eval", e)
			}
		}
	}

	if(this.handleOnChanging) {
		try {
			this.handleOnChanging(value);
		}catch(e) {
			UIElement.logError("this.handleOnChanging", e)
		}
	}

	return true;
}

UIElement.prototype.callOnChangedHandler = function(value) {
	if(!this.enable || this.isInDesignMode() || !this.events) {
		return false;
	}
	
	if(this.hasEventListener("change")) {
		var event = this.createEvent("change");
		event.value = value;
		this.dispatchEvent(event);
	}

	if(this.hasEventListener("changed")) {
		var event = this.createEvent("changed");
		event.value = value;
		this.dispatchEvent(event);
	}

	if(!this.handleOnChanged) {
		var sourceCode = this.events["onChanged"];
		if(sourceCode) {
			sourceCode = "this.handleOnChanged = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnChanged eval", e)
			}
		}
	}

	if(this.handleOnChanged) {
		try {
			this.handleOnChanged(value);
		}catch(e) {
			UIElement.logError("this.handleOnChanged", e)
		}
	}

	return true;
}

UIElement.prototype.callOnInitHandler = function() {
	if(!this.events) return;

	if(!this.handleOnInit) {
		var sourceCode = this.events["onInit"];
		if(sourceCode) {
			sourceCode = "this.handleOnInit = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnInit eval", e)
			}
		}
	}
	
	if(this.hasEventListener("init")) {
		var event = this.createEvent("init");

		this.dispatchEvent(event);
	}

	if(this.handleOnInit) {
		try {
			this.handleOnInit();
		}catch(e) {
			UIElement.logError("this.handleOnInit", e)
		}
	}

	return true;
}

UIElement.prototype.callOnFocusInHandler = function() {
	if(this.onFocusIn) {
		try {
			this.onFocusIn();
		}
		catch(e) {
			console.log("onFocusIn:" + e.message);
		}
	}

	if(!this.events) return;
	if(!this.handleOnFocusIn) {
		var sourceCode = this.events["onFocusIn"];
		if(sourceCode) {
			sourceCode = "this.handleOnFocusIn = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnFocusIn eval", e)
			}
		}
	}

	if(this.hasEventListener("focusin")) {
		var event = this.createEvent("focusin");

		this.dispatchEvent(event);
	}

	if(this.handleOnFocusIn) {
		try {
			this.handleOnFocusIn();
		}catch(e) {
			UIElement.logError("this.handleOnFocusIn", e)
		}
	}

	return true;
}

UIElement.prototype.callOnFocusOutHandler = function() {
	if(this.onFocusOut) {
		try {
			this.onFocusOut();
		}
		catch(e) {
			UIElement.logError("this.onFocusOut ", e)
		}
	}

	if(!this.events) return;
	if(!this.handleOnFocusOut) {
		var sourceCode = this.events["onFocusOut"];
		if(sourceCode) {
			sourceCode = "this.handleOnFocusOut = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.onFocusOut eval", e)
			}
		}
	}
	
	if(this.hasEventListener("focusout")) {
		var event = this.createEvent("focusout");

		this.dispatchEvent(event);
	}

	if(this.handleOnFocusOut) {
		try {
			this.handleOnFocusOut();
		}catch(e) {
			UIElement.logError("this.onFocusOut", e)
		}
	}

	return true;
}

/////////////////////////////////////////////////////////

UIElement.prototype.callOnUpdateDataHandler = function() {
	if(!this.events) return;
	if(!this.handleOnUpdateData) {
		var sourceCode = this.events["onUpdateData"];
		if(sourceCode) {
			sourceCode = "this.handleOnUpdateData = function(value) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUpdateData eval", e)
			}
		}
	}

	if(this.hasEventListener("updatedata")) {
		var event = this.createEvent("updatedata");

		this.dispatchEvent(event);
	}

	if(this.handleOnUpdateData) {
		try {
			this.handleOnUpdateData();
		}catch(e) {
			UIElement.logError("this.handleOnUpdateData", e)
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////

UIElement.prototype.callOnGestureHandler = function(gesture) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleOnGesture) {
		var sourceCode = this.events["onGesture"];
		if(sourceCode) {
			sourceCode = "this.handleOnGesture = function(gesture) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnGesture eval", e)
			}
		}
	}
	
	if(this.hasEventListener("gesture")) {
		var event = this.createEvent("gesture");
		event.gesture = gesture;

		this.dispatchEvent(event);
	}

	if(this.handleOnGesture) {
		try {
			this.handleOnGesture(gesture);
		}catch(e) {
			UIElement.logError("this.handleOnGesture", e)
		}
	}
	
	console.log("callOnGestureHandler: scale=" + gesture.scale + " rotation=" + gesture.rotation);

	return true;
}

UIElement.prototype.callOnBeforeOpenHandler = function(initData) {
	if(!this.events) return;
	if(!this.handleOnBeforeOpen) {
		var sourceCode = this.events["onBeforeOpen"];
		if(sourceCode) {
			sourceCode = "this.handleOnBeforeOpen = function(initData) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBeforeOpen eval", e)
			}
		}
	}
	
	if(this.hasEventListener("beforeopen")) {
		var event = this.createEvent("beforeopen");
		event.initData = initData;

		this.dispatchEvent(event);
	}

	if(this.handleOnBeforeOpen) {
		try {
			this.handleOnBeforeOpen(initData);
		}catch(e) {
			UIElement.logError("this.handleOnBeforeOpen", e)
		}
	}

	return true;
}

UIElement.prototype.callOnOpenHandler = function(initData) {
	if(!this.events) return;
	if(!this.handleOnOpen) {
		var sourceCode = this.events["onOpen"];
		if(sourceCode) {
			sourceCode = "this.handleOnOpen = function(initData) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnOpen eval", e)
			}
		}
	}
	
	if(this.hasEventListener("open")) {
		var event = this.createEvent("open");
		event.initData = initData;

		this.dispatchEvent(event);
	}

	if(this.handleOnOpen) {
		try {
			this.handleOnOpen(initData);	
		}catch(e) {
			UIElement.logError("this.handleOnOpen", e)
		}
	}

	return true;
}

UIElement.prototype.callOnCloseHandler = function(retInfo) {
	if(!this.events) return;
	if(!this.handleOnClose) {
		var sourceCode = this.events["onClose"];
		if(sourceCode) {
			sourceCode = "this.handleOnClose = function(retInfo) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnClose eval", e)
			}
		}
	}

	if(this.hasEventListener("close")) {
		var event = this.createEvent("close");
		event.retInfo = retInfo;

		this.dispatchEvent(event);
	}

	if(this.handleOnClose) {
		try {
			this.handleOnClose(retInfo);
		}
		catch(e) {
			UIElement.logError("this.handleOnClose", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwitchToBackHandler =function() {
	if(!this.events) return;
	if(!this.handleOnSwitchToBack) {
		var sourceCode = this.events["onSwitchToBack"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwitchToBack = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwitchToBack eval", e)
			}
		}
	}

	if(this.hasEventListener("switchtoback")) {
		var event = this.createEvent("switchtoback");
		this.dispatchEvent(event);
	}

	if(this.handleOnSwitchToBack) {
		try {
			this.handleOnSwitchToBack();
		}
		catch(e) {
			UIElement.logError("this.handleOnSwitchToBack", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwitchToFrontHandler = function() {
	if(!this.events) return;
	if(!this.handleOnSwitchToFront) {
		var sourceCode = this.events["onSwitchToFront"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwitchToFront = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwitchToFront eval", e)
			}
		}
	}

	if(this.hasEventListener("switchtofront")) {
		var event = this.createEvent("switchtofront");
		this.dispatchEvent(event);
	}

	if(this.handleOnSwitchToFront) {
		try {
			this.handleOnSwitchToFront();
		}
		catch(e) {
			UIElement.logError("this.handleOnSwitchToFront", e)
		}
	}

	return true;
}

UIElement.prototype.callOnLoadHandler =function() {
	if(!this.events) return;
	if(!this.handleOnLoad) {
		var sourceCode = this.events["onLoad"];
		if(sourceCode) {
			sourceCode = "this.handleOnLoad = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnLoad eval", e)
			}
		}
	}
	
	if(this.hasEventListener("load")) {
		var event = this.createEvent("load");
		this.dispatchEvent(event);
	}

	if(this.handleOnLoad) {
		try {
			this.handleOnLoad();
		}
		catch(e) {
			UIElement.logError("this.handleOnLoad", e)
		}
	}

	return true;
}

UIElement.prototype.callOnUnloadHandler =function() {
	if(!this.events) return;
	if(!this.handleOnUnload) {
		var sourceCode = this.events["onUnload"];
		if(sourceCode) {
			sourceCode = "this.handleOnUnload = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnUnload eval", e)
			}
		}
	}

	if(this.hasEventListener("unload")) {
		var event = this.createEvent("unload");
		this.dispatchEvent(event);
	}

	if(this.handleOnUnload) {
		try {
			this.handleOnUnload();
		}
		catch(e) {
			UIElement.logError("this.handleOnUnload", e)
		}
	}

	return true;
}

/////////////////////////////////////////////////////////////

UIElement.prototype.callOnMovedHandler = function() {
 	if(this.cameraFollowMe) {
		this.getWindow().cameraFollow(this);
	} 
	
	if(this.hasEventListener("moved")) {
		var event = this.createEvent("moved");

		this.dispatchEvent(event);
	}

   	if(!this.events) return;
	if(!this.handleOnMoved) {
		var sourceCode = this.events["onMoved"];
		if(sourceCode) {
			sourceCode = "this.handleOnMoved = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnMoved eval", e)
			}
		}
	}
	
	if(this.handleOnMoved) {
		try {
			this.handleOnMoved();
		}catch(e) {
			UIElement.logError("this.handleOnMoved", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPreSolveHandler = function(body, contact, oldManifold) {
	if(!this.events) return;

	if(!this.handleOnPreSolve) {
		var sourceCode = this.events["onPreSolve"];
		if(sourceCode) {
			sourceCode = "this.handleOnPreSolve = function(body, contact, oldManifold) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnPreSolve eval", e)
			}
		}
	}

	if(this.hasEventListener("presolve")) {
		var event = this.createEvent("presolve");
		event.body = body;
		event.contact = contact;
		event.oldManifold = oldManifold;

		this.dispatchEvent(event);
	}

	if(this.handleOnPreSolve) {
		try {
			this.handleOnPreSolve(body, contact, oldManifold);
		}catch(e) {
			UIElement.logError("this.handleOnPreSolve", e)
		}
	}

	return true;
}

UIElement.prototype.callOnPostSolveHandler = function(body, contact, impulse) {
	if(!this.events) return;

	if(!this.handleOnPostSolve) {
		var sourceCode = this.events["onPostSolve"];
		if(sourceCode) {
			sourceCode = "this.handleOnPostSolve = function(body, contact, impulse) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnPostSolve eval", e)
			}
		}
	}
	
	if(this.hasEventListener("postsolve")) {
		var event = this.createEvent("postsolve");
		event.body = body;
		event.contact = contact;
		event.impulse = impulse;

		this.dispatchEvent(event);
	}

	if(this.handleOnPostSolve) {
		try {
			this.handleOnPostSolve(body, contact, impulse);
		}catch(e) {
			UIElement.logError("this.handleOnPostSolve", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBeginContactHandler = function(body, contact) {
	if(!this.events) return;

	if(this.hasEventListener("begincontact")) {
		var event = this.createEvent("begincontact");
		event.body = body;
		event.contact = contact;

		this.dispatchEvent(event);
	}

	if(!this.handleOnBeginContact) {
		var sourceCode = this.events["onBeginContact"];
		if(sourceCode) {
			sourceCode = "this.handleOnBeginContact = function(body, contact) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBeginContact eval", e)
			}
		}
	}

	if(this.handleOnBeginContact) {
		try {
			this.handleOnBeginContact(body, contact);
		}catch(e) {
			UIElement.logError("this.handleOnBeginContact", e)
		}
	}

	return true;
}

UIElement.prototype.callOnEndContactHandler = function(body, contact) {
	if(!this.events) return;

	if(this.hasEventListener("endcontact")) {
		var event = this.createEvent("endcontact");
		event.body = body;
		event.contact = contact;

		this.dispatchEvent(event);
	}

	if(!this.handleOnEndContact) {
		var sourceCode = this.events["onEndContact"];
		if(sourceCode) {
			sourceCode = "this.handleOnEndContact = function(body, contact) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnEndContact eval", e)
			}
		}
	}

	if(this.handleOnEndContact) {
		try {
			this.handleOnEndContact(body, contact);
		}catch(e) {
			UIElement.logError("this.handleOnEndContact", e)
		}
	}

	return true;
}

UIElement.prototype.callOnAnimateDoneHandler = function(name) {
	if(!this.events) return;

	if(!this.handleOnAnimateDone) {
		var sourceCode = this.events["onAnimateDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnAnimateDone = function(name) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnAnimateDone eval", e)
			}
		}
	}
	
	if(this.hasEventListener("animatedone")) {
		var event = this.createEvent("animatedone");
		event.name = name;

		this.dispatchEvent(event);
	}

	if(this.handleOnAnimateDone) {
		try {
			this.handleOnAnimateDone(name);
		}
		catch(e) {
			UIElement.logError("this.handleOnAnimateDone", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeLeftHandler = function(start, end) {
	if(!this.events) return;

	if(!this.handleOnSwipeLeft) {
		var sourceCode = this.events["onSwipeLeft"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeLeft = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeLeft eval", e)
			}
		}
	}

	if(this.hasEventListener("swipeleft")) {
		var event = this.createEvent("swipeleft");
		event.start = start;
		event.end = end;

		this.dispatchEvent(event);
	}

	if(this.handleOnSwipeLeft) {
		try {
			this.handleOnSwipeLeft(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeLeft", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeRightHandler = function(start, end) {
	if(!this.events) return;

	if(!this.handleOnSwipeRight) {
		var sourceCode = this.events["onSwipeRight"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeRight = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeRight eval", e)
			}
		}
	}

	if(this.hasEventListener("swiperight")) {
		var event = this.createEvent("swiperight");
		event.start = start;
		event.end = end;

		this.dispatchEvent(event);
	}

	if(this.handleOnSwipeRight) {
		try {
			this.handleOnSwipeRight(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeRight", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeUpHandler = function(start, end) {
	if(!this.events) return;

	if(!this.handleOnSwipeUp) {
		var sourceCode = this.events["onSwipeUp"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeUp = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeUp eval", e)
			}
		}
	}

	if(this.hasEventListener("swipeup")) {
		var event = this.createEvent("swipeup");
		event.start = start;
		event.end = end;

		this.dispatchEvent(event);
	}

	if(this.handleOnSwipeUp) {
		try {
			this.handleOnSwipeUp(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeUp", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSwipeDownHandler = function(start, end) {
	if(!this.events) return;

	if(!this.handleOnSwipeDown) {
		var sourceCode = this.events["onSwipeDown"];
		if(sourceCode) {
			sourceCode = "this.handleOnSwipeDown = function(start, end) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSwipeDown eval", e)
			}
		}
	}

	if(this.hasEventListener("swipedown")) {
		var event = this.createEvent("swipedown");
		event.start = start;
		event.end = end;

		this.dispatchEvent(event);
	}

	if(this.handleOnSwipeDown) {
		try {
			this.handleOnSwipeDown(start, end);
		}catch(e) {
			UIElement.logError("this.handleOnSwipeDown", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBecomeZeroHandler = function() {
	if(!this.events) return;

	if(!this.handleOnBecomeZero) {
		var sourceCode = this.events["onBecomeZero"];
		if(sourceCode) {
			sourceCode = "this.handleOnBecomeZero = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBecomeZero eval", e)
			}
		}
	}
	
	if(this.hasEventListener("becomezero")) {
		var event = this.createEvent("becomezero");
		this.dispatchEvent(event);
	}

	if(this.handleOnBecomeZero) {
		try {
			this.handleOnBecomeZero();
		}catch(e) {
			UIElement.logError("this.handleOnBecomeZero", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBecomeFullHandler = function() {
	if(!this.events) return;

	if(!this.handleOnBecomeFull) {
		var sourceCode = this.events["onBecomeFull"];
		if(sourceCode) {
			sourceCode = "this.handleOnBecomeFull = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBecomeFull eval", e)
			}
		}
	}

	if(this.hasEventListener("becomefull")) {
		var event = this.createEvent("becomefull");
		this.dispatchEvent(event);
	}

	if(this.handleOnBecomeFull) {
		try {
			this.handleOnBecomeFull();
		}catch(e) {
			UIElement.logError("this.handleOnBecomeFull", e)
		}
	}

	return true;
}

UIElement.prototype.callOnTimeoutHandler = function() {
	if(!this.events) return;
	if(!this.handleOnTimeout) {
		var sourceCode = this.events["onTimeout"];
		if(sourceCode) {
			sourceCode = "this.handleOnTimeout = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnTimeout eval", e)
			}
		}
	}
	
	if(this.hasEventListener("timer")) {
		var event = this.createEvent("timer");
		this.dispatchEvent(event);
	}
	
	if(this.hasEventListener("timeout")) {
		var event = this.createEvent("timeout");
		this.dispatchEvent(event);
	}


	if(this.handleOnTimeout) {
		try {
			this.handleOnTimeout();
		}catch(e) {
			UIElement.logError("this.handleOnTimeout", e)
		}
	}

	return true;
}

UIElement.prototype.callOnSystemInitHandler = function() {
	if(!this.events) return;
	if(!this.handleOnSystemInit) {
		var sourceCode = this.events["onSystemInit"];
		if(sourceCode) {
			sourceCode = "this.handleOnSystemInit = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnSystemInit eval", e)
			}
		}
	}

	if(this.hasEventListener("systeminit")) {
		var event = this.createEvent("systeminit");

		this.dispatchEvent(event);
	}

	if(this.handleOnSystemInit) {
		try {
			this.handleOnSystemInit();
		}catch(e) {
			UIElement.logError("this.handleOnSystemInit", e)
		}
	}

	return true;
}

UIElement.prototype.callOnScrollOutOfRangeHandler = function(offset) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(this.onScrollOutOfRange) {
		this.onScrollOutOfRange(offset);

		return;
	}

	if(!this.handleOnScrollOutOfRange) {
		var sourceCode = this.events["onScrollOutOfRange"];
		if(sourceCode) {
			sourceCode = "this.handleOnScrollOutOfRange = function(offset) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnScrollOutOfRange eval", e)
			}
		}
	}

	if(this.hasEventListener("scrolloutofrange")) {
		var event = this.createEvent("scrolloutofrange");
		event.offset = offset;

		this.dispatchEvent(event);
	}

	if(this.handleOnScrollOutOfRange) {
		try {
			this.handleOnScrollOutOfRange(offset);
		}catch(e) {
			UIElement.logError("this.handleOnScrollOutOfRange", e)
		}
	}

	return true;
}

UIElement.prototype.callOnBirthedHandler = function() {
	if(this.onBirthed) {
		this.onBirthed();
	}

	if(!this.events) return;
	if(!this.handleOnBirthed) {
		var sourceCode = this.events["onBirthed"];
		if(sourceCode) {
			sourceCode = "this.handleOnBirthed = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnBirthed eval", e)
			}
		}
	}
	
	if(this.hasEventListener("birthed")) {
		var event = this.createEvent("birthed");

		this.dispatchEvent(event);
	}

	if(this.handleOnBirthed) {
		try {
			this.handleOnBirthed();
		}catch(e) {
			UIElement.logError("this.handleOnBirthed", e)
		}
	}

	return true;
}

UIElement.prototype.callOnDeviceOrientation = function(x, y, z, evt) {
	if(!this.events) return;
	if(!this.handleOnDeviceOrientation) {
		var sourceCode = this.events["onDeviceOrientation"];
		if(sourceCode) {
			sourceCode = "this.handleOnDeviceOrientation = function(x, y, z, event) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleOnDeviceOrientation eval", e)
			}
		}
	}

	if(this.hasEventListener("deviceorientation")) {
		var event = this.createEvent("deviceorientation");
		event.x = x;
		event.y = y;
		event.z = z;
		event.event = evt;

		this.dispatchEvent(event);
	}

	if(this.handleOnDeviceOrientation) {
		try {
			this.handleOnDeviceOrientation(x, y, z, evt);
		}catch(e) {
			UIElement.logError("this.handleOnDeviceOrientation", e)
		}
	}

	return true;
}

UIElement.prototype.dispatchCustomEvent = function(eventName, args) {
	if(!this.events) return;
	if(!this.customEventHandler) {
		this.customEventHandler = {};
	}

	var handleCustomEvent = this.customEventHandler[eventName];
	if(!handleCustomEvent) {
		var sourceCode = this.events[eventName];
		if(sourceCode) {
			sourceCode = "this.handleCustomEvent = function(args) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleCustomEvent eval", e)
			}
		}

		if(this.handleCustomEvent) {
			handleCustomEvent = this.handleCustomEvent;
			this.customEventHandler[eventName] = handleCustomEvent;
			this.handleCustomEvent = null;
		}
	}

	if(handleCustomEvent) {
		try {
			handleCustomEvent.call(this, args);
		}catch(e) {
			UIElement.logError("this.handleCustomEvent", e)
		}
	}

	return true;
}

UIWindow.prototype.callOnMultiTouchHandler = function(action, points, evt) {
	if(!this.enable || !this.events) {
		return false;
	}

	if(this.isInDesignMode()) {
		return false;
	}
	
	if(!this.handleMultiTouch) {
		var sourceCode = this.events["onMultiTouch"];
		if(sourceCode) {
			sourceCode = "this.handleMultiTouch = function(action, points, event) {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleMultiTouch eval", e)
			}
		}
	}
	
	if(this.hasEventListener("multitouch")) {
		var event = this.createEvent("multitouch");
		event.action = action;
		event.points = points;
		event.event = evt;

		this.dispatchEvent(event);
	}

	if(this.handleMultiTouch) {
		try {
			this.handleMultiTouch(action, points, evt);
		}catch(e) {
			UIElement.logError("this.handleMultiTouch", e)
		}
	}

	return;
}

UIElement.prototype.callOnDragStartHandler = function() {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleDragStart) {
		var sourceCode = this.events["onDragStart"];
		if(sourceCode) {
			sourceCode = "this.handleDragStart = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragStart eval", e)
			}
		}
	}
	
	if(this.hasEventListener("dragstart")) {
		var event = this.createEvent("dragstart");

		this.dispatchEvent(event);
	}

	if(this.handleDragStart) {
		try {
			this.handleDragStart();
		}catch(e) {
			UIElement.logError("this.handleDragStart", e)
		}
	}

	return;
}

UIElement.prototype.callOnDragEndHandler = function() {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleDragEnd) {
		var sourceCode = this.events["onDragEnd"];
		if(sourceCode) {
			sourceCode = "this.handleDragEnd = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragEnd eval", e)
			}
		}
	}

	if(this.hasEventListener("dragend")) {
		var event = this.createEvent("dragend");

		this.dispatchEvent(event);
	}

	if(this.handleDragEnd) {
		try {
			this.handleDragEnd();
		}catch(e) {
			UIElement.logError("this.handleDragEnd", e)
		}
	}

	return;
}

UIElement.prototype.callOnDraggingHandler = function() {
	if(!this.enable || !this.events) {
		return false;
	}

	if(!this.handleDragging) {
		var sourceCode = this.events["onDragging"];
		if(sourceCode) {
			sourceCode = "this.handleDragging = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				UIElement.logError("this.handleDragging eval", e)
			}
		}
	}

	if(this.hasEventListener("dragging")) {
		var event = this.createEvent("dragging");

		this.dispatchEvent(event);
	}

	if(this.handleDragging) {
		try {
			this.handleDragging();
		}catch(e) {
			UIElement.logError("this.handleDragging", e)
		}
	}

	return;
}
/*
 * File:   ui-v-scroll-image.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Vertical Scrollable Image
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIVScrollImage() {
	return;
}

UIVScrollImage.prototype = new UIVScrollView();

UIVScrollImage.prototype.initUIVScrollImage = function(type) {
	this.initUIVScrollView(type, 0, null, null);	
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.widthAttr = UIElement.WIDTH_SCALE;
	this.heightAttr = UIElement.HEIGHT_SCALE;
	this.setSize(200, 200);
	
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);

	return this;
}

UIVScrollImage.prototype.drawBgImage = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	if(!image || !image.height) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
		return;
	}
	var scale = this.w/image.width;
	var range = image.height * scale;

	var x = 0; 
	var y = this.offset/scale;
	var w = image.width;
	var h = Math.min(this.h/scale, image.height-y);
	var dx = 0; 
	var dy = 0;
	var dw = this.w; 
	var dh = h * scale;

	canvas.drawImage(image, x, y, w, h, dx, dy, dw, dh);

	return;
}

UIVScrollImage.prototype.getScrollRange = function() {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	if(image && image.height && image.width) {
		var scale = this.w/image.width;

		return scale * image.height + 60;
	}
	else {
		return this.h;
	}
}

UIVScrollImage.prototype.afterPaintChildren = function(canvas) {
	this.drawScrollBar(canvas);

	if(this.isInDesignMode()) {
		this.drawPageDownUp(canvas);
	}

	return;
}

function UIVScrollImageCreator() {
	var args = ["ui-v-scroll-image", "ui-v-scroll-image", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIVScrollImage();
		return g.initUIVScrollImage(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIVScrollImageCreator());
/*
 * File:   ui-page-manager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  TabPage Manager
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPageManager() {
}

UIPageManager.prototype = new UIFrames();
UIPageManager.prototype.isUIPageManager = true;

UIPageManager.prototype.initUIPageManager = function(type) {
	return this.initUIFrames(type);
}

UIPageManager.prototype.beforeAddShapeIntoChildren = function(shape) {
	return !shape.isUIPage;
}

UIPageManager.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIPage;
}

UIPageManager.prototype.relayoutChildren = function() {
	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];
		iter.left = 0;
		iter.top = 0;
		iter.w = this.w;
		iter.h = this.h;
		iter.relayoutChildren();
		iter.setUserMovable(false);
		iter.setUserResizable(false);
	}

	return;
}

UIPageManager.prototype.showHTML = function() {
	var child = this.getCurrentFrame();
	
	if(child) {
		child.showHTML();
	}

	return;
}

UIPageManager.prototype.hideHTML = function() {
	var child = this.getCurrentFrame();
	
	if(child) {
		child.hideHTML();
	}

	return;
}


UIPageManager.prototype.switchTo = function(index) {
	var pageManager = this;
	var curFrame = this.getCurrentFrame();
	var newFrame = this.getFrame(index);
	var current = this.current;

	if(curFrame) {
		curFrame.hideHTML();
	}

	if(current < 0 || current === index || !curFrame || !newFrame) {
		this.showFrame(index);

		if(newFrame) {
			newFrame.showHTML();
		}

		return;
	}

	function showNewFrame() {
		pageManager.showFrame(index);
		pageManager.postRedraw();

		return;
	}

	if(!this.isTopWindow()) {
		showNewFrame();	
		return;
	}

	var animation = null;
	var backendCanvas = null;
	var p = this.getPositionInScreen();

	if(index < current) {
		animation = AnimationFactory.create("anim-backward"); 
		backendCanvas = UIFrames.preparseBackendCanvas(newFrame, curFrame);
	}
	else {
		animation = AnimationFactory.create("anim-forward"); 
		backendCanvas = UIFrames.preparseBackendCanvas(curFrame, newFrame);
	}

//	window.open(backendCanvas.toDataURL(), "_blank");
	animation.setScale(this.getRealScale());
	animation.prepare(p.x, p.y, this.w, this.h, backendCanvas, showNewFrame);
	animation.run();

	return;
}

function UIPageManagerCreator() {
	var args = ["ui-page-manager", "ui-page-manager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageManager();

		g.initUIPageManager(this.type);

		return g;
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIPageManagerCreator());

/*
 * File:   ui-wait-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Wait Bar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWaitBar
 * @extends UIElement
 * 等待动画。
 */

/**
 * @class UIWaitBox
 * @extends UIElement
 * 等待动画。
 */

function UIWaitBar() {
	return;
}

UIWaitBar.TILES = 8;
UIWaitBar.prototype = new UIElement();

UIWaitBar.prototype.initUIWaitBar = function(type, w, h) {
	this.initUIElement(type);	

	this.offset = 0;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);

	return this;
}

UIWaitBar.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIWaitBar.prototype.step = function() {
	if(this.isVisible() && this.getParent()) {
		this.offset++;
	
		if(this.isUIWaitBar) {
			this.offset = (this.offset)%UIWaitBar.TILES;
		}

		this.postRedraw();
	}

	return this;
}

UIWaitBar.prototype.drawBgImage = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	
	if(!image) {
		return;
	}

	if(this.isUIWaitBar) {
		this.drawBgImageBar(canvas, image);
	}
	else {
		this.drawBgImageBox(canvas, image);
	}

	return;
}

UIWaitBar.prototype.drawBgImageBox =function(canvas, image) {
	var angle = 0.05*Math.PI*this.offset;
	this.setRotation(angle);

	UIElement.prototype.drawBgImage.call(this, canvas);

	return;
}

UIWaitBar.prototype.onInit = function() {
	UIElement.prototype.onInit.call(this);

	var me = this;
	function stepIt() {
		me.step();
		if(me.getParent()) {
			setTimeout(stepIt, 50);
		}
	}

	stepIt();

	return;
}

UIWaitBar.prototype.drawBgImageBar = function(canvas, image) {
	var imageWidth = image.width;
	var imageHeight = image.height;
	var tileHeight = Math.round(imageHeight/UIWaitBar.TILES);
	var yOffset = this.offset * tileHeight;

	var rect = {x:0, y:yOffset, w:imageWidth, h:tileHeight};

	UIElement.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, rect);

	return;
}

function UIWaitBarCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWaitBar();
		g.isUIWaitBar = true;

		return g.initUIWaitBar(this.type, w, h);
	}
	
	return;
}

function UIWaitBoxCreator(type, w, h) {
	var args = [type, type, null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWaitBar();
		g.isUIWaitBox = true;

		return g.initUIWaitBar(this.type, w, h);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIWaitBarCreator("ui-wait-bar", 200, 24));
ShapeFactoryGet().addShapeCreator(new UIWaitBoxCreator("ui-wait-box", 60, 60));

/*
 * File:   ui-static-map.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Static Map 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIStaticMap() {
	return;
}

UIStaticMap.prototype = new UIImage();
UIStaticMap.prototype.isUIStaticMap = true;

UIStaticMap.prototype.initUIStaticMap = function(type) {
	this.initUIImage(type, 200, 200, null);

	return this;
}

UIStaticMap.prototype.setMapProvider = function(value) {
	this.mapProvider = value;

	return;
}

UIStaticMap.prototype.setMapType = function(value) {
	this.mapType = value;

	return;
}

UIStaticMap.prototype.setMapZoom = function(value) {
	this.mapZoom = value;

	return;
}

UIStaticMap.prototype.setMapCenter = function(value) {
	this.mapCenter = value;

	return;
}

UIStaticMap.prototype.setMapWidth = function(value) {
	this.mapWidth = value;

	return;
}

UIStaticMap.prototype.setMapHeight = function(value) {
	this.mapHeight = value;

	return;
}

UIStaticMap.prototype.setMapExtraParams = function(value) {
	this.mapEtraParams = value;

	return;
}

UIStaticMap.prototype.getMapType = function() {
	return this.mapType ? this.mapType : "";
}

UIStaticMap.prototype.getMapProvider = function() {
	return this.mapProvider ? this.mapProvider : "google";
}

UIStaticMap.prototype.getMapZoom = function() {
	return this.mapZoom ? this.mapZoom : 10;
}

UIStaticMap.prototype.getMapWidth = function() {
	return this.mapWidth ? this.mapWidth : 600;
}

UIStaticMap.prototype.getMapHeight = function() {
	return this.mapHeight ? this.mapHeight : 600;
}

UIStaticMap.prototype.getMapCenter = function() {
	if(!this.mapCenter && this.currentLocation) {
		return this.currentLocation;
	}
	else {
		return this.mapCenter ? this.mapCenter : "China";
	}
}

UIStaticMap.prototype.getMapExtraParams = function() {
	return this.mapEtraParams ? this.mapEtraParams : "";
}

//http://developer.baidu.com/map/staticimg.htm
//https://developers.google.com/maps/documentation/staticmaps/?hl=zh-CN&csw=1

UIStaticMap.prototype.getMapURL = function() {
	var url = "";
	if(this.mapProvider === "baidu") {
		url = "http://api.map.baidu.com/staticimage?center="+this.getMapCenter()
			+ "&width=" + this.getMapWidth()
			+ "&height="+ this.getMapHeight()
			+ "&zoom=" + this.getMapZoom()
			+ this.getMapExtraParams();
	}
	else if(this.mapProvider === "google"){
		url = "http://maps.googleapis.com/maps/api/staticmap?center="+this.getMapCenter()
			+ "&size=" + this.getMapWidth() + "x"+this.getMapHeight()
			+ "&zoom=" + this.getMapZoom()
			+ "&maptype=" + this.getMapType() + "&sensor=true"
			+ this.getMapExtraParams();
	}

	console.log("Map URL:" + url);

	return url;
}

UIStaticMap.prototype.updateMap = function() {
	var url = this.getMapURL();

	this.setImageSrc(url);

	return;
}

UIStaticMap.prototype.onInit = function() {
	var map = this;
	
	function onCurrentLocation(position) {
		map.currentLocation = position.coords.latitude+","+position.coords.longitude;
		map.updateMap();

		return;
	}

	if (navigator.geolocation) {
		navigator.geolocation.getCurrentPosition(onCurrentLocation);
	}
	this.updateMap();

	return;
}

UIStaticMap.prototype.drawImage =function(canvas) {

	this.drawBgImage(canvas);

	return;
}

function UIStaticMapCreator() {
	var args = ["ui-static-map", "ui-static-map", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStaticMap();
		return g.initUIStaticMap(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIStaticMapCreator());

/*
 * File:   ui-status-bar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Status Bar 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIStatusBar() {
	return;
}

UIStatusBar.prototype = new UIElement();
UIStatusBar.prototype.isUIStatusBar = true;

UIStatusBar.prototype.initUIStatusBar = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;

	return this;
}

UIStatusBar.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton) {
		return true;
	}

	return false;
}

UIStatusBar.prototype.afterChildAppended = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
	if(this.type === "ui-menu-bar") {
		shape.hideSelectMark = true;
		shape.textType = Shape.TEXT_NONE;
		this.hideSelectMark = true;
	}

	return true;
}

UIStatusBar.prototype.beforeRelayoutChild = function(shape) {
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return true;
}

function UIStatusBarCreator(type, w, h, bg) {
	var args = [type, "ui-status-bar", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStatusBar();
		return g.initUIStatusBar(this.type, w, h, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIStatusBarCreator("ui-status-bar", 640, 40, null));
ShapeFactoryGet().addShapeCreator(new UIStatusBarCreator("ui-menu-bar", 640, 96, null));


/*
 * File:   ui-unkown.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  There are two conditions that shape factory can not find creator for a type: 
 *           1.The creator is not loaded yet.
 *           2.There is not such creator.
 *         For the first condition, we create a proxy first, try it create the real element later.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIUnkown() {
	return;
}

UIUnkown.prototype = new UIElement();
UIUnkown.prototype.isUIUnkown = true;

UIUnkown.prototype.initUIUnkown = function(type) {
	this.initUIElement(type);	

	return this;
}

function UIUnkownCreator() {
	var args = ["ui-unkown", "ui-unkown", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIUnkown();
		return g.initUIUnkown(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIUnkownCreator());

/*
 * File:   ui-suggestion.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Suggestion Input
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function SuggestionProvider() {
	this.query = function(key, onDone) {
	}

	this.init = function(options) {
	}

	return;
}

function StaticSuggestionProvider() {
	this.init = function(options) {
		if(typeof options == "string") {
			options = options.split("\n");
		}

		this.options = options;
		if(this.options) {
			this.options.sort();
		}

		return;
	}

	this.query = function(key, onDone) {
		if(!key || !this.options) {
			onDone([]);
			return;
		}

		function compareStr(str1, str2) {
			if(str1.indexOf(str2) == 0) {
				return 0;
			}

			if(str1 < str2) {
				return -1;
			}
			else {
				return 1;
			}
		}

		var arr = [];
		var start = this.options.binarySearch(key, compareStr);
		
		if(start >= 0) {
			var n = this.options.length;
			
			for(;start >= 0; start--) {
				var iter = this.options[start];
				if(iter.indexOf(key) !== 0) {
					start = start+1;
					break;
				}
			}

			for(var i = start; i < n; i++) {
				var iter = this.options[i];
				if(iter.indexOf(key) === 0) {
					arr.push(iter);
				}
				else {
					break;
				}
			}
		}

		onDone(arr);

		return;
	}

	return;
}

function createSuggestionProvider(type, args) {
	var suggestionProvider = null;
	if(type === "static") {
		suggestionProvider = new StaticSuggestionProvider();
	}

	if(suggestionProvider) {
		suggestionProvider.init(args);
	}

	return suggestionProvider;
}

function UISuggestion() {
	return;
}

UISuggestion.prototype = new UIListView();
UISuggestion.prototype.isUISuggestion = true;

UISuggestion.prototype.initUISuggestion = function(type) {
	this.initUIListView(type, 5, 100, null);	
	this.maxSuggestionItems = 10;
	this.suggestionProviderParams = "";
	this.suggestionProviderName = "static";

	return this;
}

UISuggestion.prototype.onInit = function() {
	this.suggestionProvider = createSuggestionProvider(this.suggestionProviderName, this.suggestionProviderParams);

	return;
}

UISuggestion.prototype.setSuggestionProvider = function(suggestionProvider) {
	this.suggestionProvider = suggestionProvider;

	return;
}

UISuggestion.prototype.getSuggestionProvider = function() {
	return this.suggestionProvider;
}

//override this.
UISuggestion.prototype.onSuggestionSelected = function(str) {

}

UISuggestion.prototype.showSuggestion = function(suggestions) {
	var data = {children:[]};
	
	if(suggestions.length > this.maxSuggestionItems) {
		suggestions.length = this.maxSuggestionItems;
	}

	for(var i = 0; i < suggestions.length; i++) {
		var item = {children:[]};
		var value = suggestions[i];
		item.children.push({text: value});
		data.children.push(item);
	}
		
	this.bindData(data, null, true);

	return;

}

UISuggestion.prototype.onSuggestionShow = function() {
}

UISuggestion.prototype.query = function(key) {
	var me = this;
	this.suggestionProvider.query(key, function(arr) {
		me.showSuggestion(arr);
		me.onSuggestionShow();
	});
}

function UISuggestionCreator() {
	var args = ["ui-suggestion", "ui-suggestion", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISuggestion();
		return g.initUISuggestion(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISuggestionCreator());

/*
 * File:   ui-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIButton
 * @extends UIElement
 * 按钮。被点击后触发一个回调函数。可以设置按钮在不同状态下的图片。
 *
 * * UIElement.IMAGE_NORMAL 正常时的图片。
 * * UIElement.IMAGE_ACTIVE 按下时的图片。
 * * UIElement.IMAGE_FOCUSED 得到焦点时的图片。
 * * UIElement.IMAGE_DISABLE 禁用时的图片。
 * * "option_image_0" 备用图片0
 * * "option_image_1" 备用图片1
 * * "option_image_2" 备用图片2
 * * "option_image_3" 备用图片3
 * ...
 * * "option_image_14" 备用图片14
 *
 * 注：备用图片在IDE的图片属性页的图片用途里显示为"图片_X"
 *
 */

function UIButton() {
	return;
}

UIButton.prototype = new UIElement();
UIButton.prototype.isUIButton = true;

UIButton.prototype.initUIButton = function(type, w, h) {
	this.initUIElement(type);	

	this.setMargin(5, 5);
	this.setDefSize(w, h);
	this.setSizeLimit(20, 20);
	this.setAutoScaleFontSize(true);
	this.setTextType(Shape.TEXT_INPUT);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIButton.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

UIButton.prototype.paintSelfOnly =function(canvas) {
	if(this.pointerDown) {
		var image = this.getHtmlImageByType(UIElement.IMAGE_ACTIVE);

		if(!image) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);
		}
	}

	return;
}

function UIButtonCreator(w, h) {
	var args = ["ui-button", "ui-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIButton();
		return g.initUIButton(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIButtonCreator(120, 60));

/*
 * File:   ui-mledit.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Multi Line Editor
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIMLEdit
 * @extends UIElement
 * 多行编辑器。
 */

/**
 * @event onChanged
 * 文本变化时触发本事件。
 * @param {String} value 当前的文本。
 */

/**
 * @event onFocusIn
 * 得到输入焦点事件。
 */

/**
 * @event onFocusOut
 * 失去输入焦点事件。
 */
function UIMLEdit() {
	return;
}

UIMLEdit.prototype = new UIElement();
UIMLEdit.prototype.isUIMLEdit = true;

UIMLEdit.prototype.saveProps = ["inputTips"];
UIMLEdit.prototype.initUIMLEdit = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setText("");
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_FOCUSED, null);
	this.setMargin(12, 12);
	this.addEventNames(["onChanged", "onFocusIn", "onFocusOut"]);
	this.setTextAlignV("top");
	this.setTextAlignH("left");

	return this;
}

UIMLEdit.prototype.drawText = function(canvas) {
	if(!this.text || this.editing) {
		return;
	}

	if(this.textNeedRelayout) {
		this.layoutText(canvas);	
	}

	return this.defaultDrawText(canvas);
}

UIMLEdit.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIMLEdit.prototype.textEditable = function(point) {
	return true;
}

UIMLEdit.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	if(!this.isInDesignMode()) {
		this.editText();
	}

    return this.callOnClickHandler(point);
}

UIMLEdit.prototype.isFocused = function() {
	return this.editing;
}

UIMLEdit.prototype.getEditorRect = function() {
	var p = this.getPositionInView();
	var cp = CantkRT.getMainCanvasPosition();
	var vp = this.view.getAbsPosition();
	var scale = this.view.getViewScale();

	var canvasScale = UIElement.getMainCanvasScale();
	var x = (vp.x + p.x * scale)/canvasScale.x + cp.x;
	var y = (vp.y + p.y * scale)/canvasScale.y + cp.y;
	var w = (this.getWidth() * scale)/canvasScale.x;
	var h = (this.getHeight() * scale)/canvasScale.y;
	
	var rect = {x:x, y:y, w:w, h:h};
	if(this.isInDesignMode()) {
		var radtio = window.devicePixelRatio || 1;
		rect.x *= radtio;
		rect.y *= radtio;
		rect.w *= radtio;
		rect.h *= radtio;
	}

	return rect;
}

UIMLEdit.prototype.editText = function(point) {
	if(this.textEditable(point)) {
		var shape = this;
		var rect = this.getEditorRect();
		var scale = this.getRealScale() / UIElement.getMainCanvasScale().y;
		var inputType = this.inputType ? this.inputType : "text";
		var fontSize = this.style.fontSize * scale; 
		var editor = cantkShowTextArea(this.getText(), fontSize, rect.x, rect.y, rect.w, rect.h);
		
		shape.editing = true;
		editor.setTextColor(this.style.textColor);
		editor.showBorder(this.isInDesignMode());
	    editor.show();	
        function onChanged(text) {
			if(text !== shape.text) {
				shape.setText(text, true);
				shape.postRedraw();
			}
			else {
				shape.text = text;
			}
			
			editor.setOnChangedHandler(null);
	        editor.setOnChangeHandler(null);
			editor.hide();
			delete shape.editing;
			shape.callOnFocusOutHandler();

			return;
		}

		function onChange(text) {
			shape.callOnChangingHandler(text);
		}

		editor.setOnChangedHandler(onChanged);
		editor.setOnChangeHandler(onChange);
		
		this.callOnFocusInHandler();
	}

	return;
}

UIMLEdit.prototype.getTextTipsPosition = function() {
	var pos = {};

	pos.x = this.hMargin;
	pos.y = this.vMargin;
	pos.textAlign = "left";
	pos.textBaseline = "top";

	return pos;
}

function UIMLEditCreator(w, h) {
	var args = ["ui-mledit", "ui-mledit", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMLEdit();
		return g.initUIMLEdit(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMLEditCreator(300, 300));

/*
 * File:   ui-toolbar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Toolbar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIToolBar
 * @extends UIElement
 * 通常是放在窗口的顶部或底部的一个容器，里面放窗口的标题和导航的按钮。
 *
 */
function UIToolBar() {
	return;
}

UIToolBar.prototype = new UIElement();
UIToolBar.prototype.isUIToolBar = true;

UIToolBar.prototype.initUIToolBar = function(type, atTop, h, bg) {
	this.initUIElement(type);	

	this.xAttr = UIElement.X_LEFT_IN_PARENT;
	this.widthAttr = UIElement.WIDTH_FILL_PARENT;
	this.yAttr = atTop ? UIElement.Y_TOP_IN_PARENT : UIElement.Y_BOTTOM_IN_PARENT;

	this.setDefSize(200, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setSizeLimit(100, 50, 2000, 200);

	return this;
}

UIToolBar.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUILabel || shape.isUIImage || shape.isUIButton || shape.isUIGroup 
	|| shape.isUIButtonGroup || shape.isUIEdit || shape.isUIImageButton
	|| shape.isUICheckBox || shape.isUIRadioBox || shape.isUIProgressBar || shape.isUISwitch 
	|| shape.isUILedDigits || shape.isUIGroup || shape.isUILayout || shape.isUIWaitBar || shape.isUIColorBar) {
		return true;
	}

	return false;
}

UIToolBar.prototype.paintSelfOnly =function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);

	if(!image) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	return;
}

function UIToolBarCreator(type, atTop, h, bg) {
	var args = [type, "ui-toolbar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIToolBar();
		return g.initUIToolBar(type, atTop, h, bg);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIToolBarCreator("ui-toolbar", true, 85, null));

/*
 * File:   ui-placeholder.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Place Holder
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPlaceholder() {
	return;
}

UIPlaceholder.prototype = new UIElement();
UIPlaceholder.prototype.isUIPlaceholder = true;
UIPlaceholder.prototype.initUIPlaceholder = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, false);

	return this;
}

UIPlaceholder.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPlaceholder.prototype.paintSelfOnly = function(canvas) {
	if(this.isInDesignMode()) {
		var x = this.vMargin;
		var y = this.hMargin;
		var w = this.getWidth(true);
		var h = this.getHeight(true);

		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		drawDashedRect(canvas, x, y, w, h);
		canvas.stroke();
	}

	return;
}

function UIVPlaceholderCreator(w, h) {
	var args = ["ui-v-placeholder", "ui-placeholder", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPlaceholder();

		g.initUIPlaceholder(this.type, w, h);
		g.widthAttr = UIElement.WIDTH_FILL_PARENT;
		g.MIN_SIZE = 4;
		g.setSizeLimit(20, 4);

		return g;
	}
	
	return;
}

function UIHPlaceholderCreator(w, h) {
	var args = ["ui-h-placeholder", "ui-placeholder", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPlaceholder();

		g.initUIPlaceholder(this.type, w, h);
		g.heightAttr = UIElement.HEIGHT_FILL_PARENT;
		g.MIN_SIZE = 4;
		g.setSizeLimit(4, 20);

		return g;
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIVPlaceholderCreator(100, 20));
ShapeFactoryGet().addShapeCreator(new UIHPlaceholderCreator(20, 100));

/*
 * File:   ui-radio-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Radio Box
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIRadioBox
 * @extends UICheckBox
 * 单选按钮。可以用setValue来勾选/去勾选，用getValue来判断是否勾选。
 *
 */
function UIRadioBox() {
	return;
}

UIRadioBox.prototype = new UICheckBox();
UIRadioBox.prototype.isUIRadioBox = true;

UIRadioBox.prototype.initUIRadioBox = function(type) {
	return this.initUICheckBox(type)
}

UIRadioBox.prototype.setParent = function(parentShape) {
	UIElement.prototype.setParent.call(this, parentShape);

	if(this.value) {
		this.setChecked();
	}

	return this;
}

UIRadioBox.prototype.onFromJsonDone = function() {
	if(this.value) {
		this.setChecked();
	}

	return this;
}

UIRadioBox.prototype.setChecked = function() {
	var parentShape = this.getParent();

	if(parentShape) {
		for(var i = 0; i < parentShape.children.length; i++) {
			var shape = parentShape.children[i];
			if(shape.isUIRadioBox) {
				shape.setValue(false);
			}
		}
	}

	this.setValue(true);

	return this;
}

UIRadioBox.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}
	
	this.setChecked();
	
	return this.callOnClickHandler(point);
}

function UIRadioBoxCreator(w, h) {
	var args = ["ui-radiobox", "ui-radiobox", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIRadioBox();
		g.initUIRadioBox(this.type);

		return g;
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIRadioBoxCreator(50, 50, null, null, null, null, null, null));

/*
 * File:   ui-led-digits.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  LED Digits 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UILedDigits() {
	return;
}

UILedDigits.prototype = new UIElement();
UILedDigits.prototype.isUILedDigits = true;

UILedDigits.prototype.initUILedDigits = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);

	return this;
}

UILedDigits.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UILedDigits.prototype.setText = function(text) {
	this.text = "";

	text = this.toText(text); 
	for(var i = 0; i < text.length; i++) {
		var c = text[i];

		switch(c) {
			case '.':
			case ':':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'E':
			case 'F':
			case 'F': {
				this.text = this.text + c;
			}
			default:break;
		}
	}

	return;
}

UILedDigits.prototype.drawBarVL = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(0, h);
	canvas.lineTo(w, h-w);
	canvas.lineTo(w, w);
	canvas.lineTo(0, 0);

	return;
}

UILedDigits.prototype.drawBarVR = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(w, 0);
	canvas.lineTo(w, h);
	canvas.lineTo(0, h-w);
	canvas.lineTo(0, w);
	canvas.lineTo(w, 0);

	return;
}

UILedDigits.prototype.drawBarHT = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, 0);
	canvas.lineTo(w, 0);
	canvas.lineTo(w-h, h);
	canvas.lineTo(h, h);
	canvas.lineTo(0, 0);

	return;
}

UILedDigits.prototype.drawBarHM = function(canvas, w, h) {
	canvas.beginPath();
	var space = Math.round(h/3);
	w = w - 2 * space;
	canvas.translate(space, 0);
	canvas.moveTo(0, h/2);
	canvas.lineTo(h/2, 0);
	canvas.lineTo(w-h/2, 0);
	canvas.lineTo(w, h/2);
	canvas.lineTo(w-h/2, h);
	canvas.lineTo(h/2, h);
	canvas.lineTo(0, h/2);
	canvas.translate(-space, 0);

	return;
}
UILedDigits.prototype.drawBarHB = function(canvas, w, h) {
	canvas.beginPath();
	canvas.moveTo(0, h);
	canvas.lineTo(w, h);
	canvas.lineTo(w-h, 0);
	canvas.lineTo(h, 0);
	canvas.lineTo(0, h);

	return;
}

UILedDigits.prototype.drawBar = function(canvas, w, h) {
	if(w < h) {
		this.drawBarV(canvas, w, h);
	}
	else {
		this.drawBarH(canvas, w, h);
	}

	return;
}

UILedDigits.prototype.drawDot = function(canvas, w, h, dot) {
	var size = (w/4 + h/8)/2;

	if(dot === ".") {
		canvas.fillRect((w-size)/2, 0.75*h - size/2, size, size);
	}
	else if(dot = ":") {
		canvas.fillRect((w-size)/2, 0.25*h - size/2, size, size);
		canvas.fillRect((w-size)/2, 0.75*h - size/2, size, size);
	}

	return;
}

UILedDigits.prototype.map = {
	"0":0x7d,
	"1":0x60,
	"2":0x37,
	"3":0x67,
	"4":0x6a,
	"5":0x4f,
	"6":0x5f,
	"7":0x61,
	"8":0x7f,
	"9":0x6f,
	"E":0x1f,
	"F":0x1b,
	"H":0x7a
};

UILedDigits.prototype.fillBar = function(canvas, light) {
	if(light) {
		canvas.fillStyle = this.style.textColor;
		canvas.fill();
	}
	else {
		canvas.lineWidth = 1;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}

UILedDigits.prototype.drawDigit = function(canvas, w, h, digit) {
	var hBarHeight = Math.max(3, Math.round(h/10));
	var vBarWidht = Math.max(3, Math.round(w/10));
	var size = Math.round((vBarWidht + hBarHeight)/2);

	var space = 1;
	var hBarWidth = w - 2 * space;
	var vBarHeight = Math.floor(h/2 - 2 * space);
	var mask = this.map[digit];

	canvas.translate(space, 0);
	this.drawBarHT(canvas, hBarWidth, size);
	canvas.translate(-space, 0);
	this.fillBar(canvas, mask & 0x01);

	var yOffset = Math.floor((h-hBarHeight)/2);
	canvas.translate(space, yOffset);
	this.drawBarHM(canvas, hBarWidth, size);
	canvas.translate(-space, -yOffset);
	this.fillBar(canvas, (mask >> 1) & 0x01);

	var yOffset = h-hBarHeight;
	canvas.translate(space, yOffset);
	this.drawBarHB(canvas, hBarWidth, size);
	canvas.translate(-space, -yOffset);
	this.fillBar(canvas, (mask >> 2) & 0x01);

	canvas.translate(0, space);
	this.drawBarVL(canvas, size, vBarHeight);
	canvas.translate(0, -space);
	this.fillBar(canvas, (mask >> 3) & 0x01);

	var yOffset = Math.round(2*space + (h-hBarHeight)/2)+space;
	canvas.translate(0, yOffset);
	this.drawBarVL(canvas, size, vBarHeight);
	canvas.translate(0, -yOffset);
	this.fillBar(canvas, (mask >> 4) & 0x01);

	canvas.translate((w-size), space);
	this.drawBarVR(canvas, size, vBarHeight);
	canvas.translate(-(w-size), -space);
	this.fillBar(canvas, (mask >> 5) & 0x01);

	canvas.translate((w-size), yOffset);
	this.drawBarVR(canvas, size, vBarHeight);
	canvas.translate(-(w-size), -yOffset);
	this.fillBar(canvas, (mask >> 6) & 0x01);
	
	return;
}

UILedDigits.prototype.drawDigits = function(canvas) {
	var dots = 0;
	var text = this.text
	var n = text.length;

	if(!n) {
		return;
	}

	for(var i = 0; i < n; i++) {
		var d = text[i];
		if(d === "." || d === ":") {
			dots = dots + 1;
		}
	}

	var space = this.w/n * 0.2;
	var w = this.w/n - space;
	var h = this.h;

	canvas.save();
	canvas.translate(w/4 * dots, 0);
	for(var i = 0; i < n; i++) {
		var d = text[i];
		if(d === "." || d === ":") {
			this.drawDot(canvas, w/2, h, text[i]);
			canvas.translate(w/2+space, 0);
		}
		else {
			this.drawDigit(canvas, w, h, text[i]);
			canvas.translate(w+space, 0);
		}
	}
	canvas.restore();

	return;
}

UILedDigits.prototype.paintSelfOnly = function(canvas) {
	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	canvas.fillStyle = this.style.lineColor;
	this.drawDigits(canvas);

	return;
}

function UILedDigitsCreator(w, h) {
	var args = ["ui-led-digits", "ui-led-digits", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILedDigits();
		return g.initUILedDigits(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UILedDigitsCreator(100, 100));

/*
 * File:   ui-canvas.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Canvas
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICanvas
 * @extends UIElement
 * 画布控件。
 *
 * 注意：UICanvas其实与其它控件共享一个画布，只是把画布的接口暴露出来，所以每次窗口重绘时，里面的内容都被清除，需要重新绘制。
 *
 */

/**
 * @event onPaint(canvas2dCtx) 
 * 绘图事件。
 * @param {Object} canvas2dCtx 画布的2d Context。
 * 参考：[https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 *
 *     @example small frame
 *     var image = this.getImageByType(0);
 *     var img = image.getImage();
 *     var rect = image.getImageRect();
 *
 *     canvas2dCtx.drawImage(img, rect.x, rect.y, rect.w, rect.h, 0, 0, this.w, this.h);
 *
 *     canvas2dCtx.moveTo(0, 0);
 *     canvas2dCtx.lineTo(this.w, this.h);
 *     canvas2dCtx.lineWidth = 2;
 *     canvas2dCtx.strokeStyle = "red";
 *     canvas2dCtx.stroke();
 *
 */

function UICanvas() {
	return;
}

UICanvas.prototype = new UIElement();
UICanvas.prototype.isUICanvas = true;

UICanvas.prototype.initUICanvas = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.addEventNames(["onPaint", "onPointerDown", "onPointerMove", "onPointerUp", "onKeyDown", 
		"onKeyUp"]);

	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);
	this.setImage("option_image_6", null);
	this.setImage("option_image_7", null);
	this.setImage("option_image_8", null);
	this.setImage("option_image_9", null);
	this.setImage("option_image_10", null);
	this.setImage("option_image_11", null);
	this.setImage("option_image_12", null);
	this.setImage("option_image_13", null);
	this.setImage("option_image_14", null);
	
	return this;
}

UICanvas.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIImage || shape.isUIButton || shape.isUIGroup || shape.isUILabel;
}

UICanvas.prototype.paintSelfOnly = function(canvas) {
	var image = this.getHtmlImageByType(UIElement.IMAGE_DEFAULT);
	
	if(!image && !this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.fillStyle = this.style.fillColor;
		canvas.fillRect(0, 0, this.w, this.h);
	}

	canvas.beginPath();
	this.callOnPaintHandler(canvas);

	return;
}

function UICanvasCreator(w, h) {
	var args = ["ui-canvas", "ui-canvas", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICanvas();
		return g.initUICanvas(this.type, w, h);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UICanvasCreator(200, 200));

/*
 * File:   ui-color-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Color Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIColorButton
 * @extends UIElement
 * 颜色按钮。不同状态下可以设置不同的颜色，可以是矩形，圆角矩形或圆形。
 *
 */

/**
 * @property {Number} roundRadius
 * 控件的圆角半径。0表示不圆角。
 */

function UIColorButton() {
	return;
}

UIColorButton.prototype = new UIElement();
UIColorButton.prototype.isUIButton = true;
UIColorButton.prototype.isUIColorButton = true;

UIColorButton.prototype.initUIColorTile = function(type, w, h) {
	this.initUIColorButton(type, w, h);
	this.isUIButton = false;
	this.isUIColorButton = false;
	this.isUIColorTile = true;
	this.setAutoScaleFontSize(true);
	this.addEventNames(["onUpdateTransform"]); 
	this.style.roundStyle = 'a';

	return this;
}

UIColorButton.prototype.initUIColorButton = function(type, w, h) {
	this.initUIElement(type);	

	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_INPUT);
	this.setCanRectSelectable(false, false);
	this.setMargin(0, 0);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIColorButton.prototype.shapeCanBeChild = UIGroup.prototype.shapeCanBeChild;

/**
 * @method setRoundStyle
 * 设置控件的圆角风格。
 * @param {String} roundStyle 圆角风格。'l'表示左边圆角, 'r'表示右边圆角, 't'表示顶部圆角, 'b'表示底部圆角, 'a'表示全部圆角。
 * @return {UIElement} 返回控件本身。
 *
 */
UIColorButton.prototype.setRoundStyle = function(roundStyle) {
	this.style.roundStyle = roundStyle;

	return this;
}

/**
 * @method getRoundStyle
 * 获取控件的圆角风格。
 * @return {UIElement} 返回圆角风格。
 *
 */
UIColorButton.prototype.getRoundStyle = function() {
	return this.style.roundStyle;
}

/**
 * @method setActiveFillColor
 * 设置控件按下时的填充颜色。
 * @param {String} color 颜色。
 * @return {UIElement} 返回控件本身。
 */
UIColorButton.prototype.setActiveFillColor = function(color) {
	this.style.activeFillColor = color;
	
	return this;
}

UIColorButton.prototype.getRoundStyleValue =function() {
	var roundStyle = this.style.roundStyle;

	if(roundStyle === 't') {
		return RoundRect.TL | RoundRect.TR;
	}
	else if(roundStyle === 'l') {
		return RoundRect.TL | RoundRect.BL;
	}
	else if(roundStyle === 'r') {
		return RoundRect.TR | RoundRect.BR;
	}
	else if(roundStyle === 'b') {
		return RoundRect.BL | RoundRect.BR;
	}
	else {
		return RoundRect.TL | RoundRect.TR | RoundRect.BL | RoundRect.BR; 
	}
}

UIColorButton.prototype.paintSelfOnly =function(canvas) {
	var roundStyle = this.getRoundStyleValue();
	var fillColor = this.style.fillColor;
	var lineColor = this.style.lineColor;

	if(this.pointerDown && this.style.activeFillColor) {
		fillColor = this.style.activeFillColor;
	}

	var fillIt = !Shape.isTransparentColor(fillColor);
	var strokeIt = !Shape.isTransparentColor(lineColor);
		
	if(!fillIt && !strokeIt) {
		return;
	}

	canvas.save();
	canvas.beginPath();

	canvas.translate(this.hMargin, this.vMargin);
	drawRoundRect(canvas, this.w-2*this.hMargin, this.h-2*this.vMargin, this.roundRadius, roundStyle);

	if(fillIt) {
		canvas.fillStyle = fillColor;
		canvas.fill();
	}

	if(strokeIt) {
		if(this.isUIColorButton && this.pointerDown) {
			canvas.lineWidth = this.style.lineWidth + 1;
		}
		else {
			canvas.lineWidth = this.style.lineWidth;
		}

		canvas.strokeStyle = lineColor;
		canvas.stroke();
	}

	canvas.restore();

	return;
}

function UIColorTileCreator(w, h) {
	var args = ["ui-color-tile", "ui-color-tile", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorButton();

		return g.initUIColorTile(this.type, w, h);
	}
	
	return;
}

function UIColorButtonCreator(w, h) {
	var args = ["ui-color-button", "ui-color-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIColorButton();

		return g.initUIColorButton(this.type, w, h);
	}
	
	return;
}

/**
 * @class UIColorTile
 * @extends UIColorButton
 * 颜色块，可以是矩形，圆角矩形或圆形。
 *
 */
ShapeFactoryGet().addShapeCreator(new UIColorTileCreator(80, 80));
ShapeFactoryGet().addShapeCreator(new UIColorButtonCreator(80, 80));

/*
 * File:   ui-view-pager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  View Page (AKA Tab Control)
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIViewPager
 * @extends UIFrames
 * 标签控件。
 *
 */
function UIViewPager() {
	return;
}

UIViewPager.prototype = new UIPageManager();
UIViewPager.prototype.isUIViewPager = true;

UIViewPager.prototype.saveProps = ["slideToChange"];
UIViewPager.prototype.initUIViewPager = function(type) {
	this.initUIPageManager(type);	

	this.current = 0;
	this.setDefSize(200, 200);
	this.setTextType(UIElement.TEXT_NONE);
	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator(2);
    this.animateQueue = [];

	return this;
}

UIViewPager.prototype.getPrevFrame = function() {
	var n = this.children.length;
	var index = (this.current - 1 + n)%n;

	return this.children[index];
}

UIViewPager.prototype.getNextFrame = function() {
	var n = this.children.length;
	var index = (this.current + 1)%n;

	return this.children[index];
}

UIViewPager.prototype.animScrollTo = function(range, newFrame) {

	var duration = 1000;
	var slideview = this;
	var startOffset = this.offset;
	var startTime = Date.now();
	var interpolator = this.interpolator;

	if(slideview.animating) {
		return;
	}

	slideview.animating = true;
	function animStep() {
		var now = Date.now();
		var timePercent = (now - startTime)/duration;
		var percent = interpolator.get(timePercent);
		
		if(timePercent < 1 && !slideview.halt) {
			slideview.offset = startOffset + range * percent;
			setTimeout(animStep, 16);
		}
		else {
			slideview.offset = 0;
			slideview.setCurrent(newFrame);
			slideview.setAnimatingFrames(null, null);

			delete startTime;
			delete interpolator;
			delete slideview.animating;
            delete slideview.halt;
            
            slideview.queueAnimation();
		}

		slideview.postRedraw();
	}

	animStep();

	return;
}

UIViewPager.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild || this.animating || !this.slideToChange) {
		return;
	}
	
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	this.velocityTracker.clear();

	return true;
}

UIViewPager.prototype.isEventHandledByChild = function() {
	if(UIElement.hScrollHandledBy && UIElement.hScrollHandledBy !== this) {
		return true;
	}else{
		return false;
	}
}

UIViewPager.prototype.setEventHandled = function() {
	UIElement.hScrollHandledBy = this;

	return this;
}

UIViewPager.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(!this.slideToChange || beforeChild || !this.pointerDown) {
		return;
	}

	if(this.animating) {
		this.setEventHandled();
		return;
	}

	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.current;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var dx = Math.abs(this.getMoveAbsDeltaX());
	var dy = Math.abs(this.getMoveAbsDeltaY());
	
	if(dx > dy && dx > 10) {
		this.offset = this.getMoveAbsDeltaX();
		this.setAnimatingFrames(this.getPrevFrame(), this.getNextFrame());
	}
	else {
		this.offset = 0;
		this.setAnimatingFrames(null, null);
	}

	this.addMovementForVelocityTracker();

	return;
}
	
UIViewPager.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(!this.slideToChange || beforeChild || !this.pointerDown) {
		return;
	}

	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.current;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var range = 0;
	var offsetX = this.offset;
	var newFrame = this.current;
	var dy = Math.abs(this.getMoveAbsDeltaY());
	var velocity = this.velocityTracker.getVelocity().x;

	if(Math.abs(offsetX) < 5 || dy > 60) {
		this.offset = 0;

		return;
	}

	var n = this.children.length;
	var distance = offsetX + velocity;

	if(Math.abs(distance) > this.w/3) {
		if(offsetX > 0) {
			range = this.w - offsetX;	
			newFrame = (this.current - 1 + n)%n;
		}
		else {
			range = -this.w - offsetX;
			newFrame = (this.current + 1)%n;
		}
	}
	else {
		range = -offsetX;
	}

	this.animScrollTo(range, newFrame);

	return;
}

UIViewPager.prototype.setAnimatingFrames = function(leftFrame, rightFrame) {
	this.leftFrame = leftFrame;
	this.rightFrame = rightFrame;

	return this;
}

/**
 * @method switchTo 
 * 设置当前显示的子控件。
 * @param {Number} index 子控件的索引，与setCurrent不同是，switchTo有切换动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIViewPager.prototype.switchTo = function(index) {
	var arr = this.children;
	var n = arr.length;
	
	this.offset = 0;
    if(index < 0 || index > n - 1) {
        return;
    }
    
    if(this.animateQueue === undefined) {
        this.animateQueue = [];
    } 
    this.animateQueue.push(index);
    
    if(this.animating) {
        console.log("busy...");
        this.halt = true;
        return;
    }
   
    this.queueAnimation();

	return this;
}

UIViewPager.prototype.queueAnimation = function() {
    if(this.animateQueue.length < 1) {
        return;
    }
	var arr = this.children;
    var index = this.animateQueue.pop();
    this.animateQueue = [];
    var newFrame = arr[index];
    if(index < this.current) {
        this.animScrollTo(this.w, index);
        this.setAnimatingFrames(newFrame, null);
    }else{
        this.animScrollTo(-this.w, index);
        this.setAnimatingFrames(null, newFrame);
    }
}

UIViewPager.prototype.paintChildrenAnimating = function(canvas) {
	var currFrame = this.getCurrentFrame();
	var prevFrame = this.leftFrame;
	var nextFrame = this.rightFrame;

	canvas.save();
	canvas.clipRect(0, 0, this.w, this.h);

	if(this.offset > 0) {
		var offsetX = this.w-this.offset;
		prevFrame.x = -offsetX;
		prevFrame.paintSelf(canvas);
		offsetX = this.offset;
		currFrame.x = offsetX;
		currFrame.paintSelf(canvas);
	}
	else {
		currFrame.x = this.offset;
		currFrame.paintSelf(canvas);
		nextFrame.x = this.w + this.offset;
		nextFrame.paintSelf(canvas);
	}
	if(currFrame) {
		currFrame.x = 0;
	}
	if(nextFrame) {
		nextFrame.x = 0;
	}
	if(prevFrame) {
		prevFrame.x = 0;
	}

	canvas.restore();

	return;
}

UIViewPager.prototype.paintChildrenNormal = function(canvas) {
	var child = this.getCurrentFrame();
	
	if(child) {
		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}
	
	return;
}

UIViewPager.prototype.paintChildren = function(canvas) {
	if(this.offset && this.children.length > 1 && (this.leftFrame || this.rightFrame)) {
		this.paintChildrenAnimating(canvas);
	}
	else {
		this.paintChildrenNormal(canvas);
	}

	return;
}

UIViewPager.prototype.setSlideToChange = function(value) {
	this.slideToChange = value;

	return;
}

function UIViewPagerCreator() {
	var args = ["ui-view-pager", "ui-view-pager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIViewPager();

		return g.initUIViewPager(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIViewPagerCreator());

/*
 * File:   ui-progressbar.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Slider/ProgressBar
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISlider
 * @extends UIProgressBar 
 * 新版本中UISlider已经被弃用，API参见UIProgressBar
 *
 */

/**
 * @class UIProgressBar
 * @extends UIElement
 * 进度条。可以用setValue/getValue来设置/获取进度。缺省进度取值范围0-100，也可以用setRange来设置它的取值范围。
 *
 * 在进度条上放一张图片，可以把进度条变成一个滑块控件。
 *
 * 进度条有3种表现形式：
 * 
 * 1.宽度大于高度时为水平进度条。

 * 2.宽度小于高度时为垂直进度条。
 * 
 * 3.宽度约等于高度时为环状进度条。
 *
 *     @example small frame
 *     this.win.find("progressbar").setValue(50, true, true);
 *
 */

/**
 * @event onChanged
 * 进度变化时触发本事件。
 * @param {Number} value 当前的进度。
 */

/**
 * @event onChanging
 * 进度正在变化时触发本事件。只有做为滑块控件时，拖动滑块才会触发本事件。
 * @param {Number} value 当前的进度。
 */
function UIProgressBar() {
	return;
}

UIProgressBar.prototype = new UIElement();
UIProgressBar.prototype.isUIProgressBar = true;
UIProgressBar.prototype.saveProps = ["stepSize", "minValue", "maxValue"];
UIProgressBar.prototype.initUIProgressBar = function(type, w, h, interactive) {
	this.initUIElement(type);	

	this.setRange(0, 100);
	this.setPercent(50);
	this.setDefSize(w, h);
	this.setStepSize(0);
	this.roundRadius = 0;
	this.setInteractive(interactive);
	this.setTextType(Shape.TEXT_INPUT);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_NORMAL_FG, null);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	if(interactive) {
		this.addEventNames(["onChanged"]);
		this.addEventNames(["onChanging"]);
	}

	return this;
}

UIProgressBar.prototype.shapeCanBeChild = function(shape) {
	if(this.dragger) {
		return false;
	}

	return (shape.isUIImage || shape.isUILabel || shape.isUIColorTile);
}

UIProgressBar.prototype.updateDraggerParams =function() {
	var shape = this.dragger;
	if(!shape) return;

	if(this.w < this.h) {
		shape.yAttr = UIElement.Y_FIX_TOP;
		shape.xAttr = UIElement.X_CENTER_IN_PARENT;
		shape.widthAttr = UIElement.WIDTH_FILL_PARENT;
		shape.heightAttr = UIElement.HEIGHT_FIX;
	}
	else {
		shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;
		shape.xAttr = UIElement.X_FIX_LEFT;
		shape.widthAttr = UIElement.WIDTH_FIX;
		shape.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	}
}

UIProgressBar.prototype.relayoutChildren = function() {
	if(!this.dragger) {
		return;
	}

	if(this.w > this.h) {
		var x = this.value * (this.w - this.dragger.w);	
		var maxX = this.w - this.dragger.w;
		this.dragger.setLeft(Math.max(0, Math.min(maxX, x)));
	}
	else {
		var y = (1-this.value) * (this.h - this.dragger.h);
		var maxY = this.h - this.dragger.h;
		this.dragger.setTop(Math.max(0, Math.min(maxY, y)))
	}

	UIElement.prototype.relayoutChildren.call(this);

	return;
}

UIProgressBar.prototype.resizeDragger =function() {
	if(this.dragger) {
		var w = this.dragger.w;
		var h = this.dragger.h;
		if(this.w > this.h) {
			h = this.h;
			w = Math.min(this.h, w);
		}
		else {
			w = this.w;
			h = Math.min(this.w, h);
		}
		this.dragger.setSize(w, h);
	}

	return this;
}

/**
 * @method setStepSize
 * 设置Slider的步长。
 * @param {Number} stepSize 取值范围0-50，0表示平滑移动。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var win = this.win;
 *     var slider = win.find("slider");
 *     slider.setStepSize(20);
 */
UIProgressBar.prototype.setStepSize = function(stepSize) {
	var range = this.maxValue - this.minValue;
	this.stepSize = Math.max(0, Math.min(stepSize, range));

	return this;
}

/**
 * @method setRange 
 * 设置进度条的取值范围。
 * @param {Number} minValue 最小值。
 * @param {Number} maxValue 最大值。
 * @return {UIElement} 返回控件本身。
 *
 * 示例：
 *
 *     @example small frame
 *     var win = this.win;
 *     var slider = win.find("slider");
 *     slider.setRange(0, 5);
 *     slider.setStepSize(1);
 */
UIProgressBar.prototype.setRange = function(minValue, maxValue) {
	this.minValue = Math.max(0, Math.min(minValue, maxValue));
	this.maxValue = Math.max(0, Math.max(minValue, maxValue));

	if(this.minValue === this.maxValue) {
		this.minValue = 0;
		this.maxValue = 100;
	}

	return this;
}

/**
 * @method getStepSize
 * 获取Slider的步长。
 * @return {Number} Slider的步长。
 */
UIProgressBar.prototype.getStepSize = function() {
	return this.stepSize || 0;
}

/**
 * @method getMinValue
 * 获取范围的最小值。可以用setRange来设置取值范围。
 * @return {Number} 范围的最小值。
 */
UIProgressBar.prototype.getMinValue = function() {
	return this.minValue;
}

/**
 * @method getMaxValue
 * 获取范围的最大值。可以用setRange来设置取值范围。
 * @return {Number} 范围的最大值。
 */
UIProgressBar.prototype.getMaxValue = function() {
	return this.maxValue;
}

UIProgressBar.prototype.afterChildRemoved = function(shape) {
    if(shape === this.dragger) {
        this.dragger = null;
    }
}

UIProgressBar.prototype.afterChildAppended =function(shape) {
	var bar = this;
	
	this.dragger = shape;
	this.updateDraggerParams();
	this.setTextType(Shape.TEXT_NONE);

	bar.onPointerDownRunning = bar.onPointerMoveRunning = function(point, beforeChild) {
		if(beforeChild) {
			return;
		}

		var hw = this.dragger.w >> 1;
		var hh = this.dragger.h >> 1;
		if(this.pointerDown && this.dragger) {
			var x = point.x - hw;
			var y = point.y - hh;
			x = Math.min(Math.max(-2, x), this.w - hw + 2);
			y = Math.min(Math.max(-2, y), this.h - hh + 2);

			this.dragger.move(x, y);
		}
		
		return;
	}

	bar.onPointerUpRunning = function(point, beforeChild) {
		if(beforeChild) {
			return;
		}

		if(this.changed) {
			this.changed = false;
			this.callOnChangedHandler(this.getValue());
		}

		return;
	}

	bar.onSized = function() {
		var size = Math.min(this.w, this.h);
		this.updateLayoutParams();
		this.setPercent(this.getPercent());
		this.resizeDragger();
		this.updateDraggerParams();

		return;
	}

	shape.onSized = function() {
		bar.resizeDragger();
	}

	shape.onMoved = function() {
		var percent = 0;
		if(bar.w > bar.h) {
			var value = this.left/(bar.w - this.w);
			percent = value * 100;
			if(this.left <= 0) {
				percent = 0;
			}
			if((this.left + this.w) >= bar.w) {
				percent = 100;
			}
		}
		else {
			var value = (bar.h - this.h - this.top)/(bar.h - this.h);
			percent = value * 100;
			if(this.top <= 0) {
				percent = 100;
			}
			if((this.top + this.h) >= bar.h) {
				percent = 0;
			}
		}

		bar.changed = true;
		bar.setPercentOnly(percent);
		bar.callOnChangingHandler(bar.getValue());

		return;
	}
	
	return;
}

UIProgressBar.prototype.setInteractive = function(value) {
	this.interactive = value;

	return this;
}

UIProgressBar.prototype.fixPercent = function(percent, stepSize) {
	var fixedPercent = percent;

	if(stepSize && percent < 100) {
		var range = this.maxValue - this.minValue;
		var value = Math.round(((percent/100) * range)/stepSize) * stepSize;
		fixedPercent = (value/range) * 100;
	}

	return Math.min(fixedPercent, 100)/100;
}

UIProgressBar.prototype.setPercentOnly = function(percent, notify, animation) {
	var stepSize = this.stepSize;
	var newValue = this.fixPercent(percent, this.stepSize);
	
	if(!animation) {
		this.value = newValue;
		this.relayoutChildren();
	}

	if(this.isInDesignMode() || !this.isVisible()) {
		return this;
	}

	if(!animation) {
		if(notify) {
			this.callOnChangedHandler(this.getValue());
		}
	}
	else {
		if(this.value == newValue) return this;
		this.setupAnimation({
			notify: notify,
			valueStart: this.value,
			valueEnd: newValue
		});
	}

	return this;
}

UIProgressBar.prototype.setupAnimation = function(config) {
	var me = this;
	var def = {
		duration: 300,
		actionWhenBusy: 'replace',
		onStep: function(ui, timePercent, config) {
			me.value = config.value;
			me.relayoutChildren();
			return true;
		},
		onDone: function(ui, aniName) {
			me.value = config.valueEnd;
			if(config.notify) {
				me.callOnChangedHandler(me.getValue());	
			}
		}
	};

	if(!config) {
		config = def;
	}
	else {
		var keys = Object.keys(def);
		for(var i = 0, len = keys.length; i < len; i++) {
			var k = keys[i];
			if(!config[k]) {
				config[k] = def[k];
			}
		}
	}

	this.animate(config);

	return this;
}

UIProgressBar.prototype.setPercent = function(value, notify, animation) {
	value = Math.max(0, Math.min(value, 100));

	this.setPercentOnly(value, notify, animation);
	this.relayoutChildren();

	return this;
}

UIProgressBar.prototype.getPercent = function() {
	return this.value * 100;
}

UIProgressBar.prototype.getValue = function() {
	var range = this.maxValue - this.minValue;
	var value = this.minValue + this.value * range;
	var stepSize = this.stepSize;

	if(stepSize) {
		var fv = Math.floor((value/stepSize)) * stepSize;
        value = Math.max(value, fv);
	}

	return Math.min(this.maxValue, Math.round(value));
}

UIProgressBar.prototype.setValue = function(value, notify, animation) {
	var range = this.maxValue - this.minValue;
	var percent = 100 * ((value-this.minValue)/range);

	this.setPercent(percent, notify, animation);

	return this;
}

UIProgressBar.prototype.drawText = function(canvas) {
	var text = Math.round(this.getPercent()) + "%";

	if(!this.isTextColorTransparent()) {
		canvas.font = this.style.getFont();
		canvas.fillStyle = this.getTextColor();
		canvas.textBaseline = "middle";
		canvas.textAlign = "center";

		canvas.fillText(text, this.w >> 1, this.h >> 1);
	}

	return;
}

UIProgressBar.prototype.paintSelfOnly = function(canvas) {
}

UIProgressBar.prototype.drawBgImageV = function(canvas) {
	var image = null;
	var w = this.w >> 1;
	var x = (this.w - w)>> 1;
	var fgColor = this.style.lineColor;
	var bgColor = this.style.fillColor;
	var r = this.roundRadius ? this.roundRadius : 0;
	var wImage = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		
		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, x, 0, w, this.h, rect);
		}
	}
	else if(!Shape.isTransparentColor(bgColor)) {
		canvas.beginPath();
		canvas.translate(x, 0);
		drawRoundRect(canvas, w, this.h, r);
		canvas.translate(-x, 0);
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);

	var h = Math.round(this.h * this.value);
	var y = this.h - h;

	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		image = wImage.getImage();

		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			var tmph = rect.h;
			var tmpy = rect.y;
			var tmprh = rect.rh;
			var ih = Math.round(tmph*this.value);
			rect.h = ih;
			rect.y = rect.y + tmph - ih;
			rect.h = ih;
			rect.rh = Math.round(tmprh*this.value);  
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, y, this.w, h, rect);
			rect.y = tmpy;
			rect.h = tmph;
			rect.rh = tmprh;
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, x, y, w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(fgColor)) {
		if(h > 2 * r) {
			canvas.beginPath();
			canvas.translate(x, y);
			drawRoundRect(canvas, w, h, r);
			canvas.fillStyle = this.style.lineColor;
			canvas.fill();
		}
	}

	return;
}

UIProgressBar.prototype.drawBgImageH = function(canvas) {
	var image = null;
	var h = this.h >> 1;
	var y = (this.h - h)>> 1;
	var fgColor = this.style.lineColor;
	var bgColor = this.style.fillColor;
	var r = this.roundRadius ? this.roundRadius : 0;

	var wImage = this.getImageByType(UIElement.IMAGE_DEFAULT);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();
		
		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, 0, y, this.w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(bgColor)) {
		canvas.beginPath();
		canvas.translate(0, y);
		drawRoundRect(canvas, this.w, h, r);
		canvas.translate(0, -y);
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	var w = Math.round(this.w * this.value);
	var wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);
	if(wImage && wImage.getImage()) {
		var rect = wImage.getImageRect();

		image = wImage.getImage();
		if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
			var tmpw = rect.w;
			var tmprw = rect.rw;
			rect.w = Math.round(rect.w*this.value);
			rect.rw = Math.round(rect.rw*this.value);
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, w, this.h, rect);
			rect.w = tmpw; 
			rect.rw= tmprw;
		}
		else {
			WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_9PATCH, 0, y, w, h, rect);
		}
	}
	else if(!Shape.isTransparentColor(fgColor)) {
		if(w > 2 * r) {
			canvas.beginPath();
			canvas.translate(0, y);
			drawRoundRect(canvas, w, h, r);
			canvas.fillStyle = this.style.lineColor;
			canvas.fill();
		}
	}

	return;
}

UIProgressBar.prototype.drawCircle = function(canvas) {
	var cx = this.w >> 1;
	var cy = this.h >> 1;
	var r = Math.min(cx, cy);
	var angle = Math.PI * 2 * this.value - 0.5 * Math.PI;
	var lineWidth = Math.min(r, Math.max(this.style.lineWidth, 5));
	
	var fgImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG);
	var bgImage = this.getImageByType(UIElement.IMAGE_DEFAULT);

	if(bgImage && bgImage.getImage()) {
		var image = bgImage.getImage();
		var rect = bgImage.getImageRect();
		WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
	}
	else if(!this.isFillColorTransparent()) {
		canvas.beginPath();
		canvas.arc(cx, cy, r, 0, Math.PI * 2);
		
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(fgImage && fgImage.getImage()) {
		canvas.beginPath();
		canvas.moveTo(r, r);
		canvas.lineTo(r, 0)
		canvas.arc(cx, cy, r, -Math.PI * 0.5, angle);
		canvas.lineTo(r, r)
		canvas.clip();

		var image = fgImage.getImage();
		var rect = fgImage.getImageRect();
		WImage.draw(canvas, image, UIElement.IMAGE_DISPLAY_SCALE, 0, 0, this.w, this.h, rect);
	}
	else if(!this.isStrokeColorTransparent()) {
		r = r - (lineWidth >> 1);
		
		canvas.beginPath();
		canvas.lineCap = 'round';
		canvas.lineWidth = lineWidth;
		canvas.arc(cx, cy, r, -Math.PI * 0.5, angle);
		
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}

UIProgressBar.prototype.drawBgImage = function(canvas) {
	canvas.save();
	if(Math.abs(this.w - this.h) < 10) {
		this.drawCircle(canvas);
	}
	else if(this.w > this.h) {
		this.drawBgImageH(canvas);
	}
	else {
		this.drawBgImageV(canvas);
	}
	canvas.restore();
}

UIProgressBar.prototype.onFromJsonDone = function() {
	this.setPercent(this.getPercent());

	return;
}

function UIProgressBarCreator(w, h, interactive) {
	var type = interactive ? "ui-slider" : "ui-progressbar";
	var args = [type, "ui-progressbar", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIProgressBar();
		return g.initUIProgressBar(this.type, w, h, interactive);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIProgressBarCreator(200, 45, false));
ShapeFactoryGet().addShapeCreator(new UIProgressBarCreator(200, 45, true));

/*
 * File:   ui-window-manager.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Window Manager
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWindowManager
 * @extends UIFrames
 * 管理着所有窗口，并提供管理窗口的函数，如打开和关闭窗口。但通常您并不需要直接调用窗口管理器的函数，因为这些函数已经封装到UIElement了，在事件处理程序中，通过this直接去访问这些函数就行了。
 *
 */

function UIWindowManager() {
}

UIWindowManager.prototype = new UIFrames();
UIWindowManager.prototype.isUIWindowManager = true;

UIWindowManager.prototype.saveProps = ["current", "sceneIdIndex"];
UIWindowManager.prototype.initUIWindowManager = function(type) {
	this.settings = {};
	this.initUIFrames(type);
	this.history = new Array();

	this.showLoadingProgress = true;
	this.setImage("force-landscape-tips", null);
	this.setImage("force-portrait-tips", null);

	this.soundMusicAutoPlay = true;
	this.setSoundEffectsEnable(true);

	this.loadedAssets = {};
	UIWindowManager.instance = this;

	return this;
}

UIWindowManager.getInstance = function() {
	return UIWindowManager.instance;
}

UIWindowManager.prototype.fromJson = function(json) {
	this.jsonData = json;

	return RShape.prototype.fromJson.call(this, json);
}

UIWindowManager.prototype.onImageLoadDone = function(img, src) {
    if(!img) {
        return;
    }
//	console.log("onImageLoadDone:" + img.src.substr(0, 256));
}

UIWindowManager.prototype.onImageLoadErr = function(src) {
	console.log("onImageLoadErr:" + src);
}

UIWindowManager.prototype.onJsonLoadDone = function(obj, src) {
//	console.log("onJsonLoadDone:" + src);
}

UIWindowManager.prototype.onJsonLoadErr = function(src) {
	console.log("onJsonLoadErr:" + src);
}

UIWindowManager.prototype.loadElementAssets = function(el) {
	if(el.images) {
		for(var key in el.images) {
			var url = el.images[key];
			if(typeof url === "string") {
				WImage.create(url, this.onImageLoadDone.bind(this));
			}
		}
	}

	var jsonAssets = UIElement.jsonAssets;
	for(var i = 0; i < jsonAssets.length; i++) {
		var key = jsonAssets[i];
		var url = el[key];
		if(url) {
			if(url.endWith(".json")) {
				ResLoader.loadJson(url, this.onJsonLoadDone.bind(this), this.onJsonLoadErr.bind(this));
			}
			else {
				ResLoader.loadData(url, this.onJsonLoadDone.bind(this), this.onJsonLoadErr.bind(this));
			}
		}
	}
	
	var imagesAssets = UIElement.imagesAssets;
	for(var i = 0; i < imagesAssets.length; i++) {
		var key = imagesAssets[i];
		var url = el[key];
		if(url) {
			WImage.create(url, this.onImageLoadDone.bind(this));
		}
	}

	var children = el.children;
	for(var i = 0; i < children.length; i++) {
		var iter = children[i];
		this.loadElementAssets(iter);	
	}

	return this;
}

UIWindowManager.prototype.clearAssetsCache = function(check) {
	WImage.clearCache(check);
	ResLoader.clearCache(check);

	return this;
}

UIWindowManager.prototype.loadAssets = function(winList, onLoadProgress, onDownloadProgress) {
	var me = this;
	winList = winList || this.getWindowNames();

	if(AssetsDownloader.isAvailable()) {
		AssetsDownloader.downloadMulti(winList, onDownloadProgress, function() {
			me.doLoadAssets(winList, onLoadProgress);
		});
	}
	else {
		me.doLoadAssets(winList, onLoadProgress);
	}

	return this;
}

UIWindowManager.prototype.shouldShowAssetsLoadingProgress = function(name) {
	return !this.isAssetsLoaded(name) && this.assetsLoadingWin;
}

UIWindowManager.prototype.isAssetsLoaded = function(name) {
	return this.loadedAssets[name];
}

UIWindowManager.prototype.doLoadAssets = function(winList, onProgress) {
	var queue = [];
	var wm = this;

	function onAssetsLoadProgress(event) {
		if(onProgress) {
			onProgress(event.percent, event.finished, event.total);
		}

		if(event.finished >= event.total) {
			ResLoader.off(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, onAssetsLoadProgress);
	
			for(var k = 0; k < queue.length; k++) {
				var iter = queue[k];
				wm.loadedAssets[iter] = true;
			}
			queue = null;
		}
	}

	var children = this.jsonData.children;
	for(var i = 0; i < children.length; i++) {
		var win = children[i];
		if(!winList || winList.indexOf(win.name) >= 0) {
			queue.push(win.name);
			this.loadElementAssets(win);	
		}
	}

	if(ResLoader.isLoadCompleted()) {
		setTimeout(function() {
			onAssetsLoadProgress({percent:100, finished:100, total:100});
		}, 10);
	}
	else {
		ResLoader.on(ResLoader.EVENT_ASSETS_LOAD_PROGRESS, onAssetsLoadProgress);
	}

	return this;
}

UIWindowManager.prototype.onFromJsonDone = function() {
	this.designWidth = this.w;
	this.designHeight = this.h;
	this.forcePortrait = false;
	this.forceLandscape = false;

	return;
}

UIWindowManager.prototype.beforeAddShapeIntoChildren = function(shape) {
	return !shape.isUIWindow;
}

UIWindowManager.prototype.getMainWindow = function() {
	var windows = this.children;
	var n = windows.length;

	for(var i = 0; i < n; i++) {
		var win = windows[i];
		if(win.isUILoadingWindow) continue;

		if(win.isUINormalWindow && win.windowType === "main") {
			return win;
		}
	}
	
	for(var i = 0; i < n; i++) {
		var win = windows[i];
		
		if(win.isUILoadingWindow) continue;

		if(win.isUINormalWindow) {
			return win;
		}
	}

	return null;
}

UIWindowManager.prototype.getWindowNames = function(excludeWin) {
	var names = [];
	var children = this.children;
	var n = children.length;

	for(var i = 0; i < n; i++) {
		var win = children[i];
		if(win !== excludeWin) {
			names.push(win.name);
		}
	}

	return names;
}

UIWindowManager.prototype.setInitWindow = function(initWindowIndex) {
	if(initWindowIndex === null || initWindowIndex === undefined) {
		this.initWindowIndex = null;
	}
	else {
		this.initWindowIndex = Math.max(0, Math.min(initWindowIndex, this.children.length-1));
	}

	return this;
}

UIWindowManager.prototype.getInitWindow = function() {
	var initWin = null;

    if(this.initWindowIndex || this.initWindowIndex === 0) {
        initWin = this.children[this.initWindowIndex];	
    }

    if(!initWin) {
        var initWinName = cantkGetQueryParam("initwin");
        if(initWinName) {	
            initWin = this.find(initWinName);
        }
    }

    if(!initWin) {
        var initWinName = this.preferInitWindow;
        if(initWinName) {	
            initWin = this.find(initWinName);
        }
    }

    if(!initWin) {
        initWin = this.getMainWindow();
    }

    if(!initWin || initWin.isUILoadingWindow) {
        return null;
    }

	return initWin;
}

UIWindowManager.prototype.waitDeviceRotate = function() {
	var wm = this;
	if(this.isDeviceDirectionOK()) {
		this.doShowInitWindow();
	}
	else {
		setTimeout(function() {
			wm.waitDeviceRotate();
		}, 100);
	}
}

UIWindowManager.prototype.showInitWindow = function(preferInitWindow) {
	this.preferInitWindow = preferInitWindow;

	this.waitDeviceRotate();
}

UIWindowManager.prototype.doShowInitWindow = function() {
	this.history.clear();
	var initWin = this.getInitWindow();

	if(initWin) {
		this.targetShape = initWin;
		initWin.prepareForOpen();
		index = this.getFrameIndex(initWin);
		this.showFrame(index);
		initWin.callOnBeforeOpen();
		initWin.callOnOpen();
		this.history.push(index);
		this.postRedraw();
		
		console.log("showInitWindow: set targetShape:" + this.targetShape.name);
	}
	else {
		console.log("Not Found Init Window.");
	}

	return true;
}

UIWindowManager.prototype.callOnLoad = function() {
	this.resLoadDone = true;

	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];

		try {
			win.callOnLoadHandler();
		}catch(e) {
			console.log("Call onLoad fail:" + e.message);
		}
	}

	return true;
}

UIWindowManager.prototype.callOnUnload = function() {
	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];

		win.callOnUnloadHandler();
	}

	return true;
}

UIWindowManager.prototype.onResLoadDone = function() {
	this.callOnLoad();
	this.showInitWindow();

	return;
}

UIWindowManager.prototype.getStartLoadingWindow = function() {
	var windows = this.children;
	var n = windows.length;

	for(var i = 0; i < n; i++) {
		var win = windows[i];
		if(win.isUINormalWindow && (win.isUILoadingWindow || win.name === "win-loading")) {
			win.isUILoadingWindow = true;
			return win;
		}
	}

	return null;
}

UIWindowManager.prototype.loadAudios = function() {
	this.loadSoundEffects();
	this.loadSoundMusic();

	return this;
}

UIWindowManager.prototype.loadFonts = function() {
	var meta = this.view.getMeta();
	if(meta && meta.extfonts) {
		ResLoader.loadFonts(meta.extfonts);
	}

	return this;
}

UIWindowManager.prototype.setAssetsLoadingWindow = function(name) {
	this.assetsLoadingWin = this.find(name);

	return this;
}

UIWindowManager.prototype.getAssetsLoadingWindow = function() {
	return this.assetsLoadingWin;
}

UIWindowManager.prototype.showStartLoadingWindow = function() {
	this.resLoadDone = false;
	var resWin = this.getStartLoadingWindow();

	if(resWin) {
		if(!resWin.isUILoadingWindowV2) {
			this.loadAssets(null, null);
            this.loadAudios();
    		this.loadFonts();
			console.log("old version, load all assets.");
		}

		this.openWindow(resWin.name);	
	}
	else {
		this.loadAssets(null, null);
		this.showInitWindow();
		console.log("no loading window, load all assets.");
	}

	return;
}

UIWindowManager.prototype.systemInit = function() {
	UIWindowManager.soundEffects = {};
	UIWindowManager.soundMusic = {};
	
	UIElement.animTimerID = null;
	this.callOnSystemInitHandler();

	for(var i = 0; i < this.children.length; i++) {
		var win = this.children[i];
		win.callOnSystemInitHandler();
	}

	var me = this;
	this.showStartLoadingWindow();
	ResLoader.setOnLoadFinishListener(function() {
		me.callOnLoad();
	});

	return;
}

UIWindowManager.prototype.systemExit = function() {
	console.log("systemExit: ");
	var n = this.history.length;
	
	for(var i = 0; i < n; i++) {
		this.closeCurrentWindow(0, true);
	}

	this.history.length = 0;

	this.stopSoundMusic();
	this.callOnUnload();

	return;
}

UIWindowManager.prototype.hasOpenPendingWindow = function() {
   	var children = this.children;
	var n = children.length;

	for(var i = 0; i < n; i++) {
		var win = children[i];
		if(win.openPending) {
            return true;
        }
	}

    return false;
}

UIWindowManager.prototype.openWindow = function(name, onClose, closeCurrent, initData, options) {
	var newWin = null;
	if(name) {
		newWin = this.find(name);
	}
	else {
		newWin = this.getMainWindow();
	}

	if(!newWin || !newWin.isUIWindow) {
		alert("Can not find window: " + name);
		return;
	}
	
    if(newWin.openPending) {
		console.log("This window is already open:" + name);
		return;
	}

	if(closeCurrent) {
		this.closeCurrentWindow(0, true);
	}

	if(newWin.pendingLoadChildren) {
		newWin.loadChildren();
	}

	if(newWin.isOpen()) {
		options = options || {closeOldIfOpened:true};
		if(options.closeOldIfOpened) {
			newWin.callOnClose({});
			this.history.remove(newWin.getIndex());
		}
		else if(options.openNewIfOpened) {
			var newWin = this.dupChild(newWin.name);
			newWin.destroyWhenClose = true;
		}
		else {
			console.log(newWin.name + " is open already.");
			return false;
		}
	}

    /*
	if(newWin.openPending) {
		newWin.openPending = false;
		console.log("This window is already open:" + name);
		return false;
	}
    */
	
	if(!newWin.isUILoadingWindow && !newWin.isUILoadingWindowV2 && this.shouldShowAssetsLoadingProgress(newWin.name)) {
		this.downloadAssetsAndOpenWindow(newWin, initData, onClose);
	}else{
		this.doOpenWindow(newWin, initData, onClose);
	}
}

UIWindowManager.prototype.doOpenWindow = function(newWin, initData, onClose) {
	newWin.prepareForOpen();
	newWin.openPending = true;
	newWin.initData = initData;
	newWin.onClose = onClose;
	newWin.callOnBeforeOpen(initData);

	this.targetShape = newWin;
	this.setPointerEventTarget(newWin);
	if(newWin.isUINormalWindow) {
		return this.openNormalWindow(newWin);
	}
	else {
		return this.openPopupWindow(newWin);
	}
}


UIWindowManager.prototype.downloadAssetsAndOpenWindow = function(newWin, initData, onClose) {
	var loadingWin = this.getAssetsLoadingWindow(); 
	if(loadingWin === newWin) {
		console.log("UIWindowManager.prototype.downloadAssetsAndOpenWindow failed.");
		return;
	}

	this.doOpenWindow(loadingWin);

	var wm = this;
	var bar = loadingWin.findChildByType("ui-progressbar");
	var label = loadingWin.findChildByType("ui-label");
	
	if(bar) {
		bar.setPercent(0);
	}

	if(label) {
		label.setText("Downloading...");
	}

	function onLoadProgress(percent, loadedNr, totalNr) {
		if(label) {
			label.setText("Loading...");
		}

		if(bar) {
			bar.setPercent(percent, true);
		}
		
		if(loadedNr >= totalNr) {
			wm.closeCurrentWindow(0, true);
			wm.doOpenWindow(newWin, initData, onClose);
		}
	}
	
	function onDownloadProgress(percent, loadedNr, totalNr) {
		if(label) {
			if(percent >= 100) {
				label.setText("Loading...");
			}else{
				label.setText("Downloading...");
			}
		}

		if(bar) {
			if(percent >= 100) {
				bar.setPercent(0, true);
			}else {
				bar.setPercent(percent, true);
			}
		}
	}
	
	this.loadAssets([newWin.name], onLoadProgress, onDownloadProgress);
}

UIWindowManager.prototype.openPopupWindow = function(newWin ) {
	var wm = this;
	var curWin = this.getCurrentFrame();

	function openPopupWindow() {
		if(!newWin.app)  {
			console.log("may be exited preview mode");
			return;
		}
        var index = wm.getFrameIndex(curWin);
        if(wm.history.indexOf(index) < 0) {
            return;
        }
		newWin.show();
		curWin.setPopupWindow(newWin);
		wm.postRedraw();
		newWin.callOnOpen(newWin.initData);
	}

	if(curWin) {
		curWin.callOnSwitchToBack(true);
		if(newWin.isAnimationEnabled()) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(newWin.getAnimationName(true), newWin.getAnimationDuration(true)); 
            animation.setWins(curWin, newWin);
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, openPopupWindow);
			animation.setRectOfFront(newWin.x, newWin.y, newWin.w, newWin.h);
			animation.run();
		}
		else {
			openPopupWindow();
		}
	}

	return true;
}

UIWindowManager.prototype.openNormalWindow = function(newWin) {
	var wm = this;
	var index = 0;

	var curWin = this.getCurrentFrame();
	function closeAndOpenWindow() {
		if(!newWin.app)  {
			console.log("may be exited preview mode");
			return;
		}

		index = wm.getFrameIndex(newWin);
		wm.showFrame(index);
		wm.history.push(index);
		curWin = wm.getCurrentFrame();
		wm.postRedraw();
		newWin.callOnOpen(newWin.initData);

		return;
	}

	if(curWin) {
		curWin.callOnSwitchToBack();
		if(newWin.isAnimationEnabled()) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(newWin.getAnimationName(true), newWin.getAnimationDuration(true)); 
            animation.setWins(curWin, newWin);
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, closeAndOpenWindow);
			animation.run();
		}
		else {
			closeAndOpenWindow();
		}
	}
	else {
		closeAndOpenWindow();
	}
	
	return true;
}

UIWindowManager.prototype.getCurrentWindow = function() {
	var curWin = this.getCurrentFrame();
	if(!curWin) {
		return null;
	}

	var childWin = curWin.getPopupWindow();

	return childWin ? childWin : curWin; 
}

UIWindowManager.prototype.backToHomeWin = function() {
	var history = this.history;
	var n = history.length - 1;
	var curWin = this.getCurrentWindow();

	if(!n) {
		if(curWin.isUIPopupWindow) {
			this.closeCurrentWindow(0);
		}

		return;
	}

	if(n === 1) {
		if(curWin.isUIPopupWindow) {
			this.closeCurrentWindow(0, true);
			this.closeCurrentWindow(0);
		}
		else {
			this.closeCurrentWindow(0);
		}

		return;
	}
	
	var mainWinIndex = history[0];
	var lastWin = this.getFrame(mainWinIndex);
	
	if(curWin.isAnimationEnabled()) {
		var p = this.getPositionInScreen();
		var animation = AnimationFactory.create(curWin.getAnimationName(false), curWin.getAnimationDuration(false)); 
        animation.setWins(curWin, lastWin);
		animation.setScale(this.getRealScale());
		animation.prepare(p.x, p.y, this.w, this.h, function() {});
		animation.run();
	}

	for(var i = 0; i < n; i++) {
		this.closeCurrentWindow(0, true);
	}

	return;
}

UIWindowManager.prototype.closeCurrentWindow = function(retInfo, syncClose) {
	var curWin = this.getCurrentWindow();

	if(!curWin || curWin.isInDesignMode()) {
		return  false;
	}

	return this.closeWindow(curWin, retInfo, syncClose);
}

UIWindowManager.prototype.closeWindow = function(win, retInfo, syncClose) {
    win.closePending = true;
	if(win.isUINormalWindow) {
		return this.closeNormalWindow(win, retInfo, syncClose);
	} 
	else {
		return this.closePopupWindow(win, retInfo, syncClose);
	}
}

UIWindowManager.prototype.closePopupWindow = function(popupWin, retInfo, syncClose) {
	var wm = this;
	var curWin = this.getCurrentFrame();

	if(curWin) {
		function closePopupWindow() {
			if(!popupWin.app)  {
				console.log("may be exited preview mode");
				return;
			}
			curWin.removePopupWindow(popupWin);
			curWin.callOnSwitchToFront(true);
			wm.postRedraw();

			popupWin.callOnClose(retInfo);
		}

        if(!popupWin.isTopWindow()) {
            console.log("close background dialog");
            if(popupWin.parentWindow) {
                popupWin.parentWindow.removePopupWindow(popupWin);
            }
            popupWin.callOnClose(retInfo); 
            
            return;
        }

		if(curWin === popupWin) {
			syncClose = true;
		}

		if(popupWin.isAnimationEnabled() && !syncClose && !wm.hasOpenPendingWindow()) {
			var p = this.getPositionInScreen();
			var animation = AnimationFactory.create(popupWin.getAnimationName(false), popupWin.getAnimationDuration(false)); 

			curWin.removePopupWindow(popupWin);
            animation.setWins(popupWin, curWin);
			curWin.setPopupWindow(popupWin);
		
			animation.setScale(this.getRealScale());
			animation.prepare(p.x, p.y, this.w, this.h, closePopupWindow);
			animation.setRectOfFront(popupWin.x, popupWin.y, popupWin.w, popupWin.h);
			animation.run();
		}
		else {
			closePopupWindow();
		}
	}

	return true;
}

UIWindowManager.prototype.closeAll = function() {
	var wins = [];

	for(var i = 0; i < this.history.length; i++) {
		var index = this.history[i];
		var win = this.getFrame(index);
		for(var iter = win; iter; iter = iter.popupWindow) {
			wins.push(iter);
		}
	}

	for(var i = wins.length-1; i >= 0; i--) {
		var win = wins[i];
		win.callOnClose({});
		win.targetShape = null;
	}

	this.history = [];

	return;
}

UIWindowManager.prototype.closeNormalWindow = function(curWin, retInfo, syncClose) {
	var wm = this;
	var lastWin = null;

	if(this.history.length < 2) {
		if(syncClose || this.history.length) {
			wm.history.remove(wm.current);
			curWin.callOnClose(retInfo);
		}

		return false;
	}

    if(!curWin.isTopWindow()) {
        var curIndex = wm.getFrameIndex(curWin);
        console.log("closing background window " + curWin.name);
        wm.history.remove(curIndex);
        curWin.callOnClose();

        if(curIndex === wm.current && wm.history.length > 0) {
            wm.showFrame(wm.history[wm.history.length - 1]);
        }
        return;
    }

	lastWinIndex = this.history[this.history.length-2];
	lastWin = this.getFrame(lastWinIndex);

	function showLastWindow() {
		if(!lastWin.app)  {
			console.log("may be exited preview mode");
			return;
		}
        if(lastWinIndex != wm.history[wm.history.length - 1] || wm.hasOpenPendingWindow()) {
            //new win was appended and shown?
            return;
        }
		wm.showFrame(lastWinIndex);
		lastWin.callOnSwitchToFront();
		
		wm.postRedraw();
		curWin.callOnClose(retInfo);

		return;
	}
	
	wm.history.remove(wm.current);
	if(syncClose) {
		showLastWindow();
	}
	else if(curWin.isAnimationEnabled() && !wm.hasOpenPendingWindow()) {
		var p = this.getPositionInScreen();
		var animation = AnimationFactory.create(curWin.getAnimationName(false), curWin.getAnimationDuration(false)); 
        animation.setWins(curWin, lastWin);
		animation.setScale(this.getRealScale());
		animation.prepare(p.x, p.y, this.w, this.h, showLastWindow);
		animation.run();
	}
	else {
		setTimeout(showLastWindow, 10);
	}

	return;
}

UIWindowManager.prototype.isWindowOpen = function(win) {
	return win && win.isOpen();
}


UIWindowManager.prototype.onChildrenChanged = function() {
}

UIWindowManager.prototype.afterChildAppended = function(shape) {
	if(this.mode !== Shape.MODE_RUNNING && !this.isUnpacking) {
		var index = this.getFrameIndex(shape);
		this.showFrame(index);
	}

	this.onChildrenChanged();

	return;
}

UIWindowManager.prototype.onChildRemoved = function(shape) {
	this.onChildrenChanged();

	return;
}

UIWindowManager.prototype.scaleForDensity = function(sizeScale, lcdDensity, recuresive) {
	if(!sizeScale || sizeScale === 1) {
		return;
	}

	for(var i = 0; i < this.children.length; i++) {
		var iter = this.children[i];

		if(!iter.lcddensity || iter.lcddensity === "all") {
			if(iter.pendingLoadChildren) {
				iter.scaleInfo = {};
				iter.scaleInfo.sizeScale = sizeScale;
				iter.scaleInfo.lcdDensity = lcdDensity;
			}
			else {
				iter.scaleForDensity(sizeScale, lcdDensity, recuresive);
			}
		}
	}

	return;
}

UIWindowManager.prototype.resize = function(w, h) {
	var x = 0;
	var y = 0;
	var fixWidth = this.screenScaleMode === "fix-width";
	var fixHeight = this.screenScaleMode === "fix-height";
	var fixResolution = this.screenScaleMode === "fix-resolution";
	var isInDevice = this.parentShape != null;

	if(this.mode === Shape.MODE_RUNNING && (fixWidth || fixHeight || fixResolution) && !isInDevice) {
		var canvas = this.view.getCanvas();

		var screenWidth = canvas.width;
		var screenHeight = canvas.height;
		var designWidth = this.designWidth;
		var designHeight = this.designHeight;
		var canvasStyleSizeSupported = true;//!(isWeiBo() || isPhoneGap());
		var sizeIsRight = (screenWidth > screenHeight && designWidth > designHeight) 
			|| (screenWidth < screenHeight && designWidth < designHeight);

		canvas.style.width = screenWidth + "px";
		canvas.style.height = screenHeight + "px";
		if(canvasStyleSizeSupported && sizeIsRight) {

			if(fixWidth) {
				var scale = designWidth/screenWidth;
				canvas.width = designWidth;
				canvas.height = screenHeight * scale;
				w = canvas.width;
				h = canvas.height;
			}
			else if(fixHeight) {
				var scale = designHeight/screenHeight;
				canvas.height = designHeight;
				canvas.width = screenWidth * scale;
				w = canvas.width;
				h = canvas.height;
			}
			else {
				var scaleW = designWidth/screenWidth;
				var scaleH = designHeight/screenHeight;
				var scale = Math.max(scaleW, scaleH);
				if(Math.abs(scaleW - scaleH) < 0.10) {
					canvas.width = designWidth;
					canvas.height = designHeight;
					
					x = 0;
					y = 0;
					w = canvas.width;
					h = canvas.height;
				}
				else {
					canvas.width = screenWidth * scale;
					canvas.height = screenHeight * scale;
					
					x = (canvas.width - designWidth)>>1; 
					y = (canvas.height - designHeight)>>1;
					w = designWidth;
					h = designHeight;
				}
			}
			var xInputScale = canvas.width/screenWidth;
			var yInputScale = canvas.height/screenHeight;
			WWindowManager.setInputScale(xInputScale, yInputScale);
		}
		else {
			canvas.width = screenWidth;
			canvas.height = screenHeight;
			WWindowManager.setInputScale(1, 1);
			w = canvas.width;
			h = canvas.height;
		}

		var vp = cantkGetViewPort();	
		this.app.onCanvasSized(canvas.width, canvas.height);

		console.log("Canvas Size: w =" + canvas.width + " h=" + canvas.height);
		console.log("ViewPort Size: w =" + vp.width + " h=" + vp.height);
		console.log("Canvas Style Size: w =" + canvas.style.width + " h=" + canvas.style.height);
	}

	this.lastWin = null;
	this.setLeftTop(x, y);
	this.setSizeLimit(w, h, w, h);
	UIElement.prototype.resize.call(this, w, h);

	return;
}

UIWindowManager.prototype.setDeviceConfig = function(deviceConfig) {
	var screenScaleMode = this.screenScaleMode;
	if(screenScaleMode === "fix-resolution" || screenScaleMode === "fix-width" || screenScaleMode === "fix-height") {
		this.oldConfig = this.deviceConfig;

		return;
	}

	var oldConfig = this.deviceConfig;
	
	this.oldConfig = this.deviceConfig;
	this.deviceConfig = deviceConfig;

	if(oldConfig && deviceConfig) {
		if(oldConfig.lcdDensity != deviceConfig.lcdDensity) {
			var sizeScale = this.getSizeScale(oldConfig.lcdDensity, deviceConfig.lcdDensity);
			this.scaleForDensity(sizeScale, deviceConfig.lcdDensity, true);
		}
		this.notifyDeviceConfigChanged(oldConfig, deviceConfig);
	}

	return;
}

UIWindowManager.prototype.getDeviceConfig = function() {
	if(this.deviceConfig) {
		return this.deviceConfig;
	}
	else {
		var device = this.getDevice();
		if(device) {
			return device.config;
		}
	}

	return null;
}

UIWindowManager.prototype.paintChildren = function(canvas) {
	if(!this.isInDesignMode()) {
		if(this.forcePortrait && this.w > this.h) {
			var image = this.getHtmlImageByType("force-portrait-tips");	

			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);	
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, this.w, this.h);

			return;
		}
		else if(this.forceLandscape && this.w < this.h) {
			var image = this.getHtmlImageByType("force-landscape-tips");	
			
			canvas.fillStyle = this.style.fillColor;
			canvas.fillRect(0, 0, this.w, this.h);	
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_CENTER, 0, 0, this.w, this.h);

			return;
		}
	}

	var child = this.getCurrentFrame();
	if(child.closePending) {
        return;
    }
    if(!this.isInDesignMode() && this.history.length === 0) { 
        UIElement.logWarning("All Windows Are Closed!");
    } else {
		if(child.isUIDialog) {
			canvas.fillStyle = "white";
			canvas.fillRect(0, 0, this.w, this.h);
		}

		canvas.save();
		canvas.beginPath();
		child.paintSelf(canvas);
		canvas.restore();
	}

	return;
}

UIWindowManager.prototype.paintSelf = function(canvas) {
	var x = this.x;
	var y = this.y;
	var translate = x || y;

	if(translate) {
		canvas.save();
		canvas.translate(x, y);
	}

	this.paintChildren(canvas);

	if(translate) {
		canvas.restore();
	}
}

UIWindowManager.prototype.isDeviceDirectionOK = function() {
	if(this.isInDesignMode()) {
		return true;
	}

	if((this.forcePortrait && this.w > this.h)
		|| (this.forceLandscape && this.w < this.h)) {
		console.log("Device Direction Incorrect.");
		return false;
	}

	return true;
}

UIWindowManager.prototype.relayout = function() {
	if(this.isDeviceDirectionOK()) {
		UIElement.prototype.relayout.call(this);
	}
	else {
		console.log("isDeviceDirectionNotOK ignore relayout");
	}

	return this;
}

UIWindowManager.prototype.relayoutChildren = function() {
	if(!this.isDeviceDirectionOK()) {
		console.log("isDeviceDirectionNotOK ignore relayout");

		return;
	}

	var curWin = this.getCurrentFrame();

	if(this.isInDesignMode()) {
		for(var i = 0; i < this.children.length; i++) {
			var iter = this.children[i];
			iter.relayout();
		}
	}
	else {
		if(curWin) {
			curWin.relayout();
			
			var childWin = curWin.getPopupWindow();
			if(childWin) {
				childWin.relayout();
			}
		}
	}

	return;
}

UIWindowManager.prototype.onKeyDown= function(code) {
	var win = this.getCurrentWindow();

	return win && win.onKeyDown(code);
}

UIWindowManager.prototype.onKeyUp= function(code) {
	var win = this.getCurrentWindow();

	return win && win.onKeyUp(code);
}

UIWindowManager.prototype.setSoundEffectURLs = function(soundEffectURLs) {
	this.soundEffectURLs = soundEffectURLs;

	return this;
}

UIWindowManager.prototype.getSoundEffectURLs = function() {
	return this.soundEffectURLs;
}

UIWindowManager.prototype.getSoundEffectNames = function() {
	if(!this.soundEffectURLs) {
		return [];
	}

	var names = this.soundEffectURLs.split("\n");
	for(var i = 0; i < names.length; i++) {
		names[i] = decodeURI(basename(names[i]));
	}

	return names;
}

UIWindowManager.prototype.getSoundEnable = function() {
	return this.soundMusicsEnalbe || this.soundEffectsEnalbe;
}

UIWindowManager.prototype.setSoundEnable = function(enable) {
	this.setSoundEffectsEnable(enable);
	this.setSoundMusicsEnable(enable);

	return this;
}

UIWindowManager.prototype.setSoundEffectsEnable = function(enable) {
	this.soundEffectsEnalbe = enable;

	return this;
}

UIWindowManager.prototype.setSoundMusicsEnable = function(enable) {
	if(this.soundMusicsEnalbe !== enable) {
		this.soundMusicsEnalbe = enable;
		if(enable) {
			this.playSoundMusic();
		}
		else {
			this.stopSoundMusic();
		}
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffects = function() {
	if(!this.soundEffectURLs) {
		return;
	}

	if(CantkRT.isCantkRTCordova()) {
		console.log("Native Audio supported: load native Audio")
		this.loadSoundEffectsNative();
	}
	else if(isWebAudioSupported()) {
		console.log("WebAudio supported: load Web Audio")
		this.loadSoundEffectsWebAudio();
	}
	else {
		console.log("WebAudio not supported: load HTML5 Audio")
		this.loadSoundEffectsHtml5Audio();
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsHtml5Audio = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];

		ResLoader.loadAudio(iter, function(audio) {
			var info = {audio:audio};
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
			var name = decodeURI(basename(audio.src));
			UIWindowManager.soundEffects[name] = info;
        });
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsNative = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];

		CantkRT.createSoundEffect(iter, function(audio) {
			var info = {audio:audio};
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
			var name = decodeURI(basename(audio.src));
			UIWindowManager.soundEffects[name] = info;
			console.log("loadSoundEffectsNative success.");
		}, function() {
			console.log("loadSoundEffectsNative fail.");
		});
	}

	return this;
}

UIWindowManager.prototype.loadSoundEffectsWebAudio = function() {
	var urlArr = this.soundEffectURLs.split("\n");
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		var config = {src: [iter], autoplay: false, loop: false, volume: 0.8};
		var name = decodeURI(basename(iter));
		var info = {audio:new Howl(config), playing: false};

        UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
		UIWindowManager.soundEffects[name] = info;
	}

	return this;
}

UIWindowManager.prototype.stopSoundEffect = function(name) {
	for(var key in UIWindowManager.soundEffects) {
		if(name === key || !name) {
			var info = UIWindowManager.soundEffects[key];
			if(info && info.audio) {
				if(info.audio.stop) {
					info.audio.stop();
				}
				else {
					info.audio.pause();
				}
				info.playing = false;
			}
		}
	}

	return this;
}

UIWindowManager.prototype.stopAllSound = function() {
	try {
		this.stopSoundMusic().stopSoundEffect();
	}catch(e) {
		console.log(e.message);
	}

	return this;
}

UIWindowManager.soundMusicVolume = 0.8
UIWindowManager.soundEffectVolume = 0.8;

UIWindowManager.prototype.setSoundEffectVolume = function(volume) {
	UIWindowManager.soundEffectVolume = volume;

	return this;
}

UIWindowManager.prototype.setSoundMusicVolume = function(volume) {
	UIWindowManager.soundMusicVolume = volume;
	
	var info = this.lastAudioInfo;
	if(info && info.audio) {
		UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
	}


	return this;
}

UIWindowManager.setVolumeOfAudio = function(audio, volume) {
	if(typeof(audio.volume) === "function") {
		audio.volume(volume);
	}
	else {
		audio.volume = volume;
	}
}

UIWindowManager.prototype.playSoundEffect = function(name, onDone) {
	if(!this.soundEffectsEnalbe) {
		console.log("this.soundEffectsEnalbe is disable ");
		return this;
	}

	var info = UIWindowManager.soundEffects[name];
	if(!info || !info.audio) {
		console.log("not found: " + name);
		return this;
	}

	if(onDone) {
		if(info.audio.once) {
			info.audio.once("end", onDone);
		}
		else {
			info.audio.addEventListener('ended', function (e) {
				onDone();
			});
		}
	}

	UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundEffectVolume);
	info.audio.play();
	console.log("playSoundEffect:" + name);

	return this;
}

//////////////////////////////////////////////////////////////////////

UIWindowManager.prototype.onMultiTouch = function(action, points, event) {
	var win = this.getCurrentWindow();
	if(win) {
		var ox = this.left + win.left;
		var oy = this.top + win.top;

		for(var i = 0; i < points.length; i++) {
			var p = points[i];
			p.x -= ox;
			p.y -= oy;
		}

		win.onMultiTouch(action, points, event);
	}
}

UIWindowManager.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(this.autoPlayPending) {
		this.playSoundMusic();
		this.autoPlayPending = false;
	}

	if(!beforeChild || this.popupWindow || !this.pointerDown) {
		return;
	}

	return this.callOnPointerDownHandler(point);
}

UIWindowManager.prototype.setSoundMusicURLs = function(soundMusicURLs) {
	this.soundMusicURLs = soundMusicURLs;

	return this;
}

UIWindowManager.prototype.getSoundMusicURLs = function() {
	return this.soundMusicURLs;
}

UIWindowManager.prototype.loadSoundMusicHTML5 = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");

	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		ResLoader.loadAudio(iter, function(audio) {
			var info = {audio:audio};
			var name = decodeURI(basename(audio.src));
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
			
			if(loop) {	
				audio.loop = "loop";
			}
			if(autoPlay) {
				audio.play();
				autoPlay = false;
			}
			me.autoPlayPending = true;
			UIWindowManager.soundMusic[name] = info;
        });
	}

	return;
}

UIWindowManager.prototype.loadSoundMusicWebAudio = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");
	
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		var config = {src: [iter], autoplay: autoPlay, loop:loop, volume: 0.8};
		var name = decodeURI(basename(iter));
		var info = {audio:new Howl(config), playing: autoPlay};

        UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
		if(autoPlay) {
			this.lastAudioInfo = info;
		}
		autoPlay = false;
		UIWindowManager.soundMusic[name] = info;
	}

	return;
}

UIWindowManager.prototype.loadSoundMusicNative = function() {
	var me = this;
	var loop = this.soundMusicLoop;
	var autoPlay = this.soundMusicAutoPlay;
	var urlArr = this.soundMusicURLs.split("\n");
	
	for(var i = 0; i < urlArr.length; i++) {
		var iter = urlArr[i];
		CantkRT.createSoundMusic(iter, function(audio) {
			var info = {audio:audio};
			var name = decodeURI(basename(audio.src));
            UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
			if(loop) {	
				audio.loop = "loop";
			}
			if(autoPlay) {
				audio.play();
				this.lastAudioInfo = info;
				autoPlay = false;
			}
			UIWindowManager.soundMusic[name] = info;
        });
	}

	return;
}

UIWindowManager.prototype.loadSoundMusic = function() {
    if(!this.soundMusicURLs) {
		return;
	}

    this.soundMusicsEnalbe = true;
	if(CantkRT.isCantkRTCordova()) {
		console.log("Native Audio supported: load native Audio")
		this.loadSoundMusicNative();
	}
	else if(isWebAudioSupported()) {
		console.log("WebAudio supported: load Web Audio")
		this.loadSoundMusicWebAudio();
	}
	else {
		this.loadSoundMusicHTML5();
	}
	this.soundMusicsPlaying = this.soundMusicAutoPlay;

	return this;
}

UIWindowManager.prototype.isSoundMusicPlaying = function(name) {
	var playing = false;
	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				if(info.playing) {
					playing = true;
					break;
				}
			}
		}
	}

	return playing;
}

/*
UIWindowManager.prototype.getSceneIds = function() {
    var ids = [];
    this.children.forEach(function(scene) {
        ids.push(scene.Id);
    });
    
    return ids;
}

UIWindowManager.prototype.getSceneJsonById = function(id) {
    var scenes = this.children;
    for(var i = 0; i < scenes.length; i++) {
        var scene = scenes[i];
        if(id === scene.id) {
            return scene.toJson();
        }  
    }
    return null;
}
*/

UIWindowManager.prototype.stopSoundMusic = function(name) {
	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				info.audio.pause();
				info.playing = false;
				this.soundMusicsPlaying = false;
			}
		}
	}

	return this;
}

UIWindowManager.prototype.playSoundMusic = function(name, onDone) {
	if(this.soundMusicsPlaying) {
		this.stopSoundMusic();
	}

	if(!this.soundMusicsEnalbe) {
        if(name) {
            this.lastAudioInfo = UIWindowManager.soundMusic[name];
        }
		console.log("this.soundMusicsEnalbe is disable ");
		return this;
	}

	if(!name && this.lastAudioInfo && this.lastAudioInfo.audio) {
		var info = this.lastAudioInfo;

		UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
		info.audio.play();
		info.playing = true;
		this.soundMusicsPlaying = true;

		return this;
	}

	for(var key in UIWindowManager.soundMusic) {
		if(name === key || !name) {
			var info = UIWindowManager.soundMusic[key];
			if(info && info.audio) {
				if(onDone) {
				    if(info.audio.once) {
                    	info.audio.once("end", onDone);
                    } else {
                        info.audio.addEventListener("ended", function(e) {
                            onDone();
                        });
                    }
				}
				UIWindowManager.setVolumeOfAudio(info.audio, UIWindowManager.soundMusicVolume);
				info.audio.play();
				info.playing = true;
				this.lastAudioInfo = info;
				this.soundMusicsPlaying = true;

				console.log("UIWindowManager.prototype.playSoundMusic");
				break;
			}
		}
	}

	console.log("playSoundMusic:" + name);

	return this;
}

UIWindowManager.prototype.getSoundMusicNames = function() {
	if(!this.soundMusicURLs) {
		return [];
	}

	var names = this.soundMusicURLs.split("\n");
	for(var i = 0; i < names.length; i++) {
		names[i] = basename(names[i]);
	}

	return names;
}

UIWindowManager.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIWindow;
}

function UIWindowManagerCreator() {
	var args = ["ui-window-manager", "ui-window-manager", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWindowManager();

		return g.initUIWindowManager(this.type);
	}
	
	return;
}
	
ShapeFactoryGet().addShapeCreator(new UIWindowManagerCreator());

/*
 * File:   ui-image-button.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Button
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageButton() {
	return;
}

UIImageButton.prototype = new UIElement();
UIImageButton.prototype.isUIImageButton = true;

UIImageButton.prototype.initUIImageButton = function(type, w, h) {
	this.initUIElement(type, w, h);
	this.setImage(UIElement.IMAGE_NORMAL, null);
	this.setImage(UIElement.IMAGE_ACTIVE, null);
	this.setImage(UIElement.IMAGE_DISABLE, null);
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIImageButton.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIImageButtonCreator(w, h) {
	var args = ["ui-image-button", "ui-image-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageButton();
		return g.initUIImageButton(this.type, w, h);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageButtonCreator(120, 90));

/*
 * File:   ui-image-normal-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Normal Image View 
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIImageNormalView() {
	return;
}

UIImageNormalView.prototype = new UIImageView();
UIImageNormalView.prototype.isUIImageNormalView = true;

UIImageNormalView.prototype.initUIImageNormalView = function(type, w, h) {
	this.userImages = [];
	this.cachedImages = [];

	this.initUIElement(type);
	this.initUIImageView(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.current = 0;
	this.offsetX = 0;
	this.offsetY = 0;
	this.imageScale = 1;

	this.velocityTracker = new VelocityTracker();
	this.interpolator =  new DecelerateInterpolator();
	this.errorImage = UIImageView.createImage("drawapp8/images/common/failed.png", null);
	this.loadingImage = UIImageView.createImage("drawapp8/images/common/loading.png", null);
	
	return this;
}

UIImageNormalView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.velocityTracker.clear();

	return;
}

UIImageNormalView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	this.offsetX = this.offsetX + this.getMoveDeltaX();
	this.offsetY = this.offsetY + this.getMoveDeltaY();

	this.addMovementForVelocityTracker();

	return ;
}

UIImageNormalView.prototype.getVelocity = function() {
	return this.velocityTracker.getVelocity().x;
}

UIImageNormalView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	var velocity = this.velocityTracker.getVelocity();
	var xa = this.w;
	var ya = this.h;
	var xt = velocity.x/xa;
	var yt = velocity.y/ya;
	var t = Math.max(xt, yt);

	var xd = 0.5 * xa * xt * xt;
	var yd = 0.5 * ya * yt * yt;

	xd = velocity.x > 0 ? xd : -xd;
	yd = velocity.y > 0 ? yd : -yd;
	this.scrollTo(xd, yd, t * 1000);

	return true;
}

UIImageNormalView.prototype.scrollTo = function(xd, yd, t) {
	var imageview = this;
	var duration = Math.max(500, Math.min(t, 1000));
	
	var startTime = (new Date()).getTime();
	var offsetXStart = this.offsetX;
	var offsetYStart = this.offsetY;
	var currentImage = this.cachedImages[this.current];

	var dx = Math.min(currentImage.width/2, xd);
	var dy = Math.min(currentImage.height/2, yd);

	function animStep() {
		var now = new Date();
		var percent = (now.getTime() - startTime)/duration;
		
		if(percent < 1) {
			imageview.offsetX = offsetXStart + percent * dx;
			imageview.offsetY = offsetYStart + percent * dy;

			setTimeout(animStep, 10);
		}
		else {
			delete startTime;
			imageview.offsetX = offsetXStart + dx;
			imageview.offsetY = offsetYStart + dy;
		}

		delete now;
		imageview.postRedraw();
	}

	animStep();

	return;
}

UIImageNormalView.prototype.switchTo = function(offset) {
	var current = this.current;
	var n = this.userImages.length;
	if(offset > 0) {
		if((this.current+offset) < n) {
			current = this.current + offset;	
		}
	}
	else {
		if((this.current+offset) > 0) {
			current = this.current + offset;
		}
	}
}

UIImageNormalView.prototype.calcImageDefaultOffset = function() {
	var index = this.current;
	if(index < 0 || index >= this.cachedImages.length) {
		return;
	}

	var image = this.cachedImages[index];
	if(!image || !image.width) {
		return;
	}

	this.imageScale = Math.min(this.w/image.width, this.h/image.height);
	
	var w = this.imageScale * image.width;
	var h = this.imageScale * image.height;

	this.offsetX = (this.w-w)/2;
	this.offsetY = (this.h-h)/2;

	return;
}

UIImageNormalView.prototype.setCurrentImage = function(index) {
	if(index < 0 || index >= this.userImages.length) {
		return;
	}

	this.current = index;
	this.calcImageDefaultOffset();

	return;
}

UIImageNormalView.prototype.onDoubleClick = function(point, beforeChild) {
	this.calcImageDefaultOffset();
	return this.callOnDoubleClickHandler(point);
}

UIImageNormalView.prototype.paintSelfOnly = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currentImage = this.cachedImages[this.current];
	if(!currentImage || !currentImage.width) {
		return;
	}

	this.imageScale = 1;
	canvas.save();
	canvas.rect(0, 0, this.w, this.h);
	canvas.clip();

	canvas.translate(this.offsetX, this.offsetY);
	canvas.scale(this.imageScale, this.imageScale);
	canvas.drawImage(currentImage, 0, 0);
	canvas.restore();

	return;
}

function UIUIImageNormalViewCreator() {
	var args = ["ui-image-normal-view", "ui-image-normal-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageNormalView();

		return g.initUIImageNormalView(this.type, 300, 300);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIUIImageNormalViewCreator());

/*
 * File:   ui-image-slide-view.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Image Slide View.
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */
function UIImageSlideView() {
	return;
}

UIImageSlideView.prototype = new UIImageView();
UIImageSlideView.prototype.isUIImageSlideView = true;

UIImageSlideView.prototype.saveProps = ["showIndicator", "frameDuration"];
UIImageSlideView.prototype.initUIImageSlideView = function(type, w, h) {
	this.initUIElement(type);	
	this.initUIImageView(w, h);
	
	this.offset = 0;
	this.addEventNames(["onChanged"]);
	this.setTextType(Shape.TEXT_NONE);
	imageSlideViewInitCustomProp(this);

	return this;
}

UIImageSlideView.prototype.onInit = function() {
	var slideview = this;

	this.currFrame = 0;

	function nextFrame() {
		if(!slideview.isInDesignMode() && slideview.isVisible()) {
			var duration = slideview.getFrameDuration();
			
			slideview.postRedraw();
			setTimeout(nextFrame, duration);

			var newFrame = slideview.currFrame + 1;
			slideview.animScrollTo(-slideview.w, newFrame);
		}
	}

	var duration = this.getFrameDuration();
	setTimeout(nextFrame, duration);

	return;
}

UIImageSlideView.prototype.getFrameDuration = function() {
	return this.frameDuration ? this.frameDuration : 5000;
}

UIImageSlideView.prototype.setFrameDuration = function(frameDuration) {
	this.frameDuration = Math.max(1000, Math.min(frameDuration, 300000));

	return;
}

UIImageSlideView.prototype.setShowIndicator = function(value) {
	this.showIndicator = value;

	return;
}

UIImageSlideView.prototype.getFrameIndicatorParams = function() {
	var n = this.userImages.length;
	var itemSize = Math.min((0.5 * this.w)/n, 40);
	var indicatorWidth = itemSize * n;

	var dx = (this.w - indicatorWidth)/2;
	var dy = 0.8 * this.h;

	return {offsetX:dx, offsetY:dy, itemSize:itemSize, n:n};
}

UIImageSlideView.prototype.getCurrent = function() {
	return this.currFrame;
}

UIImageSlideView.prototype.getCurrentImage = function() {
	var image = this.cachedImages[this.currFrame];

	return image;
}

UIImageSlideView.prototype.setValue = function(src) {
	for(var i = 0; i < this.cachedImages.length; i++) {
		var iter = this.cachedImages[i];
		if(iter.src.indexOf(src) >= 0 || src.indexOf(iter.src) >= 0) {
			return this.setCurrent(i);	
		}
	}

	return this;
}

UIImageSlideView.prototype.setCurrent = function(currFrame) {
	this.setCurrentFrame(currFrame);

	return this;
}

UIImageSlideView.prototype.setCurrentFrame = function(currFrame) {
	this.offset = 0;
	this.currFrame = (currFrame + this.userImages.length)%this.userImages.length;
	this.postRedraw();

	this.callOnChangedHandler(this.currFrame);

	return this;
}

UIImageSlideView.prototype.animScrollTo = function(range, newFrame) {
	var duration = 1000;
	var slideview = this;
	var startOffset = this.offset;
	var startTime = (new Date()).getTime();
	var interpolator = new DecelerateInterpolator(2);

	if(slideview.animating) {
		return;
	}

	slideview.animating = true;
	function animStep() {
		var now = new Date();
		var timePercent = (now.getTime() - startTime)/duration;
		var percent = interpolator.get(timePercent);
		
		if(timePercent < 1) {
			slideview.offset = startOffset + range * percent;
			setTimeout(animStep, 10);
		}
		else {
			slideview.offset = 0;
			slideview.setCurrentFrame(newFrame);
			delete startTime;
			delete interpolator;
			delete slideview.animating;
		}

		delete now;
		slideview.postRedraw();
	}

	animStep();

	return;
}

UIImageSlideView.prototype.onPointerDownRunning = function(point, beforeChild) {
	if(this.isEventHandledByChild()) {
		return;
	}
	this.setEventHandled();

	if(!this.velocityTracker) {
		this.velocityTracker = new VelocityTracker();
	}
	this.velocityTracker.clear();

	return true;
}

UIImageSlideView.prototype.isEventHandledByChild = function() {
	var status = UIElement.lastEvent.status;
	return status & UIElement.EVENT_HSCROLL_HANDLED;
}

UIImageSlideView.prototype.setEventHandled = function() {
	this.setLastEventStatus(UIElement.EVENT_HSCROLL_HANDLED);
	
	return this;
}

UIImageSlideView.prototype.onPointerMoveRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}

	var frames = this.getFrames();
	var currFrame = this.currFrame;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	this.offset = dx;
	this.addMovementForVelocityTracker();

	return;
}

UIImageSlideView.prototype.onPointerUpRunning = function(point, beforeChild) {
	if(this.animating) {
		this.setEventHandled();
		return;
	}
	if(beforeChild) {
		return;
	}
	if(this.isEventHandledByChild()) {
		return;
	}
	
	var frames = this.getFrames();
	var currFrame = this.currFrame;
	var dx = this.getMoveAbsDeltaX();
	if((currFrame > 0 && dx > 0) || ((currFrame+1) < frames && dx < 0)) {
		this.setEventHandled();
	}
	else {
		return;
	}

	var range = 0;
	var offsetX = this.offset;
	var newFrame = this.currFrame;
	var velocity = this.velocityTracker.getVelocity().x;
	var distance = offsetX + velocity;

	//console.log("offsetX: " + offsetX + "velocity:" + velocity + " distance:" + distance );
	if(Math.abs(offsetX) < 10) {
		this.offset = 0;

		return;
	}

	if(Math.abs(distance) > this.w/3) {
		if(offsetX > 0) {
			range = this.w - offsetX;	
			newFrame = this.currFrame - 1;
		}
		else {
			range = -this.w - offsetX;
			newFrame = this.currFrame + 1;
		}
	}
	else {
		range = -offsetX;
	}

	this.animScrollTo(range, newFrame);

	return;
}

UIImageSlideView.prototype.onClick = function(point, beforeChild) {
	if(beforeChild || this.animating) {
		return;
	}

	var params = this.getFrameIndicatorParams();

	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;
	var n = params.n;
	var x = point.x;
	var y = point.y;

	if(y < dy || y > (dy + itemSize) || x < dx || x > (dx + n * itemSize)) {
		return;
	}

	for(var i = 0; i < n; i++) {
		if(x > dx && x < (dx + itemSize)) {
			this.setCurrentFrame(i);	
			break;
		}

		dx += itemSize;
	}

	return;
}

UIImageSlideView.prototype.drawFrameIndicator = function(canvas, currFrame) {
	var params = this.getFrameIndicatorParams();

	var dx = params.offsetX;
	var dy = params.offsetY;
	var itemSize = params.itemSize;
	var n = params.n;

	dx += itemSize/2;
	dy += itemSize/2;

	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;

	for(var i = 0; i < n; i++) {
		canvas.beginPath();
		canvas.arc(dx, dy, 10, 0, Math.PI * 2);
		dx += itemSize;
	

		if(i === currFrame) {
			canvas.save();
			canvas.shadowColor = this.style.lineColor;
			canvas.shadowBlur = 5;
			canvas.shadowOffsetX = 0;
			canvas.shadowOffsetY = 0;

			canvas.fill();
			canvas.stroke();
			canvas.restore();
		}
		else {
			canvas.fill();
		}
	}

	return;
}

UIImageSlideView.prototype.getPrevFrame = function() {
	var index = (this.currFrame - 1 + this.userImages.length)%this.userImages.length;

	return this.cachedImages[index];
}

UIImageSlideView.prototype.getFrames = function() {
	return this.userImages.length;
}

UIImageSlideView.prototype.getNextFrame = function() {
	var index = (this.currFrame + 1) % this.userImages.length;

	return this.cachedImages[index];
}

UIImageSlideView.prototype.drawOneImage = function(canvas, image) {
	var fillColor = this.style.fillColor;

	if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE) {
		canvas.drawImage(image, 0, 0, image.width, image.height, 0, 0, this.w, this.h);
	}
	else if(this.images.display === UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO) {
		var rect = {x:0, y:0};
		rect.w = image.width;
		rect.h = image.height;

		this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_SCALE_KEEP_RATIO, 0, 0, this.w, this.h, rect);
	}
	else {
		UIImageView.drawImageAtCenter(canvas, image, 0, 0, this.w, this.h, true, fillColor);
	}

	return;
}

UIImageSlideView.prototype.drawImage = function(canvas) {
	if(!this.userImages || !this.userImages.length) {
		return;
	}
	
	this.ensureImages();

	var currFrame = (this.currFrame ? this.currFrame : 0)%this.userImages.length;
	var image = this.cachedImages[currFrame];

	if(image && image.width > 0) {
		canvas.save();
		canvas.rect(0, 0, this.w, this.h);
		canvas.clip();
		canvas.beginPath();

		canvas.translate(this.offset, 0);

		this.drawOneImage(canvas, image);

		var offset = Math.abs(this.offset);
		if(this.offset < 0) {
			image = this.getNextFrame();
			if(image && image.width > 0) {
				canvas.translate(this.w, 0);
				this.drawOneImage(canvas, image);
			}
		}
		else if(offset > 0) {
			image = this.getPrevFrame();
			if(image && image.width > 0) {
				canvas.translate(-this.w, 0);
				this.drawOneImage(canvas, image);
			}
		}
		canvas.restore();

		if(this.showIndicator) {
			this.drawFrameIndicator(canvas, currFrame);
		}
	}

	return;
}


UIImageSlideView.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIButton || shape.isUIGroup || shape.isUILabel || shape.isUIImage;
}

function UIImageSlideViewCreator() {
	var args = [ "ui-image-slide-view", "ui-image-slide-view", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIImageSlideView();
		return g.initUIImageSlideView(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIImageSlideViewCreator());

/*
 * File:   ui-page-indicator.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Page Indicator
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPageIndicator
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */

/**
 * @class UIPageIndicatorSimple
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */

/**
 * @class UIPageIndicatorNormal
 * @extends UIElement
 * 标签控件（UIViewPager）的页面指示器。
 *
 */

/**
 * @class UIPageIndicatorNormalX
 * @extends UIPageIndicatorNormal
 * 标签控件（UIViewPager）的页面指示器，UIPageIndicatorNormalX可以放UIPageIndicatorButton。
 *
 */

/**
 * @class UIPageIndicatorButton
 * @extends UIRadioBox
 * 页面指示器里的按钮，只能放在UIPageIndicatorNormalX中。
 * UIPageIndicatorNormalX会根据页面的个数自动创建UIPageIndicatorButton，你可以设置它图片和字体，它支持的图片有下面4个：
 *
 * * UIElement.IMAGE_CURRENT_PAGE_BG 当前项的背景图片。
 * * UIElement.IMAGE_CURRENT_PAGE_FG 当前项的前景图片。
 * * UIElement.IMAGE_NOT_CURRENT_PAGE_BG 非当前项的背景图片。
 * * UIElement.IMAGE_NOT_CURRENT_PAGE_FG 非当前项的前景图片。
 *
 */
function UIPageIndicator() {
	return;
}

UIPageIndicator.prototype = new UIHScrollView();
UIPageIndicator.prototype.isUIPageIndicator = true;
UIPageIndicator.prototype.onPointerUpRunning = UIScrollView.prototype.onPointerUpRunning;

UIPageIndicator.prototype.isScrollable = function() {
	return this.getPages() > this.getVisibleTabs();
}

UIPageIndicator.prototype.setVisibleTabs = function(visibleTabs) {
	this.visibleTabs = visibleTabs;
	
	return;
}

UIPageIndicator.prototype.getVisibleTabs = function() {
	return this.visibleTabs ? this.visibleTabs : 6;
}

UIPageIndicator.prototype.getTabWidth = function() {
	var n = this.getPages();
	var visibleTabs = this.getVisibleTabs();

	if(n < visibleTabs) {
		return this.w/n;
	}
	else {
		return this.w/visibleTabs;
	}
}

UIPageIndicator.prototype.getScrollRange = function() {
	var visibleTabs = this.getVisibleTabs();

	if(visibleTabs < 6) {
		return this.w;
	}
	else {
		var n = this.getPages();
		return this.getTabWidth() * n;
	}
}

UIPageIndicator.prototype.initUIPageIndicator = function(type, w, h) {
	this.initUIHScrollView(type, 10, null);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setCanRectSelectable(false, false);
	this.images.display = UIElement.IMAGE_DISPLAY_9PATCH;

	return this;
}

UIPageIndicator.prototype.getViewPager = function() {
	if(!this.getParent()) {
		return;
	}

	if(this.viewPager && !this.viewPager.parentShape) {
		this.viewPager = null
	}

	if(!this.viewPager) {
		this.viewPager = this.getParent().findChildByType("ui-view-pager", true);
		if(!this.viewPager && this.isUIPageIndicatorSimple) { 
			this.viewPager = this.getWindow().findChildByType("ui-view-pager", true);
		}
	}

	return this.viewPager;
}

UIPageIndicator.prototype.getViewPagerOffset = function() {
	var viewPager = this.getViewPager();

	return viewPager ? viewPager.offset/viewPager.w : 0;
}

UIPageIndicator.prototype.getPages = function() {
	var viewPager = this.getViewPager();

	if(viewPager) {
		viewPager.pageIndicator = this;
	}

	return viewPager ? viewPager.getFrames() : 3;
}

UIPageIndicator.prototype.getCurrent = function() {
	var viewPager = this.getViewPager();
	
	return viewPager ? viewPager.getCurrent() : 0;
}

UIPageIndicator.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {
	canvas.beginPath();
	canvas.arc(x+w/2, y+h/2, 10, 0, 2 * Math.PI);
	canvas.fill();
	if(isCurrent) {
		canvas.stroke();
	}

	return;
}

UIPageIndicator.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPageIndicator.prototype.paintOneIndicatorCircle = function(canvas, isCurrent, index, x, y, w, h) {
	var r = Math.floor(Math.max(5, h/4));

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;

	canvas.beginPath();
	canvas.arc(x+w/2, y+h/2, r, 0, 2 * Math.PI);
	canvas.fill();
	canvas.stroke();

	return;
}

UIPageIndicator.prototype.paintOneIndicatorNumber = function(canvas, isCurrent, index, x, y, w, h) {
	var r = Math.floor(Math.max(5, h/4));
	var ox = Math.floor(x+w/2);
	var oy = Math.floor(y+h/2);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;

	canvas.beginPath();
	canvas.arc(ox, oy, r, 0, 2 * Math.PI);
	canvas.fill();
	canvas.stroke();

	canvas.font = r < 20 ? "16px sans" : "22px sans";
	canvas.textAlign = "center";
	canvas.textBaseline = "middle";
	canvas.fillStyle = this.style.textColor;
	canvas.fillText(index+1, ox, oy);
	
	return;
}

UIPageIndicator.prototype.paintOneIndicatorRect = function(canvas, isCurrent, index, x, y, w, h) {
	var size = 10;
	if(w > h) {
		size = Math.max(20, h/4);
	}
	else {
		size = Math.max(20, w/4);
	}
	size = Math.floor(size);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;
	
	var dx = (w - size)/2;
	var dy = (h - size)/2;

	canvas.beginPath();
	canvas.rect(x+dx, y+dy, size, size);
	canvas.fill();
	canvas.stroke();

	return;
}

UIPageIndicator.prototype.paintOneIndicatorLine = function(canvas, isCurrent, index, x, y, w, h) {
	var size = 4;
	if(w > h) {
		size = Math.max(4, h/4);
	}
	else {
		size = Math.max(4, w/4);
	}
	size = Math.floor(size);

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = isCurrent ? this.style.fillColorOfCurrent : this.style.fillColor;
	canvas.strokeStyle = isCurrent ? this.style.lineColorOfCurrent : this.style.lineColor;
	
	var dx = (w - size)/2;
	var dy = (h - size)/2;

	canvas.beginPath();
	if(w > h) {
		canvas.rect(x, y+dy, w, size);
	}
	else {
		canvas.rect(x+dx, y, size, h);
	}
	
	canvas.fill();
	canvas.stroke();

	return;
}


UIPageIndicator.prototype.onClickItem = function(index) {
	var viewPager = this.getViewPager();
	if(viewPager) {
		viewPager.setCurrent(index);
	}

	return;
}

UIPageIndicator.prototype.findItemByPoint = function(point) {
	var n = this.getPages();

	if(this.w > this.h) {
		var itemW = this.getTabWidth();

		for(var i = 0; i < n; i++) {
			if(point.x > i * itemW && point.x < (i+1) * itemW) {
				return i;
			}
		}
	}
	else {
		var itemH = this.h/n;
		for(var i = 0; i < n; i++) {
			if(point.y > i * itemH && point.y < (i+1) * itemH) {
				return i;
			}
		}
	}

	return -1;
}

UIPageIndicator.prototype.onClick = function(point, beforeChild) {
	if(beforeChild) {
		return;
	}

	var index = this.findItemByPoint(point);
	
	if(index >= 0) {
		this.onClickItem(index);
	}

	this.callOnClickHandler(point);

	return;
}

UIPageIndicator.prototype.paintBackground = function(canvas) {
	var n = this.getPages();
	if(!n) {
		canvas.lineWidth = 1;
		canvas.strokeStyle = "Red";
		canvas.rect(0, 0, this.w, this.h)
		canvas.stroke();
	}
}

UIPageIndicator.prototype.paintSelfOnly = function(canvas) {
	var n = this.getPages();
	var current = this.getCurrent();
	var point = {};
	point.x = this.lastPosition.x - this.left;
	point.y = this.lastPosition.y - this.top;

	this.pointerOnItem = this.findItemByPoint(point);

	this.paintBackground(canvas);

	canvas.translate(-this.offset, 0);
	if(this.w > this.h) {
		var itemH = this.h;
		var itemW = this.getTabWidth();
		var offset = Math.floor(this.getViewPagerOffset() * itemW);

		for(var i = 0; i < n; i++) {
			var dx = i*itemW;
			this.paintOneIndicator(canvas, i === current, i, dx, 0, itemW, itemH);
		}
	}
	else {
		var itemW = this.w;
		var itemH = this.h / n;

		for(var i = 0; i < n; i++) {
			var dy = i*itemH; 
			this.paintOneIndicator(canvas, i === current, i, 0, dy, itemW, itemH);
		}
	}
	canvas.translate(this.offset, 0);
	delete this.pointerOnItem;

	return;
}

function UIPageIndicatorCreator() {
	var args = ["ui-page-indicator", "ui-page-indicator", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicator();

		return g.initUIPageIndicator(this.type, 200, 60);
	}
	
	return;
}

////////////////////////////////////////////////////////////////////}-{
function UIPageIndicatorSimple() {
	
	return;
}

UIPageIndicatorSimple.prototype.isScrollable = function() {
	return this.getPages() > this.getVisibleTabs();
}

UIPageIndicatorSimple.prototype = new UIPageIndicator();
UIPageIndicatorSimple.prototype.isUIPageIndicatorSimple = true;

UIPageIndicatorSimple.prototype.saveProps = ["indicatorStyle"];
UIPageIndicatorSimple.prototype.initUIPageIndicatorSimple = function(type, w, h, indicatorStyle) {
	this.initUIPageIndicator(type, w, h);	
	this.style.fillColorOfCurrent = "Gray";
	this.style.lineColorOfCurrent = "Black";
	this.setAlwaysOnTop(true);
	this.setVisibleTabs(12);
	this.setIndicatorStyle(indicatorStyle);

	return this;
}

UIPageIndicatorSimple.prototype.setLineColorOfCurrent = function(value) {
	this.style.lineColorOfCurrent = value;

	return;
}

UIPageIndicatorSimple.prototype.setFillStyleOfCurrent = function(value) {
	this.style.fillColorOfCurrent = value;

	return;
}

UIPageIndicatorSimple.prototype.setIndicatorStyle = function(indicatorStyle) {
	this.indicatorStyle = indicatorStyle;

	return this;
}

UIPageIndicatorSimple.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {
	switch(this.indicatorStyle) {
		case "circle": {
			this.paintOneIndicatorCircle(canvas, isCurrent, index, x, y, w, h);
			break;
		}
		case "rect": {
			this.paintOneIndicatorRect(canvas, isCurrent, index, x, y, w, h);
			break;
		}
		case "line": {
			this.paintOneIndicatorLine(canvas, isCurrent, index, x, y, w, h);
			break;
		}
		default: {
			this.paintOneIndicatorNumber(canvas, isCurrent, index, x, y, w, h);
			break;
		}
	}
}

function UIPageIndicatorCircleCreator() {
	var args = ["ui-page-indicator-circle", "ui-page-indicator-circle", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		return g.initUIPageIndicatorSimple(this.type, 200, 60, "circle");
	}
	
	return;
}

function UIPageIndicatorNumberCreator() {
	var args = ["ui-page-indicator-number", "ui-page-indicator-number", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();
		return g.initUIPageIndicatorSimple(this.type, 200, 60, "number");
	}
	
	return;
}

function UIPageIndicatorRectCreator() {
	var args = ["ui-page-indicator-rect", "ui-page-indicator-rect", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();

		return g.initUIPageIndicatorSimple(this.type, 200, 60, "rect");
	}
	
	return;
}

function UIPageIndicatorLineCreator() {
	var args = ["ui-page-indicator-line", "ui-page-indicator-line", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();

		return g.initUIPageIndicatorSimple(this.type, 200, 60, "line");
	}
	
	return;
}

function UIPageIndicatorSimpleCreator() {
	var args = ["ui-page-indicator-simple", "ui-page-indicator-simple", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorSimple();

		return g.initUIPageIndicatorSimple(this.type, 200, 60, "line");
	}
	
	return;
}

////////////////////////////////////////////////////////////////////}-{
function UIPageIndicatorNormal() {
	return;
}

UIPageIndicatorNormal.prototype = new UIPageIndicator();
UIPageIndicatorNormal.prototype.isUIPageIndicatorNormal = true;

UIPageIndicatorNormal.prototype.saveProps = ["enableAnimatePage", "strItemImages", "strItemTexts", "strItemImagesOfCurrent"];
UIPageIndicatorNormal.prototype.initUIPageIndicatorNormal = function(type, w, h) {
	this.initUIPageIndicator(type, w, h);	

	this.itemTexts = [];
	this.itemImages = [];
	this.imagePosition = "left";
	this.itemImagesOfCurrent = [];

	this.setMargin(5, 5);
	this.setAlwaysOnTop(false);
	this.setImage(UIElement.ITEM_BG_NOTMAL, null);
	this.setImage(UIElement.ITEM_BG_ACTIVE, null);
	this.setImage(UIElement.ITEM_BG_CURRENT_NOTMAL, null);
	this.setImage(UIElement.ITEM_BG_CURRENT_ACTIVE, null);

	return this;
}

UIPageIndicatorNormal.prototype.onInit = function() {
	this.syncImages();
}

UIPageIndicatorNormal.prototype.syncImages = function() {
	this.itemImages = [];
	this.itemImagesOfCurrent = [];

	for(var key in this.images) {
		if(key === "display") continue;
		var image = this.images[key];
		if(key.indexOf("current-item-images-") === 0) {
			this.itemImagesOfCurrent.push(image);	
		}
		else if(key.indexOf("item-images-") === 0) {
			this.itemImages.push(image);	
		}
	}

	return;
}

UIPageIndicatorNormal.prototype.setEnableAnimatePage = function(value) {
	this.enableAnimatePage = value;

	return;
}

UIPageIndicatorNormal.prototype.setItemImagesByStr = function(str) {
	var arr = str.split("\n");
	var name = "item-images-";

	var n = this.itemImages.length;
	for(var i = 0; i < n; i++) {
		this.setImage(name + i, null);
	}

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.setImage(name + i, iter);
		}
	}

	this.syncImages();
	this.strItemImages = str;

	return;
}

UIPageIndicatorNormal.prototype.setItemImagesOfCurrentByStr = function(str) {
	var arr = str.split("\n");
	var name = "current-item-images-";

	var n = this.itemImagesOfCurrent.length;
	for(var i = 0; i < n; i++) {
		this.setImage(name + i, null);
	}

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(iter) {
			this.setImage(name + i, iter);
		}
	}

	this.syncImages();
	this.strItemImagesOfCurrent = str;

	return;
}

UIPageIndicatorNormal.prototype.setItemTextsByStr = function(str) {
	this.strItemTexts = str;
	this.itemTexts = str.split("\n");

	return;
}

UIPageIndicatorNormal.prototype.setImagePosition = function(value) {
	this.imagePosition = value;

	return;
}

UIPageIndicatorNormal.prototype.getItemImagesStr = function() {
	return this.strItemImages ? this.strItemImages : "";
}

UIPageIndicatorNormal.prototype.getItemImagesStrOfCurrent = function() {
	return this.strItemImagesOfCurrent ? this.strItemImagesOfCurrent : "";
}

UIPageIndicatorNormal.prototype.getItemImages = function() {
	if(!this.itemImages.length) {
		this.syncImages();
	}

	return this.itemImages;
}

UIPageIndicatorNormal.prototype.getItemImagesOfCurrent = function() {
	if(!this.itemImagesOfCurrent.length) {
		this.syncImages();
	}

	return this.itemImagesOfCurrent;
}

UIPageIndicatorNormal.prototype.getItemTextsStr = function() {
	return this.strItemTexts ? this.strItemTexts : "";
}

UIPageIndicatorNormal.prototype.getItemTexts = function() {
	if(!this.itemTexts.length && this.strItemTexts) {
		this.setItemTextsByStr(this.strItemTexts);
	}

	return this.itemTexts;
}

UIPageIndicatorNormal.prototype.getItemImage = function(index, isCurrent) {
	var images = isCurrent ? this.getItemImagesOfCurrent() : this.getItemImages();
	if(images && index < images.length) {
		return images[index];
	}

	return null;
}

UIPageIndicatorNormal.prototype.getBackgroundImage = function(index, isCurrent) {
	var type = "";
	var active = this.pointerDown && this.pointerOnItem === index;
	if(isCurrent) {
		type = active ? UIElement.ITEM_BG_CURRENT_ACTIVE : UIElement.ITEM_BG_CURRENT_NOTMAL;
	}
	else {
		type = active ? UIElement.ITEM_BG_ACTIVE : UIElement.ITEM_BG_NOTMAL;
	}

	return this.getImageByType(type);
}

UIPageIndicatorNormal.prototype.paintOneIndicatorBackground = function(canvas, isCurrent, index, x, y, w, h) {
	var wImage = this.getBackgroundImage(index, isCurrent);
	if(!wImage || !wImage.getImage()) {
		return;
	}

	var image = wImage.getImage();
	var srcRect = wImage.getImageRect();

	this.drawImageAt(canvas, image, this.images.display, x, y, w, h, srcRect);

	return;
}

UIPageIndicatorNormal.prototype.setItemTextColorOfCurrent = function(value) {
	this.style.textColorOfCurrent = value;

	return;
}

UIPageIndicatorNormal.prototype.getItemTextColorOfCurrent = function() {
	return this.style.textColorOfCurrent ? this.style.textColorOfCurrent : "green";
}

UIPageIndicatorNormal.prototype.paintBackground = function(canvas) {
	return;
}

UIPageIndicatorNormal.prototype.getItemLocaleText= function(index) {
	var str = null;
	var texts = this.getItemTexts();
	
	if(texts && index < texts.length) {
		str = webappGetText(texts[index]);
		if(!str) {
			str = texts[index];
		}
	}

	return str;
}

UIPageIndicatorNormal.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {
	var wImage = this.getItemImage(index, isCurrent);
	this.paintOneIndicatorBackground(canvas, isCurrent, index, x, y, w, h);

	var gap = 8;
	var fontSize = this.style.fontSize;
	var str = this.getItemLocaleText(index);

	canvas.font = this.style.getFont();
	canvas.fillStyle = isCurrent ? this.getItemTextColorOfCurrent() : this.style.textColor; 
	
	if(wImage && wImage.getImage()) {
		var image = wImage.getImage();
		var srcRect = wImage.getImageRect();

		var hMargin = this.hMargin;
		var vMargin = this.vMargin;

		if(str) {
			var fontSize = this.style.fontSize;
			var dx = x + hMargin;
			var dy = y + vMargin;
			var dw = w - 2 * hMargin;
			var dh = h - fontSize - 2 * vMargin - gap;

			this.drawImageAt(canvas, image,UIElement.IMAGE_DISPLAY_AUTO, dx, dy, dw, dh, srcRect);

			dx = x + (w >> 1);
			dy = y + h - vMargin; 
			canvas.textAlign = "center";
			canvas.textBaseline = "bottom";
			canvas.fillText(str, dx, dy);
		}
		else {
			var dx = x + hMargin;
			var dy = y + vMargin;
			var dw = w - 2 * hMargin;
			var dh = h - 2 * vMargin;

			this.drawImageAt(canvas, image,UIElement.IMAGE_DISPLAY_AUTO, dx, dy, dw, dh, srcRect);
		}
	}
	else {
		if(str) {
			canvas.textAlign = "center";
			canvas.textBaseline = "middle";
			canvas.fillText(str, Math.floor(x+w/2), Math.floor(y+h/2));
		}
	}

	return;
}

UIPageIndicator.prototype.onClickItem = function(index) {
	var viewPager = this.getViewPager();
	if(viewPager) {
		if(this.enableAnimatePage) {
			viewPager.switchTo(index);
		}
		else {
			viewPager.setCurrent(index);
		}
	}

	return;
}

function UIPageIndicatorNormalCreator() {
	var args = ["ui-page-indicator-normal", "ui-page-indicator-normal", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorNormal();

		return g.initUIPageIndicatorNormal(this.type, 200, 60);
	}
	
	return;
}

////////////////////////////////////////////////////////////////////}-{
function UIPageIndicatorNormalX() {
	return;
}

UIPageIndicatorNormalX.prototype = new UIPageIndicator();
UIPageIndicatorNormalX.prototype.isUIPageIndicatorNormalX = true;
UIPageIndicatorNormalX.prototype.initUIPageIndicatorNormalX = function(type, w, h) {
	this.initUIPageIndicator(type, w, h);	

	return this;
}

UIPageIndicatorNormalX.prototype.relayoutChildren = function() {
	var arr  = this.children;
	var pagesNr = this.getPages() || 3;

	for(var i = arr.length; i < pagesNr; i++) {
		var button = this.addChild(this.createElement("ui-page-indicator-button"));
		button.setText(i);
	}
	arr.length = pagesNr;
	
	var n = pagesNr;
	var ih = this.h;
	var iw = this.w/n;

	for(var i = 0; i < n; i++) {
		var iter = arr[i];
		iter.h = ih;
		iter.w = iw;
		iter.y = 0;
		iter.x = i * iw;
		iter.xAttr = UIElement.X_FIX_LEFT;
		iter.yAttr = UIElement.Y_FIX_TOP;
		iter.widthAttr = UIElement.WIDTH_FIX;
		iter.heightAttr = UIElement.HEIGHT_FIX;
	}

	return this;
}

UIPageIndicatorNormalX.prototype.paintOneIndicator = function(canvas, isCurrent, index, x, y, w, h) {}

UIPageIndicatorNormalX.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIPageIndicatorButton;
}

function UIPageIndicatorNormalXCreator() {
	var args = ["ui-page-indicator-normal-x", "ui-page-indicator-normal-x", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorNormalX();

		return g.initUIPageIndicatorNormalX(this.type, 200, 60);
	}
	
	return;
}

/////////////////////////////////////////////////////////////////////////////////////

function UIPageIndicatorButton() {
	return;
}

UIPageIndicatorButton.prototype = new UIRadioBox();
UIPageIndicatorButton.prototype.isUIPageIndicatorButton = true;
UIPageIndicatorButton.prototype.initUIPageIndicatorButton = function(type) {
	this.initUIRadioBox(type);	
	this.userMovable = false;
	this.userResizable = false;
	this.images = {display:UIElement.IMAGE_DISPLAY_9PATCH};
    this.setImage(UIElement.IMAGE_CURRENT_PAGE_BG, null);
    this.setImage(UIElement.IMAGE_CURRENT_PAGE_FG, null);
    this.setImage(UIElement.IMAGE_NOT_CURRENT_PAGE_BG, null);
    this.setImage(UIElement.IMAGE_NOT_CURRENT_PAGE_FG, null);

	return this;
}

UIPageIndicatorButton.prototype.getValue = function() {
	var parentShape = this.parentShape;

	if(parentShape) {
		return parentShape.getCurrent() === parentShape.children.indexOf(this);
	}
	else {
		return this.value;
	}
}

UIPageIndicatorButton.prototype.drawText = function(canvas) {}
UIPageIndicatorButton.prototype.drawImage = function(canvas) {
	var rect = null;
	var image = null;
	var value = this.getValue();
	var bgImage = this.getImageByType(value ? UIElement.IMAGE_CURRENT_PAGE_BG : UIElement.IMAGE_NOT_CURRENT_PAGE_BG);
	var fgImage = this.getImageByType(value ? UIElement.IMAGE_CURRENT_PAGE_FG : UIElement.IMAGE_NOT_CURRENT_PAGE_FG);

	image = bgImage.getImage();
	rect = bgImage.getImageRect();
	if(image) {
		this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, rect);	
	}

	image = fgImage.getImage();
	rect = fgImage.getImageRect();
	var text = this.text;
	if(text) {
		canvas.textAlign = "center";
		canvas.font = this.style.getFont();
		canvas.fillStyle = value ? this.style.textColorHighlight : this.style.textColor;
	}

	if(image) {
		if(text) {
			var fontHeight = this.style.fontSize + 10;
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_AUTO_SIZE_DOWN, 0, 0, this.w, this.h-fontHeight, rect);
			canvas.textBaseline = "bottom";
			canvas.fillText(text, this.w >> 1, this.h - 3); 
		}
		else {
			this.drawImageAt(canvas, image, UIElement.IMAGE_DISPLAY_AUTO_SIZE_DOWN, 0, 0, this.w, this.h, rect);
		}
	}
	else if(text) {
		canvas.textBaseline = "middle";
		canvas.fillText(text, this.w >> 1, this.h >> 1); 
	}

	return;
}

UIPageIndicatorButton.prototype.shapeCanBeChild = function(shape) {
	return shape.isUIImage || shape.isUILabel;
}

function UIPageIndicatorButtonCreator() {
	var args = ["ui-page-indicator-button", "ui-page-indicator-button", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPageIndicatorButton();

		return g.initUIPageIndicatorButton(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPageIndicatorButtonCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorNormalXCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorNormalCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorCircleCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorNumberCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorRectCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorLineCreator());
ShapeFactoryGet().addShapeCreator(new UIPageIndicatorSimpleCreator());

/*
 * File:   ui-path.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic path for game. 
 * 
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPath
 * @extends UIElement
 * UIPath 控制物体按照指定的路径运动。目前路径支持直线，抛物线，二次和三次贝塞尔曲线，sin/cos函数和圆弧曲线。可以指定运动的速度(由duration控制)和加速度(由interpolator决定)。
 *
 * 使用时先放一个UIPath对象到场景中，然后在onInit事件里增加路径，在任何时间都可以向UIPath增加对象或删除对象。
 *
 * 注意：
 *
 * 1.文档中时长的单位为毫秒，速度单位为像素/秒，加速单位为像素/秒^2，角度单位为弧度。
 *
 * 2.插值算法实现加速/加速/匀速等效果，请参考插值算法。
 *
 */
function UIPath() {
	return;
}

UIPath.prototype = new UIElement();
UIPath.prototype.isUIPath = true;
UIPath.prototype.saveProps = ["showPath"];
UIPath.prototype.initUIPath = function(type, w, h) {
	this.initUIElement(type);	
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onInit"]);

	return this;
}

UIPath.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIPath.prototype.onInit = function() {
	this.shapesInfo = [];
	this.elapsedTime = 0;
	this.pathAnimation = new PathAnimation();
	this.animationState = UIElement.STATE_RUNNING;

	this.callOnInitHandler();

	return;
}

/**
 * @method restart
 * 重新开始。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.restart = function() {
	this.elapsedTime = 0;
	this.animationState = UIElement.STATE_RUNNING;
	
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		iter.done = false;
		iter.startTime = iter.delayTime;
	}

	return this;
}

/**
 * @method pause
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.pause = function() {
	this.animationState = UIElement.STATE_PAUSED;

	return this;
}

/**
 * @method resume 
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UIPath.prototype.resume = function() {
	this.animationState = UIElement.STATE_RUNNING;

	return this;
}

UIPath.prototype.hasObj = function(shape) {
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		if(iter.shape === shape) {
			return true;
		}
	}

	return false;
}

/**
 * @method addObj
 * 增加一个对象，让它沿路径运动。
 * @param {UIElement} shape 对象。
 * @param {Function} onStep 每一步的回调函数（可选）。
 * @param {Function} onDone 完成时的回调函数（可选）。
 * @param {Number} delayTime 延迟启动时间（可选）。
 * @param {Number} noRotation 是否禁止旋转（可选）。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addObj = function(shape, onStep, onDone, delayTime, noRotation) {
	if(this.hasObj(shape)) {
		console.log("obj exist in path.");
		return this;
	}

	var info = {
		shape : shape, 
		onStep : onStep,
		onDone : onDone,
		noRotation:noRotation,
		delayTime : delayTime ? delayTime : 0, 
		startTime: Date.now()
	};

	info.startTime = info.delayTime + this.elapsedTime;
	this.shapesInfo.push(info);

	return this;
}

/**
 * @method removeObj
 * 从路径中移除一个对象。
 * @param {UIElement} shape 对象。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.removeObj = function(shape) {
	var a = this.shapesInfo;
	var n = this.shapesInfo.length;

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		if(iter.shape === shape) {
			a.splice(i, 1);
			break;
		}
	}

	return this;
}

/**
 * @method resetObjs
 * 清除全部对象。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.resetObjs = function() {
	this.shapesInfo = [];

	return this;
}

/**
 * @method resetPath
 * 重置路径。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.resetPath = function() {
	this.pathAnimation.reset();

	return this;
}

UIPath.prototype.getStartPoint = function() {
	return this.pathAnimation.startPoint;
}

UIPath.prototype.getEndPoint = function() {
	return this.endPoint;
}

UIPath.prototype.addPath = function(path) {
	this.pathAnimation.addPath(path);

	return this;
}

/**
 * @method addLine
 * 增加一条直线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addLine = function(duration, interpolator, p1, p2) {
	return this.addPath(LinePath.create(duration, interpolator, p1.x, p1.y, p2.x, p2.y));
}

/**
 * @method addArc
 * 增加一条弧线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} origin 原点
 * @param {Number} r 半径。
 * @param {Number} sAngle 初始角度。
 * @param {Number} eAngle 结束角度。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addArc = function(duration, interpolator, origin, r, sAngle, eAngle) {
	return this.addPath(ArcPath.create(duration, interpolator, origin.x, origin.y, r, sAngle, eAngle));
}

/**
 * @method addPara
 * 增加一条抛物线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p 初始位置。 
 * @param {Point} a 加速度。
 * @param {Point} v 初速度。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addPara = function(duration, interpolator, p, a, v) {
	return this.addPath(ParaPath.create(duration, interpolator, p.x, p.y, a.x, a.y, v.x, v.y));
}

/**
 * @method addSin
 * 增加一条sin/cos曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Number} p 初始位置。
 * @param {Number} waveLenth 波长。
 * @param {Number} v 波速(X方向上的速度)。
 * @param {Number} amplitude 振幅。
 * @param {Number} phaseOffset 角度偏移。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addSin = function(duration, interpolator, p, waveLenth, v, amplitude, phaseOffset) {
	return this.addPath(SinPath.create(duration, interpolator, p.x, p.y, waveLenth, v, amplitude, phaseOffset));
}

/**
 * @method addBezier
 * 增加一条三次贝塞尔曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 控制点1。
 * @param {Point} p3 控制点2。
 * @param {Point} p4 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addBezier = function(duration, interpolator, p1, p2, p3, p4) {
	return this.addPath(Bezier3Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y, p4.x,p4.y));
}

/**
 * @method addQuad
 * 增加一条二次贝塞尔曲线到路径中。
 * @param {Number} duration 经过此路径需要的时间。
 * @param {Object} interpolator 插值算法。
 * @param {Point} p1 起点。
 * @param {Point} p2 控制点。
 * @param {Point} p3 终点。
 * @return {UIElement} 返回控件本身。
 */
UIPath.prototype.addQuad = function(duration, interpolator, p1, p2, p3) {
	return this.addPath(Bezier2Path.create(duration, interpolator, p1.x,p1.y, p2.x,p2.y, p3.x,p3.y));
}

UIPath.prototype.getDuration = function() {
	return this.pathAnimation.duration;
}

UIPath.prototype.getPosition = function(elapsedTime) {
	return this.pathAnimation.getPosition(elapsedTime);
}

UIPath.prototype.getDirection = function(elapsedTime) {
	return this.pathAnimation.getDirection(elapsedTime);
}

UIPath.prototype.updateObjs = function(canvas) {
	this.elapsedTime += canvas.timeStep;
	var elapsedTime = this.elapsedTime;
	
	var a = this.shapesInfo.slice();
	var n = this.shapesInfo.length;
	var pathAnimation = this.pathAnimation;
	var duration = pathAnimation.getDuration();

	for(var i = 0; i < n; i++) {
		var iter = a[i];
		var shape = iter.shape;
		if(!shape || !shape.parentShape) continue;

		var t = elapsedTime - iter.startTime;
		if(t > 0 && !iter.done) {
			var angle = pathAnimation.getDirection(t);
			var position = pathAnimation.getPosition(t);

			if(!shape.visible) {
				shape.setVisible(true);
			}

			if(shape.anchor) {
				shape.setPosition(position.x, position.y);
			}
			else {
				shape.setPosition(position.x-(shape.w>>1), position.y-(shape.h>>1));
			}
			if(!iter.noRotation) {
				shape.setRotation(angle);
			}

			if(iter.onStep) {
				var onStep = iter.onStep;
				onStep(shape, t, position, angle);
			}
			
			if(t > duration) {
				iter.done = true;
				if(iter.onDone) {
					var onDone = iter.onDone;
					onDone(shape);
				}
			}
		}
	}
}

UIPath.prototype.paintSelf = function(canvas) {
	if(this.isIcon || this.isInDesignMode()) {
		UIElement.prototype.paintSelf.call(this, canvas);
		return;
	}

	if(this.showPath && !this.isStrokeColorTransparent()) {
		canvas.strokeStyle = this.style.lineColor;
		canvas.lineWidth = this.style.lineWidth;
		this.pathAnimation.draw(canvas);
	}

	if(this.animationState === UIElement.STATE_RUNNING) {
		this.updateObjs(canvas);
		canvas.needRedraw++;
	}
	
	return;
}

function UIPathCreator() {
	var args = ["ui-path", "ui-path", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPath();
		return g.initUIPath(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPathCreator());
/*
* Matrix2D
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * @module EaselJS
 */

// namespace:
// this.createjs = this.createjs||{};

this.Matrix2D = (function() {
	"use strict";


// constructor:
	/**
	 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
	 *
	 * This matrix can be visualized as:
	 *
	 * 	[ a  c  tx
	 * 	  b  d  ty
	 * 	  0  0  1  ]
	 *
	 * Note the locations of b and c.
	 *
	 * @class Matrix2D
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @constructor
	 **/
	function Matrix2D(a, b, c, d, tx, ty) {
		this.setValues(a,b,c,d,tx,ty);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
	
		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
	
		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
	
		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
	
		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property tx
		 * @type Number
		 **/
	
		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
	}
	var p = Matrix2D.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
	 * @property DEG_TO_RAD
	 * @static
	 * @final
	 * @type Number
	 * @readonly
	 **/
	Matrix2D.DEG_TO_RAD = Math.PI/180;


// static public properties:
	/**
	 * An identity matrix, representing a null transformation.
	 * @property identity
	 * @static
	 * @type Matrix2D
	 * @readonly
	 **/
	Matrix2D.identity = null; // set at bottom of class definition.
	

// public methods:
	/**
	 * Sets the specified values on this instance. 
	 * @method setValues
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @return {Matrix2D} This instance. Useful for chaining method calls.
	*/
	p.setValues = function(a, b, c, d, tx, ty) {
		// don't forget to update docs in the constructor if these change:
		this.a = (a == null) ? 1 : a;
		this.b = b || 0;
		this.c = c || 0;
		this.d = (d == null) ? 1 : d;
		this.tx = tx || 0;
		this.ty = ty || 0;
		return this;
	};

	/**
	 * Appends the specified matrix properties to this matrix. All parameters are required.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method append
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.append = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		if (a != 1 || b != 0 || c != 0 || d != 1) {
			this.a  = a1*a+c1*b;
			this.b  = b1*a+d1*b;
			this.c  = a1*c+c1*d;
			this.d  = b1*c+d1*d;
		}
		this.tx = a1*tx+c1*ty+this.tx;
		this.ty = b1*tx+d1*ty+this.ty;
		return this;
	};

	/**
	 * Prepends the specified matrix properties to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * All parameters are required.
	 * @method prepend
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prepend = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;

		this.a  = a*a1+c*this.b;
		this.b  = b*a1+d*this.b;
		this.c  = a*c1+c*this.d;
		this.d  = b*c1+d*this.d;
		this.tx = a*tx1+c*this.ty+tx;
		this.ty = b*tx1+d*this.ty+ty;
		return this;
	};

	/**
	 * Appends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method appendMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendMatrix = function(matrix) {
		return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Prepends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = o.getMatrix();
	 * 	while (o = o.parent) {
	 * 		// prepend each parent's transformation in turn:
	 * 		o.prependMatrix(o.getMatrix());
	 * 	}
	 * @method prependMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependMatrix = function(matrix) {
		return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
	 * For example, you can use this to generate a matrix representing the transformations of a display object:
	 * 
	 * 	var mtx = new createjs.Matrix2D();
	 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
	 * @method appendTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (skewX || skewY) {
			// TODO: can this be combined into a single append operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
		} else {
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		
		if (regX || regY) {
			// append the registration offset:
			this.tx -= regX*this.a+regY*this.c; 
			this.ty -= regX*this.b+regY*this.d;
		}
		return this;
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = new createjs.Matrix2D();
	 * 	do  {
	 * 		// prepend each parent's transformation in turn:
	 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	 * 	} while (o = o.parent);
	 * 	
	 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
	 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
	 * @method prependTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (regX || regY) {
			// prepend the registration offset:
			this.tx -= regX; this.ty -= regY;
		}
		if (skewX || skewY) {
			// TODO: can this be combined into a single prepend operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
		} else {
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		return this;
	};

	/**
	 * Applies a clockwise rotation transformation to the matrix.
	 * @method rotate
	 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.rotate = function(angle) {
//		angle = angle*Matrix2D.DEG_TO_RAD;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var a1 = this.a;
		var b1 = this.b;

		this.a = a1*cos+this.c*sin;
		this.b = b1*cos+this.d*sin;
		this.c = -a1*sin+this.c*cos;
		this.d = -b1*sin+this.d*cos;
		return this;
	};

	/**
	 * Applies a skew transformation to the matrix.
	 * @method skew
	 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @param {Number} skewY The amount to skew vertically in degrees.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.skew = function(skewX, skewY) {
		skewX = skewX*Matrix2D.DEG_TO_RAD;
		skewY = skewY*Matrix2D.DEG_TO_RAD;
		this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		return this;
	};

	/**
	 * Applies a scale transformation to the matrix.
	 * @method scale
	 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
	 * @param {Number} y The amount to scale vertically.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.scale = function(x, y) {
		this.a *= x;
		this.b *= x;
		this.c *= y;
		this.d *= y;
		//this.tx *= x;
		//this.ty *= y;
		return this;
	};

	/**
	 * Translates the matrix on the x and y axes.
	 * @method translate
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.translate = function(x, y) {
		this.tx += this.a*x + this.c*y;
		this.ty += this.b*x + this.d*y;
		return this;
	};

	/**
	 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
	 * @method identity
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.identity = function() {
		this.a = this.d = 1;
		this.b = this.c = this.tx = this.ty = 0;
		return this;
	};

	/**
	 * Inverts the matrix, causing it to perform the opposite transformation.
	 * @method invert
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.invert = function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1*d1-b1*c1;

		this.a = d1/n;
		this.b = -b1/n;
		this.c = -c1/n;
		this.d = a1/n;
		this.tx = (c1*this.ty-d1*tx1)/n;
		this.ty = -(a1*this.ty-b1*tx1)/n;
		return this;
	};

	/**
	 * Returns true if the matrix is an identity matrix.
	 * @method isIdentity
	 * @return {Boolean}
	 **/
	p.isIdentity = function() {
		return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
	};
	
	/**
	 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
	 * @method equals
	 * @param {Matrix2D} matrix The matrix to compare.
	 * @return {Boolean}
	 **/
	p.equals = function(matrix) {
		return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
	};

	/**
	 * Transforms a point according to this matrix.
	 * @method transformPoint
	 * @param {Number} x The x component of the point to transform.
	 * @param {Number} y The y component of the point to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
	 * @return {Point} This matrix. Useful for chaining method calls.
	 **/
	p.transformPoint = function(x, y, pt) {
		pt = pt||{};
		pt.x = x*this.a+y*this.c+this.tx;
		pt.y = x*this.b+y*this.d+this.ty;
		return pt;
	};

	/**
	 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
	 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
	 * results.
	 * @method decompose
	 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
	 * @return {Object} The target, or a new generic object with the transform properties applied.
	*/
	p.decompose = function(target) {
		// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
		if (target == null) { target = {}; }
		target.x = this.tx;
		target.y = this.ty;
		target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

		var skewX = Math.atan2(-this.c, this.d);
		var skewY = Math.atan2(this.b, this.a);

		var delta = Math.abs(1-skewX/skewY);
		if (delta < 0.00001) { // effectively identical, can use rotation:
			target.rotation = skewY/Matrix2D.DEG_TO_RAD;
			if (this.a < 0 && this.d >= 0) {
				target.rotation += (target.rotation <= 0) ? 180 : -180;
			}
			target.skewX = target.skewY = 0;
		} else {
			target.skewX = skewX/Matrix2D.DEG_TO_RAD;
			target.skewY = skewY/Matrix2D.DEG_TO_RAD;
		}
		return target;
	};
	
	/**
	 * Copies all properties from the specified matrix to this matrix.
	 * @method copy
	 * @param {Matrix2D} matrix The matrix to copy properties from.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.copy = function(matrix) {
		return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Returns a clone of the Matrix2D instance.
	 * @method clone
	 * @return {Matrix2D} a clone of the Matrix2D instance.
	 **/
	p.clone = function() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
	};

	// this has to be populated after the class is defined:
	Matrix2D.identity = new Matrix2D();


	// createjs.Matrix2D = Matrix2D;
	return Matrix2D;
}());
/*
 * File: utils.js
 * Author:  Li XianJing <xianjimli@hotmail.com>
 * Brief: some functions to help load dragbones.
 * Web: https://github.com/drawapp8 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */


function loadDragonBoneArmature(textureJsonURL, skeletonJsonURL, textureURL, onDone) {
	var texture = new Image();

	texture.onload = function()	{
		httpGetJSON(textureJsonURL, function(data) {
			var textureData = data;
			if(!data) {
				console.log("Get Json Failed:" + textureJsonURL);
				return;
			}

			httpGetJSON(skeletonJsonURL, function(data) {
				if(!data) {
					console.log("Get Json Failed:" + skeletonJsonURL);
					return;
				}

				var skeletonData = data;
				var factory = new dragonBones.factorys.GeneralFactory();

				factory.addSkeletonData(dragonBones.objects.DataParser.parseSkeletonData(skeletonData));
				factory.addTextureAtlas(new dragonBones.textures.GeneralTextureAtlas(texture, textureData));
			
				for(var i = 0; i < skeletonData.armature.length; i++) {
					var name = skeletonData.armature[i].name;
					var armature = factory.buildArmature(name);

					if(i === 0) {
						onDone(armature);
					}
				}
			});
		});
	}

	texture.src = textureURL;

	return;
}

function onArmatureCreated(armature) {
	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");

	armature.setPosition(300, 300);

	function update() {
		ctx.clearRect(0,0,canvas.width, canvas.height);

		dragonBones.animation.WorldClock.clock.advanceTime(1/60);

		armature.draw(ctx);

		setTimeout(update, 16);
	}
	
	function changeAnimation() 	{
		do	{
			var index = Math.floor(Math.random() * armature.animation.animationNameList.length);
			var animationName = armature.animation.animationNameList[index];
		}while (animationName == armature.animation.getLastAnimationName());

		armature.animation.gotoAndPlay(animationName);
	}
	
	canvas.onclick = changeAnimation;
	dragonBones.animation.WorldClock.clock.add(armature);

	changeAnimation();
	update();

	return;
}

/*
 * File:   ui-scene.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  The game scene
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIScene
 * @extends UINormalWindow
 * 游戏场景。在UINormalWindow上增加了物理引擎和虚拟屏幕的支持。
 *
 */

/**
 * @property {Number} xOffset 
 * 当场景的虚拟大小大于实际大小时，当前可视区域的X偏移量。
 */

/**
 * @property {Number} yOffset 
 * 当场景的虚拟大小大于实际大小时，当前可视区域的Y偏移量。
 */

/**
 * @property {Number} virtualWidth 
 * 当场景的虚拟宽度。
 */

/**
 * @property {Number} virtualHeight 
 * 当场景的虚拟高度。
 */
function UIScene() {
	return;
}

UIScene.prototype = new UINormalWindow();
UIScene.prototype.isUIScene = true;

UIScene.prototype.saveProps = ["enablePhysics", "showFPS", "maxFPSMode", "fps", "gravityX", "gravityY",
	"pixelsPerMeter", "virtualWidth", "virtualHeight", "xOffset", "yOffset", "openAnimationDuration",
	"closeAnimationDuration", "animHint", "windowType", "refLinesV", "refLinesH", "sceneId"];

UIScene.prototype.canRectSelectable = function() {
	return this.virtualHeight <= this.h && this.virtualWidth <= this.w;
}

UIScene.prototype.initUIScene = function(type, w, h, bg) {
	this.initUIWindow(type, 0, 0, w, h, bg);	
	this.widthAttr  = UIElement.WIDTH_FILL_PARENT;
	this.heightAttr = UIElement.HEIGHT_FILL_PARENT;
	this.images.display = UIElement.IMAGE_DISPLAY_SCALE;

	this.xOffset = 0;
	this.yOffset = 0;
	this.virtualWidth = 0;
	this.virtualHeight = 0;
	this.autoClearForce = true;
	this.setAnimHint("none");
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onPointerDown", "onPointerMove", "onPointerUp", "onDoubleClick", "onMultiTouch"]);
	this.addEventNames(["onSwipeLeft", "onSwipeRight", "onSwipeUp", "onSwipeDown"]);
	this.setImage(UIElement.IMAGE_TIPS1, null);
	this.setImage(UIElement.IMAGE_TIPS2, null);
	this.setImage(UIElement.IMAGE_TIPS3, null);
	this.setImage(UIElement.IMAGE_TIPS4, null);
	this.setImage(UIElement.IMAGE_TIPS5, null);
	this.setCameraFollowParams(0.5, 0.5, 0.5, 0.5);
	this.velocityTracker = new VelocityTracker();

	return this;
}

UIScene.prototype.resetGame = function() {
	UIElement.logWarning("This API is removed, don't call it anymore! call win.replay() instead. (don't call it in open/beforeopen event.)");

	return;
}

UIScene.prototype.addStickyChild = function(child) {
	if(child.parentShape !== this || child.left >= this.w || child.top >= this.h) {
		console.log("%cWarning: invalid params to addStickyChild.", "color: red; font-weight: bold");

		return this;
	}

	child.orgX = child.left;
	child.orgY = child.top;

	this.stickyChildren.push(child);

	return this;
}

UIScene.prototype.removeStickyChild = function(child) {
	this.stickyChildren.remove(child);

	return this;
}

UIScene.prototype.updateStickyChildren = function() {
	this.stickyChildren = [];
	var a = this.children;
	for(var i = 0; i < a.length; i++) {
		var iter = a[i];
		if(iter.sticky) {
			if(iter.orgX === undefined) {
				iter.orgX = iter.left;
			}
			if(iter.orgY === undefined) {
				iter.orgY = iter.top;
			}
			this.stickyChildren.push(iter);
		}
	}

	return this;
}

UIScene.prototype.setEnablePhysics = function(enablePhysics) {
	this.enablePhysics = enablePhysics;

	return this;
}

UIScene.prototype.startPhysics = function() {
	if(this.enablePhysics) {
		Physics.createWorld(this);

		if(this.world) {
			if(this.map) {
				this.map.createBodies(this.world);
			}
		}else{
			console.log("create world failed.");
		}
	}

	return this;
}

UIScene.prototype.doInit = function() {
	this.xOffset = 0;
	this.yOffset = 0;
	this.setTimeScale(1);
	this.startPhysics();

	if(this.gameName) {
		document.title = this.gameName;
	}

	return;
}

UIScene.prototype.onOpen = function(initData) {
	this.doInit();
	this.play();

	return;
}

UIScene.prototype.onInit = function() {
	var me = this;
	this.initStageOne();
	this.updateStickyChildren();

	return;
}

UIScene.prototype.onDeinit = function() {
	if(this.world) {
		var world = this.world;
		Physics.destroyWorld(world);
		this.world = null;
	}

	this.stop();

	return;
}

UIScene.prototype.getVirtualWidth = function() {
	if(this.virtualWidth < this.w) {
		return this.w;
	}

	return this.virtualWidth;
}

UIScene.prototype.getVirtualHeight = function() {
	if(this.virtualHeight < this.h) {
		return this.h;
	}

	return this.virtualHeight;
}

UIScene.prototype.onScrolled = function() {
	var a = this.stickyChildren;
	if(a && a.length) {
		var ox = this.xOffset;
		var oy = this.yOffset;
		for(var i = 0; i < a.length; i++) {
			var iter = a[i];
			var x = iter.orgX + ox;
			var y = iter.orgY + oy;
			iter.setLeftTop(x, y);
			if(iter.isUIBody) {
				iter.onPositionChanged();
			}
		}
	}

	return;
}

UIScene.prototype.setOffsetDelta = function(x, y) {
	return this.setOffset(this.xOffset+x, this.yOffset+y);
}

/**
 * @method setOffset
 * 设置场景可视区左上角的坐标。
 * @param {Number} xOffset 
 * @param {Number} yOffset
 * @return {UIElement} 返回控件本身。
 *
 */
UIScene.prototype.setOffset = function(xOffset, yOffset) {
	if(xOffset || xOffset === 0) {
		var maxOffset = this.getVirtualWidth() - this.w;
		
		var xOffsetNew = Math.max(0, xOffset);
		if(xOffsetNew > maxOffset) {
			xOffsetNew = maxOffset;
		}
		this.xOffset = xOffsetNew >> 0;
	}

	if(yOffset || yOffset === 0) {
		var maxOffset = this.getVirtualHeight() - this.h;

		var yOffsetNew = Math.max(0, yOffset);
		if(yOffsetNew > maxOffset) {
			yOffsetNew = maxOffset;
		}
		this.yOffset = yOffsetNew >> 0;
	}

	this.onScrolled();

	return this;
}

/**
 * @method setOffsetPercent 
 * 按百分比设置场景可视区左上角的坐标。
 * @param {Number} xOffsetPercent X方向偏移量百分比(0,100)。
 * @param {Number} yOffsetPercent Y方向偏移量百分比(0,100)。
 * @return {UIElement} 返回控件本身。
 */
UIScene.prototype.setOffsetPercent = function(xOffsetPercent, yOffsetPercent) {
	var xOffset = (this.virtualWidth - this.w) * (xOffsetPercent/100);
	var yOffset = (this.virtualHeight - this.h) * (yOffsetPercent/100);

	return this.setOffset(xOffset, yOffset);
}

UIScene.prototype.getRelayoutWidth = function() {
	return this.getWidth();
}

UIScene.prototype.getRelayoutHeight = function() {
	return this.getHeight();
}

UIScene.prototype.defaultPaintChildren = function(canvas) {
	var children = this.children;
	var n = this.children.length;

	for(var i = 0; i < n; i++) {
		var shape = children[i];
		shape.paintSelf(canvas);
	}

	return;
}

UIScene.prototype.setMap = function(map) {
	this.map = map;
	if(map) {
		var mapWidth = map.getMapWidth();
		var mapHeight = map.getMapHeight();
		
		if(mapWidth > this.w) {
			this.virtualWidth = mapWidth;
		}

		if(mapHeight > this.h) {
			this.virtualHeight = mapHeight;
		}

		this.setOffset(0, 0);
	}

	return this;
}

UIScene.prototype.getMap = function() {
	return this.map;
}

UIScene.prototype.drawBgImageTile = function(canvas, image, srcRect) {
    var imageWidth = srcRect.w;
    var imageHeight = srcRect.h;

    var dx = 0;
    var dy = 0;
    var dw = this.w;
    var dh = this.h;
    var maxDx = dw;
    var maxDy = dh;
    var adjustX = srcRect.x + this.xOffset % srcRect.w;
    var adjustY = srcRect.y + this.yOffset % srcRect.h;
    var sx = adjustX;
    var sy = adjustY;
    var sw = srcRect.x + srcRect.w - adjustX;
    var sh = srcRect.y + srcRect.h - adjustY;

    while(dy < maxDy) {
        sx = adjustX;
        sw = srcRect.w - adjustX;
        sh = Math.min(sh, Math.min(maxDy-dy, imageHeight));
        while(dx < maxDx) {
            sw = Math.min(sw, Math.min(maxDx-dx, imageWidth));
            canvas.drawImage(image, sx, sy, sw, sh, dx, dy, sw, sh);
            dx += sw;
            sx = srcRect.x;
            sw = srcRect.w;
        }

        dx = 0;
        dy += sh;
        sh = srcRect.h;
        sy = srcRect.y;
    }
}

UIScene.prototype.drawBgImage = function(canvas) {
	if(this.map) {
		var ox = this.xOffset;
		var oy = this.yOffset;

		var rect = {x:ox, y:oy, w:this.w, h:this.h};
		
		canvas.translate(-ox, -oy);
		this.map.draw(canvas, rect);
		canvas.translate(ox, oy);

		return;
	}

	var wImage = this.getBgImage();
	if(wImage && wImage.getImage()) {
		var image = wImage.getImage();
		var srcRect = wImage.getImageRect();
		var display = this.images.display;

		if(display === UIElement.IMAGE_DISPLAY_TILE_V) {
			this.drawBgImageVTile(canvas, image, srcRect);
		}
		else if(display === UIElement.IMAGE_DISPLAY_TILE_H) {
			this.drawBgImageHTile(canvas, image, srcRect);
		}
        else if(display === UIElement.IMAGE_DISPLAY_TILE) {
            this.drawBgImageTile(canvas, image, srcRect);
        }
		else {
			this.drawImageAt(canvas, image, display, 0, 0, this.w, this.h, srcRect);
		}

		return;
	}
}

UIScene.prototype.drawBgImageVTile = function(canvas, image, srcRect) {
	var w = this.w;
	var h = this.h;
	var iw = srcRect.w;
	var ih = srcRect.h;
	var scale = w/iw;

	var dy = 0;
	var sx =  srcRect.x;
	var sy = srcRect.y + this.yOffset%ih;
	var sh = Math.min(srcRect.y + ih-sy, h/scale);
	for(var dy = 0; dy < h; ) {
		var dh = sh * scale;
		canvas.drawImage(image, sx, sy, iw, sh, 0, dy, w, dh);

		dy += dh;
		sh = Math.min(ih, (h - dy)/scale);
		sy = srcRect.y;
	}
}

UIScene.prototype.drawBgImageHTile = function(canvas, image, srcRect) {
	var w = this.w;
	var h = this.h;
	var iw = srcRect.w;
	var ih = srcRect.h;
	var scale = h/ih;

	var dx = 0;
	var sy = srcRect.y;
	var sx = srcRect.x + this.xOffset%iw;
	var sw = Math.min(iw-sx, w/scale);

	for(var dx = 0; dx < w; ) {
		var dw = sw * scale;
		canvas.drawImage(image, sx, sy, sw, ih, dx, 0, dw, h);

		dx += dw;
		sw = Math.min(iw, (w - dx)/scale);
		sx = srcRect.x;
	}

	return;
}

UIScene.prototype.afterPaintChildren = function(canvas) {
	if(!this.isInDesignMode()) {
		this.drawTipsImage(canvas);
	}

	if(!this.selected || !this.isInDesignMode()) {
		return;
	}
	
	var y = 10;
	var w = this.w;
	var h = this.h;
	var text = "";
	var x = w >> 1;
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(this.xOffset) {
		text = "XOffset:" + this.xOffset;
	}

	if(this.yOffset) {
		text += " YOffset:" + this.yOffset;
	}

	if(text) {
		canvas.font = "16pt Sans";
		canvas.textBaseline = "top";
		canvas.textAlign = "center";
		canvas.fillStyle = "#202020";
		canvas.fillText(text, x, y);
	}

	if(!this.pointerDown) {
		return;
	}

	if(vw === w && vh === h) {
		return;
	}

	var size = 20;
	var alpha = canvas.globalAlpha;
	canvas.fillStyle = this.style.lineColor;

	if(vw > w) {
		var y = h - size;
		var bw = w * (w/vw);
		var x = w *(this.xOffset/vw);

		canvas.globalAlpha = 0.2;
		canvas.fillRect(0, y, w, size);
		canvas.globalAlpha = 0.5;
		canvas.fillRect(x, y, bw, size);
	}

	if(vh > h) {
		var x = w - size;
		var bh = h * (h/vh);
		var y = h *(this.yOffset/vh);

		canvas.globalAlpha = 0.2;
		canvas.fillRect(x, 0, size, h);
		canvas.globalAlpha = 0.5;
		canvas.fillRect(x, y, size, bh);
	}
	canvas.globalAlpha = alpha;

	return;
}

UIScene.prototype.paintFPS = function(canvas) {
	var seconds = Math.floor(Date.now()/1000);
	if(!this.lastSeconds) {
		this.fps = 0;
		this.drawCount = 0;
		this.lastSeconds = seconds;
	}
	
	this.drawCount++;
	if(seconds > this.lastSeconds) {
		this.fps = this.drawCount;

		this.drawCount = 0;
		this.lastSeconds = seconds;
	}
	
	var h = 30;
	var w = 60;
	var str = this.fps; 

	canvas.save();
	canvas.beginPath();
	canvas.rect(0, 0, w, h);
	canvas.fillStyle = "Black";
	canvas.fill();

	canvas.textAlign = "center";
	canvas.textBaseline = "middle";
	canvas.font = "20px Sans";
	canvas.fillStyle = "White";
	canvas.fillText(str, w >> 1, h >> 1);
	canvas.restore();
}

UIScene.prototype.paintSelf = function(canvas) {
	this.stepAnimation(canvas);
	UIWindow.prototype.paintSelf.call(this, canvas);

    if(this.world && this.debugBox2d) {
        this.world.DrawDebugData(); 
    }

	if(canvas.setShowFPS) {
		canvas.setShowFPS(this.showFPS);
	}else if(this.showFPS && !this.isInDesignMode()) {
		this.paintFPS(canvas);
	}

	return;
}

UIScene.prototype.paintChildren = function(canvas) {
	var ox = this.xOffset;
	var oy = this.yOffset;
	if(!ox && !oy) {
		this.defaultPaintChildren(canvas);
	}
	else {
		canvas.save();	
		canvas.translate(-ox, -oy);
		this.defaultPaintChildren(canvas);
		canvas.restore();
	}

	return;
}

/**
 * @method setTipsImage
 * 设置提示图片的编号。提示图片通常用于显示游戏玩法之类信息。
 * @param {Number} index index 提示图片的编号，通常是1到5，0表示不显示。
 * @param {Number} display 图片显示方式。
 * @return {UIElement} 返回控件本身。
 *
 */
UIScene.prototype.setTipsImage = function(index, display) {
	this.tipsImageIndex = index;
	this.tipsImageDisplay = display;

	return this;
}

UIScene.prototype.drawTipsImage = function(canvas) {
	if(!this.tipsImageIndex) {
		return;
	}

	var name = "tips_img_" + this.tipsImageIndex;
	var wImage = this.images[name];
	if(wImage) {
		var image = wImage.getImage();

		if(image) {
			var srcRect = wImage.getImageRect();
			var display = this.tipsImageDisplay;

			if(!display && display !== 0) {
				display = this.w < this.h ? UIElement.IMAGE_DISPLAY_FIT_WIDTH : UIElement.IMAGE_DISPLAY_FIT_HEIGHT;
			}
		
			this.drawImageAt(canvas, image, display, 0, 0, this.w, this.h, srcRect);
		}
	}

	return;
}

UIScene.prototype.stepAnimation = function(canvas) {
	var c = this.animatingInfo;
	if(!c) {
		return;	
	}

	var x = this.xOffset;
	var y = this.yOffset;
	var timePercent = Math.min((canvas.now - c.startTime)/c.duration, 1);
	var percent = c.interpolator.get(timePercent);

	console.log("stepAnimation:" + timePercent + " " + percent);
	if(c.xRange) {
		x = c.xStart + percent * c.xRange;
	}

	if(c.yRange) {
		y = c.yStart + percent * c.yRange;
	}

	if(timePercent >= 1) {
		this.animatingInfo = null;
	}

	this.setOffset(x, y);
	canvas.needRedraw++;
}

UIScene.prototype.onPointerMoveEditing = function(point, beforeChild) {
	if(!this.pointerDown || beforeChild || this.targetShape) {
		return;
	}

	return this.onPointerMoveCommon(point);
}

UIScene.prototype.onPointerMoveCommon = function(point) {
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(vw === this.w && vh === this.h) {
		return;
	}

	var dx = this.getMoveDeltaX();
	var dy = this.getMoveDeltaY();

	if(vw === this.w) {
		dx = 0;
	}

	if(vh === this.h) {
		dy = 0;
	}

	this.setOffsetDelta(-dx, -dy);

	return;
}

UIScene.prototype.fixChildSize = function(shape) {
	return;
}

UIScene.prototype.fixChildPosition = function(shape) {
	return;
}

UIScene.prototype.afterRelayoutChild = function(child) {
	var vw = this.getVirtualWidth();
	var vh = this.getVirtualHeight();

	if(child.widthAttr === UIElement.WIDTH_FILL_PARENT) {
		child.left = 0;
		child.w = vw;
	}
	else if(child.widthAttr === UIElement.WIDTH_FILL_AVAILABLE) {
		child.w = vw - child.left;
	}

	if(child.heightAttr === UIElement.HEIGHT_FILL_PARENT) {
		child.top = 0;
		child.h = vh;
	}
	else if(child.heightAttr === UIElement.HEIGHT_FILL_AVAILABLE) {
		child.h = vh - child.top;
	}

	return;
}

/**
 * @method getWorld
 * 获取Box2d的World对象。
 * @return {Object} 获取Box2d的World对象。
 *
 * 参考：http://www.box2dflash.org/docs/2.1a/reference/
 */
UIScene.prototype.getWorld = function() {
	return this.world;
}

UIScene.prototype.createBodyForElement = function(shape) {
	Physics.createBodyForElement(this.world, this, shape);
}

UIScene.prototype.afterChildAppended = function(shape) {
	if(this.isInDesignMode() || !this.world) {
		return;
	}

	if(this.world.IsLocked()) {
		console.log("world IsLocked, so create body async");
		setTimeout(this.createBodyForElement.bind(this, shape), 0);
	}
	else {
		this.createBodyForElement(shape);
	}
}

UIScene.prototype.afterChildRemoved = function(shape) {
	if(this.map === shape) {
		this.map = null;
	}

	if(this.isInDesignMode() || !this.world) {
		return;
	}

	Physics.destroyBodyForElement(this.world, shape);

	this.postRedraw();

	return;
}

UIScene.prototype.translatePoint = function(point) {
	var p = {x : (point.x - this.left + this.xOffset), y : (point.y - this.top + this.yOffset)};
	return p;
}

/**
 * @method isPlaying
 * 是否处于暂停状态。
 * @return {Boolean} 是否处于暂停状态。
 *
 */
UIScene.prototype.isPlaying = function() {
	return this.playing && !this.isInDesignMode();
}

/**
 * @method replay
 * 重置游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.replay = function() {
	this.openScene(this.name, this.initData);
	this.play();

	return this;
}

/**
 * @method pause
 * 暂停游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.pause = function() {
	this.playing = false;
	this.setTimeScale(0);

	return this;
}

/**
 * @method resume
 * 恢复游戏。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.resume = function() {
	this.playing = true;
	this.setTimeScale(1);

	return this;
}

UIScene.prototype.play = function() {
	this.playing = true;

	return;
}

UIScene.prototype.stop = function() {
	this.playing = false;

	return;
}

/**
 * @method toMeter
 * 把像素转化成米。
 * @param {Number} pixel
 * @return {Number} 米。
 *
 */
UIScene.prototype.toMeter = function(pixel) {
	var pixelsPerMeter = this.pixelsPerMeter ? this.pixelsPerMeter : 10;

	return pixel/pixelsPerMeter;
}

/**
 * @method toPixel
 * 把米转化成像素。
 * @param {Number} meter
 * @return {Number} 像素。
 *
 */
UIScene.prototype.toPixel = function(meter) {
	var pixelsPerMeter = this.pixelsPerMeter ? this.pixelsPerMeter : 10;

	return meter * pixelsPerMeter;
}

UIScene.prototype.getFPS = function() {
	return this.fps ? this.fps : 30;
}

UIScene.prototype.setFPS = function(fps) {
	this.fps = Math.max(5, Math.min(50, fps));

	return this;
}

UIScene.prototype.setVelocityIterations = function(velocityIterations) {
	this.velocityIterations = velocityIterations;

	return this;
}

UIScene.prototype.setPositionIterations = function(positionIterations) {
	this.positionIterations = positionIterations;

	return this;
}

/**
 * @method setAutoClearForce
 * 设置是否自动清除作用力。
 * @param {Boolean} autoClearForce 为真则每个时间片断自动清除作用力，否则力会持续作用。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.setAutoClearForce = function(autoClearForce) {
	this.autoClearForce = autoClearForce;

	return this;
}

/**
 * @method setCameraFollowParams 
 * 设置镜头自动跟随的参数。
 * @param {Number} xMin [0-1] 角色的x < this.w * xMin时向左移动。
 * @param {Number} xMax [0-1] 角色的x > this.w * xMax时向右移动。
 * @param {Number} yMin [0-1] 角色的y < this.h * yMin时向上移动。
 * @param {Number} yMax [0-1] 角色的y > this.h * yMax时向下移动。
 * @return {UIScene} 返回场景本身。
 *
 */
UIScene.prototype.setCameraFollowParams = function(xMin, xMax, yMin, yMax) {
	this.cameraFollowParams = {};
	this.cameraFollowParams.xMin = xMin;
	this.cameraFollowParams.xMax = xMax;
	this.cameraFollowParams.yMin = yMin;
	this.cameraFollowParams.yMax = yMax;

	return this;
}

UIScene.prototype.cameraFollow = function(element) {
	var w = this.w;
	var h = this.h;
	var x = element.left;
	var y = element.top;
	var dx = x - this.xOffset;
	var dy = y - this.yOffset;
	var params = this.cameraFollowParams;

	var xOffset = this.xOffset;
	if(dx > params.xMax * w) {
		xOffset = Math.round(x - params.xMax * w) + (element.w >> 1);
	}
	else if(dx < params.xMin * w){
		xOffset = Math.round(x - params.xMin * w) + (element.w >> 1);
	}

	var yOffset = this.yOffset;
	if(dy > params.yMax * h) {
		yOffset = Math.round(y - params.yMax * h) + (element.h >> 1);
	}
	else if(dy < params.yMin * h) {
		yOffset = Math.round(y - params.yMin * h) + (element.h >> 1);
	}

	this.setOffset(xOffset, yOffset);

	return;
}

UIScene.prototype.prepareForOpen = function() {
	if(this.world) {
		var world = this.world;
		Physics.destroyWorld(world);
		this.world = null;
	}

	UIWindow.prototype.prepareForOpen.call(this);
}

UIScene.prototype.isCurrent = function() {
	var wm = this.getParent();
	return wm && wm.getCurrentFrame() === this;
}

UIScene.prototype.onCreateRUBEBody = function(body) {
    if(body) {
        return Physics.createUIRubeBody(body, this.world, this);
    }
    return null;
}

UIScene.prototype.onRUBEJointCreated = function(joint) {
    if(joint) {
        return Physics.createElementForJoint(joint, this.world, this);
    }
    return null;
}

function UISceneCreator() {
	var args = ["ui-scene", "ui-scene", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIScene();
		return g.initUIScene(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISceneCreator());

/*
 * File:   ui-sound.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sound for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISoundMusic
 * @extends UICheckBox
 * 背景音乐开关。
 *
 * 可以在项目设置中添加背景音乐文件，添加的背景音乐文件是全局的，删除背景音乐控件并不会删除背景音乐文件。
 *
 * 可以通过任何一个控件调用playSoundMusic播放背景音乐。
 *
 */
function UISoundMusic() {
	return;
}

UISoundMusic.prototype = new UICheckBox();
UISoundMusic.prototype.isUISoundMusic = true;

UISoundMusic.prototype.initUISoundMusic = function(type) {
	this.initUICheckBox(type);	

	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UISoundMusic.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUISoundEffects || shape.isUISoundMusic) {
		return false;
	}

	return UIGroup.prototype.shapeCanBeChild.call(this, shape);
}


UISoundMusic.prototype.setValue = function(value) {
	if(this.isInDesignMode()) {
		return this;
	}

	this.setSoundMusicEnable(value);
	
	return this;
}

UISoundMusic.prototype.getValue = function(value) {
	if(this.isInDesignMode()) {
		return true;
	}

	return this.getSoundMusicEnable();
}

UISoundMusic.prototype.isPlaying = UISoundMusic.prototype.getValue;

function UISoundMusicCreator() {
	var args = ["ui-sound-music", "ui-sound-music", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISoundMusic();
		return g.initUISoundMusic(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISoundMusicCreator());

/*
 * File:   ui-sound.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sound for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UISoundEffects
 * @extends UICheckBox
 * 音效开关。
 *
 * 可以在项目设置中添加背景音效文件，添加的音效文件是全局的，删除音效控件并不会删除音效文件。
 *
 * 可以通过任何一个控件调用playSoundEffect播放音效。
 *
 */
function UISoundEffects() {
	return;
}

UISoundEffects.prototype = new UICheckBox();
UISoundEffects.prototype.isUISoundEffects = true;

UISoundEffects.prototype.initUISoundEffects = function(type) {
	this.initUICheckBox(type);	

	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UISoundEffects.prototype.shapeCanBeChild = function(shape) {
	if(shape.isUISoundEffects || shape.isUISoundMusic) {
		return false;
	}

	return UIGroup.prototype.shapeCanBeChild.call(this, shape);
}

UISoundEffects.prototype.setValue = function(value) {
	if(this.isInDesignMode()) {
		return this;
	}

	this.setSoundEffectEnable(value);

	return this;
}

UISoundEffects.prototype.getValue = function(value) {
	if(this.isInDesignMode()) {
		return true;
	}

	return this.getSoundEffectEnable(value);
}

UISoundEffects.prototype.isPlaying = UISoundEffects.prototype.getValue;

function UISoundEffectsCreator() {
	var args = ["ui-sound-effects", "ui-sound-effects", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISoundEffects();
		return g.initUISoundEffects(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISoundEffectsCreator());

/*
 * File:   ui-status.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Use color to present a value.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIStatus
 * @extends UIElement
 * 用来表示的事物状态，比如怪物的血量，角色的生命值。可以用setValue来改变当前的状态，value取值0-100。
 * 值为0触发onBecomeZero事件。
 * 值为100触发onBecomeFull事件。
 * 值有变化触发onChanged事件。
 *
 */

/**
 * @event onBecomeZero
 * value变为0时触发本事件。
 */

/**
 * @event onBecomeFull
 * value变为100时触发本事件。
 */

/**
 * @event onChanged
 * value变化时触发本事件。
 * @param {Number} value 当前的值。
 */

function UIStatus() {
	return;
}

UIStatus.prototype = new UIElement();
UIStatus.prototype.isUIStatus = true;

UIStatus.prototype.saveProps = ["horizonal", "realValue"];
UIStatus.prototype.initUIStatus = function(type, w, h) {
	this.initUIElement(type);	

	this.realValue = 0.5;
	this.roundRadius = 5;
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.addEventNames(["onBecomeZero", "onBecomeFull", "onChanged", "onUpdateTransform"]);

	return this;
}

UIStatus.prototype.shapeCanBeChild = function(shape) {
	return this.children.length===0 && shape.isUILabel;
}

UIStatus.prototype.setValue = function(value) {
	this.realValue = Math.max(0, Math.min(100, value))/100;

	if(this.realValue === 0) {
		this.callOnBecomeZeroHandler();
	}
	else if(this.realValue === 1) {
		this.callOnBecomeFullHandler();
	}

	this.callOnChangedHandler(this.getValue());

	return this.getValue();
}

UIStatus.prototype.getValue = function() {
	return Math.round(this.realValue * 100);
}

UIStatus.prototype.paintSelfOnly = function(canvas) {
	var value = this.realValue;
	var r = this.roundRadius;
	var bh = Math.round(value * this.h);
	var th = Math.round((1-value) * this.h);
	var lw = Math.round(value * this.w);
	var rw = Math.round((1-value) * this.w);

	canvas.save();
	canvas.beginPath();
	drawRoundRect(canvas, this.w, this.h, r);
	canvas.clip();

	if(!this.isFillColorTransparent()) {
		canvas.fillStyle = this.style.fillColor;
		canvas.beginPath();
		if(this.horizonal) {
			canvas.translate(lw, 0);
			canvas.rect(0, 0, rw, this.h);
			canvas.translate(-lw, 0);
		}
		else {
			canvas.rect(0, 0, this.w, th);
		}
		canvas.fill();
	}

	if(!this.isTextColorTransparent()) {
		canvas.fillStyle = this.style.textColor;
		canvas.beginPath();
		if(this.horizonal) {
			canvas.rect(0, 0, lw, this.h);
		}
		else {
			canvas.translate(0, th);
			canvas.rect(0, 0, this.w, bh);
			canvas.translate(0, -th);
		}
		canvas.fill();
	}
	canvas.restore();

	if(!this.isStrokeColorTransparent() && this.style.lineWidth) {
		canvas.beginPath();
		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		drawRoundRect(canvas, this.w, this.h, r, RoundRect.BL | RoundRect.BR | RoundRect.TL | RoundRect.TR);
		canvas.stroke();
	}
	canvas.beginPath();

	return;
}

function UIStatusCreator() {
	var args = ["ui-status", "ui-status", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIStatus();
		return g.initUIStatus(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIStatusCreator());

/*
 * File:   ui-timer.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic timer for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

/**
 * @class UITimer
 * @extends UIElement
 * 定时器。用于实现定时操作，可以通过setEnable启用或关闭定时器。定时器用来代替javascript原生的setInterval和setTimeout方法，它会在窗口退到后台自动暂停，取消预览时自动停止。可以使用setEnable来启用或禁用定时器。
 */

/**
 * @property {Number} times
 * 触发的次数，默认为100000000。
 */

/**
 * @property {String} durationType 
 * "random"使用随机时长，否则使用固定时长。
 */

/**
 * @property {Number} duration 
 * 使用固定时长的时长，默认为500，单位为毫秒。
 */

/**
 * @property {Number} durationMin
 * 使用随机时长的最小时长。
 */

/**
 * @property {Number} durationMax
 * 使用随机时长的最大时长。
 */
function UITimer() {
	return;
}

UITimer.prototype = new UIElement();
UITimer.prototype.isUITimer = true;
UITimer.prototype.saveProps = ["times", "delayStart", "durationType", "duration", "durationMin", "durationMax"];

UITimer.prototype.initUITimer = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_AUTO;
	this.addEventNames(["onTimeout"]);

	return this;
}

UITimer.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UITimer.prototype.onInit = function() {
	var me = this;
	var win = this.win;

	function startTimer() {
		me.start();
		win.off("open", startTimer);
	}

	if(this.enable) {
		win.on("open", startTimer);

		console.log("start timer.");
	}
	else {
		console.log("not start disable timer.");
	}

	return;
}

UITimer.prototype.setEnable = function(enable) {
	var parent = this.getParent();
	if(!parent || this.enable == enable) {
		return this;
	}
	
	this.enable = enable;
	if(enable) {
		this.start();
	}
	else {
		this.stop();
	}

	return;
}

UITimer.prototype.getDuration = function() {
	if(this.durationType === "random") {
		var duration = this.durationMin + Math.random() * (this.durationMax - this.durationMin);
		
		return duration;
	}
	else {
		return this.duration;
	}
}

UITimer.prototype.start = function() {
	if(!this.enable) {
		console.log("can not start disabled timer, please call setEnable first.");
	}

	if(this.timerID) {
		console.log("Timer is alread started:" + this.timerID);
		return;
	}

	var me = this;
	this.paused = false;
	this.startTime = Date.now();
	
	function onTimer() {
		if(!me.enable || !me.timerID || !me.parentShape || !me.win) {
			me.timerID = null;
			return;
		}

		if(me.paused) {
			me.timerID = setTimeout(onTimer, me.getDuration());
			return;
		}

		if(me.timeScaleIsZero()) {
			me.timerID = setTimeout(onTimer, me.getDuration());
			return;	
		}

		if(me.win.isVisible()) {
			me.callOnTimeoutHandler();
			me.times--;
		}

		if(me.times <= 0) {
			me.timerID = null;
			console.log("timer stop " + me.name);
		}
		else {
			me.timerID = setTimeout(onTimer, me.getDuration());
		}
	}

	if(this.delayStart) {
		this.timerID = setTimeout(function() {
			me.timerID = setTimeout(onTimer, me.getDuration());
		}, this.delayStart);
	}
	else {
		this.timerID = setTimeout(onTimer, me.getDuration());
	}

	return this;
}

UITimer.prototype.stop = function() {
	if(this.timerID) {
		clearTimeout(this.timerID);
		this.timerID = null;
	}

	return this;
}

/**
 * @method pause
 * 暂停。
 * @return {UIElement} 返回控件本身。
 *
 */
UITimer.prototype.pause = function() {
	this.paused = true;

	return this;
}

/**
 * @method resume 
 * 恢复。
 * @return {UIElement} 返回控件本身。
 *
 */
UITimer.prototype.resume = function() {
	this.paused = false;

	return this;
}

UITimer.prototype.getElapsedTime = function() {
	return Date.now() - this.startTime;
}

function UITimerCreator() {
	var args = ["ui-timer", "ui-timer", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITimer();
		return g.initUITimer(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITimerCreator());

/*
 * File:   ui-dragger.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  mouse joint, react with pointer event.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIDragger
 * @extends UIElement
 * Dragger。把它放到某个控件上，该控件便可被玩家拖动了。
 *
 */

/**
 * @event onDragStart
 * 拖动开始事件。
 */

/**
 * @event onDragEnd
 * 拖动结束事件。
 */

/**
 * @event onDragging
 * 拖动事件。
 */
function UIDragger() {
	return;
}

UIDragger.prototype = new UIElement();
UIDragger.prototype.isUIDragger = true;

UIDragger.prototype.saveProps = ["enableVer", "enableHor"];
UIDragger.prototype.initUIDragger = function(type, w, h) {
	this.initUIElement(type, w, h);	
	this.enableVer = true;
	this.enableHor = true;
	this.addEventNames(["onDragStart", "onDragging", "onDragEnd"]);

	return this;
}

UIDragger.prototype.onInit = function() {
	var parentShape = this.getParent();

	var enableHor = this.enableHor;
	var enableVer = this.enableVer;

	var dragger = this;
	if(parentShape.isUIPhysicsShape || parentShape.isUIImage || parentShape.isUISkeletonAnimation 
		|| parentShape.isUIFrameAnimation || parentShape.isUIScene) {
		parentShape.handlePointerDown = function(point, beforeChild) {
			if(!beforeChild) return;

			dragger.callOnDragStartHandler();
			return UIDragger.handleSpritePointerDown(parentShape, point);	
		}

		parentShape.handlePointerMove = function(point, beforeChild) {
			if(!beforeChild) return;

			if(parentShape.pointerDown) {
				dragger.callOnDraggingHandler();
			}
			return UIDragger.handleSpritePointerMove(parentShape, point, enableVer, enableHor);	
		}

		parentShape.handlePointerUp = function(point, beforeChild) {
			if(!beforeChild) return;

			dragger.callOnDragEndHandler();
			return UIDragger.handleSpritePointerUp(parentShape, point);	
		}
	}
}

UIDragger.handleSpritePointerDown = function(parentShape, point) {
	if(parentShape.isUIScene) {
		parentShape.saveXOffset = parentShape.xOffset;
		parentShape.saveYOffset = parentShape.yOffset;
	}
	else {
		parentShape.saveX  = parentShape.left;
		parentShape.saveY  = parentShape.top;
	}

	return;
}

UIDragger.handleSpritePointerUp = function(parentShape, point) {
}

UIDragger.handleSpritePointerMove = function(parentShape, point, enableVer, enableHor) {
	if(parentShape.pointerDown) {
		var dx = parentShape.getMoveAbsDeltaX();
		var dy = parentShape.getMoveAbsDeltaY();

		if(parentShape.isUIScene) {
			var x = enableHor ? parentShape.saveXOffset - dx : parentShape.saveXOffset;
			var y = enableVer ? parentShape.saveYOffset - dy : parentShape.saveYOffset;
			parentShape.setOffset(x, y);
		}
		else {
			var x = enableHor ? parentShape.saveX + dx : parentShape.saveX;
			var y = enableVer ? parentShape.saveY + dy : parentShape.saveY;
			parentShape.setLeftTop(x, y);
			parentShape.onPositionChanged();
		}
	}

	return;
}

function UIDraggerCreator() {
	var args = ["ui-dragger", "ui-dragger", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDragger();
		return g.initUIDragger(this.type, 20, 20, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDraggerCreator());

/*
 * File:   ui-sprite.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic sprite for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UISprite() {
	return;
}

UISprite.prototype = new UIImage();
UISprite.prototype.isUISprite = true;

UISprite.prototype.initUISprite = function(type, w, h, bg) {
	this.initUIImage(type, w ,h, bg);	

	return this;
}

function UISpriteCreator() {
	var args = ["ui-sprite", "ui-sprite", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISprite();
		return g.initUISprite(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISpriteCreator());

/*
 * File:   ui-transform-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Animation By Change Transform.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UITransformAnimation
 * @extends UIImage
 * 通过几何变换实现动画效果。它本身只是一张图片，可以放入其它动画在里面，实现更复杂的效果。
 *
 */
function UITransformAnimation() {
	return;
}

UITransformAnimation.prototype = new UIImage();
UITransformAnimation.prototype.isUITransformAnimation = true;

UITransformAnimation.prototype.initUITransformAnimation = function(type, w, h, bg) {
	this.initUIImage(type, w, h, bg);	

	this.animationConfig = {};
	this.animationConfig.opacityFrom = 1;
	this.animationConfig.opacityTo = 1;
	this.animationConfig.scaleXFrom = 1;
	this.animationConfig.scaleXTo = 1;
	this.animationConfig.scaleYFrom = 1;
	this.animationConfig.scaleYTo = 1;
	this.animationConfig.rotationFrom = 0;
	this.animationConfig.rotationTo = 0;
	this.animationConfig.offsetXFrom = 0;
	this.animationConfig.offsetXTo = 0;
	this.animationConfig.offsetYFrom = 0;
	this.animationConfig.offsetYTo = 0;
	this.animationConfig.frequency = 2;
	this.animationConfig.random = 1000 * Math.random();

	return this;
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.pause = function() {
	if(this.highlightConfig) {
		this.highlightConfig.paused = true;
	}

	return this;
}

/**
 * @method resume 
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.resume = function() {
	if(this.highlightConfig) {
		this.highlightConfig.paused = false;
	}

	return this;
}

/**
 * @method play
 * 播放动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.play = function() {
	this.setHighlightConfig(this.animationConfig);

	return this;
}

/**
 * @method stop
 * 停止动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UITransformAnimation.prototype.stop = function() {
	this.setHighlightConfig(null);

	return this;
}

UITransformAnimation.prototype.getScaleXFrom = function() {
	return this.animationConfig.scaleXFrom;
}

UITransformAnimation.prototype.setScaleXFrom = function(scaleXFrom) {
	this.animationConfig.scaleXFrom = scaleXFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleXTo = function() {
	return this.animationConfig.scaleXTo;
}

UITransformAnimation.prototype.setScaleXTo = function(scaleXTo) {
	this.animationConfig.scaleXTo = scaleXTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleYFrom = function() {
	return this.animationConfig.scaleYFrom;
}

UITransformAnimation.prototype.setScaleYFrom = function(scaleYFrom) {
	this.animationConfig.scaleYFrom = scaleYFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getScaleYTo = function() {
	return this.animationConfig.scaleYTo;
}

UITransformAnimation.prototype.setScaleYTo = function(scaleYTo) {
	this.animationConfig.scaleYTo = scaleYTo;
	this.play();

	return this;
}

UITransformAnimation.RADIAN_TO_ANGLE = 180/Math.PI;

UITransformAnimation.prototype.getRotationFrom = function() {
	return this.animationConfig.rotationFrom * UITransformAnimation.RADIAN_TO_ANGLE;
}

UITransformAnimation.prototype.setRotationFrom = function(rotationFrom) {
	this.animationConfig.rotationFrom = rotationFrom/UITransformAnimation.RADIAN_TO_ANGLE;
	this.play();

	return this;
}

UITransformAnimation.prototype.getRotationTo = function() {
	return this.animationConfig.rotationTo * UITransformAnimation.RADIAN_TO_ANGLE;
}

UITransformAnimation.prototype.setRotationTo = function(rotationTo) {
	this.animationConfig.rotationTo = rotationTo/UITransformAnimation.RADIAN_TO_ANGLE;
	this.play();

	return this;
}

UITransformAnimation.prototype.getOpacityFrom = function() {
	return this.animationConfig.opacityFrom;
}

UITransformAnimation.prototype.setOpacityFrom = function(opacityFrom) {
	this.animationConfig.opacityFrom = opacityFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getOpacityTo = function() {
	return this.animationConfig.opacityTo;
}

UITransformAnimation.prototype.setOpacityTo = function(opacityTo) {
	this.animationConfig.opacityTo = opacityTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getXFrom = function() {
	return this.animationConfig.offsetXFrom;
}

UITransformAnimation.prototype.setXFrom = function(offsetXFrom) {
	this.animationConfig.offsetXFrom = offsetXFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getXTo = function() {
	return this.animationConfig.offsetXTo;
}

UITransformAnimation.prototype.setXTo = function(offsetXTo) {
	this.animationConfig.offsetXTo = offsetXTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getYFrom = function() {
	return this.animationConfig.offsetYFrom;
}

UITransformAnimation.prototype.setYFrom = function(offsetYFrom) {
	this.animationConfig.offsetYFrom = offsetYFrom;
	this.play();

	return this;
}

UITransformAnimation.prototype.getYTo = function() {
	return this.animationConfig.offsetYTo;
}

UITransformAnimation.prototype.setYTo = function(offsetYTo) {
	this.animationConfig.offsetYTo = offsetYTo;
	this.play();

	return this;
}

UITransformAnimation.prototype.getFrequency = function() {
	return this.animationConfig.frequency;
}

UITransformAnimation.prototype.setFrequency = function(frequency) {
	this.animationConfig.frequency = frequency;
	this.play();

	return this;
}

UITransformAnimation.prototype.getRandom = function() {
	return this.animationConfig.random;
}

UITransformAnimation.prototype.setRandom = function(random) {
	this.animationConfig.random = random%1000;
	this.play();

	return this;
}

UITransformAnimation.prototype.doFromJson = function(js) {
	UISprite.prototype.doFromJson.call(this, js);

	if(js.animationConfig) {
		this.animationConfig = JSON.parse(JSON.stringify(js.animationConfig));
		this.play();
	}

	return;
}

UITransformAnimation.prototype.doToJson = function(o) {
	UISprite.prototype.doToJson.call(this, o);

	o.animationConfig = JSON.parse(JSON.stringify(this.animationConfig));

	return o;
}

UITransformAnimation.prototype.beforePaintChildren = function(canvas) {
//	this.applyTransform(canvas);

	return this;
}

UITransformAnimation.prototype.onInit = function() {
	this.play();

	return;
}

function UITransformAnimationCreator() {
	var args = ["ui-transform-animation", "ui-transform-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITransformAnimation();
		return g.initUITransformAnimation(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UITransformAnimationCreator());

/*
 * File:   ui-skeleton-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  SkelentonAnimation
 *
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 *
 */

/**
 * @class UISkeletonAnimation
 * @extends UIElement
 * 骨骼动画。目前支持[DragonBones](https://github.com/DragonBones)和[Spine](https://github.com/EsotericSoftware/spine-runtimes)两种格式。
 */
function UISkeletonAnimation() {
	return;
}

UISkeletonAnimation.prototype = new UIElement();
UISkeletonAnimation.prototype.isUISkeletonAnimation = true;

UISkeletonAnimation.prototype.saveProps = ["enableCache", "animationName", "skinName", "animationScaleX", "animationScaleY",
"textureJsonURL", "skeletonJsonURL", "textureURL"];

UISkeletonAnimation.prototype.urlProps = ["textureJsonURL", "skeletonJsonURL", "textureURL"];

UISkeletonAnimation.prototype.initUISkeletonAnimation = function(type, w, h) {
	this.initUIElement(type);

	this.setDefSize(w, h);
	this.setSizeLimit(50, 50);
	this.setTextType(Shape.TEXT_NONE);
	this.setCanRectSelectable(false, true);
	this.addEventNames(["onDoubleClick", "onUpdateTransform", "onLoadDone"]);

	this.animTimeScale = 1;
	this.animationScaleX = 1;
	this.animationScaleY = 1;
	this.animationNames = [];

	return this;
}

/**
 * @method play
 * 播放动画。
 * @param {String} name 动作名称。
 * @param {Number} repeatTimes 播放次数。
 * @param {Function} onDone (可选) 播放指定次数后的回调函数。
 * @param {Function} onOneCycle (可选) 每播放一次的回调函数。
 * @param {Number} useFadeIn (可选) 启用渐变。
 * @return {Object} 返回Promise
 *
 */
UISkeletonAnimation.prototype.play = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	var me = this;

    if(me.loadDataDone !== true) {
        this.initPlayArgs = [].slice.call(arguments);
        return;
    }

	var deferred = Deferred();
	this.resume();
	this.doPlay(animationName, repeatTimes, function() {
		if(typeof onDone === 'function') {
			onDone.call(me);
		}
		deferred.resolve();
	}, function() {
		if(typeof onOneCycle === 'function') {
			onOneCycle.call(me);
		}
	}, useFadeIn, duration);

	return deferred.promise;
};


/**
 * @method setSkeletonJsonURL
 * 设置骨骼动画的JSON URL。需要调用reload才能生效。
 * @param {String} skeletonJsonURL 骨骼动画的JSON URL。
 * @return {UIElement} 返回控件本身。
 */
UISkeletonAnimation.prototype.setSkeletonJsonURL = function(skeletonJsonURL) {
	this.skeletonJsonURL = skeletonJsonURL;

	return this;
}

/**
 * @method getSkeletonJsonURL
 * 获取骨骼动画的JSON URL。
 * @return {String} 返回骨骼动画的JSON URL。
 */
UISkeletonAnimation.prototype.getSkeletonJsonURL = function() {
	return this.skeletonJsonURL ? this.skeletonJsonURL : "";
}

/**
 * @method setTextureJsonURL
 * 设置骨骼动画的纹理集的JSON/ATLAS URL。需要调用reload才能生效。
 * @param {String} textureJsonURL 骨骼动画的纹理集的JSON/ATLAS URL。
 * @return {UIElement} 返回控件本身。
 */
UISkeletonAnimation.prototype.setTextureJsonURL = function(textureJsonURL) {
	this.textureJsonURL = textureJsonURL;

	return this;
}

/**
 * @method getTextureJsonURL
 * 获取骨骼动画的纹理集的JSON/ATLAS URL。
 * @return {String} 返回骨骼动画的纹理集的JSON/ATLAS URL。
 */
UISkeletonAnimation.prototype.getTextureJsonURL = function() {
	return this.textureJsonURL ? this.textureJsonURL : "";
}

/**
 * @method setTextureURL
 * 设置骨骼动画的纹理图片的URL。需要调用reload才能生效。
 * @param {String} textureURL 骨骼动画的纹理图片的URL。
 * @return {UIElement} 返回控件本身。
 */
UISkeletonAnimation.prototype.setTextureURL = function(textureURL) {
	this.textureURL = textureURL;

	return this;
}

/**
 * @method getTextureURL
 * 获取骨骼动画的纹理图片的URL。
 * @return {String} 返回骨骼动画的纹理图片的URL。
 */
UISkeletonAnimation.prototype.getTextureURL = function() {
	return this.textureURL ? this.textureURL : "";
}

UISkeletonAnimation.prototype.loadSheletonData = function(textureJsonURL, skeletonJsonURL, textureURL, onDone) {
	var me = this;
	ResLoader.loadImage(textureURL, function(texture) {
		var loadFunc = ResLoader.loadJson;
		if(textureJsonURL.indexOf(".atlas") > 0) {
			loadFunc = ResLoader.loadData;
		}

		loadFunc(textureJsonURL, function(data) {
			var textureData = data;
			if(!data) {
				console.log("Get Json Failed:" + textureJsonURL);
				return;
			}

			ResLoader.loadJson(skeletonJsonURL, function(data) {
				if(!data) {
					console.log("Get Json Failed:" + skeletonJsonURL);
					return;
				}

				var skeletonData = data;
				onDone(texture, textureData, skeletonData);
			});
		});
	});

	return;
}

UISkeletonAnimation.prototype.createSkelentonAnimation = function(onDone) {
	var me = this;
	this.destroyArmature();

	function onDataLoad(texture, textureData, skeletonData) {
		me.createArmature(texture, textureData, skeletonData);
		var animationName = me.getAnimationName();
		if(me.skinName) {
			me.setSkin(me.skinName);
		}
        me.loadDataDone = true;
        if(me.initPlayArgs) {
            me.play.apply(me, me.initPlayArgs);
            me.initPlayArgs = null;
        }
        else {
		    me.play(animationName);
        }
		me.callOnLoadDoneHandler();
		if(onDone) {
			onDone();
		}
	}

    me.loadDataDone = false;
	this.loadSheletonData(this.textureJsonURL, this.skeletonJsonURL, this.textureURL, onDataLoad);

	return;
}

UISkeletonAnimation.prototype.onFromJsonDone = function(js) {
	if(this.textureURL && this.textureJsonURL && this.skeletonJsonURL) {

		function onDataLoad(texture, textureData, skeletonData) {
			console.log("skeleton preload data done.");
		}

		this.loadSheletonData(this.textureJsonURL, this.skeletonJsonURL, this.textureURL, onDataLoad);
	}

	if(js && js.animationScale) {
		if(!js.animationScaleX) {
			this.animationScaleX = js.animationScale;
		}

		if(!js.animationScaleY) {
			this.animationScaleY = js.animationScale;
		}
		delete this.animationScale;
	}

	return;
}

UISkeletonAnimation.prototype.onInit = function() {
	this.reload();

	return;
}

/**
 * @method reload
 * 修改骨骼动画的URL后，需要调用本函数重新载入新的数据。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     var dragonbones = this.win.dragonbones;
 *     var assets = this.win.assets;
 *
 *     dragonbones.setSkeletonJsonURL(assets.getAssetURL("Robot.json"));
 *     dragonbones.setTextureJsonURL(assets.getAssetURL("texture.json"));
 *     dragonbones.setTextureURL(assets.getAssetURL("texture.png"));
 *     dragonbones.reload();
 */
UISkeletonAnimation.prototype.reload = function(onDone) {
	if(this.textureURL && this.textureJsonURL && this.skeletonJsonURL) {
		this.createSkelentonAnimation(onDone);
	}

	return this;
}

UISkeletonAnimation.prototype.destroy = function() {
	this.destroyArmature();
	Shape.prototype.destroy.call(this);

	return;
}

UISkeletonAnimation.prototype.callOnLoadDoneHandler = function() {
	if(this.isInDesignMode()) {
		return;
	}

	if(!this.handleOnLoadDone) {
		var sourceCode = this.events["onLoadDone"];
		if(sourceCode) {
			sourceCode = "this.handleOnLoadDone = function() {\n" + sourceCode + "\n}\n";
			try {
				eval(sourceCode);
			}catch(e) {
				console.log("eval sourceCode failed: " + e.message + "\n" + sourceCode);
			}
		}
	}

	if(this.handleOnLoadDone) {
		try {
			this.handleOnLoadDone();
		}catch(e) {
			console.log("this.handleOnLoadDone:" + e.message);
		}
	}

	return true;
}

UISkeletonAnimation.prototype.destroyArmature = function() {
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.pause = function() {
	return this;
}

/**
 * @method resume
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.resume = function() {
	return this;
}

/**
 * @method getAnimationDuration
 * 获取指定动作的时长。
 * @param {String} animaName 动作名称。
 * @return {UIElement} 返回指定动画的时长。
 *
 */
UISkeletonAnimation.prototype.getAnimationDuration = function(animaName) {
}

UISkeletonAnimation.prototype.getAnimationNames = function() {
	return this.animationNames;
}

UISkeletonAnimation.prototype.setAnimationName = function(animationName) {
	this.animationName = animationName;

	return this;
}

/**
 * @method getAnimationName
 * 获取当前播放动画得名称。
 * @return {String} 返回当前播放的动画名称
 *
 */
UISkeletonAnimation.prototype.getAnimationName = function() {
	if(this.animationName) return this.animationName;

	var animationNames = this.getAnimationNames();
	return animationNames ? animationNames[0] : "";
}

UISkeletonAnimation.prototype.setScale = function(animationScale) {
	this.animationScaleX = animationScale;
	this.animationScaleY = animationScale;
	return this;
}

UISkeletonAnimation.prototype.getScale = function() {
	return this.animationScaleX;
}

UISkeletonAnimation.prototype.setScaleX = function(animationScale) {
	this.animationScaleX = animationScale;
	return this;
}

UISkeletonAnimation.prototype.setScaleY = function(animationScale) {
	this.animationScaleY = animationScale;
	return this;
}

UISkeletonAnimation.prototype.getScaleX = function(animationScale) {
	return this.animationScaleX;
}

UISkeletonAnimation.prototype.getScaleY = function(animationScale) {
	return this.animationScaleY;
}

UISkeletonAnimation.prototype.applyScale = function(canvas) {
}

/**
 * @method setTimeScale
 * 设置时间缩放比例, 小于1变慢，大于1变快。
 * @param {Number} animTimeScale 时间缩放比例。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.setTimeScale = function(animTimeScale) {
	this.animTimeScale = animTimeScale;

	return this;
}

UISkeletonAnimation.prototype.setDuration = function(duration) {
//TODO
}

UISkeletonAnimation.prototype.preprocessTextureAtlas = function(skeletonData) {
	return skeletonData;
}

/**
 * @method setSkin
 * 设置当前皮肤的名称。
 * @param {String} skinName 皮肤的名称。
 * @return {UIElement} 返回控件本身。
 *
 */
UISkeletonAnimation.prototype.setSkin = function(skinName) {
	this.skinName = skinName;

	return this;
}

/**
 * @method getSkin
 * 获取当前皮肤的名称。
 * @return {String} 返回当前皮肤的名称。
 *
 */
UISkeletonAnimation.prototype.getSkin = function() {
	return this.skinName;
}

UISkeletonAnimation.prototype.getSkins = function() {
	return ["default"];
}

UISkeletonAnimation.prototype.isPaused = function() {
	return this.timeScaleIsZero();
}

UISkeletonAnimation.prototype.shapeCanBeChild = UISprite.prototype.shapeCanBeChild;


/*
 * File:   ui-bitmap-font-text.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  BitmapFontText
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

/**
 * @class UIBitmapFontText
 * @extends UIElement
 * 数字标签。把文字做成等大小的图片，然后合并到一张大图里，显示时根据文字内容取出子图组装起来。图片一般用透明背景的PNG格式。
 *
 * 注意：要求图片的高度和宽度能被行数和列数整除，否者在部分浏览器上显示不正常。
 *
 */
function UIBitmapFontText() {
	return;
}

UIBitmapFontText.prototype = new UIElement();
UIBitmapFontText.prototype.isUIBitmapFontText = true;

UIBitmapFontText.prototype.saveProps = ["allText", "textAlignment", "imageRows", "imageColumns"];
UIBitmapFontText.prototype.initUIBitmapFontText = function(type, w, h) {
	this.initUIElement(type);	

	this.text = "";
	this.textAlignment = "center";

	this.setMargin(5, 5);
	this.setDefSize(w, h);
	this.setSizeLimit(10, 10);
	this.setTextType(Shape.TEXT_NONE);
	this.addEventNames(["onUpdateTransform"]); 
	this.setImage(UIElement.IMAGE_NORMAL_FG, null);
	this.setImage("option_image_0", null);
	this.setImage("option_image_1", null);
	this.setImage("option_image_2", null);
	this.setImage("option_image_3", null);
	this.setImage("option_image_4", null);
	this.setImage("option_image_5", null);

	return this;
}

UIBitmapFontText.prototype.getDefaultImageType = function() {
	return UIElement.IMAGE_NORMAL_FG;
}

UIBitmapFontText.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIBitmapFontText.prototype.setImageWithRowCols = function(url, rows, columns) {
	this.imageRows = rows;
	this.imageColumns = columns;
	this.setImage(UIElement.IMAGE_NORMAL_FG, url);

	return;
}

UIBitmapFontText.prototype.getRectOfChar = function(image, imageRect, c) {
	if(this.allText) {
		var n = this.allText.length;
		var i = this.allText.indexOf(c);

		if(i >= 0) {
			var w = imageRect.trimmed ? imageRect.rw : imageRect.w;
			var h = imageRect.trimmed ? imageRect.rh : imageRect.h;
			var rows = this.imageRows ? this.imageRows : (h > w ? n : 1);
			var columns = this.imageColumns ? this.imageColumns : (w > h ? n : 1);
			var iw = Math.round(w/columns);
			var ih = Math.round(h/rows);
			var r = Math.floor(i/columns);
			var c = i%columns;

			var rect = {};
			rect.w = iw;
			rect.h = ih;
			rect.x = iw * c + imageRect.x;
			rect.y = ih * r + imageRect.y;

			if(i === 0) {
				rect.w = rect.w - (imageRect.ox || 0);
				rect.h = rect.h - (imageRect.oy || 0);
			}
			else {
				rect.x = rect.x - (imageRect.ox || 0);
				rect.y = rect.y - (imageRect.oy || 0);
			}

			return rect;
		}
	}

	return null;
}

UIBitmapFontText.prototype.setAllText = function(allText) {
	this.allText = allText;

	return this;
}

UIBitmapFontText.prototype.getAllText = function() {
	return this.allText;
}

UIBitmapFontText.prototype.getBgImage =function() {
	var image = null;
	
	if(this.pointerDown && !this.isClicked()) {
		image = this.images.active_bg;
	}
	else {
		image = this.images.normal_bg;
	}
	
	if(!image || !image.getImage()) {
		image = this.images.default_bg;
	}

	if(!image || !image.getImage()) {
		return;
	}

	return image;
}

UIBitmapFontText.prototype.drawFgImage = function(canvas) {
	var text = this.text;
	var wImage = this.getImageByType(UIElement.IMAGE_NORMAL_FG)

	if(!text || !wImage) {
		return;
	}

	var image = wImage.getImage();
	var imageRect = wImage.getImageRect();
	if(!image) {
		return;
	}

	var size = 0;
	var h = this.h;
	var maxItemHeight = 15;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var rect = this.getRectOfChar(image, imageRect, c);
		if(rect) {
			size += rect.w;
			if(rect.h > maxItemHeight) {
				maxItemHeight = rect.h;
			}
		}
	}

	var oy = 0;
	var ox = 0;
	var tx = 0;
	var hh = this.h >> 1;
	var scale = Math.min(this.h/maxItemHeight, this.w/size);

	switch(this.textAlignment) {
		case "right": {
			ox = this.w - this.hMargin - size;
			tx = ox + size;
			break;
		}
		case "center": {
			ox = (this.w - size) >> 1;
			tx = this.w >> 1;
			break;
		}
		default: {
			ox = this.hMargin;
			tx = ox;
			break;
		}
	}	
	
	if(scale != 1) {
		canvas.translate(tx, hh);
		canvas.scale(scale, scale);
		canvas.translate(-tx, -hh);
	}

	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var rect = this.getRectOfChar(image, imageRect, c);

		if(rect) {
			oy = (h - rect.h) >> 1;
			canvas.drawImage(image, rect.x, rect.y, rect.w, rect.h, ox, oy, rect.w, rect.h);
			ox += rect.w;
		}
	}

	return;
}

function UIBitmapFontTextCreator() {
	var args = ["ui-bitmap-font-text", "ui-bitmap-font-text", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBitmapFontText();
		return g.initUIBitmapFontText(this.type, 400, 100);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBitmapFontTextCreator());

/*
 * File:   ui-bitmap-font-text-x.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  BitmapFontTextX
 * 
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015  Holaverse Inc.
 * 
 */

/**
 * @class UIBitmapFontTextX
 * @extends UIElement
 * 图片文字。支持[bmfont](http://www.angelcode.com/products/bmfont/doc/file_format.html)和TexturePacker打包的Json Hash格式的图片集(不支持rotation和trim)。
 *
 * 参考：http://www.angelcode.com/products/bmfont/doc/file_format.html
 */
function UIBitmapFontTextX() {
	return;
}

UIBitmapFontTextX.prototype = new UIElement();
UIBitmapFontTextX.prototype.isUIBitmapFontTextX = true;

UIBitmapFontTextX.prototype.saveProps = ["spacer"];
UIBitmapFontTextX.prototype.initUIBitmapFontTextX = function(type) {
	this.spacer = 0;
	this.initUIElement(type);	
	this.textAlignment = "center";
	this.addEventNames(["onUpdateTransform"]); 

	return this;
}

UIBitmapFontTextX.prototype.getCharDesc = function(c) {
	if(this.bitmapFont) {
		return this.bitmapFont.getCharDesc(c);
	}
	else {
		if(!this.charsDesc) {
			this.charsDesc = {};
		}
		var charDesc = this.charsDesc[c];
		var image = this.getImageByType(c);

		if(!charDesc && image) {
			var r = image.getImageRect();
			if(r && r.w) {
				this.charsDesc[c] = {};
				charDesc = this.charsDesc[c];

				charDesc.x = r.x;
				charDesc.y = r.y;
				charDesc.w = r.w;
				charDesc.h = r.h;
				charDesc.image = image;
			}
		}

		return charDesc;
	}
}

UIBitmapFontTextX.prototype.parseFont = function(data, dataURL) {
	var path = dataURL.dirname();
	this.bitmapFont = new BitmapFont();
	this.bitmapFont.parse(data);
	
	var pages = this.bitmapFont.getPagesDesc();
	for(var key in pages) {
		var page = pages[key];
		var imageURL = path + "/" + page.file;
		this.setImage("page" + page.id, imageURL);
	}

	var chars = this.bitmapFont.getCharsDesc();
	for(var c in chars) {
		var charDesc = chars[c];
		charDesc.image = this.getImageByType("page"+charDesc.page);
	}

	return;
}

UIBitmapFontTextX.prototype.parseJson = function(data, dataURL) {
	var frames = data.frames;
	var imageURL = dataURL.dirname() + "/" + data.meta.image;

	for(var c in frames) {
		var name = c.replace(".png", "");
		if(name.length === 1) {
			this.setImage(name, dataURL + "#" + c);
		}
	}

	return;
}

UIBitmapFontTextX.prototype.setDataURL = function(dataURL) {
	this.images = {};
	this.images.display = 0;
	this.dataURL = dataURL;

	if(dataURL) {
		if(dataURL.endWith(".fnt")) {
			ResLoader.loadData(dataURL, function(data) {	
				this.parseFont(data, dataURL);
			}.bind(this));
		}
		else if(dataURL.endWith(".json")) {
			ResLoader.loadJson(dataURL, function(data) {	
				this.parseJson(data, dataURL);
			}.bind(this));
		}
		else {
			console.log("not supported:" + dataURL);
		}
	}

	return this;
}

UIBitmapFontTextX.prototype.setSpacer = function(spacer) {
	this.spacer = spacer;

	return this;
}

UIBitmapFontTextX.prototype.getDataURL = function() {
	return this.dataURL;
}

UIBitmapFontTextX.prototype.measureText = function() {
	var w = 0;
	var h = 10;
	var text = this.text;
	var spacer = this.spacer;

	for(var i = 0; i <text.length; i++) {
		var charDesc = this.getCharDesc(text[i]);
		if(charDesc) {
			var rw = charDesc.rw || charDesc.w;
			var rh = charDesc.rh || (charDesc.h + (charDesc.oy || 0));

			w += rw;
			if(h < rh) {
				h = rh;
			}

			if(i) {
				w += spacer;
			}
		}
	}

	return {w:w, h:h};
}

UIBitmapFontTextX.prototype.onFromJsonDone = function() {
	this.setDataURL(this.dataURL);
}

UIBitmapFontTextX.prototype.drawText = function(canvas) {
	var text = this.text;

	if(!text) { 
		return;
	}

	var oy = 0;
	var ox = 0;
	var tx = 0;
	var h = this.h;
	var w = this.w;
	var hh = h >> 1;
	var spacer = this.spacer;
	var hMargin = this.hMargin;
	var size = this.measureText();
	
	if(size.w < 1 || size.h < 1) {
		return;
	}

	var scale = Math.min(h/size.h, w/size.w);

	switch(this.textAlignment) {
		case "right": {
			ox = w - hMargin - size.w;
			tx = ox + size.w;
			break;
		}
		case "center": {
			ox = (w - size.w) >> 1;
			tx = w >> 1;
			break;
		}
		default: {
			ox = hMargin;
			tx = ox;
			break;
		}
	}	

	canvas.save();
	if(scale !== 1) {
		canvas.translate(tx, hh);
		canvas.scale(scale, scale);
		canvas.translate(-tx, -hh);
	}

	var x = 0;
	var y = 0;
	var baseY = (h - size.h) >> 1;
	for(var i = 0; i < text.length; i++) {
		var c = text[i];
		var charDesc = this.getCharDesc(c);
		if(charDesc && charDesc.image) {
			var rect = charDesc;
			var img = charDesc.image.getImage();

			if(img) {
				x = ox + (rect.ox || 0);
				y = baseY + (rect.oy || 0);

				canvas.drawImage(img, rect.x, rect.y, rect.w, rect.h, x, y, rect.w, rect.h);
				ox += (rect.rw || rect.w);
				ox += spacer;
			}
		}
	}
	canvas.restore();

	return;
}

function UIBitmapFontTextXCreator() {
	var args = ["ui-bitmap-font-text-x", "ui-bitmap-font-text-x", null, true];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBitmapFontTextX();
		return g.initUIBitmapFontTextX(this.type, 400, 100);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBitmapFontTextXCreator());

/*
 * File:   ui-frame-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Frame Animation.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIFrameAnimation
 * @extends UIImage
 * 帧动画。通过连续播放多张图片形成动画效果。可以对图片进行分组，播放时指定分组的名称。
 *
 */
function UIFrameAnimation() {
	return;
}

UIFrameAnimation.prototype = new UIElement();
UIFrameAnimation.prototype.isUIFrameAnimation = true;

UIFrameAnimation.prototype.saveProps = ["autoPlay", "frameRate", "autoPlayDelay", "defaultGroupName"];
UIFrameAnimation.prototype.initUIFrameAnimation = function(type, w, h) {
	this.initUIElement(type);	
	
	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.current = 0;
	this.frameRate = 10;
	this.playing = false;
	this.autoPlay = true;
	this.repeatTimes = 0xFFFFFFFF;
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	this.frames = [];
	this.addEventNames(["onDoubleClick", "onUpdateTransform"]);

	return this;
}

UIFrameAnimation.prototype.syncImageFrames = function() {
	this.frames = [];
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter) {
			this.frames.push(iter);
		}
	}

	return;
}

UIFrameAnimation.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	if(this.groups) {
		o.groups = JSON.parse(JSON.stringify(this.groups));
	}

	return o;
}

UIFrameAnimation.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);
	
	this.playing = false;
	this.syncImageFrames();

	if(js.groups) {
		this.groups = js.groups;
	}
	else if(js.groupsData) {
		this.groups = this.parseGroupsData(js.groupsData);
		this.groupsData = null;
	}

	return js;
}

UIFrameAnimation.prototype.afterChildAppended = function(shape) {
	shape.xAttr = UIElement.X_CENTER_IN_PARENT;
	shape.yAttr = UIElement.Y_MIDDLE_IN_PARENT;

	return;
}

UIFrameAnimation.prototype.setAutoPlay = function(autoPlay) {
	this.autoPlay = autoPlay;

	return this;
}

/**
 * @method resume 
 * 恢复动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.resume = function() {
	this.playing = true;

	return this;
}

/**
 * @method pause
 * 暂停动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.pause = function() {
	this.playing = false;

	return this;
}

/**
 * @method stop 
 * 停止动画。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.stop = function() {
	this.playing = false;

	return this;
}

UIFrameAnimation.prototype.playSequence = function(sequence, repeatTimes, onDone, onOneCycle) {
	this.deferred = Deferred();

	var n = this.frames.length;
	if(!n || !sequence || !sequence.length) {
		return;
	}

	this.current = 0;
	this.playing = true;
	this.onDone = onDone;
	this.onOneCycle = onOneCycle;
	this.runningSequence = sequence;
	this.nextUpdateTime = Date.now() + this.getDuration();
	this.repeatTimes = repeatTimes ? repeatTimes : 0xFFFFFFFF;

	return this.deferred.promise;
}

UIFrameAnimation.prototype.playRange = function(startFrame, endFrame, repeatTimes, onDone, onOneCycle) {
	var n = this.frames.length;
	if(startFrame > endFrame) {
		var t = startFrame;
		startFrame = endFrame;
		endFrame = t;
	}

	var sequence = [];
	for(var i = startFrame; i <= endFrame; i++) {
		sequence.push(i);
	}

	return this.playSequence(sequence, repeatTimes, onDone, onOneCycle);
}

/**
 * @method play
 * 播放动画。
 * @param {String} name 分组名称。
 * @param {Number} repeatTimes 播放次数。 
 * @param {Function} onDone (可选) 播放指定次数后的回调函数。
 * @param {Function} onOneCycle (可选) 每播放一次的回调函数。
 *
 */
UIFrameAnimation.prototype.gotoAndPlayByName = function(name, repeatTimes, onDone, onOneCycle) {
	var range = this.getGroupRange(name);

	if(range.start !== undefined && range.end !== undefined) { 
		return this.gotoAndPlay(range.start, range.end, repeatTimes, onDone, onOneCycle);
	}
	else if(range && range.length){
		return this.playSequence(range, repeatTimes, onDone, onOneCycle);
	}
	else if(this.animations && name) {
		return this.animate(name);
	}
}

UIFrameAnimation.prototype.play = UIFrameAnimation.prototype.gotoAndPlayByName;
UIFrameAnimation.prototype.gotoAndPlay = UIFrameAnimation.prototype.playRange;

UIFrameAnimation.prototype.nextFrame = function() {
	if(!this.frames || !this.frames.length || !this.runningSequence || !this.runningSequence.length) {
		return;
	}

	var current = this.current + 1;
	var n = this.runningSequence.length;

	if(current === n) {
		if(this.onOneCycle) {
			try {
				this.onOneCycle(this);
			} catch(e) {
				console.log("onOneCycle: " + e.message);
			}
		}

		this.repeatTimes--;
		if(this.repeatTimes <= 0) {
			this.playing = false;
			if(this.onDone) {
				try{
					this.onDone(this);
				}catch(e) {
					console.log("onDone: " + e.message);
				}
			}

			if(this.deferred) {
				this.deferred.resolve();
			}

			return;
		}
	}

	this.current = current % n;

	return;
}

UIFrameAnimation.prototype.getCurrentImage = function() {
	if(!this.frames || !this.frames.length) {
		return null;
	}

	if(!this.runningSequence || !this.runningSequence.length) {
		return this.frames[0];
	}

	if(this.current >= this.runningSequence.length) {
		this.current = 0;
	}

	var index =  this.runningSequence[this.current];

	return this.frames[index];
}

UIFrameAnimation.prototype.getGroupRange = function(name) {
	var range = null;

	if(this.groups && name) {
		range = this.groups[name];
	}
	
	if(!range) {
		range = {start:0, end:this.frames.length-1};
	}

	return range;
}

UIFrameAnimation.prototype.getImages = function() {
	var str = "";
	for(var key in this.images) {
		var iter = this.images[key];
		if(key.indexOf("option_image_") >= 0 && iter && iter.src) {
			str += iter.src.toRelativeURL() + "\n";
		}
	}

	return str;
}

UIFrameAnimation.prototype.setImages = function(value) {
	var display = this.images.display;
	this.images = {};
	this.images.display = display;

	if(value) {
		var i = 0;
		var k = 0;
		var arr = value.split("\n");

		for(var i = 0; i < arr.length; i++) {
			var iter = arr[i];
			if(!iter) continue;

			if(iter.indexOf("/") === 0) {
				iter = iter.substr(1);
			}

			var name = "option_image_" + (k++);
			this.setImage(name, iter);
		}
	}
	this.syncImageFrames();
	
	return this;
}

UIFrameAnimation.prototype.getValue = function() {
	return this.current;
}

UIFrameAnimation.prototype.setValue = function(value) {
	this.current = Math.min(value, this.frames.length);

	return this;
}

UIFrameAnimation.prototype.startAutoPlay = function() {
	if(this.defaultGroupName) {
		this.play(this.defaultGroupName, 0xFFFFFFF); 
	}
	else {
		this.gotoAndPlay(0, this.frames.length-1, 0xFFFFFFF);	
	}

	return;
}

UIFrameAnimation.prototype.onInit = function() {
	this.syncImageFrames();

	if(this.autoPlay && this.frames && this.frames.length) {
		this.startAutoPlay();
		if(this.autoPlayDelay) {
			this.nextUpdateTime += this.autoPlayDelay;
		}
	}

	return;
}

UIFrameAnimation.prototype.paintSelf = function(canvas) {
	
	if(this.playing && this.isVisible()) {
		var duration = this.getDuration();
		var nextUpdateTime = canvas.now + duration;

		if(canvas.now > this.nextUpdateTime) {
			this.nextFrame();
			this.nextUpdateTime = nextUpdateTime;
		}
		else {
			this.nextUpdateTime = Math.min(this.nextUpdateTime, nextUpdateTime);
		}

		canvas.needRedraw++;
	}
	
	return UIElement.prototype.paintSelf.call(this, canvas);
}

/**
 * @method getFrameRate 
 * 获取帧率。
 * @return {Number} 返回帧率。
 *
 */
UIFrameAnimation.prototype.getFrameRate = function() {
	return this.frameRate ? this.frameRate : 5;
}

/**
 * @method setFrameRate 
 * 设置帧率。
 * @param {Number} frameRate 帧率。
 * @return {UIElement} 返回控件本身。
 *
 */
UIFrameAnimation.prototype.setFrameRate = function(frameRate) {
	this.frameRate = Math.max(1, Math.min(frameRate, 30));

	return this;
}

UIFrameAnimation.prototype.getDuration = function() {
	if(this.isInDesignMode() && this.disablePreview) {
		return 0xffffff;
	}

	if(this.timeScaleIsZero()) {
		return 0xffffff;
	}
	else {
		return (1000/this.frameRate)/this.getTimeScale();
	}
}

UIFrameAnimation.prototype.shapeCanBeChild = UISprite.prototype.shapeCanBeChild;

UIFrameAnimation.prototype.drawImage = function(canvas) {
	var image = this.getCurrentImage();

	if(image) {
		var srcRect = image.getImageRect();
		var htmlImage = image.getImage();
		if(htmlImage) {
			this.drawImageAt(canvas, htmlImage, this.images.display, 0, 0, this.w, this.h, srcRect);
		}	
	}

	return;
}

function UIFrameAnimationCreator() {
	var args = [ "ui-frame-animation", "ui-frame-animation", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFrameAnimation();
		return g.initUIFrameAnimation(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIFrameAnimationCreator());

/*
 * File:   ui-shaker.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  shaker 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 Holaverse Inc.
 * 
 */

/**
 * @class UIShaker
 * @extends UIElement
 * 振动器。在启用时(setEnable(true))让所在的父控件(通常是场景)按指定参数振动，振动完成后自动进入禁用状态。
 *
 */
function UIShaker() {
	return;
}

UIShaker.prototype = new UIImage();
UIShaker.prototype.isUIShaker = true;

UIShaker.prototype.saveProps = ["amplitudeX", "amplitudeY", "times", "duration", "amplitudeModifier"];
UIShaker.prototype.initUIShaker = function(type, w, h) {
	this.initUIImage(type, w ,h);	

	return this;
}

/**
 * @method setAmplitudeX
 * 设置水平方向上的振幅。
 * @param {Number} value value为正向先向右动，为负向先向左动。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setAmplitudeX = function(value) {
	this.amplitudeX = value;

	return this;
}

/**
 * @method setAmplitudeY
 * 设置垂直方向上的振幅。
 * @param {Number} value 为正向先向下动，为负向先向上动。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setAmplitudeY = function(value) {
	this.amplitudeY = value;

	return this;
}

/**
 * @method setDuration
 * 设置振动持续的时间。
 * @param {Number} value 振动持续的时间。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setDuration = function(value) {
	this.duration = value;

	return this;
}

/**
 * @method setTimes
 * 设置振动的次数。
 * @param {Number} value 次数。
 * @return {UIElement} 返回控件本身。
 */
UIShaker.prototype.setTimes = function(value) {
	this.times = value;

	return this;
}

UIShaker.prototype.setAmplitudeModifier = function(value) {
	this.amplitudeModifier = value;

	return this;
}

UIShaker.prototype.getAmplitudeX = function() {
	return this.amplitudeX;
}

UIShaker.prototype.getAmplitudeY = function() {
	return this.amplitudeY;
}

UIShaker.prototype.getDuration = function() {
	return this.duration;
}

UIShaker.prototype.getTimes = function() {
	return this.times;
}

UIShaker.prototype.getAmplitudeModifier = function() {
	return this.amplitudeModifier;
}

UIShaker.prototype.setEnable = function(enable) {
	var parent = this.getParent();

	if(!parent || this.enable == enable) {
		return this;
	}

	if(!enable) {
		this.enable = enable;
		return this;
	}
	
	var me = this;
	var aX = this.amplitudeX ? this.amplitudeX : 0;
	var aY = this.amplitudeY ? this.amplitudeY : 0;
	var n = this.times ? this.times : 1;
	var duration = this.duration ? this.duration : 200;
	
	var startTime = Date.now();
	var oldPaintSelf = parent.paintSelf;
	var range = n * 2 * Math.PI;
	var am = this.amplitudeModifier;

	parent.paintSelf = function(canvas) {
		var dt = (Date.now() - startTime);

		if(dt < duration) {
			var factor = 1;
			var percent = dt/duration;
			var angle = range *  percent;
			var xo = aX * Math.cos(angle);
			var yo = aY * Math.sin(angle);

			if(am === "i") {
				factor = percent;
			}
			else if(am === "d") {
				factor = (1-percent);
			}
			else if(am === "i->d") {
				factor = 2 * (percent < 0.5 ? percent : (1-percent));
			}

			xo *= factor;
			yo *= factor;

			canvas.translate(xo, yo);
		}
		else {
			 parent.paintSelf = oldPaintSelf;
			 me.enable = false;
		}

		oldPaintSelf.call(parent, canvas);
	}
	
	return this;
}

function UIShakerCreator() {
	var args = ["ui-shaker", "ui-shaker", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIShaker();
		return g.initUIShaker(this.type, 80, 80);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIShakerCreator());

/*
 * File:   ui-settings.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  settings shape
 * 
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 * 
 */

/**
 * @class UISettings
 * @extends UIElement
 * 将游戏的设置独立出来，在IDE中提供一个可视化的界面，让游戏策划不需要程序配合，就可以修改这些数值来调节游戏的效果（使用时先用管理设置对话框中增加设置)。
 *
 *     @example small frame
 *     var settings = this.win.find("settings");
 *
 *     var speed = settings.getSetting("speed");
 *     console.log(speed);
 *
 */
function UISettings() {
	return;
}

UISettings.prototype = new UIElement();
UISettings.prototype.isUISettings = true;

UISettings.prototype.initUISettings = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.settingsDef = {};

	return this;
}

UISettings.prototype.getSettingObj = function(name) {
	var def = this.settingsDef[name];

	if(def && def.isGlobal) {
		return this.getWindowManager();
	}
	else {
		return this.getWindow();
	}
}

/**
 * @method getSetting
 * 获取name设置对应的值。
 * @param {String} name 
 * @return {Number} 返回对应的值。
 *
 */
UISettings.prototype.getSetting = function(name) {
	var obj = this.getSettingObj(name);

	var value = obj.settings[name];
	if(value === undefined) {
		var def = this.settingsDef[name];
		if(def) {
			value = def.defVal;
		}
	}

	return value;
}

/**
 * @method setSetting
 * 设置name设置对应的值。
 * @param {String} name 
 * @param {Number} value
 * @return {UIElement} 返回控件本身。
 *
 */
UISettings.prototype.setSetting = function(name, value) {
	var obj = this.getSettingObj(name);

	obj.settings[name] = value;

	return this;
}

UISettings.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.settingsDef = js.settingsDef;

	return this;
}

UISettings.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.settingsDef = this.settingsDef;

	return o;
}

function UISettingsCreator() {
	var args = ["ui-settings", "ui-settings", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISettings();
		return g.initUISettings(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UISettingsCreator());

/*
 * File:   ui-assets.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  assets manager
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIAssets
 * @extends UIElement
 * 资源管理控件，可以添加一组资源(如图片、JSON和其它数据)，导出时自动导出这些资源，运行时可以用loadImage/loadData/loadJSON来获取相应的资源。
 *
 * 资源管理控件主要用于管理普通控件没有引用到的资源，比如游戏需要的关卡数据，动态创建的控件需要的图片和JSON等等。
 *
 * 使用方法：
 *
 * 1.放入UIAssets控件。
 *
 * 2.双击UIAssets打开资源管理对话框。
 *
 * 3.点击“添加"按钮添加资源。
 *
 * 4.点击“确定"按钮保存配置。
 *
 * 5.在程序中使用请参考后面的示例。
 *
 */
function UIAssets() {
	return;
}

UIAssets.prototype = new UIElement();
UIAssets.prototype.isUIAssets = true;

UIAssets.prototype.initUIAssets = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.assets = {};

	return this;
}

UIAssets.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);
	
	this.assets = js.assets;

	return this;
}

UIAssets.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.assets = JSON.parse(JSON.stringify(this.assets || {}));

	return o;
}

/**
 * @method getAssetInfo
 * 获取指定名称的资源的相关信息。
 * @param {String} name 资源的名称。
 * @return {Object} 返回资源的信息。.name表示资源的名称, .url资源的URL,  .type资源的类型。
 *
 */
UIAssets.prototype.getAssetInfo = function(name) {
	var info = this.assets[name];

	if(!info) {
		console.log("not found asset:" + name);
	}

	return info;
}

/**
 * @method getAssetURL
 * 获取指定名称的资源的URL。
 * @param {String} name 资源的名称。
 * @return {Object} 返回资源的URL。
 *
 *     @example small frame
 *
 *     var win = this.win;
 *     var url = win.find("assets").getAssetURL("t.jpg");
 *     win.find("image").setValue(url);
 */
UIAssets.prototype.getAssetURL = function(name) {
	var info = this.getAssetInfo(name);

	return info ? info.url : null;
}

/**
 * @method loadJSON 
 * 加载指定名称的JSON数据。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(json) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *
 *     function onJsonLoad(json) {
 *          console.log("onJsonLoad:" + JSON.stringify(json, null, "\t"));
 *     }
 *     this.win.find("assets").loadJSON("test.json", onJsonLoad.bind(this));
 */
UIAssets.prototype.loadJSON = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "json") {
		console.log("asset is not json:" + name);
		return false;
	}

	return ResLoader.loadJson(info.url, onDone, onDone);
}

/**
 * @method loadImage
 * 加载指定名称的图片。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(img) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *
 *     function onImageLoad(img) {
 *          this.win.find("image").setValue(img);
 *     }
 *     this.win.find("assets").loadImage("t.jpg", onImageLoad.bind(this));
 */
UIAssets.prototype.loadImage = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "image") {
		console.log("asset is not image:" + name);
		return false;
	}

	return ResLoader.loadImage(info.url, onDone, onDone);
}

/**
 * @method loadData
 * 加载指定名称的文本数据。
 * @param {String} name 资源的名称。
 * @param {Function} onDone onDone(str) 加载完成时的回调函数。
 * @return {Boolean} false表示没有找到指定名称的资源，不会调用onDone函数。true表示开始加载，无论加载是否成功都会调用onDone函数。
 *
 *     @example small frame
 *     
 *     function onDataLoad(data) {
 *          console.log("onDataLoad:" + data);
 *     }
 *     this.win.find("assets").loadData("test.txt", onDataLoad.bind(this));
 */
UIAssets.prototype.loadData = function(name, onDone) {
	var info = this.getAssetInfo(name);
	if(!info) {
		return false;
	}

	if(info.type !== "data") {
		console.log("asset is not data:" + name);
		return false;
	}

	return ResLoader.loadData(info.url, onDone, onDone);
}

/**
 * @method loadAll
 * 加载全部资源。
 * @param {Function} onProgress(percent, finished, total) 加载进度的回调函数。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *
 *     this.win.assets.loadAll(function(percent, finished, total) {
 *         console.log("finished " + percent + "(" + finished + "/" + total + ")");
 *     })
 */
UIAssets.prototype.loadAll = function(onProgress) {
	var total = 0;
	var finished = 0;

	function onDone() {
		finished++;
		if(onProgress) {
			onProgress(100*(finished/total), finished, total);
		}
	}

	var assets = this.assets;
	for(var key in assets) {
		total++;
	}

	for(var key in assets) {
		var info = assets[key];
		if(info.type === "json") {
			ResLoader.loadJson(info.url, onDone);
		}else if(info.type === "data") {
			ResLoader.loadData(info.url, onDone);
		}else if(info.type === "image") {
			ResLoader.loadImage(info.url, onDone);
		}
	}

	return this;
}

function UIAssetsCreator() {
	var args = ["ui-assets", "ui-assets", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIAssets();
		return g.initUIAssets(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIAssetsCreator());

/*
 * File:   ui-tile.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  tile shape
 *
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 *
 */


/**
 * @class UITile
 * @extends UIElement
 * 是瓦片游戏地图控件，只需要放一个UITile到场景中，地图自动与场景关联。UITile支持由Map Editor Tiled制作的地图。场景中有多个地图时，可以通过UITile的setEnable函数，或用场景的setMap来设置场景当前的地图。
 *
 * 注意：
 *
 * 1.在新建地图时请选择CSV格式作为tile layer format，保存时使用JSON格式保存，图片与数据放在同一目录下。
 *
 * 2.JSON数据中的图片名不能带路径。
 *
 * 3.启用物理引擎的方法：在tiled中新建立一个图层，给图层加几个自定义的属性。physics为true表示启用物理引擎，friction表示刚体的摩擦力系数，restitution表示刚体的弹力系数。
 *
 * 参考：http://www.mapeditor.org
 *
 */
function UITile() {
	return;
}

UITile.prototype = new UIElement();
UITile.prototype.isUITile = true;

UITile.prototype.saveProps = ["dataURL"];
UITile.prototype.initUITile = function(type, w, h) {
	this.initUIElement(type);
	this.setSize(w, h);

	return this;
}

UITile.Layer = function() {
}

UITile.Layer.prototype.init = function(tile, info) {
	this.tile = tile;
	this.info = info;

	return this;
}

UITile.Layer.prototype.drawOrthogonal = function(canvas, rect) {
	var info = this.info;
	var ox = info.x || 0;
	var oy = info.y || 0;
	var data = info.data;
	var rows = info.height;
	var cols = info.width;
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;

	var w = tileW * cols;
	var top = Math.max(Math.floor(rect.y/tileH), 0);
	var left = Math.max(Math.floor(rect.x/tileW), 0);
	var right = Math.min(Math.ceil((rect.x + rect.w)/tileW), cols);
	var bottom = Math.min(Math.ceil((rect.y + rect.h)/tileH), rows);

	var x = left * tileW + ox;
	var y = top * tileH + oy;
	var rect = {x:x, y:y, w:tileW, h:tileH};

	ox = x;
	canvas.globalAlpha = info.opacity;
	for(var r = top; r <= bottom; r++) {
		for(var c = left; c <= right; c++) {
			var i = r * cols + c;
			var imgIndex = data[i]

			if(imgIndex) {
				rect.x = x;
				rect.y = y;
				tile.drawTile(canvas, rect, imgIndex);
			}

			x += tileW;
		}
		x = ox;
		y += tileH;
	}

	return;
}

UITile.Layer.prototype.drawIsometric = function(canvas, rect) {
	var top = rect.y;
	var left = rect.x;
	var right = left + rect.w;
	var bottom = top + rect.h;

	var i = 0;
	var info = this.info;
	var x = info.x || 0;
	var y = info.y || 0;
	var data = info.data;
	var rows = info.height;
	var cols = info.width;
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;

	canvas.globalAlpha = info.opacity;

	var originY = y;
	var originX = x + (this.info.width*tileW)/2 - tileW/2;
	var rect = {x:x, y:y, w:tileW, h:tileH};

	for(var r = 0; r < rows; r++) {
		for(var c = 0; c < cols; c++, i++) {
			var imgIndex = data[i]
			x = (c - r)*tileH + originX;
			y = (c + r)*tileW/4 + originY;
			if(!imgIndex || x > right || y > bottom || (x + tileW) < left || (y + tileH) < top) {
				continue;
			}
			rect.x = x;
			rect.y = y;
			tile.drawTile(canvas, rect, imgIndex);
		}
	}

	return;
}

UITile.Layer.prototype.drawHexagonal = function(canvas, rect) {
    var top = rect.y;
	var left = rect.x;
	var right = left + rect.w;
	var bottom = top + rect.h;

	var i = 0;
	var info = this.info;
	var x = info.x || 0;
	var y = info.y || 0;
	var data = info.data;
	var rows = info.height;
	var cols = info.width;
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;

	canvas.globalAlpha = info.opacity;

	var originY = y;
	var originX = x;
	var rect = {x:x, y:y, w:tileW, h:tileH};

	for(var r = 0; r < rows; r++) {
	    y = r*tileH/2 + originY;
		for(var c = 0; c < cols; c++, i++) {
			var imgIndex = data[i]
            if(!imgIndex) {
                continue;
            }
			x = c*tileW + originX;
            if(r%2 > 0) x += tileW/2;
			if(x > right || y > bottom || (x + tileW) < left || (y + tileH) < top) {
				continue;
			}
			rect.x = x;
			rect.y = y;
			tile.drawTile(canvas, rect, imgIndex);
		}
	}

	return;
}

UITile.Layer.prototype.draw = function(canvas, rect) {
	var info = this.info;

	if(!info.visible) return;

	switch(this.tile.orientation) {
		case 'orthogonal': {
			this.drawOrthogonal(canvas, rect);
			break;
		}
		case 'isometric': {
			this.drawIsometric(canvas, rect);
			break;
		}
        case 'staggered':
        case 'hexagonal': {
            this.drawHexagonal(canvas, rect);
            break;
        }
		default: {
			throw new Error('unknow orientation: ', this.tile.orientation);
		}
	}

	return;
}

UITile.Layer.prototype.getTileByPoint = function(x, y) {
	var tile = this.tile;
	var tileW = tile.tileWidth;
	var tileH = tile.tileHeight;
	var row = Math.floor(y/tileH);
	var col = Math.floor(x/tileW);
	var index = row * this.info.width + col;
	var imageIndex = this.info.data[index];

	return {row:row, col:col, index:index, imageIndex:imageIndex};
}

UITile.TileSet = function() {
}

UITile.TileSet.prototype.init = function(tile, rootURL, info) {
	this.tile = tile;
	this.info = info;
	this.imageURL = rootURL + "/" + info.image.basename();
	this.image = WImage.create(this.imageURL);
	this.tileWidth = info.tilewidth+info.spacing;
	this.tileHeight = info.tileheight+info.spacing;
	this.cols = Math.floor((info.imagewidth-2*info.margin)/this.tileWidth);
	this.rows = Math.floor((info.imageheight-2*info.margin)/this.tileHeight);
	this.tileNr = this.cols * this.rows;
	this.startIndex = info.firstgid;

	return this;
}

UITile.TileSet.prototype.testImageIndex = function(imageIndex) {
	return imageIndex >= this.startIndex && imageIndex < (this.startIndex + this.tileNr);
}

UITile.TileSet.prototype.drawTile = function(canvas, x, y, imageIndex) {
	var image = this.image.getImage();
	var index = imageIndex - this.startIndex;

	if(index < 0 || index >= this.tileNr || !image || !image.width) {
		return;
	}

	var info = this.info;
	var c = index%this.cols;
	var r = Math.floor(index/this.cols);
	var sx = c * this.tileWidth + info.margin;
	var sy = r * this.tileHeight + info.margin;
	var w = info.tilewidth;
	var h = info.tileheight;

	if(this.tileHeight !== this.tile.tileHeight) {
		y = y - (this.tileHeight - this.tile.tileHeight);
	}

	canvas.drawImage(image,sx, sy, w, h, x, y, w, h);

	return;
}

UITile.prototype.loadTileSets = function(url, tilesets) {
	this.tilesets = [];
	var n = tilesets.length;
	var rootURL = url.dirname();

	this.images = {};
	for(var i = 0; i < n; i++) {
		var tileSet = new UITile.TileSet();
		tileSet.init(this, rootURL, tilesets[i]);

		this.setImage("option_image_"+i, tileSet.imageURL);
		this.tilesets.push(tileSet);
	}

	return this;
}

UITile.prototype.loadLayers = function(layers) {
	this.layers = [];
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		this.layers.push((new UITile.Layer()).init(this, layers[i]));
	}

	return this;
}

/**
 * @method getMapWidth
 * 获取地图的宽度。
 * @return {Number} 返回地图的宽度。
 *
 */
UITile.prototype.getMapWidth = function() {
	return this.mapWidth;
}

/**
 * @method getMapHeight
 * 获取地图的高度。
 * @return {Number} 返回地图的高度。
 *
 */
UITile.prototype.getMapHeight = function() {
	return this.mapHeight;
}

/**
 * @method getLayerNr
 * 获取地图的层数。
 * @return {Number} 返回地图的层数。
 *
 */
UITile.prototype.getLayerNr = function() {
	return this.layers ? this.layers.length : 0;
}

/**
 * @method getLayerByIndex
 * 获取地图某层的数据。
 * @param {Number} index 层数索引。
 * @return {Object} 返回地图某层的数据。layer.info里是tiled生成的原始数据。
 *
 */
UITile.prototype.getLayerByIndex = function(index) {
	if(this.layers && index < this.layers.length) {
		return this.layers[index];
	}

	return null;
}

UITile.prototype.loadJSON = function(url, json) {
	if(this.isIcon) return;

	if(!json || !json.width || !json.height) {
		console.log("invalid tiled json");
		return;
	}

	this.tileRows = json.height;
	this.tileCols = json.width;
	this.tileWidth = json.tilewidth;
	this.tileHeight = json.tileheight;
	this.orientation = json.orientation;
	this.renderorder = json.renderorder;
	this.properties = json.properties;
	this.mapWidth = this.tileWidth * this.tileCols;
	this.mapHeight = this.tileHeight * this.tileRows;

	this.loadTileSets(url, json.tilesets);
	this.loadLayers(json.layers);

	if(this.enable) {
		var win = this.getWindow();
		if(win && win.isUIScene) {
			win.setMap(this);
		}
	}

	return;
}

UITile.prototype.loadURL = function(url) {
	var me = this;

    ResLoader.loadJson(url, function(json) {
	    me.loadJSON(url, json);
    });

	return;
}

UITile.prototype.load = function() {
	var dataURL = this.dataURL || this.tiledJsonURL;
	if(dataURL) {
		this.dataURL = dataURL;
		this.loadURL(dataURL);
	}

	return;
}

/**
 * @method setClipRegion
 * 只显示指定区域的地图。有的游戏中只显示玩家视力范围类的地图，这时可以用本函数实现。
 * @param {Array} rects
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     var tile = this.win.find("tile");
 *     tile.setClipRegion([{x:40, y:50, w:100, h:200},{x:200, y:200, w:100, h:200}]);
 */
UITile.prototype.setClipRegion = function(rects) {
	this.clipRegion = rects;

	return this;
}

UITile.prototype.isInClipRegion = function(r) {
	if(!this.clipRegion) return true;

	var rects = this.clipRegion;
	var n = rects.length;

	for(var i = 0; i < n; i++) {
		var rect = rects[i];
		if(Rect.hasIntersection(rect, r)) {
			return true;
		}
	}

	return false;
}

UITile.prototype.drawTile = function(canvas, rect, imageIndex) {
	if(!this.isInClipRegion(rect)) {
		return;
	}

	var n = this.tilesets.length;
	for(var i = 0; i < n; i++) {
		var iter = this.tilesets[i];
		if(iter.testImageIndex(imageIndex)) {
			iter.drawTile(canvas, rect.x, rect.y, imageIndex);
			break;
		}
	}

	return;
}

UITile.prototype.draw = function(canvas, rect) {
	if(!this.layers) {
		return;
	}

	var layers = this.layers;
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		layers[i].draw(canvas, rect);
	}

	return;
}

UITile.prototype.onAppendedInParent = function() {
	this.load();
}

UITile.prototype.createBody = function(world, name, x, y, w, h, prop) {
	var hw = w >> 1;
	var hh = h >> 1;
	var cx = x + hw;
	var cy = y + hh;
	var fixtureDef = new b2FixtureDef();
	fixtureDef.density = prop.density;
	fixtureDef.friction = prop.friction;
	fixtureDef.restitution = prop.restitution;

	if(prop.groupIndex) {
		fixtureDef.filter.groupIndex = prop.groupIndex;
	}

	if(prop.isSensor) {
		fixtureDef.isSensor = true;
	}

	fixtureDef.shape = new b2PolygonShape();
	fixtureDef.shape.SetAsBox(Physics.toMeter(hw), Physics.toMeter(hh));

	var bodyDef = new b2BodyDef();
	bodyDef.type = prop.density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
	bodyDef.position.Set(Physics.toMeter(cx), Physics.toMeter(cy));
	bodyDef.allowSleep = true;
	body = world.CreateBody(bodyDef);
	body.CreateFixture(fixtureDef);
	body.name = name;

	return;
}

UITile.prototype.createLayerBodies = function(world, layerIndex, info) {
	var data = info.data;
	var n = data.length;
	var prop = info.properties || {};
	var rows = info.height;
	var cols = info.width;
	var tileW = this.tileWidth;
	var tileH = this.tileHeight;
	var ox = info.x ? info.x : 0;
	var oy = info.y ? info.y : 0;

	prop.density = 0;
	prop.restitution = prop.restitution ? parseFloat(prop.restitution) : 0.5;
	prop.friction    = prop.friction ? parseFloat(prop.friction) : 0.5;

	for(var i = 0; i < n; i++) {
		var imageIndex = data[i];
		if(!imageIndex) continue;
		var r = Math.floor(i/cols);
		var c = i%cols;
		var x = ox + c * tileW;
		var y = oy + r * tileH;
		this.createBody(world, layerIndex+"-"+i, x, y, tileW, tileH, prop);
	}

	return;
}

UITile.prototype.createBodies = function(world) {
	var layers = this.layers;
	var n = layers.length;

	for(var i = 0; i < n; i++) {
		var layer = layers[i];
		var prop = layer.info.properties;
		if(prop && prop.physics) {
			this.createLayerBodies(world, i, layer.info);
		}
	}

	return;
}

UITile.prototype.onFromJsonDone = function(js) {
	this.load();
}

UITile.prototype.setTiledJsonURL = function(url) {
	this.dataURL = url;
	this.load();
}

UITile.prototype.getTiledJsonURL = function() {
	return this.dataURL || this.tiledJsonURL;
}

UITile.prototype.setEnable = function(enable) {
	var parent = this.getParent();

	if(!parent || this.enable == enable) {
		return this;
	}

	var win = this.getWindow();
	if(win && win.isUIScene) {
		if(enable) {
			win.setMap(this);
		}
		else {
			if(win.getMap() === this) {
				win.setMap(null);
			}
		}
	}
	this.enable = enable;

	return;
}

function UITileCreator() {
	var args = ["ui-tile", "ui-tile", null, 1];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITile();
		return g.initUITile(this.type, 200, 200);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UITileCreator());

/*
 * File:   ui-gsensor.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  gsensor event 
 * 
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIGSensor
 * @extends UIElement
 * 用于监听设备方向变化。
 *
 * 调用setEnable启用/关闭onDeviceOrientation事件。
 *
 */

/**
 * @event onDeviceOrientation
 * 重力感应事件。
 * @param {Number} x X方向重力。
 * @param {Number} y Y方向重力。
 * @param {Number} z Z方向重力。
 * @param {Object} event 原始事件。 
 */
function UIGSensor() {
	return;
}

UIGSensor.prototype = new UIElement();
UIGSensor.prototype.isUIGSensor = true;

UIGSensor.prototype.initUIGSensor = function(type, w, h) {
	this.initUIElement(type);	
	this.setSize(w, h);
	this.addEventNames(["onDeviceOrientation"]);

	return this;
}

UIGSensor.prototype.onInit = function() {
	if(this.enable) {
		this.setEnable(true);
	}
}

UIGSensor.prototype.setEnable = function(enable) {
	var me = this;
	if(this.isInDesignMode()) return this;

	function onDeviceOrientation(e) {
		var current = e.accelerationIncludingGravity;
		if(!current) {
			console.log("accelerationIncludingGravity not available.");
			return;
		}
		
		var x = current.x || 0;
		var y = current.y || 0;
		var z = current.z || -9.8;

		if(isAndroid()) {
			x = -x;
		}
		else if(isIPhone()) {
			y = -y;
		}

		me.callOnDeviceOrientation(x, y, z, e);

		return;
	}

	this.enable = enable;
	if(enable) {
		window.removeEventListener('devicemotion', onDeviceOrientation, false);		   
		window.addEventListener('devicemotion', onDeviceOrientation, false);	
	}
	else {
		window.removeEventListener('devicemotion', onDeviceOrientation, false);		   
	}

	return this;
}

function UIGSensorCreator() {
	var args = ["ui-gsensor", "ui-gsensor", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIGSensor();
		return g.initUIGSensor(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIGSensorCreator());

function UIMarquee() {
	return;
}

UIMarquee.prototype = new UILabel();
UIMarquee.isUIMarquee = true;

UIMarquee.prototype.saveProps = ["direction", "behavior", "scrollamount", "scrolldelay", "loop", "autoPlay"];
//direction
UIMarquee.DIR_UP   = 'up';
UIMarquee.DIR_DOWN = 'down';
UIMarquee.DIR_LEFT = 'left';
UIMarquee.DIR_RIGHT= 'right';

//behavior
UIMarquee.BEHAVIOR_SCROLL = 'scroll';
UIMarquee.BEHAVIOR_SLIDE  = 'slide';
UIMarquee.BEHAVIOR_ALTERNATE = 'alternate';

//loop
UIMarquee.LOOP_INFINITE = 'infinite';

//scrollamount
UIMarquee.DEFAULT_SCROLL_AMOUNT = 1;//px

//scrolldelay
UIMarquee.DEFAULT_SCROLL_DELAY  = 20;//ms

UIMarquee.prototype.initUIMarquee = function(type, initText, bg) {
	this.initUIElement(type);	

	this.setText(initText);
	this.setDefSize(200, 200);
	this.setMargin(5, 5);
	this.running = false;
	this.scrollCounter = 0;
	this.timeScale = 1;
	this.autoPlay = false;
	this.setTextType(Shape.TEXT_TEXTAREA);
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.addEventNames(["onChanged", "onUpdateTransform", "onPlayStepDone", "onPlayDone"]);

	return this;
}

var configLeftResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis = scrollDis%(w+textLen);
		if(scrollDis <= textLen) {
			canvas.rect(w - textLen, 0, textLen, h);	
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= w) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(w - scrollDis, 0);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {	
		if(this.done) return;
		scrollDis%=w;
		if(scrollDis <= textLen) {
			canvas.rect(w-textLen, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(w - scrollDis, 0);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(w-textLen, 0);
			return;
		}
		var odd = parseInt(scrollDis/(w-textLen), 10)%2 > 0;
		var dis = parseInt(scrollDis%(w-textLen), 10);
			dis = odd ? w-textLen-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(!odd && this.needStep){
			this.callOnStep();
		}

		canvas.translate(w - textLen - dis, 0);
	}
};

var configUpResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis = scrollDis%(h+textHeight);
		if(scrollDis <= textHeight) {
			canvas.rect(0, h - textHeight, w, textHeight);	
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= h) {
			canvas.rect(0, 0, w, h);
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(0, h - scrollDis);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		scrollDis%=h;
		if(scrollDis <= textHeight) {
			canvas.rect(0, h-textHeight, w, textHeight);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(0, h - scrollDis);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(0, h - textHeight);
			return;
		}
		var odd = parseInt(scrollDis/(h-textHeight), 10)%2 > 0;
		var dis = parseInt(scrollDis%(h-textHeight), 10);
			dis = odd ? h-textHeight-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(!odd && this.needStep) {
			this.callOnStep();
		}

		canvas.translate(0, h - textHeight - dis);
	}
};

var configRightResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);
			canvas.clip();
			return;
		}
		scrollDis%=(w+textLen);
		if(scrollDis >= w) {
			this.needStep = true;
			canvas.rect(w-textLen, 0, textLen, h);
			canvas.clip();
		}
		else if(scrollDis <= textLen) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		canvas.translate(scrollDis - textLen, 0);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(w - textLen, 0);	
			return;
		}
		scrollDis%=w;
		if(scrollDis <= textLen) {
			canvas.rect(0, 0, textLen, h);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(scrollDis - textLen, 0);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		var odd = parseInt(scrollDis/(w-textLen), 10)%2 > 0;
		var dis = parseInt(scrollDis%(w-textLen), 10);
			dis = odd ? w-textLen-dis : dis;

		if(odd) {
			this.needStep = true;
		}
		if(!odd && this.needStep) {
			this.callOnStep();
		}

		canvas.translate(dis, 0);
	}
};

var configDownResolve = {
	onScroll: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.rect(0, 0, 0, 0);	
			canvas.clip();
			return;
		}
		scrollDis%=(h+textHeight);
		if(scrollDis <= textHeight) {
			canvas.rect(0, 0, w, textHeight + scrollDis);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
			if(this.done) {
				this.backText = this.text;
				this.text = "";
			}
		}
		else if(scrollDis >= h) {
			canvas.rect(0, h - textHeight, w, textHeight);	
			canvas.clip();
			this.needStep = true;
		}
		canvas.translate(0, scrollDis - textHeight);
	},
	onSlide: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			canvas.translate(0, h - textHeight);	
			return;
		}
		scrollDis%=h;
		if(scrollDis <= textHeight) {
			canvas.rect(0, 0, w, textHeight);
			canvas.clip();
			if(this.needStep) {
				this.callOnStep();
			}
		}
		else {
			this.needStep = true;
		}
		canvas.translate(0, scrollDis - textHeight);
	},
	onAlternate: function(canvas, scrollDis, textLen, textHeight, w, h) {
		if(this.done) {
			return;
		}
		var odd = parseInt(scrollDis/(h-textHeight), 10)%2 > 0;
		var dis = parseInt(scrollDis%(h-textHeight), 10);
			dis = odd ? h-textHeight-dis : dis;
		if(odd) {
			this.needStep = true;
		}
		else if(this.needStep && !odd) {
			this.callOnStep();
		}
		canvas.translate(0, dis);
	}
};


UIMarquee.makeResolve = function(hAlign, vAlign, handlers) {
	return function(canvas) {
		var w = this.getWidth(true),
			h = this.getHeight(true),
			timeStep = canvas.timeStep;

		var scrollDis = parseInt(this.scrollCounter*this.scrollamount/this.scrolldelay, 10);

		canvas.font = this.style.getFont();
		var text = this.getLocaleText(this.text);
		var textLen = canvas.measureText(text).width;
		var textHeight = parseInt(canvas.font);

		this.hTextAlign = hAlign;
		this.vTextAlign = vAlign;

		var args = [canvas, scrollDis, textLen, textHeight, w, h];
		switch(this.behavior) {
			case UIMarquee.BEHAVIOR_SCROLL: {
				handlers.onScroll.apply(this, args);
				break;
			}
			case UIMarquee.BEHAVIOR_SLIDE: {
				handlers.onSlide.apply(this, args);
				break;
			}
			case UIMarquee.BEHAVIOR_ALTERNATE: {
				handlers.onAlternate.apply(this, args);
				break;
			}
			default: {
				throw new Error('unknow behavior');
			}
		}
	};
}

UIMarquee.prototype.leftResolve = UIMarquee.makeResolve('left', 'middle', configLeftResolve); 
UIMarquee.prototype.rightResolve = UIMarquee.makeResolve('left', 'middle', configRightResolve); 
UIMarquee.prototype.upResolve = UIMarquee.makeResolve('center', 'up', configUpResolve); 
UIMarquee.prototype.downResolve = UIMarquee.makeResolve('center', 'up', configDownResolve); 

UIMarquee.prototype.update = function(canvas) {
	var timeStep = canvas.timeStep;

	if(timeStep < this.scrolldelay) timeStep = this.scrolldelay;

	this.scrollCounter += (this.timeScale*timeStep);

	switch(this.direction) {
		case UIMarquee.DIR_RIGHT: {
			this.rightResolve(canvas);
			break;
		}
		case UIMarquee.DIR_LEFT: {
			this.leftResolve(canvas);
			break;
		}
		case UIMarquee.DIR_UP: {
			this.upResolve(canvas);
			break;
		}
		case UIMarquee.DIR_DOWN: {
			this.downResolve(canvas);
			break;
		}
		default: {
			throw new Error("unknow UIMarquee.direction:" + this.direction);
		}
	}
}

UIMarquee.prototype.onInit = function() {
	if(this.autoPlay) {
		this.play();
	}

	return;
}

UIMarquee.prototype.drawText = function(canvas) {
	this.layoutText(canvas);
	if((this.running || this.done) && !this.isInDesignMode()) {
		this.update(canvas);
		this.defaultDrawText(canvas);
	}

	if(this.isInDesignMode()) {
		this.defaultDrawText(canvas);
	}

	return;
}

UIMarquee.prototype.initOpts = function(config, onDone, onStep) {
	if(typeof config === 'function') {
		onStep = onDone;
		onDone = config;
		config = {};
	}

	this.onStep = onStep || config.onStep;
	this.onDone = onDone || config.onDone;
	this.direction = config.direction || this.direction || UIMarquee.DIR_RIGHT;
	this.behavior = config.behavior || this.behavior || UIMarquee.BEHAVIOR_SCROLL;
	this.loop = config.loop > 0 ? config.loop : (this.loop ? this.loop : UIMarquee.LOOP_INFINITE);
	this.backloop = this.loop;
	this.scrolldelay = config.scrolldelay || this.scrolldelay || UIMarquee.DEFAULT_SCROLL_DELAY;
	this.scrollamount = config.scrollamount || this.scrollamount || UIMarquee.DEFAULT_SCROLL_AMOUNT;

	return this;
}

UIMarquee.prototype.play = function(config, onStep, onDone) {
	config = config || {};
	this.initOpts(config, onStep, onDone);
	this.reset();
	this.started = true;
	this.running = true;
	this.done = false;
	this.text = this.backText ? this.backText : this.text;

	return this;
}

UIMarquee.prototype.reset = function() {
	this.timeScale = 1;
	this.scrollCounter = 0;
	this.needStep = false;
	this.loop = this.backloop;
}

UIMarquee.prototype.restart = function() {
	if(!this.started) return;
	this.running = true;
	this.done = false;
	this.text = this.backText ? this.backText : this.text;
	this.reset();
	return this;
}

UIMarquee.prototype.stop = function() {
	this.reset();
	this.running = false;
	return this;
}

UIMarquee.prototype.pause = function() {
	if(!this.running) return;

	this.timeScale = 0;
	return this;
}

UIMarquee.prototype.resume = function() {
	if(!this.running) return;

	this.timeScale = 1;
	return this;
}

UIMarquee.prototype.callOnStep = function() {
	this.needStep = false;
	if(this.loop !== UIMarquee.LOOP_INFINITE) {
		--this.loop;
		if(this.loop === 0) {
			this.callOnDone();
			return;
		}
	}

	if(typeof this.onStep === 'function') {
		if(!this.onStep()) {
			this.callOnDone();
			return;
		}
	}

	return this;
}

UIMarquee.prototype.callOnDone = function() {
	if(typeof this.onDone === 'function') {
		this.onDone();
	}

	this.done = true;
	this.stop();

	return this;
}

function UIMarqueeCreator() {
	var args = ["ui-marquee", "ui-marquee", null, 1];	

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMarquee();
		return g.initUIMarquee(this.type, dappGetText("Text"), null);
	}
}

ShapeFactoryGet().addShapeCreator(new UIMarqueeCreator());
UIElement.prototype.getScence= function() {
	return this.getWindow();
}

UIElement.prototype.getFootprints = function(name) {
	var x = 0;
	var y = 0;
	var footPrints = [];
	var arr = this.isUIWindow ? this : this.getParent().children;

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		if(!iter.isUIFootprint) {
			continue;
		}

		if(name && name != iter.name) {
			continue;
		}

		x = iter.left + (iter.w >> 1);
		y = iter.top + (iter.h >> 1);

		footPrints.push({x:x, y:y});
	}

	return footPrints;
}

UIElement.prototype.moveAlongPath = function(name, duration, enableRotation, onDone) {
	var footPrints = this.getFootprints(name);

	return this.moveAlongPoints(footPrints, duration, enableRotation, onDone);
}

UIElement.prototype.moveAlongPoints = function(points, duration, enableRotation, onDone) {
	var d = 0;
	var dx = 0;
	var dy = 0;
	var moveInfo = {};
	var distances = [];
	var totalDistance = 0;

	if(!points.length) {
		console.log("no footprint found.");
	}

	for(var i = 0; i < points.length; i++) {
		var iter = points[i];
		if(i) {
			dx = points[i].x - points[i-1].x;
			dy = points[i].y - points[i-1].y;

			d = Math.sqrt(dx*dx+dy*dy);
			distances.push(d);
			totalDistance += d;
		}
	}

	moveInfo.onDone = onDone;
	moveInfo.duration = duration;
	moveInfo.distances = distances;
	moveInfo.points = points;
	moveInfo.totalDistance = totalDistance;
	moveInfo.enableRotation = enableRotation;

	this.startMove(moveInfo);

	return;
}

UIElement.prototype.startMove = function(moveInfo) {
	var x = 0;
	var y = 0;
	var index = 0;
	var me = this;
	var hw = this.w >> 1;
	var hh = this.h >> 1;

	var duration = moveInfo.duration;
	var distances = moveInfo.distances;
	var points = moveInfo.points;
	var totalDistance = moveInfo.totalDistance;
	var enableRotation = moveInfo.enableRotation;

	function moveToNext() {
		if((index+1) >= points.length) {
			if(moveInfo.onDone) {
				moveInfo.onDone();
			}

			return;
		}

		var start = Date.now();
		var endPoint = points[index+1];
		var startPoint = points[index];
		var dt = duration * (distances[index]/totalDistance);
		var dx = endPoint.x - startPoint.x;
		var dy = endPoint.y - startPoint.y;

		var angle = Math.asin(Math.abs(dy)/Math.sqrt(dx * dx + dy * dy));

		if(dy <= 0 && dx < 0 ) {
			angle = Math.PI - angle;
		}
		
		if(dy > 0 && dx < 0 ) {
			angle = Math.PI + angle;
		}
		
		if(dy > 0 && dx >= 0 ) {
			angle = 2 * Math.PI - angle;
		}

		angle = -angle;
		function step() {
			var percent = (Date.now() - start)/dt;
			if(percent < 1) {
				x = startPoint.x + dx * percent - hw;
				y = startPoint.y + dy * percent - hh;

				me.setPosition(x, y);
				if(enableRotation) {
					me.setRotation(angle);
				}
				me.postRedraw();
				
				return true;
			}
			else {
				index++;
				x = endPoint.x - hw;
				y = endPoint.y - hh;

				me.setPosition(x, y);
				me.postRedraw();
				moveToNext();

				return false;
			}
		}

		UIElement.setAnimTimer(step);
	}

	moveToNext();

	return;
}

UIElement.prototype.setPositionWithSticky = function(x, y) {
	this.setPosition(x, y);

	if(this.sticky) {
		this.orgX = this.x;		
		this.orgY = this.y;	
	}

	return this;
}

UIElement.prototype.setAngle = UIElement.prototype.setRotation;

UIElement.prototype.setPositionByBody = function(left, top) {
    if(this.anchor) {
        this._x = left + this.w * this.anchor.x;
        this._y = top + this.h * this.anchor.y;
        this.setLeftTop(left, top);
    }
    else {
        this._x = left;
        this._y = top;
        this.setLeftTop(this._x, this._y);
    }

	this.callOnMovedHandler();

	return this;
}

UIElement.prototype.setSoundMusicVolume = function(volume) {
	this.getWindowManager().setSoundMusicVolume(volume);

	return this;
}

UIElement.prototype.setSoundEffectVolume = function(volume) {
	this.getWindowManager().setSoundEffectVolume(volume);

	return this;
}

UIElement.prototype.playSoundEffect = function(name, onDone) {
	this.getWindowManager().playSoundEffect(name, onDone);

	return this;
}

UIElement.prototype.playSoundMusic = function(name, onDone) {
	this.getWindowManager().playSoundMusic(name, onDone);

	return this;
}

UIElement.prototype.stopSoundMusic = function(name) {
	this.getWindowManager().stopSoundMusic(name);

	return this;
}

UIElement.prototype.stopSoundEffect = function(name) {
	this.getWindowManager().stopSoundEffect(name);

	return this;
}

UIElement.prototype.setSoundEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundEnable(enable);

	return this;
}

UIElement.prototype.isSoundEnable = UIElement.prototype.getSoundEnable = function() {
	var wm = this.getWindowManager();

	return wm.getSoundEnable();
}

UIElement.prototype.setSoundEffectEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundEffectsEnable(enable);

	return this;
}

UIElement.prototype.isSoundEffectEnable = UIElement.prototype.getSoundEffectEnable = function() {
	var wm = this.getWindowManager();

	return wm.soundEffectsEnalbe;
}

UIElement.prototype.setSoundMusicEnable = function(enable) {
	var wm = this.getWindowManager();

	wm.setSoundMusicsEnable(enable);

	return this;
}

UIElement.prototype.isSoundMusicEnable = UIElement.prototype.getSoundMusicEnable = function() {
	var wm = this.getWindowManager();

	return wm.soundMusicsEnalbe;
}

UIElement.prototype.setVOf = function(name, x, y) {
	var el = this.getWindow().findChildByName(name, true);
	if(el) {
		el.setV(x, y);
	}
	else {
		console.log("not found " + name);
	}

	return this;
}

UIElement.prototype.setV = function(x, y) {
	var body = this.body;
	if(body) {
		this.setVisible(true);

		if(!body.IsActive()) {
			body.SetActive(true);
		}

		if(!body.IsAwake()) {
			body.SetAwake(true);
		}

		var v = body.GetLinearVelocity();
		if(x !== null && x !== undefined) {
			v.x = x;
		}

		if(y !== null && y !== undefined) {
			v.y = y;
		}

		body.SetLinearVelocity(v);
	}

	return this;
}

UIElement.prototype.onRemoved = function(parent) {
	if(!parent) {
		return;
	}

	var win = parent.getWindow();
	if(!win) {
		return;
	}

	var world = win.world;

	if(this.body) {
		Physics.destroyBodyForElement(world, this);
		this.body = null;
	}

	if(this.joint) {
		Physics.destroyJointForElement(world, this);
		this.joint = null;
	}

	return this;
}

/*
 * File:   ui-weixin.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  WeiXin Settings/Events
 * 
 * Copyright (c) 2015 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIWeixin 
 * @extends UIElement 
 * 微信设置控件。配置成功后可以调用微信JSAPI。导出游戏到自己的服务器上运行，需要提供自己的配置文件URL。
 * 
 * 使用自己的配置文件URL请参考：https://github.com/drawapp8/GameWiki/wiki/Wechat-JSSDK-wiki
 *
 * 微信JSAPI: http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html
 *
 */
function UIWeixin() {
	return;
}

UIWeixin.prototype = new UIElement();
UIWeixin.prototype.isUIWeixin = true;
UIWeixin.prototype.saveProps = ["configURL", "shareTitle", "shareDesc", "shareLink", "shareImage", 
		"apiList", "debug"];

UIWeixin.prototype.initUIWeixin = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);
	this.setCanRectSelectable(false, true);

	return this;
}

UIWeixin.jsApiList = [
        'checkJsApi',
        'onMenuShareTimeline',
        'onMenuShareAppMessage',
        'onMenuShareQQ',
        'onMenuShareWeibo',
        'hideMenuItems',
        'showMenuItems',
        'hideAllNonBaseMenuItem',
        'showAllNonBaseMenuItem',
        'translateVoice',
        'startRecord',
        'stopRecord',
        'onRecordEnd',
        'playVoice',
        'pauseVoice',
        'stopVoice',
        'uploadVoice',
        'downloadVoice',
        'chooseImage',
        'previewImage',
        'uploadImage',
        'downloadImage',
        'getNetworkType',
        'openLocation',
        'getLocation',
        'hideOptionMenu',
        'showOptionMenu',
        'closeWindow',
        'scanQRCode',
        'chooseWXPay',
        'openProductSpecificView',
        'addCard',
        'chooseCard',
        'openCard'
      ];

UIWeixin.prototype.getConfig = function(configURL, jsApiList, debug) {
	if(UIWeixin.config) {
		return;
	}
	else {
		UIWeixin.config = {};
	}

	httpGetJSON(configURL, function onDone(data) {
		UIWeixin.config = data;

		if(UIWeixin.config) {
			UIWeixin.config.jsApiList = jsApiList;
			UIWeixin.config.debug = debug;
			console.log("Fetch UIWeixin.config success:");
		}
		else {
			console.log("Fetch weixin config failed.");
			return;
		}

		function callWeiXinConfig() {
			try {
				wx.config(UIWeixin.config);
				UIWeixin.configDone = true;
				console.log(JSON.stringify(UIWeixin.config, null, "\t"));
				console.log("Call wx.config done:");
			}
			catch(e) {
				console.log("wx script is not load yet, try to config lator:");
				setTimeout(callWeiXinConfig, 100);
			}
		}

		if(isWeiXin()) {
			console.log("Is WeiXin, try to config it.");
			callWeiXinConfig();
		}
		else {
			console.log("It is not weixin browser");
		}
	});
}

UIWeixin.prototype.onFromJsonDone = function() {
	var url = window.btoa(location.href);
	var configURL = null;

	if(location.href.indexOf('i5r.com.cn') >= 0) {
		configURL = this.configURL ? this.configURL : "/weixin/php/json_config.php";
	}
	else {
		configURL = this.configURL ? this.configURL : "/wechat/config";
	}

	if(configURL.indexOf("?") > 0) {
		configURL = configURL + "&url=" + url;
	}
	else {
		configURL = configURL + "?url=" + url;
	}

	var jsApiList = UIWeixin.jsApiList;
	if(this.apiList) {
		jsApiList = this.apiList.split("\n");
	}

	this.getConfig(configURL, jsApiList, this.debug);

	return;
}

UIWeixin.prototype.onInit = function() {
	var me = this;
	if(!window.wx) {
		console.log("UIWeixin.prototype.onInit wx not defined.");
		return;
	}

	wx.ready(function () {
		UIWeixin.ready = true;
		me.updateShareInfo();
		console.log("wx.ready");
	});

	wx.error(function (res) {
	});

	console.log("UIWeixin.prototype.onInit end");

	return;
}

UIWeixin.prototype.onDeinit = function() {

	return;
}

UIWeixin.prototype.shapeCanBeChild = function(shape) {
	return false;
}

/**
 * @method setShareTitle
 * 设置分享标题。
 * @param {String} shareTitle 分享标题。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareTitle = function(shareTitle) {
	this.shareTitle = shareTitle;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareDesc
 * 设置分享描述。
 * @param {String} shareDesc 分享描述。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareDesc = function(shareDesc) {
	this.shareDesc = shareDesc;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareLink
 * 设置分享链接。
 * @param {String} shareLink 分享链接。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareLink = function(shareLink) {
	this.shareLink = shareLink;
	this.updateShareInfo();

	return this;
}

/**
 * @method setShareImage
 * 设置分享图片。
 * @param {String} shareImage 分享图片。
 * @return {UIElement} 返回控件本身。
 *
 */
UIWeixin.prototype.setShareImage = function(shareImage) {
	this.shareImage = shareImage;
	this.updateShareInfo();

	return this;
}

UIWeixin.prototype.updateShareInfo = function() { 
	if(!window.wx) {
		return;
	}

	var view = this.view;
	var title = this.shareTitle ? this.shareTitle : view.getAppName();
	var desc = this.shareDesc ? this.shareDesc : view.getAppDesc();
	var link = this.shareLink ? this.shareLink : location.href;
	var imgUrl = ResLoader.toAbsURL(this.shareImage ? this.shareImage : view.getAppIcon());

	var info = {
		title: title,
		desc: desc,
		link: link,
		imgUrl: imgUrl,
		trigger: function (res) {
			console.log("weixin operation trigger:" + JSON.stringify(res));
		},
		success: function (res) {
			console.log("weixin operation success:" + JSON.stringify(res));
		},
		cancel: function (res) {
			console.log("weixin operation cancel:" + JSON.stringify(res));
		},
		fail: function (res) {
			console.log("weixin operation fail:" + JSON.stringify(res));
		}
	};

    wx.onMenuShareAppMessage(info);
    wx.onMenuShareTimeline(info);
    wx.onMenuShareQQ(info);
    wx.onMenuShareWeibo(info);

	return;
}

function UIWeixinCreator() {
	var args = ["ui-weixin", "ui-weixin", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIWeixin();
		return g.initUIWeixin(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIWeixinCreator());


/**
 * @class HolaSDK
 * HolaSDK。广告，分享和统计等API。
 *
 * 所有函数通过HolaSDK直接调用。示例：
 * 
 *     @example small frame
 *     HolaSDK.exit()
 *
 */
function HolaSDK() {
}

HolaSDK.exec = function(action, options) {
	if(window.HolaF) {
		window.HolaF(action, options);
		console.log("HolaSDK.exec:" + action + ":" + (options ? JSON.stringify(options) : "{}"));
	}
	else {
		console.log("HolaSDK.exec(e):" + action + ":" + (options ? JSON.stringify(options) : "{}"));
	}
}

HolaSDK.init = function(appID, debug) {
	if(HolaSDK.initialized) {
		return;
	}

	var options = {};
	options.app_id = appID;
	options.debug = debug;

	HolaSDK.appID = appID;
	HolaSDK.initialized = true;
	HolaSDK.startTime = Date.now();
	HolaSDK.exec('GameJsAdSdk.init', options);
	console.log("HolaSDK.init done");
}

/**
 * @method showAd
 * 显示广告(一般不需要直接调用)。
 * @param {String} placementID 位置ID。
 * @param {Number} placementType 类型。 
 * @param {Number} impressionTime 显示时间。
 * @param {Boolean} closable 是否可关闭。
 *
 */
HolaSDK.showAd = function(placementID, placementType, impressionTime, closable) {
	var options = {};
	options.placement_id = HolaSDK.appID + '_' + placementID;
	options.placement_type = placementType;
	options.impression_time = impressionTime;
	options.closable = closable;

	HolaSDK.exec('GameJsAdSdk.showAd', options);
}

/**
 * @method closeAd
 * 关闭广告(一般不需要直接调用)。
 */
HolaSDK.closeAd = function() {
    if(!HolaSDK.initialized) return;
	HolaSDK.exec('GameJsAdSdk.closeAd');
}

/**
 * @method share
 * 分享(在分享按钮的Click事件中填写相应参数即可)。
 * @param {String} title 标题。
 * @param {String} description 描述。
 * @param {String} link 链接。
 * @param {String} icon 图标。
 *
 */
HolaSDK.share = function(title, description, link, icon) {
	var options = {};
	options.title = title;
	options.description = description;

	HolaSDK.exec('share', options);
}

HolaSDK.fixTime = function(duration) {
	if(duration > 1000) {
		duration = duration/1000;
	}

	return duration;
}

/**
 * @method sendBarrage
 * 发送弹幕。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.sendBarrage = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Barrage.send', options);
}

/**
 * @method ping
 * 更新游戏状态。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.ping = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Barrage.ping', options);
}

HolaSDK.onPaused = function() {
	if(HolaSDK.onPausedCallback) {
		HolaSDK.onPausedCallback();
	}
}

/**
 * @method whenPaused
 * 注册暂停事件的回调函数。
 * @param {Function} callback 
 *
 */
HolaSDK.whenPaused = function(callback) {
	HolaSDK.onPausedCallback = callback;

	HolaSDK.exec('Game.Event.onPause', HolaSDK.onPaused);
}

HolaSDK.onResumed = function() {
	if(HolaSDK.onResumedCallback) {
		HolaSDK.onResumedCallback();
	}
}

/**
 * @method whenResumed
 * 注册恢复事件的回调函数。
 * @param {Function} callback 
 *
 */
HolaSDK.whenResumed = function(callback) {
	HolaSDK.onResumedCallback = callback;

	HolaSDK.exec('Game.Event.onResume', HolaSDK.onResumed);
}

HolaSDK.onRestarted = function() {
	if(HolaSDK.onRestartedCallback) {
		HolaSDK.onRestartedCallback();
	}
}

/**
 * @method whenRestarted
 * 注册重玩事件的回调函数。游戏盒子上的Replay按钮被按下时触发本事件。
 * @param {Function} callback 
 *
 */
HolaSDK.whenRestarted = function(callback) {
	HolaSDK.onRestartedCallback = callback;

	HolaSDK.exec('Game.Event.onRestart', HolaSDK.onRestarted);
}

/**
 * @method gameStarted
 * 游戏开始时调用(用于更新统计信息)。
 * @param {Number} level 当前关数。
 *
 */
HolaSDK.gameStarted = function(level) {
	var options = {};
	options.level = level;

	HolaSDK.exec('Game.Status.start', options);
}

/**
 * @method gamePaused
 * 游戏暂停时调用(用于更新统计信息)。
 *
 */
HolaSDK.gamePaused = function() {
	HolaSDK.exec('Game.Status.pause');
}

/**
 * @method gameResumed
 * 游戏恢复时调用(用于更新统计信息)。
 *
 */
HolaSDK.gameResumed = function() {
	HolaSDK.exec('Game.Status.resume');
}

/**
 * @method gameOver
 * 游戏结束时调用(用于更新统计信息)。
 * @param {Number} score 当前分数。 
 * @param {Number} level 当前关数。
 * @param {Number} duration 游戏时间(毫秒)。
 *
 */
HolaSDK.gameOver = function(score, level, duration) {
	var options = {};
	options.score = score;
	options.level = level;
	options.duration = HolaSDK.fixTime(duration);
	HolaSDK.exec('Game.Status.over', options);
}

HolaSDK.gameRestarted = function() {
	console.log("HolaSDK.gameRestarted is not supported now!!!");
}

HolaSDK.gameExited = function() {
	HolaSDK.exec('Game.Status.exit');
}

/**
 * @method exit
 * 退出游戏，返回游戏大厅。
 *
 */
HolaSDK.exit = function() {
	HolaSDK.exec('Game.exit');
}


HolaSDK.getSDKURL = function() {
    return "http://game-ad-sdk.haloapps.com/static/abyhola/sdk/js_ad_sdk_loader.js?v=034";
}

window.HolaSDK = HolaSDK;

if(!window.CanTK) {
	window.CanTK = {};
}

CanTK.isOldIE = isOldIE;
CanTK.isTizen = isTizen;
CanTK.isMobile = isMobile;
CanTK.isAndroid = isAndroid;
CanTK.isFirefoxOS = isFirefoxOS;
CanTK.initViewPort = cantkInitViewPort;
CanTK.restoreViewPort = cantkRestoreViewPort;
CanTK.httpGetURL = httpGetURL;
CanTK.httpGetJSON = httpGetJSON;
CanTK.httpDoRequest = httpDoRequest;

CanTK.LinearInterpolator = LinearInterpolator;
CanTK.BounceInterpolator = BounceInterpolator;
CanTK.AccelerateInterpolator = AccelerateInterpolator;
CanTK.AccDecelerateInterpolator = AccDecelerateInterpolator;
CanTK.DecelerateInterpolator = DecelerateInterpolator;
CanTK.detectDeviceConfig = cantkDetectDeviceConfig;
CanTK.regShapeCreator = cantkRegShapeCreator;
CanTK.ShapeCreator = ShapeCreator;

window.isOldIE = isOldIE;
window.isTizen = isTizen;
window.isMobile = isMobile;
window.isAndroid = isAndroid;
window.isFirefoxOS = isFirefoxOS;
window.httpGetURL = httpGetURL;
window.httpGetJSON = httpGetJSON;
window.httpDoRequest = httpDoRequest;
window.cantkInitViewPort = cantkInitViewPort;
window.cantkRestoreViewPort = cantkRestoreViewPort;
window.cantkGetViewPort = cantkGetViewPort;

window.Shape = Shape;
window.UIElement = UIElement;
window.UIWindowManager = UIWindowManager;
window.ShapeFactory = ShapeFactory;

CanTK.UIImage = UIImage;

CanTK.Shape = Shape;
CanTK.UIElement = UIElement;

CanTK.init = function () {
}

CanTK.createElement = function(type) {
	return ShapeFactoryGet().createShape(type, C_CREATE_FOR_PROGRAM);
}

CanTK.createElementWithJson = function(data) {
	var type = data.type;
	var el = ShapeFactoryGet().createShape(type, C_CREATE_FOR_PROGRAM);

	if(el) {
		el.fromJson(data);
		el.setMode(Shape.MODE_RUNNING, true);
	}

	return el;
}

CanTK.UIElement.RUNNING = Shape.MODE_RUNNING;
CanTK.UIElement.DEFAULT_IMAGE = UIElement.IMAGE_DEFAULT;

CanTK.setResRoot = function(resRoot) {
	return ResLoader.setResRoot(resRoot);
}

/*
 * File:   ui-circle.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic circle for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIBody
 * @extends UIElement
 * 物理引擎中的刚体。它是方块刚体，圆形刚体和多边形刚体的父类，它本身是一个抽象类，不能直接创建对象。
 * 
 * 可以设置它的物理引擎参数，如摩擦力，弹力和密度等。密度为0表示是静态刚体，大于0表示是动态刚体。
 * 静态刚体不会有速度等动态行为，通常用来表示大地等不动的物体，但可以通过程序来移动它的位置。
 *
 * 可以向刚体中添加图片和动画来装饰刚体。
 *
 * 注意：刚体只能放到场景中，如果设计时把刚体放在其它控件中，它不会继承父控件的位置属性，移动父控件刚体不会跟随移动。
 */

/**
 * @event onBeginContact
 * 两个刚体碰撞到一起时，会触发onBeginContact事件。一般事件调用顺序是：onBeginContact ->  onPreSolve -> onPostSolve ->onPreSolve -> onPostSolve -> ………… -> onPreSolve -> onPostSolve -> onEndContact。
 *
 *
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/](//www.box2dflash.org/docs/2.1a/reference/)
 *
 *     @example small frame
 *     if(body.element.name === "ui-coin") {
 *          body.element.remove(true);
 *     }
 */

/**
 * @event onEndContact
 * 碰撞结束事件。两个刚体碰撞在一起，然后分离开的事件。
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 *
 */

/**
 * @event onPreSolve
 * PreSolve
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 * @param {Object} oldManifold [b2Manifold](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Collision/b2Manifold.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html](//www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html)
 */

/**
 * @event onPostSolve
 * Post Solve 
 * @param {Object} body 是碰撞当前刚体的刚体。通过body.element可以获取body对应的控件。
 * @param {Object} contact [碰撞信息](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/Contacts/b2Contact.html)
 * @param {Object} impulse [b2ContactImpulse](http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactImpulse.html)
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html](//www.box2dflash.org/docs/2.1a/reference/Box2D/Dynamics/b2ContactListener.html)
 */

/**
 * @event onMoved
 * 当刚体移动时触发本事件。
 *
 */

/**
 * @property {Boolean} cameraFollowMe
 * 是否启用镜头跟随。
 * 注意：需要设置当前场景的虚拟宽度大于场景宽度，或虚拟高度大于场景高度，否则镜头跟随不生效。
 */

function UIBody() {
	return;
}

UIBody.prototype = new UIElement();
UIBody.prototype.isUIBody = true;
UIBody.prototype.isUIPhysicsShape = true;

UIBody.prototype.saveProps = ["density", "friction", "restitution", "isSensor", "allowSleep", "isBullet", "autoDestroyWhenOutside",
	"fixedRotation", "groupIndex", "noStroke", "cameraFollowMe", "xInitVelocity", "yInitVelocity",
	"linearDamping", "angularDamping"];

UIBody.prototype.initUIBody = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setCanRectSelectable(false, false);

	this.density = 0;
	this.friction = 0;
	this.restitution = 0;
	this.allowSleep = true;

	this.addEventNames(["onBeginContact", "onEndContact", "onMoved", "onPreSolve", "onPostSolve"]);

	return this;
}

UIBody.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

//////////////////////////////////////////////////////////////

/**
 * @method setGravityScale
 * 设置刚体的重力系数，动态修改单个刚体的重力。
 * @param {Point} gravityScale 重力系数。
 * @return {UIElement} 返回控件本身。
 *
 *
 * 去掉重力影响：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:0});
 *
 * Y方向的重力取反：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:-1});
 
 * Y方向的重力减半：
 *
 *     @example small frame
 *     this.setGravityScale({x:0, y:0.5});
 *
 */
UIBody.prototype.setGravityScale = function(gravityScale) {
	this.gravity = {};
	this.gravityScale = gravityScale;

	if(this.body) {
		this.body.modifyGravity  = this.modifyGravity.bind(this);
	}

	return this;
}

UIBody.prototype.modifyGravity = function(gravity) {
	var g = this.gravity;
	var gs = this.gravityScale;

	g.x = gravity.x * gs.x;
	g.y = gravity.y * gs.y;

	return g;
}

UIBody.prototype.onBodyCreated = function() {
	if(this.gravity && this.gravityScale) {
		this.body.modifyGravity  = this.modifyGravity.bind(this);
	}
}

/**
 * @method setSensor
 * 设置刚体为感应器。感应器可以产生碰撞的事件，但不会有碰撞的效果(直接穿越过对方)。
 * @param {Boolean} isSensor 是否为感应器。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setSensor = function(isSensor) {
	this.isSensor = isSensor;

	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetSensor(isSensor);
		}
	}

	return this;
}

/**
 * @method getDensity
 * 获取刚体的密度。
 * @return {Number} 返回刚体的密度。
 *
 */
UIBody.prototype.getDensity = function() {
	if(this.body) {
		return this.body.GetFixtureList().GetDensity();
	}
	else {
		return this.density;
	}
}

/**
 * @method setRestitution
 * 设置刚体的弹力系数。
 * @param {Number} restitution 刚体的弹力系数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setRestitution = function(restitution) {
	this.restitution = restitution;

    if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetRestitution(restitution);
		}
    }

    return this;
}

/**
 * @method getRestitution
 * 获取刚体的弹力系数。
 * @return {Number} 返回刚体的弹力系数。
 *
 */
UIBody.prototype.getRestitution = function() {
    if(this.body) {
        return this.body.GetFixtureList().GetRestitution();
    } else {
        return this.restitution;
    }
}

/**
 * @method setFriction
 * 设置刚体的摩擦系数。
 * @param {Number} friction 刚体的摩擦系数。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setFriction = function(friction) {
	this.friction = friction;

    if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetFriction(friction);
		}
    }

    return this;
}

/**
 * @method getFriction
 * 获取刚体的摩擦系数。
 * @return {Number} 返回刚体的摩擦系数。
 *
 */
UIBody.prototype.getFriction = function() {
    if(this.body) {
        return this.body.GetFixtureList().GetFriction();
    } else {
        return this.friction;
    }
}

/**
 * @method setDensity
 * 设置刚体的密度。
 * @param {Number} density 刚体的密度。 
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setDensity = function(density) {
	this.density = density;

	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.SetDensity(density);
		}

		if(density > 0) {
			this.body.SetType(b2Body.b2_dynamicBody);
		}
		else if(density === 0) {
			this.body.SetType(b2Body.b2_staticBody);
		}
		else {
			this.body.SetType(b2Body.b2_kinematicBody);
		}
		this.body.ResetMassData();
	}

	return this;
}


/**
 * @method setV
 * 设置刚体的线性速度，x，y的取值为null/undefined时，保留原来的值。
 * @param {Number} x 水平方向上的速度，向右为正，向左为负。
 * @param {Number} y 垂直方向上的速度，向下为正，向上为负。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setV = function(x, y) {
	var body = this.body;
	if(body) {
		this.setVisible(true);

		if(!body.IsActive()) {
			body.SetActive(true);
		}

		if(!body.IsAwake()) {
			body.SetAwake(true);
		}

		var v = body.GetLinearVelocity();
		if(x !== null && x !== undefined) {
			v.x = x;
		}

		if(y !== null && y !== undefined) {
			v.y = y;
		}

		body.SetLinearVelocity(v);
	}
	else {
		this.xInitVelocity = x;
		this.yInitVelocity = y;
	}

	return this;
}

/**
 * @method getV
 * 获取刚体的线性速度。
 * @return {Point} 返回刚体的线性速度。
 *
 */
UIBody.prototype.getV = function() {
	return this.body ? this.body.GetLinearVelocity() : {x:0, y:0};
}

/**
 * @method addV
 * 增加刚体的线性速度。
 * @param {Number} dx 水平方向上的速度增量。
 * @param {Number} dy 垂直方向上的速度增量。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.addV = function(dx, dy) {
	var v = this.getV();

	if(dx !== null && dx !== undefined) {
		v.x += dx;
	}
	
	if(dy !== null && dy !== undefined) {
		v.y += dy;
	}

	return this.setV(v.x, v.y);
}

/**
 * @method getMass
 * 获取刚体的质量。
 * @return {Number} 返回刚体的质量。
 *
 */
UIBody.prototype.getMass = function() {
	return this.body ? this.body.GetMass() : 0;
}

/**
 * @method applyTorque
 * 作用一个力矩到刚体上。
 * @param {Number} torque
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.applyTorque = function(torque) {
	if(this.body) {
		this.body.ApplyTorque(torque);
	}

	return this;
}

/**
 * @method applyForce
 * 作用一个力到刚体上。
 * @param {Number} forceX X方向上的力。
 * @param {Number} forceY Y方向上的力。
 * @param {Number} x 作用点X。
 * @param {Number} y 作用点Y。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.applyForce = function(forceX, forceY, x, y) {
	if(this.body) {
		var force = {};
		var position = {};
		x = (x === undefined || x === null) ? (this.left + (this.w >> 1)) : x;
		y = (y === undefined || y === null) ? (this.top + (this.h >> 1)) : y;

		force.x = forceX;
		force.y = forceY;
		position.x = Physics.toMeter(x);
		position.y = Physics.toMeter(y);

		this.body.ApplyForce(force, position);
	}

	return this;
}

UIBody.prototype.setEnable = function(enable) {
	this.enable = enable;
	if(this.body) {
		this.body.SetActive(enable);
	}

	return this;
}

/**
 * @method setGroupIndex
 * 设置刚体的分组。
 * @param {Number} groupIndex 相同负数分组的刚体之间不会碰撞。
 * @return {UIElement} 返回控件本身。
 *
 */
UIBody.prototype.setGroupIndex = function(groupIndex) {
	this.groupIndex = groupIndex;
	if(this.body) {
		for (var f = this.body.GetFixtureList(); f; f = f.m_next) {
			f.m_filter.groupIndex = groupIndex;
		}
	}

	return this;
}

/**
 * @method getGroupIndex
 * 获取刚体的分组。
 * @return {Number} 返回控件的分组。
 *
 */
UIBody.prototype.getGroupIndex = function() {
	return this.groupIndex;
}

/**
 * @method getBody
 * 获取box2d的刚体对象。在特殊情况下，需要直接操作box2d，请使用本函数。
 * @return {Object} 返回box2d的刚体对象。
 *
 * 参考：[http://www.box2dflash.org/docs/2.1a/reference/](http://www.box2dflash.org/docs/2.1a/reference/)
 */
UIBody.prototype.getBody = function() {
	return this.body;
}

UIBody.prototype.setRotation = function(rotation) {
	this.rotation = rotation;

	if(this.body) {
		this.body.SetAngle(rotation);
	}

	return this;
}

/**
 * @method boom
 * 通过这个方法向刚体周围放射作用力，达到爆炸效果。
 * @param {Number} range 爆炸的作用半径范围。
 * @param {Number} force 爆炸产成的作用力大小。
 * @param {Boolean} removeSelf 是否删除空间本身。
 */
UIBody.prototype.boom = function(range, force, removeSelf) {
    var position = this.getPosition();
    position = new b2Vec2(Physics.toMeter(position.x), Physics.toMeter(position.y));
    var win = this.getWindow();
    var world = win.world;
    range = Physics.toMeter(range);

    for (var i = 0; i <= 100; i++) {
        var angle = 360 / 100 * i;

        var input = new b2RayCastInput();
        input.p1 = position;
        input.p2.Set(position.x + range * Math.cos(angle), position.y + range * Math.sin(angle));
        input.maxFraction = 1;
        var output = new b2RayCastOutput();

        for (var currentBody = world.GetBodyList(); currentBody; currentBody = currentBody.GetNext()) {
            if (currentBody.element == this) {
                continue;
            }
            var fix = currentBody.GetFixtureList();
            if (!fix) {
                continue;
            }

            var isHit = fix.RayCast(output, input);
            if (isHit) {
                var p1 = input.p1.Copy();
                var p2 = input.p2.Copy();
                p2.Subtract(p1);
                p2.Multiply(output.fraction);
                p1.Add(p2);
  
                var hitPoint = p1.Copy();
                hitPoint.Subtract(position);
                currentBody.ApplyForce(new b2Vec2(hitPoint.x * (1 - output.fraction) * force, hitPoint.y * (1 - output.fraction) * force), hitPoint);
            }
        }
    }

    removeSelf && this.remove();
}



UIBody.prototype.needStroke = function() {
	return (!this.noStroke && !this.isStrokeColorTransparent()) || this.isInDesignMode();
}

UIBody.prototype.setSize = function(w, h) {
	RShape.prototype.setSize.call(this, w, h);

	var win = this.getWindow();
	this.updateLayoutParams();

	if(this.body && win && win.isUIScene) {
		this.resizeBody();
	}

	return this;
}

UIBody.prototype.onPositionChanged = function() {
	var x = this.left;
	var y = this.top;
	var body = this.body;
	var win = this.getWindow();
	if(body && win && win.isUIScene) {
		var p = {};
		var pos = this.getParent().getPositionInWindow();

		x += pos.x;
		y += pos.y;

		p.x = win.toMeter(x + (this.w >> 1)); 
		p.y = win.toMeter(y + (this.h >> 1)); 
		if(body.m_world.IsLocked()) {
			setTimeout(function() {
				body.SetPosition(p);
			}, 0);
		}
		else {
			body.SetPosition(p);
		}
	}
	
	return this;
}

UIBody.prototype.checkIfOutside = function() {
	if(!this.autoDestroyWhenOutside) {
		return;
	}

	var w = this.w;
	var h = this.h;
	var win = this.win;
	var p = this.getAbsLeftTop();
	var rWin = {x:win.x-w, y:win.y-h, w:win.w+w, h:win.h+h};

	p.w = w;
	p.h = h;
	p.x -= win.xOffset;
	p.y -= win.yOffset;

	var ret = Rect.hasIntersection(p, rWin);
	if(!ret) {
		this.remove(true, false);
		console.log("checkIfOutside remove outside body:" + this.name);
	}
}

UIBody.prototype.onInit = function() {
	if(this.autoDestroyWhenOutside) {
		this.on("moved", this.checkIfOutside.bind(this));
	}
}

UIBody.prototype.paintSelfOnly = function(canvas) {
	var needStroke = this.needStroke();
	var needFill = !this.isFillColorTransparent();

	if(!needFill && !needStroke) {
		return;
	}

	canvas.beginPath();
	this.drawShape(canvas);

	if(needFill) {
		canvas.fillStyle = this.style.fillColor;
		canvas.fill();
	}

	if(needStroke) {
		if(this.noStroke) {
			canvas.setLineDash([5, 5]);	
		}

		canvas.lineWidth = this.style.lineWidth;
		canvas.strokeStyle = this.style.lineColor;
		canvas.stroke();
	}

	return;
}
/*
 * File:   ui-point.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIPoint() {
	return;
}

UIPoint.prototype = new UIElement();
UIPoint.prototype.isUIPoint = true;

UIPoint.prototype.initUIPoint = function(type, w, h, bg) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, bg);

	return this;
}

UIPoint.prototype.paintSelfOnly = function(canvas) {
	var fillIt = !this.isFillColorTransparent();
	var strokeIt = !this.isStrokeColorTransparent();

	if(fillIt || strokeIt) {
		var x = this.w >> 1;
		var y = this.h >> 1;
		canvas.beginPath();
		canvas.arc(x, y, 10, 0, 2 * Math.PI);
		
		if(fillIt) {
			canvas.fillStyle = this.style.fillColor;
			canvas.fill();
		}

		if(strokeIt) {
			canvas.strokeStyle = this.style.lineColor;
			canvas.lineWidth = this.style.lineWidth;
			canvas.stroke();
		}

		if(this.showIndex) {
			canvas.font = "12px";
			canvas.textAlign = "center";
			canvas.textBaseline = "middle";
			canvas.fillStyle = this.style.textColor || "Black";
			canvas.fillText(this.getIndex(), x, y);
		}
	}

	return;
}

UIPoint.prototype.setShowIndex = function(showIndex) {
	this.showIndex = showIndex;

	return this;
}

UIPoint.prototype.isUserResizable = function() {
	return false;
}

UIPoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIPointCreator() {
	var args = ["ui-point", "ui-point", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPoint();
		return g.initUIPoint(this.type, 20, 20, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPointCreator());

/*
 * File:   ui-two-points.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  two anchor points 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UITwoPoints
 * @extends UIElement
 * 两个点组成的控件。用来实现边(Edge)刚体和距离关节等。
 */
function UITwoPoints() {
	return;
}

UITwoPoints.prototype = new UIElement();
UITwoPoints.prototype.isUITwoPoints = true;

UITwoPoints.prototype.initUITwoPoints = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.setImage(UIElement.IMAGE_POINT1, null);
	this.setImage(UIElement.IMAGE_POINT2, null);
	
	this.points = [{x:0, y:0}, {x:80, y:80}];
	this.savedPoints = [{x:0, y:0}, {x:80, y:80}];

	return this;
}

UITwoPoints.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.points = [{x:0, y:0}, {x:80, y:80}];
	o.points[0].x = this.points[0].x;
	o.points[0].y = this.points[0].y;
	o.points[1].x = this.points[1].x;
	o.points[1].y = this.points[1].y;

	o.x0Param = this.x0Param;
	o.x1Param = this.x1Param;
	o.y0Param = this.y0Param;
	o.y1Param = this.y1Param;

	return o;
}

UITwoPoints.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	this.points[0].x = js.points[0].x;
	this.points[0].y = js.points[0].y;
	this.points[1].x = js.points[1].x;
	this.points[1].y = js.points[1].y;
	this.x0Param = js.x0Param;
	this.x1Param = js.x1Param;
	this.y0Param = js.y0Param;
	this.y1Param = js.y1Param;


	return this;
}

UITwoPoints.prototype.relayout = function() {
	if(this.disableRelayout || this.isInDesignMode()) {
		return;
	}

	var p = getParentShapeOfShape(this);
	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);

	if(this.xAttr === UIElement.X_SCALE) {
		this.points[0].x = wParent * this.x0Param;
		this.points[1].x = wParent * this.x1Param;
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.points[0].y = hParent * this.y0Param;
		this.points[1].y = hParent * this.y1Param;
	}

	return;
}

UITwoPoints.prototype.updateLayoutParams = function() {
	this.xParam = 1;
	this.yParam = 1;

	var p = this.parentShape;
	if(!p) {
		return;
	}

	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.x0Param = this.points[0].x / wParent;
		this.x1Param = this.points[1].x / wParent;
	}

	if(this.yAttr === UIElement.Y_SCALE) {
		this.y0Param = this.points[0].y / hParent;
		this.y1Param = this.points[1].y / hParent;
	}

    this.w = Math.abs(this.points[0].x - this.points[1].x);
    this.h = Math.abs(this.points[0].y - this.points[1].y);

	return;
}

UITwoPoints.prototype.drawSelectMarks = function(canvas) {
}

UITwoPoints.prototype.moveDelta = function(dx, dy) {
	this.points[0].x += dx;
	this.points[0].y += dy;
	this.points[1].x += dx;
	this.points[1].y += dy;

	return this;
}

UITwoPoints.prototype.setPositionByBody = function(x, y) {
    if(this.isUIEdge) {
        var dx = x - this.left;
        var dy = y - this.top;
        this.points[0].x += dx;
        this.points[0].y += dy;
        this.points[1].x += dx;
        this.points[1].y += dy;
    }
    UIElement.prototype.setPositionByBody.call(this, x, y);
}

UITwoPoints.prototype.paintSelf = function(canvas) {
	canvas.save();
	canvas.globalAlpha *=  this.opacity;
	var p1 = this.points[0];
	var p2 = this.points[1];
	if(this.isIcon) {
		this.translate(canvas);
		p1 = {x:p1.x+25, y:p1.y+25}
		p2 = {x:p2.x-25, y:p2.y-25}
	}

	var image = null;
	var srcRect = null;
	var bg = this.getImageByType(UIElement.IMAGE_DEFAULT);
	var p1Img = this.getImageByType(UIElement.IMAGE_POINT1);
	var p2Img = this.getImageByType(UIElement.IMAGE_POINT2);
	var r = this.anchorSize ? this.anchorSize : 5;

	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;

	if(bg && bg.getImage()) {
		image = bg.getImage();
		srcRect = bg.getImageRect();
		UIElement.drawImageLine(canvas, image, this.images.display, p1, p2, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.moveTo(p1.x, p1.y);
		canvas.lineTo(p2.x, p2.y);
		canvas.stroke();
	}

	if(p1Img && p1Img.getImage()) {
		image = p1Img.getImage();
		srcRect = p1Img.getImageRect();
		this.drawImageAt(canvas, image, WImage.DISPLAY_CENTER , p1.x-r, p1.y-r, r+r, r+r, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.arc(p1.x, p1.y, r, 0, Math.PI * 2);
		canvas.fill();
	}

	if(p2Img && p2Img.getImage()) {
		image = p2Img.getImage();
		srcRect = p2Img.getImageRect();
		this.drawImageAt(canvas, image, WImage.DISPLAY_CENTER , p2.x-r, p2.y-r, r+r, r+r, srcRect);
	}
	else {
		canvas.beginPath();
		canvas.arc(p2.x, p2.y, r, 0, Math.PI * 2);
		canvas.fill();
	}

	canvas.restore();
	
	this.drawSelectMarks(canvas);

	return;
}

UITwoPoints.prototype.shapeCanBeChild = function(shape) {
	return false;
}

/**
 * @method getPoint
 * 获取点的坐标。 
 * @param {Number} index 索引。
 * @return {Point} 返回点的坐标。
 *
 */
UITwoPoints.prototype.getPoint = function(index) {
	return this.points[index ? 1 : 0];
}

UITwoPoints.prototype.getCenterX = function() {
	return (this.points[0].x + this.points[1].x)>>1;
}

UITwoPoints.prototype.getCenterY = function() {
	return (this.points[0].y + this.points[1].y)>>1;
}

/**
 * @method setPoint
 * 设置点的坐标。 
 * @param {Number} index 索引。
 * @param {Number} x
 * @param {Number} y
 * @return {UIElement} 返回控件本身。
 *
 */
UITwoPoints.prototype.setPoint = function(index, x, y) {
	var p = this.points[index ? 1 : 0];
	p.x = x;
	p.y = y;
	this.updateLayoutParams();

	return this;
}

/**
 * @method getDistance
 * 获取两点的距离。
 * @return {Number} 返回两点的距离。
 *
 */
UITwoPoints.prototype.getDistance = function() {
	return Math.round(Math.distanceBetween(this.points[0], this.points[1]));
}

/**
 * @method getAngle
 * 获取两点的的角度。
 * @return {Number} 返回两点的的角度。
 *
 */
UITwoPoints.prototype.getAngle = function() {
	return Math.lineAngle(this.points[0], this.points[1]);
}

/*
 * File:   ui-polygon.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic polygon for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIPolygon
 * @extends UIBody
 * 多边形刚体。是物理引擎中的多边形刚体。多边形可以是三角形，四边形，五边形和组合多边形，多边形必须是按顺时针形成的凸多边形。组合多边形每5个点组成一个多边形。
 */
function UIPolygon() {
	return;
}

UIPolygon.prototype = new UIBody();
UIPolygon.prototype.isUIPolygon = true;

UIPolygon.prototype.initUIPolygon = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UIPolygon.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	if(shape.isUIPoint) {
		return true;
	}

	return !shape.isUIPhysicsShape;
}

UIPolygon.prototype.getVerticesArray = function() {
	var x0 = 0;
	var y0 = 0;
    var last2i = -1;
    var cx = this.w >> 1;
    var cy = this.h >> 1;
    var points = this.children.filter(function(child) {return child.isUIPoint});
    
    var vertices = points.map(function(p) {return new b2Vec2(p.x + (p.w >> 1), p.y + (p.h >> 1))});
   
    var complex = false;
    if(ClockWise(vertices) === CLOCKWISE) {
        vertices.reverse();
    }
    if(Convex(vertices) === CONCAVE) {
        complex = true;
    }
    
    var array = complex ? process(vertices) : vertices;
    return {complex: complex, vertices: array};
}

UIPolygon.prototype.drawShape = function(canvas) {
    if(!this.verticesInfo || this.isInDesignMode()) {
        this.verticesInfo = this.getVerticesArray();
    }
    var result = this.verticesInfo;
    var vertices = result.vertices;
    if(result.complex){
        var lines = [];
        if(vertices!= null) {
            for(i = 0; i < vertices.length; i = i + 3) {
                canvas.beginPath();
                lines.push([vertices[i], vertices[i+1]]);
                lines.push([vertices[i], vertices[i+2]]);
                lines.push([vertices[i+1], vertices[i+2]]);
                canvas.moveTo(vertices[i].x, vertices[i].y);
                canvas.lineTo(vertices[i+1].x, vertices[i+1].y);
                canvas.lineTo(vertices[i+2].x, vertices[i+2].y);
                canvas.closePath();
                canvas.globalAlpha = 0.4;
                //canvas.fillStyle = this.getDensity() > 0 ? "#ff00ff" : "#00ffff";
                //canvas.fill();
            } 
        }
        canvas.globalAlpha = 1;
        canvas.strokeStyle = "#ffffff";
        for(var i = 0; i < lines.length; i++) {
            var line = lines[i];
            canvas.moveTo(line[0].x, line[0].y);
            canvas.lineTo(line[1].x, line[1].y);
        }
    } else {
        canvas.beginPath();
        canvas.moveTo(vertices[0].x, vertices[0].y);
        for(var i = 1; i < vertices.length; i++) {
            canvas.lineTo(vertices[i].x, vertices[i].y);
        }
        canvas.closePath();
        canvas.globalAlpha = 0.4;
        //canvas.fillStyle = this.getDensity() > 0 ? "#ff00ff" : "#00ffff";
        //canvas.fill();
        canvas.globalAlpha = 1;
        canvas.strokeStyle = "#ffffff";
        canvas.stroke();
    }
}

UIPolygon.prototype.afterChildRemoved = function(shape) {
	if(shape.isUIPoint) {
        delete this.verticesInfo;
    }
    return true;
}

UIPolygon.prototype.afterChildAppended = function(shape) {
	if(shape.isUIPoint) {
		shape.z = shape.getIndex();
		shape.setShowIndex(true).setSize(20, 20);
        delete this.verticesInfo;
	}

	return;
}

UIPolygon.prototype.resizeBody = function(xScale, yScale) {
	var arr = [];
	var cx = this.w >> 1;
	var cy = this.h >> 1
	var n = this.children.length;
	var body = this.body;

	for(var i = 0; i < n; i++) {
		var iter = this.children[i];

		if(!iter.isUIPoint) {
			continue;
		}

		var hw = iter.w >> 1;
		var hh = iter.h >> 1;
		var icx = (iter.left + (hw >> 1)) * xScale;
		var icy = (iter.top + (hh >> 1)) * yScale;
		var left = icx - hw;
		var top = icy - hh;
		iter.setLeftTop(left, top);

		arr.push({x:Physics.toMeter(icx-cx), y:Physics.toMeter(icy-cy)});
	}

	var x = Physics.toMeter(this.left + (this.w >> 1));
	var y = Physics.toMeter(this.top + (this.h>>1));
	
	var shape = body.GetFixtureList().GetShape();
	shape.SetAsArray(arr, arr.length);

	var rotation = this.rotation;
	if(body.m_world.IsLocked()) {
		setTimeout(function() {
			body.SetAwake(true);
			body.SynchronizeFixtures();
			body.SetPositionAndAngle({x:x, y:y}, rotation);
		}, 0);
	}
	else {
		body.SetPosition(p);
	}

	return;
}

UIPolygon.prototype.setSize = function(w, h) {
	if(w === this.w && h === this.h) {
		console.log("UIPolygon.prototype.setSize: Size not changed.");
		return;
	}

	var xScale = w/this.w;
	var yScale = h/this.h;
	RShape.prototype.setSize.call(this, w, h);

	var win = this.getWindow();
	this.updateLayoutParams();

	if(this.body && win && win.isUIScene) {
		this.resizeBody(xScale, yScale);
	}

	return this;
}

UIPolygon.prototype.onFromJsonDone = function(js) {
	var n = this.children.length;
	for(var i = 0; i < n; i++) {
		var iter = this.children[i];
		if(iter.isUIPoint) {
			iter.z = iter.getIndex();
			iter.setShowIndex(true).setSize(20, 20);
		}
	}

	return;
}

function UIPolygonCreator() {
	var args = ["ui-polygon", "ui-polygon", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIPolygon();
		return g.initUIPolygon(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIPolygonCreator());
/*
 * File:   ui-box.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic box for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIBox
 * @extends UIBody
 * 方形刚体。
 */
function UIBox() {
	return;
}

UIBox.prototype = new UIBody();
UIBox.prototype.isUIBox = true;

UIBox.prototype.initUIBox = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UIBox.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

UIBox.prototype.resizeBody = function() {
	var x = this.left;
	var y = this.top;
	var hw = this.getWidth(true) >> 1;
	var hh = this.getHeight(true) >> 1;
	var shape = this.body.GetFixtureList().GetShape();

	shape.SetAsBox(Physics.toMeter(hw), Physics.toMeter(hh));
	this.body.SynchronizeFixtures();
	this.setLeftTop(x, y);
}

UIBox.prototype.drawShape = function(canvas) {
	var x = this.getHMargin();
	var y = this.getVMargin();
	var w = this.getWidth(true);
	var h = this.getHeight(true);
	
	canvas.rect(x, y, w, h);

	return;
}

function UIBoxCreator() {
	var args = ["ui-box", "ui-box", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIBox();
		return g.initUIBox(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIBoxCreator());

/*
 * File:   ui-circle.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Basic circle for game. 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UICircle
 * @extends UIBody
 * 圆形刚体。
 */
function UICircle() {
	return;
}

UICircle.prototype = new UIBody();
UICircle.prototype.isUICircle = true;

UICircle.prototype.initUICircle = function(type, w, h) {
	this.initUIBody(type, w, h);	

	return this;
}

UICircle.prototype.shapeCanBeChild = function(shape) {
	if(!UIGroup.prototype.shapeCanBeChild.call(this, shape) || (shape.isUIJoint && !shape.isUIMouseJoint)) {
		return false;
	}

	return !shape.isUIPhysicsShape;
}

UICircle.prototype.resizeBody = function() {
	var x = this.left;
	var y = this.top;
	var r = Physics.toMeter(Math.min(this.getWidth(true)>>1, this.getHeight(true)>>1));
	var shape = this.body.GetFixtureList().GetShape();

	shape.SetRadius(r);
	this.body.SynchronizeFixtures();
	this.setLeftTop(x, y);
}

UICircle.prototype.drawShape = function(canvas) {
	var x = this.w >> 1;
	var y = this.h >> 1;
	var r = Math.min(this.getWidth(true)>>1, this.getHeight(true)>>1);

	canvas.arc(x, y, r, 0, Math.PI * 2);

	return;
}

function UICircleCreator() {
	var args = ["ui-circle", "ui-circle", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UICircle();
		return g.initUICircle(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UICircleCreator());

/*
 * File:   ui-line-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  line joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UILineJoint() {
	return;
}

UILineJoint.prototype = new UITwoJoint();
UILineJoint.prototype.isUIJoint = true;
UILineJoint.prototype.isUILineJoint = true;

UILineJoint.prototype.initUILineJoint = function(type, w, h) {
	this.initUITwoJoint(type, w, h);	

	return this;
}

function UILineJointCreator() {
	var args = ["ui-line-joint", "ui-line-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UILineJoint();
		return g.initUILineJoint(this.type, 200, 200);
	}
	
	return;
}

/*
 * File:   ui-two-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  two anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UITwoJoint() {
	return;
}

UITwoJoint.prototype = new UITwoPoints();
UITwoJoint.prototype.isUIJoint = true;
UITwoJoint.prototype.isUITwoJoint = true;

UITwoJoint.prototype.initUITwoJoint = function(type, w, h) {
	this.initUITwoPoints(type);	

	return this;
}

function UITwoJointCreator() {
	var args = ["ui-two-joint", "ui-two-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UITwoJoint();
		return g.initUITwoJoint(this.type, 200, 200);
	}
	
	return;
}

/*
 * File:   ui-one-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  one anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIOneJoint() {
	return;
}

UIOneJoint.prototype = new UIElement();
UIOneJoint.prototype.isUIJoint = true;
UIOneJoint.prototype.isUIOneJoint = true;

UIOneJoint.prototype.initUIOneJoint = function(type) {
	this.initUIElement(type);	

	this.setDefSize(20, 20);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.setImage(UIElement.IMAGE_POINT, null);

	return this;
}

UIOneJoint.prototype.isUserResizable = function() {
	return false;
}

UIOneJoint.prototype.setSize = function(w, h) {
	this.w = 20;
	this.h = 20;

	return this;
}

UIOneJoint.prototype.paintSelfOnly = function(canvas) {
	var pImage = this.getImageByType(UIElement.IMAGE_POINT);
	if(pImage && pImage.getImage()) {
		var image = pImage.getImage();
		var srcRect = pImage.getImageRect();
		this.drawImageAt(canvas, image, this.images.display, 0, 0, this.w, this.h, srcRect);
	}
	else {
		var fillIt = !this.isFillColorTransparent();
		var strokeIt = !this.isStrokeColorTransparent();

		if(fillIt || strokeIt) {
			var x = this.w >> 1;
			var y = this.h >> 1;
			canvas.beginPath();
			canvas.arc(x, y, 10, 0, 2 * Math.PI);
			
			if(fillIt) {
				canvas.fillStyle = this.style.fillColor;
				canvas.fill();
			}

			if(strokeIt) {
				canvas.strokeStyle = this.style.lineColor;
				canvas.lineWidth = this.style.lineWidth;
				canvas.stroke();
			}
		}
	}

	return;
}

UIOneJoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIOneJointCreator() {
	var args = ["ui-one-joint", "ui-one-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIOneJoint();
		return g.initUIOneJoint(this.type);
	}
	
	return;
}
/*
 * File:   ui-four-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  four anchor joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * 
 */

function UIFourJoint() {
	return;
}

UIFourJoint.prototype = new UIElement();
UIFourJoint.prototype.isUIJoint = true;
UIFourJoint.prototype.isUIFourJoint = true;

UIFourJoint.prototype.initUIFourJoint = function(type, w, h) {
	this.initUIElement(type);	

	this.setDefSize(w, h);
	this.setTextType(Shape.TEXT_NONE);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;
	this.points = [{x:0, y:80}, {x:0, y:0}, {x:80, y:0},{x:80, y:80}];

	return this;
}

UIFourJoint.prototype.doToJson = function(o) {
	UIElement.prototype.doToJson.call(this, o);

	o.points = [{}, {},{},{}];
	o.points[0].x = this.points[0].x;
	o.points[0].y = this.points[0].y;
	o.points[1].x = this.points[1].x;
	o.points[1].y = this.points[1].y;
	o.points[2].x = this.points[2].x;
	o.points[2].y = this.points[2].y;
	o.points[3].x = this.points[3].x;
	o.points[3].y = this.points[3].y;

	return;
}

UIFourJoint.prototype.doFromJson = function(js) {
	UIElement.prototype.doFromJson.call(this, js);

	if(js.points) {
		this.points = js.points;
	}

	return;
}

UIFourJoint.prototype.asIcon = function() {
	if(!this.isIcon) {
		this.isIcon = true;
		this.points = [{x:0, y:80}, {x:20, y:0}, {x:60, y:0},{x:80, y:80}];
	}

	return;
}

UIFourJoint.prototype.relayout = function() {
	if(this.disableRelayout || this.isInDesignMode()) {
		return;
	}

	var p = getParentShapeOfShape(this);
	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);

	if(this.xAttr === UIElement.X_SCALE) {
		this.points[0].x = wParent * this.x0Param;
		this.points[1].x = wParent * this.x1Param;
		this.points[2].x = wParent * this.x2Param;
		this.points[3].x = wParent * this.x3Param;
	}
	
	if(this.yAttr === UIElement.Y_SCALE) {
		this.points[0].y = hParent * this.y0Param;
		this.points[1].y = hParent * this.y1Param;
		this.points[2].y = hParent * this.y2Param;
		this.points[3].y = hParent * this.y3Param;
	}

	return;
}

UIFourJoint.prototype.updateLayoutParams = function() {
	this.xParam = 1;
	this.yParam = 1;

	var p = this.parentShape;
	if(!p) {
		return;
	}

	var wParent = p.getWidth(true);
	var hParent = p.getHeight(true);
	
	if(this.xAttr === UIElement.X_SCALE) {
		this.x0Param = this.points[0].x / wParent;
		this.x1Param = this.points[1].x / wParent;
		this.x2Param = this.points[2].x / wParent;
		this.x3Param = this.points[3].x / wParent;
	}

	if(this.yAttr === UIElement.Y_SCALE) {
		this.y0Param = this.points[0].y / hParent;
		this.y1Param = this.points[1].y / hParent;
		this.y2Param = this.points[2].y / hParent;
		this.y3Param = this.points[3].y / hParent;
	}

	return;
}

UIFourJoint.prototype.hitTest = function(point) {
	if(Math.distanceBetween(point, this.points[0]) < 20) {
		return 1;
	}

	if(Math.distanceBetween(point, this.points[1]) < 20) {
		return 2;
	}

	if(Math.distanceBetween(point, this.points[2]) < 20) {
		return 3;
	}
	
	if(Math.distanceBetween(point, this.points[3]) < 20) {
		return 4;
	}

	return Shape.HIT_TEST_NONE;
}

UIFourJoint.prototype.getSelectMark = function(type, point) {
	var n =  this.points.length;
	if(type <= n) {
		point.x = this.points[type-1].x;
		point.y = this.points[type-1].y;

		return true;
	}

	return false;
}

UIFourJoint.prototype.onAppendedInParent = function() {
	if(this.isCreatingElement()) {
		var parentShape = this.getParent();
		var p = parentShape.getPositionInView();

		this.points[0].x -= p.x;
		this.points[0].y -= p.y;
		
		this.points[1].x -= p.x;
		this.points[1].y -= p.y;
		
		this.points[2].x -= p.x;
		this.points[2].y -= p.y;
		
		this.points[3].x -= p.x;
		this.points[3].y -= p.y;
	}

	return;
}

UIFourJoint.prototype.drawSelectMarks = function(canvas) {
	return UITwoJoint.prototype.drawSelectMarks.call(this, canvas);
}

UIFourJoint.prototype.getMinMaxX = function() {
	var max = this.points[0].x;
	var min = max;

	for(var i = 0; i < this.points.length; i++) {
		var p = this.points[i];
		if(p.x > max) {
			max = p.x;
		}
		if(p.x < min) {
			min = p.x;
		}
	}

	return {min:min, max:max};
}

UIFourJoint.prototype.getMinMaxY = function() {
	var max = this.points[0].y;
	var min = max;

	for(var i = 0; i < this.points.length; i++) {
		var p = this.points[i];
		if(p.y > max) {
			max = p.y;
		}
		if(p.y < min) {
			min = p.y;
		}
	}

	return {min:min, max:max};
}

UIFourJoint.prototype.getX = function() {
	return this.getMinMaxX().min;
}

UIFourJoint.prototype.getY = function() {
	return this.getMinMaxY().min;
}

UIFourJoint.prototype.getWidth = function() {
	var range = this.getMinMaxX();

	return range.max - range.min;
}

UIFourJoint.prototype.getHeight = function() {
	var range = this.getMinMaxY();

	return range.max - range.min;
}

UIFourJoint.prototype.paintSelf = function(canvas) {
	canvas.save();
	if(this.isIcon) {
		this.translate(canvas);
	}

	var r = this.anchorSize ? this.anchorSize : 5;
	canvas.lineWidth = this.style.lineWidth;
	canvas.fillStyle = this.style.fillColor;
	canvas.strokeStyle = this.style.lineColor;
	
	canvas.beginPath();
	canvas.moveTo(this.points[0].x, this.points[0].y);
	canvas.lineTo(this.points[1].x, this.points[1].y);
	canvas.lineTo(this.points[2].x, this.points[2].y);
	canvas.lineTo(this.points[3].x, this.points[3].y);
	canvas.stroke();
	
	canvas.beginPath();
	canvas.arc(this.points[0].x, this.points[0].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[1].x, this.points[1].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[2].x, this.points[2].y, r, 0, Math.PI * 2);
	canvas.fill();
	canvas.beginPath();
	canvas.arc(this.points[3].x, this.points[3].y, r, 0, Math.PI * 2);
	canvas.fill();

	canvas.beginPath();

	canvas.restore();
	
	this.drawSelectMarks(canvas);

	return;
}

UIFourJoint.prototype.shapeCanBeChild = function(shape) {
	return false;
}

UIFourJoint.prototype.onPointerDownNormal = function(point) {
	this.hitTestResult = this.hitTest(point);
	this.selected = this.hitTestResult != Shape.HIT_TEST_NONE;

	return this.hitTestResult;
}

UIFourJoint.prototype.onPointerMoveNormal = function(point) {
	 if(this.isInDesignMode() && this.hitTestResult > 0) {
	 	var index = this.hitTestResult - 1;
	 	this.points[index].x = point.x;
	 	this.points[index].y = point.y;
	 }
}

UIFourJoint.prototype.onPointerUpNormal = function(point) {
	this.hitTestResult = Shape.HIT_TEST_NONE;

	return;
}

UIFourJoint.prototype.onPointerDownCreating = function(point) {
	switch(this.state) {
		case Shape.STAT_CREATING_0: {
			this.state = Shape.STAT_NORMAL;
		}
		default: {
			return false;
		}
	}
}

UIFourJoint.prototype.onPointerMoveCreating = function(point) {
	switch(this.state) {
		case Shape.STAT_CREATING_0: {
			this.points[0].x = point.x;
			this.points[0].y = point.y + 80;
			this.points[1].x = point.x + 20;
			this.points[1].y = point.y;
			this.points[2].x = point.x + 60;
			this.points[2].y = point.y;
			this.points[3].x = point.x + 80;
			this.points[3].y = point.y + 80;
			return true;
		}
		default: {
			return false;
		}
	}
}

function UIFourJointCreator() {
	var args = ["ui-four-joint", "ui-four-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIFourJoint();
		return g.initUIFourJoint(this.type, 200, 200);
	}
	
	return;
}

/*
 * File:   ui-revolute-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  foot print
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIRevoluteJoint
 * @extends UIElement
 * 转动关节。它将两个刚体钉在一起，或者把一个刚体钉在场景上。
 * 可以设置马达参数、 角度限制和其他参数，来决定两个刚体之间的相对运动。
 *
 */
function UIRevoluteJoint() {
	return;
}

UIRevoluteJoint.prototype = new UIOneJoint();
UIRevoluteJoint.prototype.isUIJoint = true;
UIRevoluteJoint.prototype.isUIRevoluteJoint = true;

UIRevoluteJoint.prototype.saveProps = ["enableMotor", "enableLimit", "lowerAngle", "upperAngle", "maxMotorTorque", "motorSpeed"];
UIRevoluteJoint.prototype.initUIRevoluteJoint = function(type) {
	this.initUIOneJoint(type);	
	
	return this;
}

/**
 *  @method setEnable
 *  设置启用马达。
 *  @return {UIElement} 返回控件本身
 *  
 */
UIRevoluteJoint.prototype.setEnable = function(enable) {
    if(this.joint) {
		this.joint.EnableMotor(enable);
        this.enableMotor = this.enable = enable;
    }

    return this;
}

/**
 * @method isEnable
 * 获取是否启用马达
 * @return {Boolean} 返回是否启用马达
 *
 */
UIRevoluteJoint.prototype.isEnable = function() {
    if(this.joint) {
        return this.joint.IsMotorEnabled();
    }

    return enableMotor;
}

/**
 * @method setMaxMotorTorque
 * 设置最大马达力矩
 * @return {UIElement} 返回控件本身
 *
 */
UIRevoluteJoint.prototype.setMaxMotorTorque = function(torque) {
    if(this.joint) {
        this.joint.SetMaxMotorTorque(torque);
    }
    
    return this;
}

/**
 * @method getMotorTorque
 * 获取马达力矩。
 * @return {Number} 返回马达力矩。
 *
 */
UIRevoluteJoint.prototype.getMotorTorque = function() {
    if(this.joint) {
        return this.joint.GetMotorTorque();
    }

    return 0;
}

/**
 * @method setLimitEnable
 * 设置马达角度限制。
 * @param {Boolean} enable 是否启用马达角度限制。
 * @return {UIElement} 返回控件本身。
 * 
 */
UIRevoluteJoint.prototype.setLimitEnable = function(enable) {
    if(this.joint) {
        this.joint.EnableLimit(enable);   
        this.enableLimit = enable;
    }

    return this;
}

/**
 * @method getLimitEnable
 * 获取马达角度限制。
 * @return {Boolean} 是否开启了角度限制。
 * 
 */
UIRevoluteJoint.prototype.getLimitEnable = function() {
    if(this.joint) {
        return this.joint.IsLimitEnabled();
    }
    return this.enableLimit;
}

/**
 * @method setLimits
 * 设置马达限制的角度范围，只有开启了马达限制才会生效。
 * @param {Number} lower 角度下限(弧度)。
 * @param {Number} upper 角度上限(弧度)。
 * @return {UIElement} 返回控件本身。
 * 
 */
UIRevoluteJoint.prototype.setLimits = function(lower, upper) {
    if(this.joint) {
        this.joint.SetLimits(lower, upper);
    }

    return this;
}

/**
 * @getLowerLimit 
 * 获取角度限制的下限。
 * @return {Number} 角度下限。
 *
 */
UIRevoluteJoint.prototype.getLowerLimit = function() {
    if(this.joint) {
        return this.joint.GetLowerLimit();
    }

    return 0;
}

/**
 * @getUpperLimit
 * 获取角度限制的上限。
 * @return {Number} 角度上限。
 *
 */
UIRevoluteJoint.prototype.getUpperLimit = function() {
    if(this.joint) {
        return this.joint.GetUpperLimit();
    }

    return 0;
}

/**
 * @method getJointAngle
 * 获取关节角度。
 * @return {Number} 返回关节的旋转角度。
 *
 */
UIRevoluteJoint.prototype.getJointAngle = function() {
    if(this.joint) {
        return this.joint.GetJointAngle();
    }

    return 0;
}

/**
 * @method getJointSpeed
 * 获取关节转动速度。
 * @return {Number} 返回关节转动速度。
 *
 */
UIRevoluteJoint.prototype.getJointSpeed = function() {
    if(this.joint) {
        return this.joint.GetJointSpeed();
    }

    return 0;
}

/**
 * @method setMotorSpeed
 * 设置马达的转速（只有在启用马达时有效）。
 * @param {Number} motorSpeed 转速。单位为弧度，正数顺时针转，负数逆时针转。 
 * @return {UIElement} 返回控件本身。
 *
 */
UIRevoluteJoint.prototype.setValue = UIRevoluteJoint.prototype.setMotorSpeed = function(motorSpeed) {
	if(this.joint) {
		this.joint.SetMotorSpeed(motorSpeed);
	}

	return this;
}

/**
 * @method getJoint
 * 获取Box2d的Joint对象。
 * @return {Object} 返回Joint对象。
 *
 * 参考：http://bacon2d.com/docs/qml-bacon2d-revolutejoint.html
 *
 */
UIRevoluteJoint.prototype.getJoint = function() { 
	return this.joint;
}

/**
 * @method getMotorSpeed
 * 获取马达的转速。
 * @return {Number} 返回马达的转速。
 *
 */
UIRevoluteJoint.prototype.getValue = UIRevoluteJoint.prototype.getMotorSpeed = function() {
	if(this.joint) {
		return this.joint.GetMotorSpeed();
	}

	return 0;
}

UIRevoluteJoint.prototype.recreateJoint = function() {
	var world = this.getWindow().world;

	if(world) {
		Physics.destroyJointForElement(world, this);
		Physics.createJoint(world, this);
	}

	return;
}

function UIRevoluteJointCreator() {
	var args = ["ui-revolute-joint", "ui-revolute-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIRevoluteJoint();
		return g.initUIRevoluteJoint(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIRevoluteJointCreator());

/*
 * File:   ui-distance-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  distance joint 
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIDistanceJoint
 * @extends UITwoPoints
 * 把两个刚体链接在一起，保持它们的距离不变。
 *
 */
function UIDistanceJoint() {
	return;
}

UIDistanceJoint.prototype = new UITwoJoint();
UIDistanceJoint.prototype.isUIJoint = true;
UIDistanceJoint.prototype.isUIDistanceJoint = true;

UIDistanceJoint.prototype.saveProps = ["collideConnected", "frequencyHz", "dampingRatio", "disableBounce"];
UIDistanceJoint.prototype.initUIDistanceJoint = function(type, w, h) {
	this.initUITwoJoint(type, w, h);	
	
	this.frequencyHz = 4;
	this.dampingRatio = 0.5;
	this.disableBounce = false;
	this.collideConnected = true;

	return this;
}

function UIDistanceJointCreator() {
	var args = ["ui-distance-joint", "ui-distance-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDistanceJoint();
		return g.initUIDistanceJoint(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIDistanceJointCreator());

/*
 * File:   ui-edge.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  edge shape
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 * 
 */

/**
 * @class UIEdge
 * @extends UITwoPoints
 * 边刚体。可以用一些线段来模拟复杂的地形。边刚体是静态刚体，只能设置摩擦力和弹力系数。
 */
function UIEdge() {
	return;
}

UIEdge.prototype = new UITwoPoints();
UIEdge.prototype.isUIEdge = true;
UIEdge.prototype.isUIPhysicsShape = true;
UIEdge.prototype.saveProps = ["friction", "restitution", "density", "groupIndex"];

UIEdge.prototype.initUIEdge = function(type, w, h) {
	this.initUITwoPoints(type);	

	return this;
}

UIEdge.prototype.setEnable = function(enable) {
	this.enable = enable;
	if(this.body) {
		this.body.SetActive(enable);
	}

	return this;
}


UIEdge.prototype.onPositionChanged = function() {
	var win = this.win;
	if(this.body) {
		var parent = this.getParent();
		var p0 = parent.localToGlobal(this.points[0]);
		var p1 = parent.localToGlobal(this.points[1]);
		var x = (p0.x + p1.x) >> 1;
		var y = (p0.y + p1.y) >> 1;
		var p = {};
		p.x = win.toMeter(x); 
		p.y = win.toMeter(y); 
		
		this.body.SetPosition(p);
	}

	return; 
}

UIEdge.prototype.onBodyCreated = function() {
}

function UIEdgeCreator() {
	var args = ["ui-edge", "ui-edge", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIEdge();
		return g.initUIEdge(this.type, 200, 200);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIEdgeCreator());

function Physics() {
};

Physics.pixelsPerMeter = 10;

Physics.toMeter = function(pixel) {
	return pixel / Physics.pixelsPerMeter;
}

Physics.toPixel = function(meter) {
	return meter * Physics.pixelsPerMeter;
}

Physics.createFixtureDef = function(world, element) {
	var hw = element.w >> 1;
	var hh = element.h >> 1;
	var fixtureDef = new b2FixtureDef();
	var x = element.left + hw;
	var y = element.top + hh;

	fixtureDef.density = element.density;
	fixtureDef.friction = element.friction;
	fixtureDef.restitution = element.restitution;

	if(element.categoryBits) {
		fixtureDef.filter.categoryBits = element.categoryBits;
	}

	if(element.maskBits) {
		fixtureDef.filter.maskBits = element.maskBits;
	}

	if(element.groupIndex) {
		fixtureDef.filter.groupIndex = element.groupIndex;
	}

	if(element.isSensor) {
		fixtureDef.isSensor = true;
	}

	if(element.isUICircle || element.physicsShape === "circle") {
		hw = element.getWidth(true) >> 1;
		hh = element.getHeight(true) >> 1;
		var radius = Physics.toMeter(Math.min(hw, hh));
		fixtureDef.shape = new b2CircleShape(radius);
	}
	else if(element.isUIBox || element.physicsShape ===	"rectangle") {
	        hw = element.getWidth(true) >> 1;
	        hh = element.getHeight(true) >> 1;
	        fixtureDef.shape = new b2PolygonShape();
	        fixtureDef.shape.SetAsBox(Physics.toMeter(hw),	Physics.toMeter(hh));
	}
	else if(element.isUIPolygon) {
		    var cx = hw;
	        var cy = hh;
	        var arr = [];
	        var fixtureDefs = [];
	        var n = element.children.length;
			if(n < 3) {
				alert("Polygon has no enough points");
				return null;
			}
            var result = element.getVerticesArray();
            var vertices = result.vertices;
            if(result.complex) {
                for(var i = 0; i < vertices.length; i = i + 3) {
                    var arr = vertices.slice(i, i + 3);
                    arr = arr.map(function(p){return new b2Vec2(Physics.toMeter(p.x -cx), Physics.toMeter(p.y -cy))});
                    fixtureDef = new b2FixtureDef();
                    fixtureDef.density = element.density;
                    fixtureDef.friction = element.friction;
                    fixtureDef.restitution = element.restitution;
                    fixtureDef.isSensor = element.isSensor;
                    if(element.categoryBits) {
                        fixtureDef.filter.categoryBits = element.categoryBits;
                    }
                    if(element.maskBits) {
                        fixtureDef.filter.maskBits = element.maskBits;
                    }
                    if(element.groupIndex) {
                        fixtureDef.filter.groupIndex = element.groupIndex;
                    }

                    fixtureDef.shape = new	b2PolygonShape();
                    fixtureDef.shape.SetAsArray(arr, arr.length);
                    fixtureDefs.push(fixtureDef);
                }
            } else {
                fixtureDef = new b2FixtureDef();
                fixtureDef.density = element.density;
                fixtureDef.friction = element.friction;
                fixtureDef.restitution = element.restitution;
                fixtureDef.isSensor = element.isSensor;
                if(element.categoryBits) {
                    fixtureDef.filter.categoryBits = element.categoryBits;
                }
                if(element.maskBits) {
                    fixtureDef.filter.maskBits = element.maskBits;
                }
                if(element.groupIndex) {
                    fixtureDef.filter.groupIndex = element.groupIndex;
                }

                var arr = vertices.map(function(p){return new b2Vec2(Physics.toMeter(p.x -cx), Physics.toMeter(p.y -cy))});
                fixtureDef.shape = b2PolygonShape.AsArray(arr, arr.length);
                fixtureDefs.push(fixtureDef);
            }

	        return fixtureDefs.length > 1 ? fixtureDefs : fixtureDefs[0];
	}
	else if(element.isUIEdge) {
			var parent = element.getParent();
			var p0 = parent.localToGlobal(element.points[0]);
			var p1 = parent.localToGlobal(element.points[1]);

			var cx = (p0.x + p1.x) >> 1;
			var cy = (p0.y + p1.y) >> 1;
			var x0 = p0.x - cx;
			var y0 = p0.y - cy;
			var x1 = p1.x - cx;
			var y1 = p1.y - cy;
			var v0 = new b2Vec2(Physics.toMeter(x0), Physics.toMeter(y0));
			var v1 = new b2Vec2(Physics.toMeter(x1), Physics.toMeter(y1));
			fixtureDef.shape = new b2PolygonShape()
			fixtureDef.shape.SetAsEdge(v0, v1);
	}

	return fixtureDef;
}

Physics.createBody = function(world, element) {
    if(element.fixture || element.body) {
        return;
    }
	var body = null;
	var pos = element.getPositionInWindow();
	var hw = element.getWidth() >> 1;
	var hh = element.getHeight() >> 1;
	var x  = pos.x + hw;
	var y  = pos.y + hh;
	var density = element.density;
	var bodyDef = new b2BodyDef();
	var fixtureDef = Physics.createFixtureDef(world, element);

	if(density < 0) {
		bodyDef.type = b2Body.b2_kinematicBody;
	}
	else {
		bodyDef.type = density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
	}

	if(element.isUIEdge) {
		var parent = element.getParent();
		var p0 = parent.localToGlobal(element.points[0]);
		var p1 = parent.localToGlobal(element.points[1]);
		x = (p0.x + p1.x) >> 1;
		y = (p0.y + p1.y) >> 1;
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	}
	else {
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	}
	
	if(element.fixedRotation) {
		bodyDef.fixedRotation = true;
	}
	
	if(element.isBullet) {
		bodyDef.bullet = true;
	}
	
	if(element.allowSleep) {
		bodyDef.awake = true;
		bodyDef.allowSleep = true;
	}
	else {
		bodyDef.allowSleep = false;
	}
					
	bodyDef.linearDamping = element.linearDamping || 0;
	bodyDef.angularDamping = element.angularDamping || 0;

	body = world.CreateBody(bodyDef);
	if(fixtureDef.length) {
		for(var i = 0; i < fixtureDef.length; i++) {
			body.CreateFixture(fixtureDef[i]);
		}
		console.log("Create Composite Polygon: n=" + fixtureDef.length);
	}
	else {
		body.CreateFixture(fixtureDef);
	}

    body.GetFixtureList().m_shape.element = element;
    element.fixture = body.GetFixtureList().m_shape;
    body.element = element;
	body.name = element.name;
	element.body = body;

	if(element.rotation) {
		body.SetAngle(element.rotation);
	}

	if(!element.enable) {
		body.SetActive(false);
	}

	if(element.xInitVelocity || element.yInitVelocity) {
		element.setV(element.xInitVelocity, element.yInitVelocity);
	}

	element.onBodyCreated();

	return body;
}

Physics.createEmbedBody = function(world, parentElement, childElement) {
	var bodyDef = null;
	var fixtureDef = Physics.createFixtureDef(world, childElement);

	if(!bodyDef) {
		var pos = parentElement.getPositionInWindow();
		var hw = parentElement.w >> 1;
		var hh = parentElement.h >> 1;
		var x  = pos.x + hw;
		var y  = pos.y + hh;
		
		bodyDef = new b2BodyDef();
		if(fixtureDef.density < 0) {
			delete fixtureDef.density;
			b2BodyDef.type = b2Body.b2_kinematicBody;
		}
		else {
			bodyDef.type = fixtureDef.density ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
		}
		bodyDef.position.Set(Physics.toMeter(x), Physics.toMeter(y));
	
		if(parentElement.fixedRotation || childElement.fixedRotation) {
			bodyDef.fixedRotation = true;
		}

		if(parentElement.isBullet || childElement.isBullet) {
			bodyDef.bullet = true;
		}

		if(parentElement.allowSleep || childElement.allowSleep) {
			bodyDef.awake = true;
			bodyDef.allowSleep = true;
		}
		else {
			bodyDef.allowSleep = false;
		}
		
		if(childElement.linearDamping !== undefined) {
			bodyDef.linearDamping = childElement.linearDamping;
		}
		
		if(childElement.angularDamping !== undefined) {
			bodyDef.angularDamping = childElement.angularDamping;
		}

		var body = world.CreateBody(bodyDef);
		body.element = parentElement;
		parentElement.body = body;
		
		if(!parentElement.enable || !childElement.enable) {
			body.SetActive(false);
		}
	}

	body.CreateFixture(fixtureDef);

	return body;
}

Physics.createBodyForElement = function(world, parentElement, childElement) {
	if(childElement.physicsShape) {
		Physics.createBody(world, childElement);	
	}
	else if(childElement.isUIPhysicsShape) {
		if(parentElement.isUIWindow) {
			Physics.createBody(world, childElement);
		}
		else if(parentElement.isUISprite || parentElement.isUISkeletonAnimation 
			|| parentElement.isUITransformAnimation || parentElement.isUIFrameAnimation){
			Physics.createEmbedBody(world, parentElement, childElement);
		}
		else {
			Physics.createBody(world, childElement);
		}
	} else {
		Physics.createWorldShapes(world, childElement);
	}

	return;
}

Physics.destroyBodyForElement = function(world, element) {
	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.destroyBodyForElement(world, iter);
	}
	
	if(element.body) {
		var body = element.body;
		body.SetActive(false);
		
		setTimeout(function() {			
			world.DestroyBody(body);
		}, 0);

		body.element = null;
		element.body = null;
	}

	return;
}

Physics.destroyJointForElement = function(world, element) {
	if(element.joint) {
        var joint = element.joint;
        element.joint = null;
		setTimeout(function() {
			world.DestroyJoint(joint);
            joint = null;
		}, 0);
	}

	return;
}

Physics.createWorldShapes = function(world, element) {
	var x = 0;
	var y = 0;
	var bodyDef = null;
	var fixtureDef = null;

	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.createBodyForElement(world, element, iter);
	}

	return;
}

Physics.findBodiesAtPoint = function(scene, point, index) {
	var arr = [];
	var n = scene.children.length;

	var canvas = cantkGetTempCanvas(scene.w, scene.h);
	var ctx = canvas.getContext("2d");

	for(var i = index; i >= 0; i--) {
		var iter = scene.children[i];
		if(!iter.body) {
			continue;
		}

		var rect = {x:iter.left, y:iter.top, w:iter.w, h:iter.h};
		if(iter.rotation) {
			ctx.save();
			ctx.beginPath();
			ctx.translate(rect.x, rect.y);
			if(iter.rotation) {
				ctx.translate(rect.w >> 1, rect.h >> 1);
				ctx.rotate(iter.rotation);
				ctx.translate(-(rect.w >> 1), -(rect.h >> 1));
			}
			ctx.rect(0, 0, rect.w, rect.h);
			if(ctx.isPointInPath(point.x, point.y)) {
				arr.push(iter.body);
			}
			ctx.restore();
		}
		else {
			if(isPointInRect(point, rect)) {
				arr.push(iter.body);
			}
		}
	}

	return arr;
}

Physics.createJoint = function(world, element, scene) {
	var scene = element.getWindow();
	if(!element.isUIJoint || element.isUIMouseJoint) {
		return;
	}

	if(element.isUIOneJoint) {
		var p = {};
		var arr = null;
		p.x = element.left + (element.w >> 1);
		p.y = element.top + (element.h >> 1);

		var index = element.getIndex();
		arr = Physics.findBodiesAtPoint(scene, p, index);

		if(arr.length == 1) {
			arr = [world.GetGroundBody(), arr[0]];
		}

		if(arr.length > 1) {
			var rJointDef = null;
			var anchorPoint = new b2Vec2(Physics.toMeter(p.x), Physics.toMeter(p.y));

			if(arr[0].GetType() === b2Body.b2_staticBody && arr[1].GetType() === b2Body.b2_staticBody) {
				console.log("%cWarning: it seems no meanings to pin two static body together.", 
					"color: red; font-weight: bold");
			}
			
			if(element.isUIRevoluteJoint) {
				rJointDef = new b2RevoluteJointDef();
				rJointDef.Initialize(arr[0], arr[1], anchorPoint);

				rJointDef.lowerAngle = (element.lowerAngle ? element.lowerAngle : 0)*Math.PI/180;
				rJointDef.upperAngle = (element.upperAngle ? element.upperAngle : 0)*Math.PI/180;
				rJointDef.motorSpeed = element.motorSpeed ? element.motorSpeed : 0;
				rJointDef.maxMotorTorque = element.maxMotorTorque ? element.maxMotorTorque : 0;
				rJointDef.enableLimit = element.enableLimit ? element.enableLimit : false;
				rJointDef.enableMotor = element.enableMotor ? element.enableMotor : false;
			}
			else if(element.isUIWeldJoint) {
				rJointDef = new b2WeldJointDef();
				rJointDef.Initialize(arr[0], arr[1], anchorPoint);
			}

			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}
	else if(element.isUITwoJoint) {
		var rJointDef = null;
		var p0 = element.points[0];
		var p1 = element.points[1];
		var index = element.getIndex();
		var arr0 = Physics.findBodiesAtPoint(scene, p0, index);
		var arr1 = Physics.findBodiesAtPoint(scene, p1, index);

		if(arr0.length && arr1.length) {
			var anchorPoint0 = new b2Vec2(Physics.toMeter(p0.x), Physics.toMeter(p0.y));
			var anchorPoint1 = new b2Vec2(Physics.toMeter(p1.x), Physics.toMeter(p1.y));

			if(element.disableBounce) {
				var anchorPoint = new b2Vec2(Physics.toMeter((p0.x+p1.x) >> 1), Physics.toMeter((p0.y + p1.y)>>1));
				rJointDef = new b2RevoluteJointDef();
				rJointDef.Initialize(arr0[0], arr1[0], anchorPoint);

				rJointDef.lowerAngle = (element.lowerAngle ? element.lowerAngle : 0)*Math.PI/180;
				rJointDef.upperAngle = (element.upperAngle ? element.upperAngle : 0)*Math.PI/180;
				rJointDef.motorSpeed = element.motorSpeed ? element.motorSpeed : 0;
				rJointDef.maxMotorTorque = element.maxMotorTorque ? element.maxMotorTorque : 0;
				rJointDef.enableLimit = element.enableLimit ? element.enableLimit : false;
				rJointDef.enableMotor = element.enableMotor ? element.enableMotor : false;
				rJointDef.collideConnected = element.collideConnected;
			}else if(element.isUIDistanceJoint) {
				rJointDef = new b2DistanceJointDef();
				rJointDef.Initialize(arr0[0], arr1[0], anchorPoint0, anchorPoint1);

				rJointDef.frequencyHz = element.frequencyHz || 0;
				rJointDef.dampingRatio = element.dampingRatio || 0;
				rJointDef.collideConnected = element.collideConnected;
			}
			else if(element.isUILineJoint) {
				var dx = anchorPoint1.x - anchorPoint0.x;
				var dy = anchorPoint1.y - anchorPoint0.y;
				var axis = {};

				axis.x = dx/Math.sqrt(dx*dx+dy*dy);
				axis.y = dy/Math.sqrt(dx*dx+dy*dy);

				rJointDef = new b2LineJointDef();
				rJointDef.Initialize(arr0[0], arr0[1], anchorPoint0, axis);
				rJointDef.enableLimit = true;
				rJointDef.lowerTranslation = 0;
				rJointDef.upperTranslation = 10;
				rJointDef.enableMotor = false;
				rJointDef.maxMotorForce = 300000;
				rJointDef.motorSpeed = 1;
			}

			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}
	else if(element.isUIPulleyJoint) {
		var rJointDef = null;
		var p0 = element.points[0];
		var p1 = element.points[1];
		var p2 = element.points[2];
		var p3 = element.points[3];
		var index = element.getIndex();
		var arr0 = Physics.findBodiesAtPoint(scene, p0, index);
		var arr1 = Physics.findBodiesAtPoint(scene, p3, index);

		if(arr0.length && arr1.length) {
			rJointDef = new b2PulleyJointDef();
			var ratio = 1;
			var anchorPoint0 = new b2Vec2(Physics.toMeter(p0.x), Physics.toMeter(p0.y));
			var anchorPoint1 = new b2Vec2(Physics.toMeter(p1.x), Physics.toMeter(p1.y));
			var anchorPoint2 = new b2Vec2(Physics.toMeter(p2.x), Physics.toMeter(p2.y));
			var anchorPoint3 = new b2Vec2(Physics.toMeter(p3.x), Physics.toMeter(p3.y));

			rJointDef.Initialize(arr0[0], arr1[0], anchorPoint1, anchorPoint2, anchorPoint0, anchorPoint3, ratio);
			
			var joint = world.CreateJoint(rJointDef);
			joint.element = element;
			element.joint = joint;
		}
		else {
			console.log("not found body");
		}
	}

	return;
}

Physics.createWorldJoints = function(world, scene, element) {
	for(var i = 0; i < element.children.length; i++) {
		var iter = element.children[i];

		Physics.createWorldJoints(world, scene, iter);
	}

	Physics.createJoint(world, element, scene);
}

Physics.getBodySize = function(body) {
    var fixture = body.GetFixtureList();
    var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
    var pb = body.GetPosition();
    while(fixture) {
        var shape = fixture.m_shape;
        if(shape instanceof b2CircleShape){
            if(maxX < pb.x + shape.m_p.x + shape.m_radius) {
                maxX = pb.x + shape.m_p.x + shape.m_radius
            } 
            if(maxY < pb.y + shape.m_p.y + shape.m_radius){
                maxY = pb.y + shape.m_p.y + shape.m_radius
            }
            if(minX > pb.x + shape.m_p.x - shape.m_radius) {
                minX = pb.x + shape.m_p.x - shape.m_radius
            } 
            if(minY > pb.y + shape.m_p.y - shape.m_radius){
                minY = pb.y + shape.m_p.y - shape.m_radius
            }
        } else if(shape instanceof b2PolygonShape) {
            for(var i = 0; i < shape.m_vertexCount; i++) {
                var vert = shape.m_vertices[i];
                if(minX > pb.x + vert.x) {
                    minX = pb.x + vert.x;
                }
                if(maxX < pb.x + vert.x) {
                    maxX = pb.x + vert.x;
                }
                if(minY > pb.y + vert.y) {
                    minY = pb.y + vert.y
                }
                if(maxY < pb.y + vert.y) {
                    maxY = pb.y + vert.y;
                }
            }
        }
        fixture = fixture.m_next;
    }
    return {w:Physics.toPixel(maxX - minX), h:Physics.toPixel(maxY - minY)}
}

Physics.createUIRubeBody = function(body, world, scene) {
    var rubeBody = ShapeFactoryGet().createShape("ui-rube-body", "from RUBE");
    rubeBody.setBody(body);
    rubeBody.setGravityScale({x:body.gravityScale, y:body.gravityScale});
    rubeBody.name = body.name;
    rubeBody.setZIndex(0);
    rubeBody.setAnchor(0.5, 0.5);
    var size = Physics.getBodySize(body);
    rubeBody.resize(size.w, size.h);
    body.element = rubeBody;
    scene.addChild(rubeBody);
    
    return rubeBody;
}

Physics.createElementForJoint = function(joint, world, scene) {
    var shape = joint;
    if(shape instanceof b2RevoluteJoint) {
        console.log("create b2RevoluteJoint");
    } else if(shape instanceof b2DistanceJoint){
        console.log("create b2DistanceJoint");
    } else if(shape instanceof b2PrismaticJoint) {
        console.log("crate b2PrismaticJoint");
    } else if(shape instanceof b2FrictionJoint) {
        console.log("create b2FrictionJoint");
    } else if(shape instanceof b2WeldJoint) {
        console.log("create b2WeldJoint");
    } else {
        console.warn("RUBE: unknown joint type");
    }
}

Physics.updateBodyElementsPosition = function(world) {
	for (var b = world.m_bodyList; b; b = b.m_next) {
        var element = b.element;
        
		if(element && element.getParent()) {
			var a = b.GetAngle();
			var p = b.GetPosition();
            if(p.x !== undefined && p.y !== undefined) {
                var x = Physics.toPixel(p.x) - (element.getWidth() >> 1);
                var y = Physics.toPixel(p.y) - (element.getHeight() >> 1);

                var parent = element.getParent();
                if(!parent.isUIWindow) {
                    var pos = parent.getPositionInWindow();
                    x = x - pos.x;
                    y = y - pos.y;
                }

                var ox = element.left;
                var oy = element.top;

                element.setRotation(a);
                if(ox !== x || oy !== y) {
                    element.setPositionByBody(x, y);
                }
            }
		}
	}

	for (var joint = world.m_jointList; joint; joint = joint.m_next) {
		var element = joint.element;
		if(!element || !element.getParent()) continue;

		switch (joint.m_type) {
			case b2Joint.e_distanceJoint: {
				var p0 = joint.GetAnchorA();
				var p1 = joint.GetAnchorB();
				var element = joint.element;

				element.points[0].x = Physics.toPixel(p0.x);
				element.points[0].y = Physics.toPixel(p0.y);

				element.points[1].x = Physics.toPixel(p1.x);
				element.points[1].y = Physics.toPixel(p1.y);
				break;
			}
			case b2Joint.e_pulleyJoint: {
				var p0 = joint.GetAnchorA();
				var p1 = joint.GetGroundAnchorA();
				var p2 = joint.GetGroundAnchorB();
				var p3 = joint.GetAnchorB();

				var element = joint.element;

				element.points[0].x = Physics.toPixel(p0.x);
				element.points[0].y = Physics.toPixel(p0.y);

				element.points[1].x = Physics.toPixel(p1.x);
				element.points[1].y = Physics.toPixel(p1.y);

				element.points[2].x = Physics.toPixel(p2.x);
				element.points[2].y = Physics.toPixel(p2.y);

				element.points[3].x = Physics.toPixel(p3.x);
				element.points[3].y = Physics.toPixel(p3.y);
				break;
			}
			default: {
				var p = joint.GetAnchorA();
				var element = joint.element;
				if(element.isUIDistanceJoint) {
					var p0 = joint.GetAnchorA();
					var p1 = joint.GetAnchorB();

					element.points[0].x = Physics.toPixel(p0.x);
					element.points[0].y = Physics.toPixel(p0.y);

					element.points[1].x = Physics.toPixel(p1.x);
					element.points[1].y = Physics.toPixel(p1.y);
				}
				else {
					var x = Physics.toPixel(p.x) - (element.w >> 1);
					var y = Physics.toPixel(p.y) - (element.h >> 1);
					element.setPositionByBody(x, y);
				}

				break;
			}
		}
	}

	return;
}

Physics.destroyWorld = function(world) {
	var b = world.m_bodyList;
	do {
		if(!b) break;

		var next = b.m_next;
		if(b.element) {
			b.element.body = null;
			b.element = null;
		}
		
		world.DestroyBody(b);

		b = next;
	}while(true);

	var joint = world.m_jointList;
	do {
		if(!joint) break;
		var next = joint.m_next;

		if(joint.element) {
			joint.element = null;
		}
			
		world.DestroyJoint(joint);

		joint = next;
	}while(true);

	return;
}

Physics.reparentPhysicsToScene = function(scene) {
	var arr = [];

	function onVisit(el) {
		var parentShape = el.getParent();
		if(el.isUISkeletonAnimation || el.isUISprite || el.isUIFrameAnimation || el.isUITransformAnimation) {
			if(!parentShape.isUIWindow) {
				arr.push(el);
			}
		}
		else if(el.isUIPhysicsShape) {
			if(!parentShape.isUISkeletonAnimation && !parentShape.isUISprite 
				&& !parentShape.isUIFrameAnimation && !parentShape.isUITransformAnimation
				&& !parentShape.isUIWindow) {
					arr.push(el);
			}
		}
	}

	scene.forEach(onVisit);

	for(var i = 0; i < arr.length; i++) {
		var iter = arr[i];
		iter.reparent(scene, true);
	}

	return;
}

Physics.setEventListeners = function(world) {
	var listener = new b2ContactListener();
	listener.BeginContact = function (contact) {
        var body1 = contact.GetFixtureA().GetBody();
        var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;
		
        if(element1 && element2) {
			element1.callOnBeginContactHandler(body2, contact);
			element2.callOnBeginContactHandler(body1, contact);
		}
	}
	
	listener.EndContact = function (contact) {
        var body1 = contact.GetFixtureA().GetBody();
        var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			element1.callOnEndContactHandler(body2, contact);
			element2.callOnEndContactHandler(body1, contact);
		}
	}
	
	listener.PreSolve = function (contact, oldManifold) {
        var body1 = contact.GetFixtureA().GetBody();
        var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			element1.callOnPreSolveHandler(body2, contact, oldManifold);
			element2.callOnPreSolveHandler(body1, contact, oldManifold);
		}
	}

	listener.PostSolve = function (contact, impulse) {
        var body1 = contact.GetFixtureA().GetBody();
        var body2 = contact.GetFixtureB().GetBody();
		var element1 = body1.element;
		var element2 = body2.element;

		if(element1 && element2) {
			element1.callOnPostSolveHandler(body2, contact, impulse);
			element2.callOnPostSolveHandler(body1, contact, impulse);
		}
	}

	world.SetContactListener(listener);
}

Physics.createWorld = function(scene) {
	if(scene.world || !window.b2World) {
		return;
	}
	
	if(!scene.pixelsPerMeter) {
		scene.pixelsPerMeter = 100;
	}
	var velocityIterations = scene.velocityIterations || 8;
	var positionIterations = scene.positionIterations || 3;
	var gravity = new b2Vec2(scene.gravityX || 0, scene.gravityY || 0);
	var world = new b2World(gravity, scene.allowSleep || false);
	Physics.pixelsPerMeter = scene.pixelsPerMeter || 100;

	Physics.createWorldShapes(world, scene);
	Physics.createWorldJoints(world, scene, scene);
	Physics.setEventListeners(world);
    world.SetWarmStarting(scene.warmStarting);

	scene.world = world;
	Physics.startTimer(world, scene, velocityIterations, positionIterations);
}

Physics.startTimer = function(world, scene, velocityIterations, positionIterations) {
	var timeStep = 1/40;
	var timerID = setInterval(stepIt, timeStep * 1000);

	function stepIt(timestamp) {
		if(scene.world !== world) {
			console.log("World is recreated.");
			clearInterval(timerID);
			return false;
		}

		var realTimeStep = scene.scaleTime(timeStep);
		if(scene.timeScaleIsZero()) {
			realTimeStep = 0;
		}

		if(scene.isCurrent() && realTimeStep > 0) {
			world.Step(realTimeStep, velocityIterations, positionIterations);
		
			if(scene.autoClearForce) {
				world.ClearForces();
			}

			Physics.pixelsPerMeter = scene.pixelsPerMeter;
			Physics.updateBodyElementsPosition(world);
		}
	}

	return;
}

/*
 * File:   ui-mouse-joint.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  mouse joint, react with pointer event.
 * 
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 * 
 */

/**
 * @class UIMouseJoint
 * @extends UIElement
 * 鼠标关节。通过指针事件控制刚体的速度。
 *
 */
function UIMouseJoint() {
	return;
}

UIMouseJoint.prototype = new UIOneJoint();
UIMouseJoint.prototype.isUIMouseJoint = true;

UIMouseJoint.prototype.saveProps = ["speedScale", "enableTop", "enableLeft", "enableRight", "enableBottom"];
UIMouseJoint.prototype.initUIMouseJoint = function(type) {
	this.initUIOneJoint(type);	
	this.speedScale = 1;
	this.enableTop = true;
	this.enableLeft = true;
	this.enableRight = true;
	this.enableBottom = true;

	return this;
}

UIMouseJoint.prototype.onInit = function() {
	var sprite = this.getParent();
	var speedScale = this.speedScale;
	var enableLeft = this.enableLeft;
	var enableRight = this.enableRight;
	var enableTop = this.enableTop;
	var enableBottom = this.enableBottom;

	if(sprite.physicsShape || sprite.isUIPhysicsShape) {
		sprite.handlePointerDown = function(point, beforeChild) {
            if(!beforeChild) {
			    return UIMouseJoint.handleSpritePointerDown(sprite, point);	
            }
            return false;
		}

		sprite.handlePointerMove = function(point, beforeChild) {
            if(!beforeChild) {
			    return UIMouseJoint.handleSpritePointerMove(sprite, point);	
            }
            return false;
		}

		sprite.handlePointerUp = function(point, beforeChild) {
            if(!beforeChild) {
			    return UIMouseJoint.handleSpritePointerUp(sprite, point, speedScale, enableLeft, enableRight, enableTop, enableBottom);
            }
            return false;    
		}
	}
}

UIMouseJoint.handleSpritePointerDown = function(sprite, point) {
	sprite.body.SetLinearVelocity({x:0, y:0});

	return;
}

UIMouseJoint.handleSpritePointerMove = function(sprite, point) {
	sprite.body.SetLinearVelocity({x:0, y:0});

	return;
}

UIMouseJoint.prototype.setSpeedLimit = function(xMinV, xMaxV, yMinV, yMaxV) { 
	var sprite = this.getParent();

	sprite.xMinV = xMinV;
	sprite.yMinV = yMinV;
	sprite.xMaxV = xMaxV;
	sprite.yMaxV = yMaxV;

	return;
}

UIMouseJoint.handleSpritePointerUp = function(sprite, point, speedScale, enableLeft, enableRight, enableTop, enableBottom) {
	var dt = (Date.now() - sprite.pointerDownTime)/1000;
	var dx = sprite.getMoveAbsDeltaX();
	var dy = sprite.getMoveAbsDeltaY();
	var vx = speedScale * Physics.toMeter(dx)/dt;
	var vy = speedScale * Physics.toMeter(dy)/dt;

	if(!enableLeft && vx < 0) {
		vx = 0;
	}

	if(!enableTop && vy < 0) {
		vy = 0;
	}

	if(!enableRight && vx > 0) {
		vx = 0;
	}

	if(!enableBottom && vy > 0) {
		vy = 0;
	}

	var xMaxV = sprite.xMaxV;
	if(xMaxV && Math.abs(vx) > xMaxV) {
		vx = vx > 0 ? xMaxV : -xMaxV;
	}
	
	var yMaxV = sprite.yMaxV;
	if(yMaxV && Math.abs(vy) > yMaxV) {
		vy = vy > 0 ? yMaxV : -yMaxV;
	}
	
	var xMinV = sprite.xMinV;
	if(xMinV && Math.abs(vx) < xMinV) {
		vx = vx > 0 ? xMinV : -xMinV;
	}
	
	var yMinV = sprite.yMinV;
	if(yMinV && Math.abs(vy) < yMinV) {
		vy = vy > 0 ? yMinV : -yMinV;
	}

    sprite.body.SetAwake(true);

    sprite.body.SetLinearVelocity({x:vx, y:vy});

	return;
}

function UIMouseJointCreator() {
	var args = ["ui-mouse-joint", "ui-mouse-joint", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIMouseJoint();
		return g.initUIMouseJoint(this.type);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIMouseJointCreator());

/*
 * File: ui-rubebody.js
 * Author: Johnny <johnny.yin@holaverse.cn>
 * Brief: body for create by rube
 *
 * Copyright (c) 2016 - 2017 Holaverse Inc.
 *
 */

function UIRubeBody() {
    return;
}

UIRubeBody.prototype = new UIBody();
UIRubeBody.prototype.isUIRubeBody = true;

UIRubeBody.prototype.initUIRubeBody = function(type, w, h) {
    this.initUIBody(type, w, h);
    
    return this;
}

UIRubeBody.prototype.shapeCanBeChild = function(shape) {
    return false;
}

UIRubeBody.prototype.setBody = function(body) {
    this.body = body;
}

UIRubeBody.prototype.drawCircle = function(canvas, fixture) {
    var shape = fixture.m_shape;
    var vertices = shape.m_vertices;
    var body = fixture.m_body;
    var bp = body.GetPosition();
    var mp = shape.m_p;
    var cx = this.w >> 1;
    var cy = this.h >> 1;
    var c = new b2Vec2(cx + Physics.toPixel(mp.x), cy + Physics.toPixel(mp.y));
    
    var r = Physics.toPixel(shape.m_radius);
    canvas.beginPath();
    canvas.arc(c.x, c.y, r, 0, Math.PI * 2);
    canvas.closePath();
    
    canvas.lineWidth = 2;
    canvas.strokeStyle = "#ffffff";
    canvas.stroke();
}

UIRubeBody.prototype.getConvexHull = function(vertices, vertexCount) {
    // Find the right most point on the hull
    var i0 = 0;
    var x0 = vertices[0].x;
    for(var i = 1; i < vertexCount; i++) {
        var x = vertices[i].x;
        if(x > x0 || (x == x0 && vertices[i].y < vertices[i0].y)){
            i0 = i;
            x0 = x;
        }
    }
    var hull = [];
    var m = 0; 
    var ih = i0;
    while(true){
        hull[m] = ih;

        var ie = 0;
        for(var j = 1; j < vertexCount; j++) {
            if(ie == ih) {
                ie = j;
                continue;
            }
            var r = b2Math.SubtractVV(vertices[ie], vertices[hull[m]]);
            var v = b2Math.SubtractVV(vertices[j], vertices[hull[m]]);
            var c = b2Math.CrossVV(r, v);
            if(c < 0) {
                ie = j;
            }

            // Collinearity check
            if(c == 0 && v.LengthSquared() > r.LengthSquared()) {
                ie = j;
            }
        }
        ++m;
        ih = ie;

        if(ie == i0) {
            break;
        }
    }

    if(m < 3) {
        return [];
    }

    if(m < vertexCount) {
        console.warn("some vertices have to be abandomed");
    }
   
    vertexCount = m; 
    var result = [];
    // Copy vertices
    var i = 0;
    for (i = 0;
            i < vertexCount; i++) {
        result[i] = new b2Vec2();
        result[i].SetV(vertices[hull[i]]);
    }

    return result;
}

UIRubeBody.prototype.drawPolygon = function(canvas, fixture) {
    var shape = fixture.m_shape;
    var vertices = shape.m_vertices;
    var body = fixture.m_body;
    var cx = this.w >> 1;
    var cy = this.h >> 1;
    var centroid = shape.m_centroid;
    var points = vertices.map(function(vert){
        return new b2Vec2(cx + Physics.toPixel(vert.x), cy + Physics.toPixel(vert.y))
    });
 
    points = this.getConvexHull(points, points.length);
    var length = points.length; 
    canvas.save();
    canvas.beginPath();
    canvas.moveTo(points[0].x, points[0].y); 
    for(var i = 1; i < length; i++){
        canvas.lineTo(points[i].x, points[i].y);
    } 
    canvas.closePath();
    canvas.strokeStyle = "#ffffff";
    canvas.lineWidth = 2;
    canvas.stroke();
    canvas.restore();
}

UIRubeBody.prototype.paintSelfOnly = function(canvas){
    if(!this.body){
        return;
    }
    var body = this.body;

    var fixtureList = body.GetFixtureList();
    if(!fixtureList) {
        //TODO check why fixtureList is null
        console.warn("empty fixtureList");
        return;
    }

    canvas.save();
    
    var fixture = fixtureList;
    while(fixture){
        var shape = fixture.m_shape;
        if(shape instanceof b2CircleShape) {
            this.drawCircle(canvas, fixture);
        } else if(shape instanceof b2PolygonShape) {
            this.drawPolygon(canvas, fixture);
        } else {
            console.warn("RUBE: unkown shape body type");
        }
        fixture = fixture.m_next;
    }
    canvas.restore();
}

function UIRubeBodyCreator() {
    var args = ["ui-rube-body", "ui-rube-body", null, 1];
	
	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIRubeBody();
		return g.initUIRubeBody(this.type, 200, 200, null);
	}
	
	return;
}

ShapeFactoryGet().addShapeCreator(new UIRubeBodyCreator());
/**
 * Functions to determine whether or not a polygon (2D) has its vertices ordered
 * clockwise or counterclockwise and also for testing whether a polygon is convex 
 * or concave
 * 
 * This code is a very quick port of the C functions written by Paul Bourke 
 * found here - http://debian.fmi.uni-sofia.bg/~sergei/cgsr/docs/clockwise.htm
 * 
 * ported to actionscript by @yadurajiv
 * http://chronosign.com/rant
 */

var CLOCKWISE = 1,
    COUNTERCLOCKWISE = -1,
    CONCAVE = -1,
    CONVEX = 1;

/*
  Return the clockwise status of a curve, clockwise or counterclockwise
  n vertices making up curve p
  return 0 for incomputables eg: colinear points
    CLOCKWISE == 1
    COUNTERCLOCKWISE == -1
  It is assumed that
  - the polygon is closed
  - the last point is not repeated.
  - the polygon is simple (does not intersect itself or have holes)
*/

function ClockWise(p) {
  var i, j, k, z,
      count = 0,
      n = p.length;

  if (n < 3) {
    return (0);
  }

  for (i = 0; i < n; i++) {
    j = (i + 1) % n;
    k = (i + 2) % n;
    z  = (p[j].x - p[i].x) * (p[k].y - p[j].y);
    z -= (p[j].y - p[i].y) * (p[k].x - p[j].x);

    if (z < 0) {
      count--;
    } else if (z > 0) {
      count++;
    }
  }

  if (count > 0) {
    return (COUNTERCLOCKWISE);
  } else if (count < 0) {
    return (CLOCKWISE);
  } else {
    return (0);
  }
}

function Convex(p) {
  var i, j, k, z,
      flag = 0,
      n = p.length;

  if (n < 3) {
    return (0);
  }

  for(var step = 1 + Math.floor(n / 3); step >=1; step--) {
      for (i = 0; i < n; i += step) {
          j = (i + 1 * step) % n;
          k = (i + 2 * step) % n;
          z  = (p[j].x - p[i].x) * (p[k].y - p[j].y);
          z -= (p[j].y - p[i].y) * (p[k].x - p[j].x);

          if (z < 0) {
              flag |= 1;
          } else if (z > 0) {
              flag |= 2;
          }

          if (flag === 3) {
              return (CONCAVE);
          }
      }
  }

  if (flag !== 0) {
    return (CONVEX);
  } else {
    return (0);
  }
}
/**
This code is a quick port of code written in C++ which was submitted to 
flipcode.com by John W. Ratcliff  // July 22, 2000 
See original code and more information here:
http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml

ported to actionscript by Zevan Rosser
www.actionsnippet.com
*/

var EPSILON = 0.0000000001;

function process(contour) {
  var result = [],
      n = contour.length,
      verts = [],
      v,
      nv = n,
      m,
      count = 2 * nv;  /* error detection */

  if (n < 3) {
    return null;
  }

  /* we want a counter-clockwise polygon in verts */

  if (0.0 < area(contour)) {
    for (v = 0; v < n; v++) {
      verts[v] = v;
    }
  } else {
    for (v = 0; v < n; v++) {
      verts[v] = (n - 1) - v;
    }
  }

  /*  remove nv-2 vertsertices, creating 1 triangle every time */
  for (m = 0, v = nv - 1; nv > 2;) {
    /* if we loop, it is probably a non-simple polygon */
    if (0 >= (count--)) {
      //** Triangulate: ERROR - probable bad polygon!
      // console.log("bad poly");
      return null;
    }

    /* three consecutive vertices in current polygon, <u,v,w> */
    var u = v;
    if (nv <= u) {
      u = 0; /* previous */
    }

    v = u + 1;
    if (nv <= v) {
      v = 0; /* new v */
    }

    var w = v + 1;
    if (nv <= w) {
      w = 0; /* next */
    }

    if (snip(contour, u, v, w, nv, verts)) {
      var a, b, c, s, t;

      /* true names of the vertices */
      a = verts[u];
      b = verts[v];
      c = verts[w];

      /* output Triangle */
      result.push(contour[a]);
      result.push(contour[b]);
      result.push(contour[c]);

      m++;

      /* remove v from remaining polygon */
      for (s = v, t = v + 1; t < nv; s++, t++) {
        verts[s] = verts[t];
      }

      nv--;

      /* resest error detection counter */
      count = 2 * nv;
    }
  }

  return result;
}

// calculate area of the contour polygon
function area(contour) {
  var n = contour.length,
      a = 0.0;

  for (var p = n - 1, q = 0; q < n; p = q++) {
    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
  }

  return a * 0.5;
}

// see if p is inside triangle abc
function insideTriangle(ax, ay, bx, by, cx, cy, px, py) {
  var aX, aY, bX, bY,
      cX, cY, apx, apy,
      bpx, bpy, cpx, cpy,
      cCROSSap, bCROSScp, aCROSSbp;

  aX = cx - bx;
  aY = cy - by;
  bX = ax - cx;
  bY = ay - cy;
  cX = bx - ax;
  cY = by - ay;
  apx = px - ax;
  apy = py - ay;
  bpx = px - bx;
  bpy = py - by;
  cpx = px - cx;
  cpy = py - cy;

  aCROSSbp = aX * bpy - aY * bpx;
  cCROSSap = cX * apy - cY * apx;
  bCROSScp = bX * cpy - bY * cpx;

  return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
}

function snip(contour, u, v, w, n, verts) {
  var p,
      ax, ay, bx, by,
      cx, cy, px, py;

  ax = contour[verts[u]].x;
  ay = contour[verts[u]].y;

  bx = contour[verts[v]].x;
  by = contour[verts[v]].y;

  cx = contour[verts[w]].x;
  cy = contour[verts[w]].y;

  if (EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax)))) {
    return false;
  }

  for (p = 0; p < n; p++) {
    if ((p == u) || (p == v) || (p == w)) {
      continue;
    }

    px = contour[verts[p]].x
    py = contour[verts[p]].y

    if (insideTriangle(ax, ay, bx, by, cx, cy, px, py)) {
      return false;
    }
  }

  return true;
}
/*
 * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * 
 * Sean Lin 2012-5-8,
 *
 * The library is box2dweb, http://code.google.com/p/box2dweb/
 *
 * It is a port of Box2DFlash 2.1a to JavaScript.
 * You can read the documentation for Box2dFlash, since nearly everything is
 * organized the same way. http://www.box2dflash.org/docs/2.1a/reference/
 *
 */

var Box2D = {};

Box2D.MIN_VALUE = Number.MIN_VALUE;
if(Box2D.MIN_VALUE === 0) {
	var d = 2;
	while (Box2D.MIN_VALUE === 0) {
	  Box2D.MIN_VALUE = 1/(Number.MAX_VALUE/d);
	  d *= 2;
	}
}

(function (a2j, undefined) {

    if(!(Object.defineProperty instanceof Function)
        && Object.prototype.__defineGetter__ instanceof Function
        && Object.prototype.__defineSetter__ instanceof Function)
    {
        Object.defineProperty = function(obj, p, cfg) {
            if(cfg.get instanceof Function)
                obj.__defineGetter__(p, cfg.get);
            if(cfg.set instanceof Function)
                obj.__defineSetter__(p, cfg.set);
        }
    }

    function emptyFn() {};
    a2j.inherit = function(cls, base) {
        var tmpCtr = cls;
        emptyFn.prototype = base.prototype;
        cls.prototype = new emptyFn;
        cls.prototype.constructor = tmpCtr;
    };

    a2j.generateCallback = function generateCallback(context, cb) {
        return function () {
            cb.apply(context, arguments);
        };
    };

    a2j.NVector = function NVector(length) {
        if (length === undefined) length = 0;
        var tmp = new Array(length || 0);
        for (var i = 0; i < length; ++i)
            tmp[i] = 0;
        return tmp;
    };

    a2j.is = function is(o1, o2) {
        if (o1 === null) return false;
        if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
        if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
        return false;
    };

    a2j.parseUInt = function(v) {
        return Math.abs(parseInt(v));
    }

})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
    Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

    function b2AABB() {
        b2AABB.b2AABB.apply(this, arguments);
    };
    Box2D.Collision.b2AABB = b2AABB;

    function b2Bound() {
        b2Bound.b2Bound.apply(this, arguments);
    };
    Box2D.Collision.b2Bound = b2Bound;

    function b2BoundValues() {
        b2BoundValues.b2BoundValues.apply(this, arguments);
        if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
    };
    Box2D.Collision.b2BoundValues = b2BoundValues;

    function b2Collision() {
        b2Collision.b2Collision.apply(this, arguments);
    };
    Box2D.Collision.b2Collision = b2Collision;

    function b2ContactID() {
        b2ContactID.b2ContactID.apply(this, arguments);
        if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
    };
    Box2D.Collision.b2ContactID = b2ContactID;

    function b2ContactPoint() {
        b2ContactPoint.b2ContactPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ContactPoint = b2ContactPoint;

    function b2Distance() {
        b2Distance.b2Distance.apply(this, arguments);
    };
    Box2D.Collision.b2Distance = b2Distance;

    function b2DistanceInput() {
        b2DistanceInput.b2DistanceInput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceInput = b2DistanceInput;

    function b2DistanceOutput() {
        b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

    function b2DistanceProxy() {
        b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
    };
    Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

    function b2DynamicTree() {
        b2DynamicTree.b2DynamicTree.apply(this, arguments);
        if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTree = b2DynamicTree;

    function b2DynamicTreeBroadPhase() {
        b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

    function b2DynamicTreeNode() {
        b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

    function b2DynamicTreePair() {
        b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
    };
    Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

    function b2Manifold() {
        b2Manifold.b2Manifold.apply(this, arguments);
        if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
    };
    Box2D.Collision.b2Manifold = b2Manifold;

    function b2ManifoldPoint() {
        b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
        if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
    };
    Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

    function b2Point() {
        b2Point.b2Point.apply(this, arguments);
    };
    Box2D.Collision.b2Point = b2Point;

    function b2RayCastInput() {
        b2RayCastInput.b2RayCastInput.apply(this, arguments);
        if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastInput = b2RayCastInput;

    function b2RayCastOutput() {
        b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
    };
    Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

    function b2Segment() {
        b2Segment.b2Segment.apply(this, arguments);
    };
    Box2D.Collision.b2Segment = b2Segment;

    function b2SeparationFunction() {
        b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
    };
    Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

    function b2Simplex() {
        b2Simplex.b2Simplex.apply(this, arguments);
        if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
    };
    Box2D.Collision.b2Simplex = b2Simplex;

    function b2SimplexCache() {
        b2SimplexCache.b2SimplexCache.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexCache = b2SimplexCache;

    function b2SimplexVertex() {
        b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
    };
    Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

    function b2TimeOfImpact() {
        b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
    };
    Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

    function b2TOIInput() {
        b2TOIInput.b2TOIInput.apply(this, arguments);
    };
    Box2D.Collision.b2TOIInput = b2TOIInput;

    function b2WorldManifold() {
        b2WorldManifold.b2WorldManifold.apply(this, arguments);
        if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
    };
    Box2D.Collision.b2WorldManifold = b2WorldManifold;

    function ClipVertex() {
        ClipVertex.ClipVertex.apply(this, arguments);
    };
    Box2D.Collision.ClipVertex = ClipVertex;

    function Features() {
        Features.Features.apply(this, arguments);
    };
    Box2D.Collision.Features = Features;

    function b2CircleShape() {
        b2CircleShape.b2CircleShape.apply(this, arguments);
        if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

    function b2EdgeChainDef() {
        b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
        if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

    function b2EdgeShape() {
        b2EdgeShape.b2EdgeShape.apply(this, arguments);
        if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

    function b2MassData() {
        b2MassData.b2MassData.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2MassData = b2MassData;

    function b2PolygonShape() {
        b2PolygonShape.b2PolygonShape.apply(this, arguments);
        if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

    function b2Shape() {
        b2Shape.b2Shape.apply(this, arguments);
        if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
    };
    Box2D.Collision.Shapes.b2Shape = b2Shape;
    Box2D.Common.b2internal = 'Box2D.Common.b2internal';

    function b2Color() {
        b2Color.b2Color.apply(this, arguments);
        if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
    };
    Box2D.Common.b2Color = b2Color;

    function b2Settings() {
        b2Settings.b2Settings.apply(this, arguments);
    };
    Box2D.Common.b2Settings = b2Settings;

    function b2Mat22() {
        b2Mat22.b2Mat22.apply(this, arguments);
        if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat22 = b2Mat22;

    function b2Mat33() {
        b2Mat33.b2Mat33.apply(this, arguments);
        if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
    };
    Box2D.Common.Math.b2Mat33 = b2Mat33;

    function b2Math() {
        b2Math.b2Math.apply(this, arguments);
    };
    Box2D.Common.Math.b2Math = b2Math;

    function b2Sweep() {
        b2Sweep.b2Sweep.apply(this, arguments);
    };
    Box2D.Common.Math.b2Sweep = b2Sweep;

    function b2Transform() {
        b2Transform.b2Transform.apply(this, arguments);
        if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
    };
    Box2D.Common.Math.b2Transform = b2Transform;

    function b2Vec2() {
        b2Vec2.b2Vec2.apply(this, arguments);
        if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec2 = b2Vec2;

    function b2Vec3() {
        b2Vec3.b2Vec3.apply(this, arguments);
        if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
    };
    Box2D.Common.Math.b2Vec3 = b2Vec3;

    function b2Body() {
        b2Body.b2Body.apply(this, arguments);
        if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
    };
    Box2D.Dynamics.b2Body = b2Body;

    function b2BodyDef() {
        b2BodyDef.b2BodyDef.apply(this, arguments);
        if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2BodyDef = b2BodyDef;

    function b2ContactFilter() {
        b2ContactFilter.b2ContactFilter.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

    function b2ContactImpulse() {
        b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

    function b2ContactListener() {
        b2ContactListener.b2ContactListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactListener = b2ContactListener;

    function b2ContactManager() {
        b2ContactManager.b2ContactManager.apply(this, arguments);
        if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
    };
    Box2D.Dynamics.b2ContactManager = b2ContactManager;

    function b2DebugDraw() {
        b2DebugDraw.b2DebugDraw.apply(this, arguments);
        if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
    };
    Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

    function b2DestructionListener() {
        b2DestructionListener.b2DestructionListener.apply(this, arguments);
    };
    Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

    function b2FilterData() {
        b2FilterData.b2FilterData.apply(this, arguments);
    };
    Box2D.Dynamics.b2FilterData = b2FilterData;

    function b2Fixture() {
        b2Fixture.b2Fixture.apply(this, arguments);
        if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
    };
    Box2D.Dynamics.b2Fixture = b2Fixture;

    function b2FixtureDef() {
        b2FixtureDef.b2FixtureDef.apply(this, arguments);
        if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
    };
    Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

    function b2Island() {
        b2Island.b2Island.apply(this, arguments);
        if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
    };
    Box2D.Dynamics.b2Island = b2Island;

    function b2TimeStep() {
        b2TimeStep.b2TimeStep.apply(this, arguments);
    };
    Box2D.Dynamics.b2TimeStep = b2TimeStep;

    function b2World() {
        b2World.b2World.apply(this, arguments);
        if (this.constructor === b2World) this.b2World.apply(this, arguments);
    };
    Box2D.Dynamics.b2World = b2World;

    function b2CircleContact() {
        b2CircleContact.b2CircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

    function b2Contact() {
        b2Contact.b2Contact.apply(this, arguments);
        if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2Contact = b2Contact;

    function b2ContactConstraint() {
        b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
        if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

    function b2ContactConstraintPoint() {
        b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

    function b2ContactEdge() {
        b2ContactEdge.b2ContactEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

    function b2ContactFactory() {
        b2ContactFactory.b2ContactFactory.apply(this, arguments);
        if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

    function b2ContactRegister() {
        b2ContactRegister.b2ContactRegister.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

    function b2ContactResult() {
        b2ContactResult.b2ContactResult.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

    function b2ContactSolver() {
        b2ContactSolver.b2ContactSolver.apply(this, arguments);
        if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

    function b2EdgeAndCircleContact() {
        b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

    function b2NullContact() {
        b2NullContact.b2NullContact.apply(this, arguments);
        if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

    function b2PolyAndCircleContact() {
        b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

    function b2PolyAndEdgeContact() {
        b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

    function b2PolygonContact() {
        b2PolygonContact.b2PolygonContact.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

    function b2PositionSolverManifold() {
        b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
        if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
    };
    Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

    function b2BuoyancyController() {
        b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

    function b2ConstantAccelController() {
        b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

    function b2ConstantForceController() {
        b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

    function b2Controller() {
        b2Controller.b2Controller.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2Controller = b2Controller;

    function b2ControllerEdge() {
        b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

    function b2GravityController() {
        b2GravityController.b2GravityController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

    function b2TensorDampingController() {
        b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
    };
    Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

    function b2DistanceJoint() {
        b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
        if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

    function b2DistanceJointDef() {
        b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
        if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

    function b2FrictionJoint() {
        b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
        if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

    function b2FrictionJointDef() {
        b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
        if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

    function b2GearJoint() {
        b2GearJoint.b2GearJoint.apply(this, arguments);
        if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

    function b2GearJointDef() {
        b2GearJointDef.b2GearJointDef.apply(this, arguments);
        if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

    function b2Jacobian() {
        b2Jacobian.b2Jacobian.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

    function b2Joint() {
        b2Joint.b2Joint.apply(this, arguments);
        if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2Joint = b2Joint;

    function b2JointDef() {
        b2JointDef.b2JointDef.apply(this, arguments);
        if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

    function b2JointEdge() {
        b2JointEdge.b2JointEdge.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

    function b2LineJoint() {
        b2LineJoint.b2LineJoint.apply(this, arguments);
        if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

    function b2LineJointDef() {
        b2LineJointDef.b2LineJointDef.apply(this, arguments);
        if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

    function b2MouseJoint() {
        b2MouseJoint.b2MouseJoint.apply(this, arguments);
        if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

    function b2MouseJointDef() {
        b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
        if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

    function b2PrismaticJoint() {
        b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
        if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

    function b2PrismaticJointDef() {
        b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
        if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

    function b2PulleyJoint() {
        b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
        if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

    function b2PulleyJointDef() {
        b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
        if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

    function b2RevoluteJoint() {
        b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
        if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

    function b2RevoluteJointDef() {
        b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
        if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

    function b2WeldJoint() {
        b2WeldJoint.b2WeldJoint.apply(this, arguments);
        if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

    function b2WeldJointDef() {
        b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
        if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
    };
    Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    b2AABB.b2AABB = function () {
        this.lowerBound = new b2Vec2();
        this.upperBound = new b2Vec2();
    };
    b2AABB.prototype.IsValid = function () {
        var dX = this.upperBound.x - this.lowerBound.x;
        var dY = this.upperBound.y - this.lowerBound.y;
        var valid = dX >= 0.0 && dY >= 0.0;
        valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
        return valid;
    }
    b2AABB.prototype.GetCenter = function () {
        return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
    }
    b2AABB.prototype.GetExtents = function () {
        return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
    }
    b2AABB.prototype.Contains = function (aabb) {
        var result = true;
        result = result && this.lowerBound.x <= aabb.lowerBound.x;
        result = result && this.lowerBound.y <= aabb.lowerBound.y;
        result = result && aabb.upperBound.x <= this.upperBound.x;
        result = result && aabb.upperBound.y <= this.upperBound.y;
        return result;
    }
    b2AABB.prototype.RayCast = function (output, input) {
        var tmin = (-Number.MAX_VALUE);
        var tmax = Number.MAX_VALUE;
        var pX = input.p1.x;
        var pY = input.p1.y;
        var dX = input.p2.x - input.p1.x;
        var dY = input.p2.y - input.p1.y;
        var absDX = Math.abs(dX);
        var absDY = Math.abs(dY);
        var normal = output.normal;
        var inv_d = 0;
        var t1 = 0;
        var t2 = 0;
        var t3 = 0;
        var s = 0; {
            if (absDX < Box2D.MIN_VALUE) {
                if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
            }
            else {
                inv_d = 1.0 / dX;
                t1 = (this.lowerBound.x - pX) * inv_d;
                t2 = (this.upperBound.x - pX) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.x = s;
                    normal.y = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        } {
            if (absDY < Box2D.MIN_VALUE) {
                if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
            }
            else {
                inv_d = 1.0 / dY;
                t1 = (this.lowerBound.y - pY) * inv_d;
                t2 = (this.upperBound.y - pY) * inv_d;
                s = (-1.0);
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1.0;
                }
                if (t1 > tmin) {
                    normal.y = s;
                    normal.x = 0;
                    tmin = t1;
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false;
            }
        }
        output.fraction = tmin;
        return true;
    }
    b2AABB.prototype.TestOverlap = function (other) {
        var d1X = other.lowerBound.x - this.upperBound.x;
        var d1Y = other.lowerBound.y - this.upperBound.y;
        var d2X = this.lowerBound.x - other.upperBound.x;
        var d2Y = this.lowerBound.y - other.upperBound.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    b2AABB.Combine = function (aabb1, aabb2) {
        var aabb = new b2AABB();
        aabb.Combine(aabb1, aabb2);
        return aabb;
    }
    b2AABB.prototype.Combine = function (aabb1, aabb2) {
        this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
        this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
        this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
        this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
    }
    b2Bound.b2Bound = function () {};
    b2Bound.prototype.IsLower = function () {
        return (this.value & 1) == 0;
    }
    b2Bound.prototype.IsUpper = function () {
        return (this.value & 1) == 1;
    }
    b2Bound.prototype.Swap = function (b) {
        var tempValue = this.value;
        var tempProxy = this.proxy;
        var tempStabbingCount = this.stabbingCount;
        this.value = b.value;
        this.proxy = b.proxy;
        this.stabbingCount = b.stabbingCount;
        b.value = tempValue;
        b.proxy = tempProxy;
        b.stabbingCount = tempStabbingCount;
    }
    b2BoundValues.b2BoundValues = function () {};
    b2BoundValues.prototype.b2BoundValues = function () {
        this.lowerValues = new Vector_a2j_Number();
        this.lowerValues[0] = 0.0;
        this.lowerValues[1] = 0.0;
        this.upperValues = new Vector_a2j_Number();
        this.upperValues[0] = 0.0;
        this.upperValues[1] = 0.0;
    }
    b2Collision.b2Collision = function () {};
    b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
        if (offset === undefined) offset = 0;
        var cv;
        var numOut = 0;
        cv = vIn[0];
        var vIn0 = cv.v;
        cv = vIn[1];
        var vIn1 = cv.v;
        var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
        var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
        if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
        if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
        if (distance0 * distance1 < 0.0) {
            var interp = distance0 / (distance0 - distance1);
            cv = vOut[numOut];
            var tVec = cv.v;
            tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
            tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
            cv = vOut[numOut];
            var cv2;
            if (distance0 > 0.0) {
                cv2 = vIn[0];
                cv.id = cv2.id;
            }
            else {
                cv2 = vIn[1];
                cv.id = cv2.id;
            }++numOut;
        }
        return numOut;
    }
    b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
        var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = vertices2[i];
            var dot = tVec.x * normal1X + tVec.y * normal1Y;
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        tVec = vertices1[edge1];
        tMat = xf1.R;
        var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = vertices2[index];
        tMat = xf2.R;
        var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        v2X -= v1X;
        v2Y -= v1Y;
        var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
        return separation;
    }
    b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = poly2.m_centroid;
        var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf1.R;
        tVec = poly1.m_centroid;
        dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
        var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
        var edge = 0;
        var maxDot = (-Number.MAX_VALUE);
        for (var i = 0; i < count1; ++i) {
            tVec = normals1[i];
            var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
            if (dot > maxDot) {
                maxDot = dot;
                edge = i;
            }
        }
        var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
        var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
        var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
        var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
        var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
        var bestEdge = 0;
        var bestSeparation = 0;
        var increment = 0;
        if (sPrev > s && sPrev > sNext) {
            increment = (-1);
            bestEdge = prevEdge;
            bestSeparation = sPrev;
        }
        else if (sNext > s) {
            increment = 1;
            bestEdge = nextEdge;
            bestSeparation = sNext;
        }
        else {
            edgeIndex[0] = edge;
            return s;
        }
        while (true) {
            if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
            else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
            if (s > bestSeparation) {
                bestEdge = edge;
                bestSeparation = s;
            }
            else {
                break;
            }
        }
        edgeIndex[0] = bestEdge;
        return bestSeparation;
    }
    b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
        if (edge1 === undefined) edge1 = 0;
        var count1 = parseInt(poly1.m_vertexCount);
        var normals1 = poly1.m_normals;
        var count2 = parseInt(poly2.m_vertexCount);
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
        normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
        normal1X = tX;
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = normals2[i];
            var dot = (normal1X * tVec.x + normal1Y * tVec.y);
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        var tClip;
        var i1 = parseInt(index);
        var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
        tClip = c[0];
        tVec = vertices2[i1];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i1;
        tClip.id.features.incidentVertex = 0;
        tClip = c[1];
        tVec = vertices2[i2];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i2;
        tClip.id.features.incidentVertex = 1;
    }
    b2Collision.MakeClipPointVector = function () {
        var r = new Vector(2);
        r[0] = new ClipVertex();
        r[1] = new ClipVertex();
        return r;
    }
    b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
        var cv;
        manifold.m_pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = 0;
        b2Collision.s_edgeAO[0] = edgeA;
        var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
        edgeA = b2Collision.s_edgeAO[0];
        if (separationA > totalRadius) return;
        var edgeB = 0;
        b2Collision.s_edgeBO[0] = edgeB;
        var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
        edgeB = b2Collision.s_edgeBO[0];
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1;
        var xf2;
        var edge1 = 0;
        var flip = 0;
        var k_relativeTol = 0.98;
        var k_absoluteTol = 0.001;
        var tMat;
        if (separationB > k_relativeTol * separationA + k_absoluteTol) {
            poly1 = polyB;
            poly2 = polyA;
            xf1 = xfB;
            xf2 = xfA;
            edge1 = edgeB;
            manifold.m_type = b2Manifold.e_faceB;
            flip = 1;
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            xf1 = xfA;
            xf2 = xfB;
            edge1 = edgeA;
            manifold.m_type = b2Manifold.e_faceA;
            flip = 0;
        }
        var incidentEdge = b2Collision.s_incidentEdge;
        b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = parseInt(poly1.m_vertexCount);
        var vertices1 = poly1.m_vertices;
        var local_v11 = vertices1[edge1];
        var local_v12;
        if (edge1 + 1 < count1) {
            local_v12 = vertices1[parseInt(edge1 + 1)];
        }
        else {
            local_v12 = vertices1[0];
        }
        var localTangent = b2Collision.s_localTangent;
        localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
        localTangent.Normalize();
        var localNormal = b2Collision.s_localNormal;
        localNormal.x = localTangent.y;
        localNormal.y = (-localTangent.x);
        var planePoint = b2Collision.s_planePoint;
        planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
        var tangent = b2Collision.s_tangent;
        tMat = xf1.R;
        tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
        tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
        var tangent2 = b2Collision.s_tangent2;
        tangent2.x = (-tangent.x);
        tangent2.y = (-tangent.y);
        var normal = b2Collision.s_normal;
        normal.x = tangent.y;
        normal.y = (-tangent.x);
        var v11 = b2Collision.s_v11;
        var v12 = b2Collision.s_v12;
        v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
        v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
        v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
        v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
        var frontOffset = normal.x * v11.x + normal.y * v11.y;
        var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
        var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
        var clipPoints1 = b2Collision.s_clipPoints1;
        var clipPoints2 = b2Collision.s_clipPoints2;
        var np = 0;
        np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
        if (np < 2) return;
        np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
        if (np < 2) return;
        manifold.m_localPlaneNormal.SetV(localNormal);
        manifold.m_localPoint.SetV(planePoint);
        var pointCount = 0;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
            cv = clipPoints2[i];
            var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
            if (separation <= totalRadius) {
                var cp = manifold.m_points[pointCount];
                tMat = xf2.R;
                var tX = cv.v.x - xf2.position.x;
                var tY = cv.v.y - xf2.position.y;
                cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
                cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
                cp.m_id.Set(cv.id);
                cp.m_id.features.flip = flip;
                ++pointCount;
            }
        }
        manifold.m_pointCount = pointCount;
    }
    b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
        manifold.m_pointCount = 0;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = circle1.m_p;
        var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        tVec = circle2.m_p;
        var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var distSqr = dX * dX + dY * dY;
        var radius = circle1.m_radius + circle2.m_radius;
        if (distSqr > radius * radius) {
            return;
        }
        manifold.m_type = b2Manifold.e_circles;
        manifold.m_localPoint.SetV(circle1.m_p);
        manifold.m_localPlaneNormal.SetZero();
        manifold.m_pointCount = 1;
        manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
        manifold.m_points[0].m_id.key = 0;
    }
    b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX = 0;
        var dY = 0;
        var positionX = 0;
        var positionY = 0;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
        var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
        var dist = 0;
        var normalIndex = 0;
        var separation = (-Number.MAX_VALUE);
        var radius = polygon.m_radius + circle.m_radius;
        var vertexCount = parseInt(polygon.m_vertexCount);
        var vertices = polygon.m_vertices;
        var normals = polygon.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
            tVec = vertices[i];
            dX = cLocalX - tVec.x;
            dY = cLocalY - tVec.y;
            tVec = normals[i];
            var s = tVec.x * dX + tVec.y * dY;
            if (s > radius) {
                return;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        var vertIndex1 = parseInt(normalIndex);
        var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < Box2D.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
            manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
            manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return;
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0.0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else {
            var faceCenterX = 0.5 * (v1.x + v2.x);
            var faceCenterY = 0.5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
            manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
    }
    b2Collision.TestOverlap = function (a, b) {
        var t1 = b.lowerBound;
        var t2 = a.upperBound;
        var d1X = t1.x - t2.x;
        var d1Y = t1.y - t2.y;
        t1 = a.lowerBound;
        t2 = b.upperBound;
        var d2X = t1.x - t2.x;
        var d2Y = t1.y - t2.y;
        if (d1X > 0.0 || d1Y > 0.0) return false;
        if (d2X > 0.0 || d2Y > 0.0) return false;
        return true;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
        Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
        Box2D.Collision.b2Collision.s_normal = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
        Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
        Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
        Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
        Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
    });
    b2ContactID.b2ContactID = function () {
        this.features = new Features();
    };
    b2ContactID.prototype.b2ContactID = function () {
        this.features._m_id = this;
    }
    b2ContactID.prototype.Set = function (id) {
        this.key = id._key;
    }
    b2ContactID.prototype.Copy = function () {
        var id = new b2ContactID();
        id.key = this.key;
        return id;
    }
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._key;
        }
    });
    Object.defineProperty(b2ContactID.prototype, 'key', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._key = value;
            this.features._referenceEdge = this._key & 0x000000ff;
            this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
            this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
            this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
        }
    });
    b2ContactPoint.b2ContactPoint = function () {
        this.position = new b2Vec2();
        this.velocity = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2Distance.b2Distance = function () {};
    b2Distance.Distance = function (output, cache, input) {
        ++b2Distance.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        var simplex = b2Distance.s_simplex;
        simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = simplex.m_vertices;
        var k_maxIters = 20;
        var saveA = b2Distance.s_saveA;
        var saveB = b2Distance.s_saveB;
        var saveCount = 0;
        var closestPoint = simplex.GetClosestPoint();
        var distanceSqr1 = closestPoint.LengthSquared();
        var distanceSqr2 = distanceSqr1;
        var i = 0;
        var p;
        var iter = 0;
        while (iter < k_maxIters) {
            saveCount = simplex.m_count;
            for (i = 0;
                 i < saveCount; i++) {
                saveA[i] = vertices[i].indexA;
                saveB[i] = vertices[i].indexB;
            }
            switch (simplex.m_count) {
                case 1:
                    break;
                case 2:
                    simplex.Solve2();
                    break;
                case 3:
                    simplex.Solve3();
                    break;
                default:
                    b2Settings.b2Assert(false);
            }
            if (simplex.m_count == 3) {
                break;
            }
            p = simplex.GetClosestPoint();
            distanceSqr2 = p.LengthSquared();
            if (distanceSqr2 > distanceSqr1) {}
            distanceSqr1 = distanceSqr2;
            var d = simplex.GetSearchDirection();
            if (d.LengthSquared() < Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                break;
            }
            var vertex = vertices[simplex.m_count];
            vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
            vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
            vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
            vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
            vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
            ++iter;
            ++b2Distance.b2_gjkIters;
            var duplicate = false;
            for (i = 0;
                 i < saveCount; i++) {
                if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                    duplicate = true;
                    break;
                }
            }
            if (duplicate) {
                break;
            }++simplex.m_count;
        }
        b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
        simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
        output.iterations = iter;
        simplex.WriteCache(cache);
        if (input.useRadii) {
            var rA = proxyA.m_radius;
            var rB = proxyB.m_radius;
            if (output.distance > rA + rB && output.distance > Box2D.MIN_VALUE) {
                output.distance -= rA + rB;
                var normal = b2Math.SubtractVV(output.pointB, output.pointA);
                normal.Normalize();
                output.pointA.x += rA * normal.x;
                output.pointA.y += rA * normal.y;
                output.pointB.x -= rB * normal.x;
                output.pointB.y -= rB * normal.y;
            }
            else {
                p = new b2Vec2();
                p.x = .5 * (output.pointA.x + output.pointB.x);
                p.y = .5 * (output.pointA.y + output.pointB.y);
                output.pointA.x = output.pointB.x = p.x;
                output.pointA.y = output.pointB.y = p.y;
                output.distance = 0.0;
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
        Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
        Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
    });
    b2DistanceInput.b2DistanceInput = function () {};
    b2DistanceOutput.b2DistanceOutput = function () {
        this.pointA = new b2Vec2();
        this.pointB = new b2Vec2();
    };
    b2DistanceProxy.b2DistanceProxy = function () {};
    b2DistanceProxy.prototype.Set = function (shape) {
        switch (shape.GetType()) {
            case b2Shape.e_circleShape:
            {
                var circle = (shape instanceof b2CircleShape ? shape : null);
                this.m_vertices = new Vector(1, true);
                this.m_vertices[0] = circle.m_p;
                this.m_count = 1;
                this.m_radius = circle.m_radius;
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var polygon = (shape instanceof b2PolygonShape ? shape : null);
                this.m_vertices = polygon.m_vertices;
                this.m_count = polygon.m_vertexCount;
                this.m_radius = polygon.m_radius;
            }
                break;
            case b2Shape.e_edgeShape:
            {
                var edge = (shape instanceof b2EdgeShape ? shape : null);
                this.m_vertices = new Vector(2, true);
                this.m_vertices[0] = edge.m_v1;
                this.m_vertices[1] = edge.m_v2;
                this.m_count = 2;
                this.m_radius = edge.m_radius;
            }
                break;
            default:
                b2Settings.b2Assert(false);
        }
    }
    b2DistanceProxy.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2DistanceProxy.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2DistanceProxy.prototype.GetVertexCount = function () {
        return this.m_count;
    }
    b2DistanceProxy.prototype.GetVertex = function (index) {
        if (index === undefined) index = 0;
        b2Settings.b2Assert(0 <= index && index < this.m_count);
        return this.m_vertices[index];
    }
    b2DynamicTree.b2DynamicTree = function () {};
    b2DynamicTree.prototype.b2DynamicTree = function () {
        this.m_root = null;
        this.m_freeList = null;
        this.m_path = 0;
        this.m_insertionCount = 0;
    }
    b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
        var node = this.AllocateNode();
        var extendX = b2Settings.b2_aabbExtension;
        var extendY = b2Settings.b2_aabbExtension;
        node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        node.aabb.upperBound.x = aabb.upperBound.x + extendX;
        node.aabb.upperBound.y = aabb.upperBound.y + extendY;
        node.userData = userData;
        this.InsertLeaf(node);
        return node;
    }
    b2DynamicTree.prototype.DestroyProxy = function (proxy) {
        this.RemoveLeaf(proxy);
        this.FreeNode(proxy);
    }
    b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
        b2Settings.b2Assert(proxy.IsLeaf());
        if (proxy.aabb.Contains(aabb)) {
            return false;
        }
        this.RemoveLeaf(proxy);
        var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
        var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
        proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
        proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
        this.InsertLeaf(proxy);
        return true;
    }
    b2DynamicTree.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        if (this.m_root == null) return;
        for (var i = 0; i < iterations; i++) {
            var node = this.m_root;
            var bit = 0;
            while (node.IsLeaf() == false) {
                node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
                bit = (bit + 1) & 31;
            }++this.m_path;
            this.RemoveLeaf(node);
            this.InsertLeaf(node);
        }
    }
    b2DynamicTree.prototype.GetFatAABB = function (proxy) {
        return proxy.aabb;
    }
    b2DynamicTree.prototype.GetUserData = function (proxy) {
        return proxy.userData;
    }
    b2DynamicTree.prototype.Query = function (callback, aabb) {
        if (this.m_root == null) return;
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(aabb)) {
                if (node.IsLeaf()) {
                    var proceed = callback(node);
                    if (!proceed) return;
                }
                else {
                    stack[count++] = node.child1;
                    stack[count++] = node.child2;
                }
            }
        }
    }
    b2DynamicTree.prototype.RayCast = function (callback, input) {
        if (this.m_root == null) return;
        var p1 = input.p1;
        var p2 = input.p2;
        var r = b2Math.SubtractVV(p1, p2);
        r.Normalize();
        var v = b2Math.CrossFV(1.0, r);
        var abs_v = b2Math.AbsV(v);
        var maxFraction = input.maxFraction;
        var segmentAABB = new b2AABB();
        var tX = 0;
        var tY = 0; {
            tX = p1.x + maxFraction * (p2.x - p1.x);
            tY = p1.y + maxFraction * (p2.y - p1.y);
            segmentAABB.lowerBound.x = Math.min(p1.x, tX);
            segmentAABB.lowerBound.y = Math.min(p1.y, tY);
            segmentAABB.upperBound.x = Math.max(p1.x, tX);
            segmentAABB.upperBound.y = Math.max(p1.y, tY);
        }
        var stack = new Vector();
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(segmentAABB) == false) {
                continue;
            }
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
            if (separation > 0.0) continue;
            if (node.IsLeaf()) {
                var subInput = new b2RayCastInput();
                subInput.p1 = input.p1;
                subInput.p2 = input.p2;
                subInput.maxFraction = input.maxFraction;
                maxFraction = callback(subInput, node);
                if (maxFraction == 0.0) return;
                if (maxFraction > 0.0) {
                    tX = p1.x + maxFraction * (p2.x - p1.x);
                    tY = p1.y + maxFraction * (p2.y - p1.y);
                    segmentAABB.lowerBound.x = Math.min(p1.x, tX);
                    segmentAABB.lowerBound.y = Math.min(p1.y, tY);
                    segmentAABB.upperBound.x = Math.max(p1.x, tX);
                    segmentAABB.upperBound.y = Math.max(p1.y, tY);
                }
            }
            else {
                stack[count++] = node.child1;
                stack[count++] = node.child2;
            }
        }
    }
    b2DynamicTree.prototype.AllocateNode = function () {
        if (this.m_freeList) {
            var node = this.m_freeList;
            this.m_freeList = node.parent;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            return node;
        }
        return new b2DynamicTreeNode();
    }
    b2DynamicTree.prototype.FreeNode = function (node) {
        node.parent = this.m_freeList;
        this.m_freeList = node;
    }
    b2DynamicTree.prototype.InsertLeaf = function (leaf) {
        ++this.m_insertionCount;
        if (this.m_root == null) {
            this.m_root = leaf;
            this.m_root.parent = null;
            return;
        }
        var center = leaf.aabb.GetCenter();
        var sibling = this.m_root;
        if (sibling.IsLeaf() == false) {
            do {
                var child1 = sibling.child1;
                var child2 = sibling.child2;
                var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
                var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
                if (norm1 < norm2) {
                    sibling = child1;
                }
                else {
                    sibling = child2;
                }
            }
            while (sibling.IsLeaf() == false)
        }
        var node1 = sibling.parent;
        var node2 = this.AllocateNode();
        node2.parent = node1;
        node2.userData = null;
        node2.aabb.Combine(leaf.aabb, sibling.aabb);
        if (node1) {
            if (sibling.parent.child1 == sibling) {
                node1.child1 = node2;
            }
            else {
                node1.child2 = node2;
            }
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            do {
                if (node1.aabb.Contains(node2.aabb)) break;
                node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
                node2 = node1;
                node1 = node1.parent;
            }
            while (node1)
        }
        else {
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            this.m_root = node2;
        }
    }
    b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
        if (leaf == this.m_root) {
            this.m_root = null;
            return;
        }
        var node2 = leaf.parent;
        var node1 = node2.parent;
        var sibling;
        if (node2.child1 == leaf) {
            sibling = node2.child2;
        }
        else {
            sibling = node2.child1;
        }
        if (node1) {
            if (node1.child1 == node2) {
                node1.child1 = sibling;
            }
            else {
                node1.child2 = sibling;
            }
            sibling.parent = node1;
            this.FreeNode(node2);
            while (node1) {
                var oldAABB = node1.aabb;
                node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
                if (oldAABB.Contains(node1.aabb)) break;
                node1 = node1.parent;
            }
        }
        else {
            this.m_root = sibling;
            sibling.parent = null;
            this.FreeNode(node2);
        }
    }
    b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
        this.m_tree = new b2DynamicTree();
        this.m_moveBuffer = new Vector();
        this.m_pairBuffer = new Vector();
        this.m_pairCount = 0;
    };
    b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
        var proxy = this.m_tree.CreateProxy(aabb, userData);
        ++this.m_proxyCount;
        this.BufferMove(proxy);
        return proxy;
    }
    b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
        this.UnBufferMove(proxy);
        --this.m_proxyCount;
        this.m_tree.DestroyProxy(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
        var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
        if (buffer) {
            this.BufferMove(proxy);
        }
    }
    b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
        var aabbA = this.m_tree.GetFatAABB(proxyA);
        var aabbB = this.m_tree.GetFatAABB(proxyB);
        return aabbA.TestOverlap(aabbB);
    }
    b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
        return this.m_tree.GetUserData(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
        return this.m_tree.GetFatAABB(proxy);
    }
    b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
        return this.m_proxyCount;
    }
    b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
        var __this = this;
        __this.m_pairCount = 0;
        var i = 0,
            queryProxy;
        for (i = 0;
             i < __this.m_moveBuffer.length; ++i) {
            queryProxy = __this.m_moveBuffer[i];

            function QueryCallback(proxy) {
                if (proxy == queryProxy) return true;
                if (__this.m_pairCount == __this.m_pairBuffer.length) {
                    __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
                }
                var pair = __this.m_pairBuffer[__this.m_pairCount];
                pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
                pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
                return true;
            };
            var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
            __this.m_tree.Query(QueryCallback, fatAABB);
        }
        __this.m_moveBuffer.length = 0;
        for (var i = 0; i < __this.m_pairCount;) {
            var primaryPair = __this.m_pairBuffer[i];
            var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
            var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
            callback(userDataA, userDataB);
            ++i;
            while (i < __this.m_pairCount) {
                var pair = __this.m_pairBuffer[i];
                if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
                    break;
                }++i;
            }
        }
    }
    b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
        this.m_tree.Query(callback, aabb);
    }
    b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
        this.m_tree.RayCast(callback, input);
    }
    b2DynamicTreeBroadPhase.prototype.Validate = function () {}
    b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
        if (iterations === undefined) iterations = 0;
        this.m_tree.Rebalance(iterations);
    }
    b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
        this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
    }
    b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
        var i = parseInt(this.m_moveBuffer.indexOf(proxy));
        this.m_moveBuffer.splice(i, 1);
    }
    b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
        return 0;
    }
    b2DynamicTreeBroadPhase.__implements = {};
    b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
    b2DynamicTreeNode.b2DynamicTreeNode = function () {
        this.aabb = new b2AABB();
    };
    b2DynamicTreeNode.prototype.IsLeaf = function () {
        return this.child1 == null;
    }
    b2DynamicTreePair.b2DynamicTreePair = function () {};
    b2Manifold.b2Manifold = function () {
        this.m_pointCount = 0;
    };
    b2Manifold.prototype.b2Manifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2ManifoldPoint();
        }
        this.m_localPlaneNormal = new b2Vec2();
        this.m_localPoint = new b2Vec2();
    }
    b2Manifold.prototype.Reset = function () {
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
        }
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_type = 0;
        this.m_pointCount = 0;
    }
    b2Manifold.prototype.Set = function (m) {
        this.m_pointCount = m.m_pointCount;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
        }
        this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_type = m.m_type;
    }
    b2Manifold.prototype.Copy = function () {
        var copy = new b2Manifold();
        copy.Set(this);
        return copy;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Manifold.e_circles = 0x0001;
        Box2D.Collision.b2Manifold.e_faceA = 0x0002;
        Box2D.Collision.b2Manifold.e_faceB = 0x0004;
    });
    b2ManifoldPoint.b2ManifoldPoint = function () {
        this.m_localPoint = new b2Vec2();
        this.m_id = new b2ContactID();
    };
    b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
        this.Reset();
    }
    b2ManifoldPoint.prototype.Reset = function () {
        this.m_localPoint.SetZero();
        this.m_normalImpulse = 0.0;
        this.m_tangentImpulse = 0.0;
        this.m_id.key = 0;
    }
    b2ManifoldPoint.prototype.Set = function (m) {
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_normalImpulse = m.m_normalImpulse;
        this.m_tangentImpulse = m.m_tangentImpulse;
        this.m_id.Set(m.m_id);
    }
    b2Point.b2Point = function () {
        this.p = new b2Vec2();
    };
    b2Point.prototype.Support = function (xf, vX, vY) {
        if (vX === undefined) vX = 0;
        if (vY === undefined) vY = 0;
        return this.p;
    }
    b2Point.prototype.GetFirstVertex = function (xf) {
        return this.p;
    }
    b2RayCastInput.b2RayCastInput = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
        if (p1 === undefined) p1 = null;
        if (p2 === undefined) p2 = null;
        if (maxFraction === undefined) maxFraction = 1;
        if (p1) this.p1.SetV(p1);
        if (p2) this.p2.SetV(p2);
        this.maxFraction = maxFraction;
    }
    b2RayCastOutput.b2RayCastOutput = function () {
        this.normal = new b2Vec2();
    };
    b2Segment.b2Segment = function () {
        this.p1 = new b2Vec2();
        this.p2 = new b2Vec2();
    };
    b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
        if (maxLambda === undefined) maxLambda = 0;
        var s = segment.p1;
        var rX = segment.p2.x - s.x;
        var rY = segment.p2.y - s.y;
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var nX = dY;
        var nY = (-dX);
        var k_slop = 100.0 * Box2D.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = s.x - this.p1.x;
            var bY = s.y - this.p1.y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= maxLambda * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    nX /= nLen;
                    nY /= nLen;
                    lambda[0] = a;
                    normal.Set(nX, nY);
                    return true;
                }
            }
        }
        return false;
    }
    b2Segment.prototype.Extend = function (aabb) {
        this.ExtendForward(aabb);
        this.ExtendBackward(aabb);
    }
    b2Segment.prototype.ExtendForward = function (aabb) {
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x + dX * lambda;
        this.p2.y = this.p1.y + dY * lambda;
    }
    b2Segment.prototype.ExtendBackward = function (aabb) {
        var dX = (-this.p2.x) + this.p1.x;
        var dY = (-this.p2.y) + this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
            dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + dX * lambda;
        this.p1.y = this.p2.y + dY * lambda;
    }
    b2SeparationFunction.b2SeparationFunction = function () {
        this.m_localPoint = new b2Vec2();
        this.m_axis = new b2Vec2();
    };
    b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
        this.m_proxyA = proxyA;
        this.m_proxyB = proxyB;
        var count = parseInt(cache.count);
        b2Settings.b2Assert(0 < count && count < 3);
        var localPointA;
        var localPointA1;
        var localPointA2;
        var localPointB;
        var localPointB1;
        var localPointB2;
        var pointAX = 0;
        var pointAY = 0;
        var pointBX = 0;
        var pointBY = 0;
        var normalX = 0;
        var normalY = 0;
        var tMat;
        var tVec;
        var s = 0;
        var sgn = 0;
        if (count == 1) {
            this.m_type = b2SeparationFunction.e_points;
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_axis.x = pointBX - pointAX;
            this.m_axis.y = pointBY - pointAY;
            this.m_axis.Normalize();
        }
        else if (cache.indexB[0] == cache.indexB[1]) {
            this.m_type = b2SeparationFunction.e_faceA;
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
            this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else if (cache.indexA[0] == cache.indexA[0]) {
            this.m_type = b2SeparationFunction.e_faceB;
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
            this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
                this.m_axis.NegativeSelf();
            }
        }
        else {
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            var pA = b2Math.MulX(transformA, localPointA);
            var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
            var pB = b2Math.MulX(transformB, localPointB);
            var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
            var a = dA.x * dA.x + dA.y * dA.y;
            var e = dB.x * dB.x + dB.y * dB.y;
            var r = b2Math.SubtractVV(dB, dA);
            var c = dA.x * r.x + dA.y * r.y;
            var f = dB.x * r.x + dB.y * r.y;
            var b = dA.x * dB.x + dA.y * dB.y;
            var denom = a * e - b * b;
            s = 0.0;
            if (denom != 0.0) {
                s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
            }
            var t = (b * s + f) / e;
            if (t < 0.0) {
                t = 0.0;
                s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
            }
            localPointA = new b2Vec2();
            localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
            localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
            localPointB = new b2Vec2();
            localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
            localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
            if (s == 0.0 || s == 1.0) {
                this.m_type = b2SeparationFunction.e_faceB;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
                this.m_axis.Normalize();
                this.m_localPoint = localPointB;
                tVec = this.m_axis;
                tMat = transformB.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointA;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
            else {
                this.m_type = b2SeparationFunction.e_faceA;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
                this.m_localPoint = localPointA;
                tVec = this.m_axis;
                tMat = transformA.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointB;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
                if (s < 0.0) {
                    this.m_axis.NegativeSelf();
                }
            }
        }
    }
    b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
        var axisA;
        var axisB;
        var localPointA;
        var localPointB;
        var pointA;
        var pointB;
        var seperation = 0;
        var normal;
        switch (this.m_type) {
            case b2SeparationFunction.e_points:
            {
                axisA = b2Math.MulTMV(transformA.R, this.m_axis);
                axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointA = b2Math.MulX(transformA, localPointA);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceA:
            {
                normal = b2Math.MulMV(transformA.R, this.m_axis);
                pointA = b2Math.MulX(transformA, this.m_localPoint);
                axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
                localPointB = this.m_proxyB.GetSupportVertex(axisB);
                pointB = b2Math.MulX(transformB, localPointB);
                seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
                return seperation;
            }
            case b2SeparationFunction.e_faceB:
            {
                normal = b2Math.MulMV(transformB.R, this.m_axis);
                pointB = b2Math.MulX(transformB, this.m_localPoint);
                axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
                localPointA = this.m_proxyA.GetSupportVertex(axisA);
                pointA = b2Math.MulX(transformA, localPointA);
                seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
                return seperation;
            }
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2SeparationFunction.e_points = 0x01;
        Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
        Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
    });
    b2Simplex.b2Simplex = function () {
        this.m_v1 = new b2SimplexVertex();
        this.m_v2 = new b2SimplexVertex();
        this.m_v3 = new b2SimplexVertex();
        this.m_vertices = new Vector(3);
    };
    b2Simplex.prototype.b2Simplex = function () {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3;
    }
    b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
        b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
        var wALocal;
        var wBLocal;
        this.m_count = cache.count;
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            wALocal = proxyA.GetVertex(v.indexA);
            wBLocal = proxyB.GetVertex(v.indexB);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            v.a = 0;
        }
        if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Box2D.MIN_VALUE) {
                this.m_count = 0;
            }
        }
        if (this.m_count == 0) {
            v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            wALocal = proxyA.GetVertex(0);
            wBLocal = proxyB.GetVertex(0);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            this.m_count = 1;
        }
    }
    b2Simplex.prototype.WriteCache = function (cache) {
        cache.metric = this.GetMetric();
        cache.count = Box2D.parseUInt(this.m_count);
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
            cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
        }
    }
    b2Simplex.prototype.GetSearchDirection = function () {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
            {
                var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
                var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
                if (sgn > 0.0) {
                    return b2Math.CrossFV(1.0, e12);
                }
                else {
                    return b2Math.CrossVF(e12, 1.0);
                }
            }
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetClosestPoint = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return new b2Vec2();
            case 1:
                return this.m_v1.w;
            case 2:
                return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2();
        }
    }
    b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                break;
            case 1:
                pA.SetV(this.m_v1.wA);
                pB.SetV(this.m_v1.wB);
                break;
            case 2:
                pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                b2Settings.b2Assert(false);
                break;
        }
    }
    b2Simplex.prototype.GetMetric = function () {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return 0.0;
            case 1:
                return 0.0;
            case 2:
                return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                b2Settings.b2Assert(false);
                return 0.0;
        }
    }
    b2Simplex.prototype.Solve2 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
        if (d12_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        var d12_1 = (w2.x * e12.x + w2.y * e12.y);
        if (d12_1 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        var inv_d12 = 1.0 / (d12_1 + d12_2);
        this.m_v1.a = d12_1 * inv_d12;
        this.m_v2.a = d12_2 * inv_d12;
        this.m_count = 2;
    }
    b2Simplex.prototype.Solve3 = function () {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var w3 = this.m_v3.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var w1e12 = b2Math.Dot(w1, e12);
        var w2e12 = b2Math.Dot(w2, e12);
        var d12_1 = w2e12;
        var d12_2 = (-w1e12);
        var e13 = b2Math.SubtractVV(w3, w1);
        var w1e13 = b2Math.Dot(w1, e13);
        var w3e13 = b2Math.Dot(w3, e13);
        var d13_1 = w3e13;
        var d13_2 = (-w1e13);
        var e23 = b2Math.SubtractVV(w3, w2);
        var w2e23 = b2Math.Dot(w2, e23);
        var w3e23 = b2Math.Dot(w3, e23);
        var d23_1 = w3e23;
        var d23_2 = (-w2e23);
        var n123 = b2Math.CrossVV(e12, e13);
        var d123_1 = n123 * b2Math.CrossVV(w2, w3);
        var d123_2 = n123 * b2Math.CrossVV(w3, w1);
        var d123_3 = n123 * b2Math.CrossVV(w1, w2);
        if (d12_2 <= 0.0 && d13_2 <= 0.0) {
            this.m_v1.a = 1.0;
            this.m_count = 1;
            return;
        }
        if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
            var inv_d12 = 1.0 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
            return;
        }
        if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
            var inv_d13 = 1.0 / (d13_1 + d13_2);
            this.m_v1.a = d13_1 * inv_d13;
            this.m_v3.a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v2.Set(this.m_v3);
            return;
        }
        if (d12_1 <= 0.0 && d23_2 <= 0.0) {
            this.m_v2.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return;
        }
        if (d13_1 <= 0.0 && d23_1 <= 0.0) {
            this.m_v3.a = 1.0;
            this.m_count = 1;
            this.m_v1.Set(this.m_v3);
            return;
        }
        if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
            var inv_d23 = 1.0 / (d23_1 + d23_2);
            this.m_v2.a = d23_1 * inv_d23;
            this.m_v3.a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v1.Set(this.m_v3);
            return;
        }
        var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
        this.m_v1.a = d123_1 * inv_d123;
        this.m_v2.a = d123_2 * inv_d123;
        this.m_v3.a = d123_3 * inv_d123;
        this.m_count = 3;
    }
    b2SimplexCache.b2SimplexCache = function () {
        this.indexA = new Vector_a2j_Number(3);
        this.indexB = new Vector_a2j_Number(3);
    };
    b2SimplexVertex.b2SimplexVertex = function () {};
    b2SimplexVertex.prototype.Set = function (other) {
        this.wA.SetV(other.wA);
        this.wB.SetV(other.wB);
        this.w.SetV(other.w);
        this.a = other.a;
        this.indexA = other.indexA;
        this.indexB = other.indexB;
    }
    b2TimeOfImpact.b2TimeOfImpact = function () {};
    b2TimeOfImpact.TimeOfImpact = function (input) {
        ++b2TimeOfImpact.b2_toiCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var sweepA = input.sweepA;
        var sweepB = input.sweepB;
        b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
        b2Settings.b2Assert(1.0 - sweepA.t0 > Box2D.MIN_VALUE);
        var radius = proxyA.m_radius + proxyB.m_radius;
        var tolerance = input.tolerance;
        var alpha = 0.0;
        var k_maxIterations = 1000;
        var iter = 0;
        var target = 0.0;
        b2TimeOfImpact.s_cache.count = 0;
        b2TimeOfImpact.s_distanceInput.useRadii = false;
        for (;;) {
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
            b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
            b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
            b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
            b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
            b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
            if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
                alpha = 1.0;
                break;
            }
            b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
            var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (separation <= 0.0) {
                alpha = 1.0;
                break;
            }
            if (iter == 0) {
                if (separation > radius) {
                    target = b2Math.Max(radius - tolerance, 0.75 * radius);
                }
                else {
                    target = b2Math.Max(separation - tolerance, 0.02 * radius);
                }
            }
            if (separation - target < 0.5 * tolerance) {
                if (iter == 0) {
                    alpha = 1.0;
                    break;
                }
                break;
            }
            var newAlpha = alpha; {
                var x1 = alpha;
                var x2 = 1.0;
                var f1 = separation;
                sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
                sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
                var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                if (f2 >= target) {
                    alpha = 1.0;
                    break;
                }
                var rootIterCount = 0;
                for (;;) {
                    var x = 0;
                    if (rootIterCount & 1) {
                        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
                    }
                    else {
                        x = 0.5 * (x1 + x2);
                    }
                    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
                    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
                    var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                    if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                        newAlpha = x;
                        break;
                    }
                    if (f > target) {
                        x1 = x;
                        f1 = f;
                    }
                    else {
                        x2 = x;
                        f2 = f;
                    }++rootIterCount;
                    ++b2TimeOfImpact.b2_toiRootIters;
                    if (rootIterCount == 50) {
                        break;
                    }
                }
                b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
            }
            if (newAlpha < (1.0 + 100.0 * Box2D.MIN_VALUE) * alpha) {
                break;
            }
            alpha = newAlpha;
            iter++;
            ++b2TimeOfImpact.b2_toiIters;
            if (iter == k_maxIterations) {
                break;
            }
        }
        b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
        return alpha;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
        Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
        Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
        Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
        Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
    });
    b2TOIInput.b2TOIInput = function () {
        this.proxyA = new b2DistanceProxy();
        this.proxyB = new b2DistanceProxy();
        this.sweepA = new b2Sweep();
        this.sweepB = new b2Sweep();
    };
    b2WorldManifold.b2WorldManifold = function () {
        this.m_normal = new b2Vec2();
    };
    b2WorldManifold.prototype.b2WorldManifold = function () {
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
        if (radiusA === undefined) radiusA = 0;
        if (radiusB === undefined) radiusB = 0;
        if (manifold.m_pointCount == 0) {
            return;
        }
        var i = 0;
        var tVec;
        var tMat;
        var normalX = 0;
        var normalY = 0;
        var planePointX = 0;
        var planePointY = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        switch (manifold.m_type) {
            case b2Manifold.e_circles:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_points[0].m_localPoint;
                var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1;
                    this.m_normal.y = 0;
                }
                var cAX = pointAX + radiusA * this.m_normal.x;
                var cAY = pointAY + radiusA * this.m_normal.y;
                var cBX = pointBX - radiusB * this.m_normal.x;
                var cBY = pointBY - radiusB * this.m_normal.y;
                this.m_points[0].x = 0.5 * (cAX + cBX);
                this.m_points[0].y = 0.5 * (cAY + cBY);
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = xfA.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfA.R;
                tVec = manifold.m_localPoint;
                planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = normalX;
                this.m_normal.y = normalY;
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfB.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = xfB.R;
                tVec = manifold.m_localPlaneNormal;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = xfB.R;
                tVec = manifold.m_localPoint;
                planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                this.m_normal.x = (-normalX);
                this.m_normal.y = (-normalY);
                for (i = 0;
                     i < manifold.m_pointCount; i++) {
                    tMat = xfA.R;
                    tVec = manifold.m_points[i].m_localPoint;
                    clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
                    this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
                }
            }
                break;
        }
    }
    ClipVertex.ClipVertex = function () {
        this.v = new b2Vec2();
        this.id = new b2ContactID();
    };
    ClipVertex.prototype.Set = function (other) {
        this.v.SetV(other.v);
        this.id.Set(other.id);
    }
    Features.Features = function () {};
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._referenceEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'referenceEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._referenceEdge = value;
            this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentEdge;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentEdge', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentEdge = value;
            this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._incidentVertex;
        }
    });
    Object.defineProperty(Features.prototype, 'incidentVertex', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._incidentVertex = value;
            this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        get: function () {
            return this._flip;
        }
    });
    Object.defineProperty(Features.prototype, 'flip', {
        enumerable: false,
        configurable: true,
        set: function (value) {
            if (value === undefined) value = 0;
            this._flip = value;
            this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
        }
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
    b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2CircleShape.b2CircleShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.m_p = new b2Vec2();
    };
    b2CircleShape.prototype.Copy = function () {
        var s = new b2CircleShape();
        s.Set(this);
        return s;
    }
    b2CircleShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2CircleShape)) {
            var other2 = (other instanceof b2CircleShape ? other : null);
            this.m_p.SetV(other2.m_p);
        }
    }
    b2CircleShape.prototype.TestPoint = function (transform, p) {
        var tMat = transform.R;
        var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        dX = p.x - dX;
        dY = p.y - dY;
        return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
    }
    b2CircleShape.prototype.RayCast = function (output, input, transform) {
        var tMat = transform.R;
        var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        var sX = input.p1.x - positionX;
        var sY = input.p1.y - positionY;
        var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        var c = (sX * rX + sY * rY);
        var rr = (rX * rX + rY * rY);
        var sigma = c * c - rr * b;
        if (sigma < 0.0 || rr < Box2D.MIN_VALUE) {
            return false;
        }
        var a = (-(c + Math.sqrt(sigma)));
        if (0.0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            output.normal.x = sX + a * rX;
            output.normal.y = sY + a * rY;
            output.normal.Normalize();
            return true;
        }
        return false;
    }
    b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
        aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
    }
    b2CircleShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
        massData.center.SetV(this.m_p);
        massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
    }
    b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var p = b2Math.MulX(xf, this.m_p);
        var l = (-(b2Math.Dot(normal, p) - offset));
        if (l < (-this.m_radius) + Box2D.MIN_VALUE) {
            return 0;
        }
        if (l > this.m_radius) {
            c.SetV(p);
            return Math.PI * this.m_radius * this.m_radius;
        }
        var r2 = this.m_radius * this.m_radius;
        var l2 = l * l;
        var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
        var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
        c.x = p.x + normal.x * com;
        c.y = p.y + normal.y * com;
        return area;
    }
    b2CircleShape.prototype.GetLocalPosition = function () {
        return this.m_p;
    }
    b2CircleShape.prototype.SetLocalPosition = function (position) {
        this.m_p.SetV(position);
    }
    b2CircleShape.prototype.GetRadius = function () {
        return this.m_radius;
    }
    b2CircleShape.prototype.SetRadius = function (radius) {
        if (radius === undefined) radius = 0;
        this.m_radius = radius;
    }
    b2CircleShape.prototype.b2CircleShape = function (radius) {
        if (radius === undefined) radius = 0;
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_circleShape;
        this.m_radius = radius;
    }
    b2EdgeChainDef.b2EdgeChainDef = function () {};
    b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0;
        this.isALoop = true;
        this.vertices = [];
    }
    Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
    b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2EdgeShape.b2EdgeShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.s_supportVec = new b2Vec2();
        this.m_v1 = new b2Vec2();
        this.m_v2 = new b2Vec2();
        this.m_coreV1 = new b2Vec2();
        this.m_coreV2 = new b2Vec2();
        this.m_normal = new b2Vec2();
        this.m_direction = new b2Vec2();
        this.m_cornerDir1 = new b2Vec2();
        this.m_cornerDir2 = new b2Vec2();
    };
    b2EdgeShape.prototype.TestPoint = function (transform, p) {
        return false;
    }

    b2EdgeShape.prototype.Copy = function () {
        var s = new b2EdgeShape(this.m_v1, this.m_v2);
        s.Set(this);
        return s;
    }

    b2EdgeShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2EdgeShape)) {
            var other2 = (other instanceof b2EdgeShape ? other : null);
            this.s_supportVec.SetV(other2.s_supportVec);
            this.m_v1.SetV(other2.m_v1);
            this.m_v2.SetV(other2.m_v2);
            this.m_coreV1.SetV(other2.m_coreV1);
            this.m_coreV2.SetV(other2.m_coreV2);
            this.m_normal.SetV(other2.m_normal);
            this.m_direction.SetV(other2.m_direction);
            this.m_cornerDir1.SetV(other2.m_cornerDir1);
            this.m_cornerDir2.SetV(other2.m_cornerDir2);
        }
    }
    b2EdgeShape.prototype.RayCast = function (output, input, transform) {
        var tMat;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
        var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
        var k_slop = 100.0 * Box2D.MIN_VALUE;
        var denom = (-(rX * nX + rY * nY));
        if (denom > k_slop) {
            var bX = input.p1.x - v1X;
            var bY = input.p1.y - v1Y;
            var a = (bX * nX + bY * nY);
            if (0.0 <= a && a <= input.maxFraction * denom) {
                var mu2 = (-rX * bY) + rY * bX;
                if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
                    a /= denom;
                    output.fraction = a;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    output.normal.x = nX / nLen;
                    output.normal.y = nY / nLen;
                    return true;
                }
            }
        }
        return false;
    }
    b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
        var tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
        var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
        if (v1X < v2X) {
            aabb.lowerBound.x = v1X;
            aabb.upperBound.x = v2X;
        }
        else {
            aabb.lowerBound.x = v2X;
            aabb.upperBound.x = v1X;
        }
        if (v1Y < v2Y) {
            aabb.lowerBound.y = v1Y;
            aabb.upperBound.y = v2Y;
        }
        else {
            aabb.lowerBound.y = v2Y;
            aabb.upperBound.y = v1Y;
        }
    }
    b2EdgeShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        massData.mass = 0;
        massData.center.SetV(this.m_v1);
        massData.I = 0;
    }
    b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
        var v1 = b2Math.MulX(xf, this.m_v1);
        var v2 = b2Math.MulX(xf, this.m_v2);
        var d1 = b2Math.Dot(normal, v1) - offset;
        var d2 = b2Math.Dot(normal, v2) - offset;
        if (d1 > 0) {
            if (d2 > 0) {
                return 0;
            }
            else {
                v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
        }
        else {
            if (d2 > 0) {
                v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
                v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
            }
            else {}
        }
        c.x = (v0.x + v1.x + v2.x) / 3;
        c.y = (v0.y + v1.y + v2.y) / 3;
        return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
    }
    b2EdgeShape.prototype.GetLength = function () {
        return this.m_length;
    }
    b2EdgeShape.prototype.GetVertex1 = function () {
        return this.m_v1;
    }
    b2EdgeShape.prototype.GetVertex2 = function () {
        return this.m_v2;
    }
    b2EdgeShape.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1;
    }
    b2EdgeShape.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2;
    }
    b2EdgeShape.prototype.GetNormalVector = function () {
        return this.m_normal;
    }
    b2EdgeShape.prototype.GetDirectionVector = function () {
        return this.m_direction;
    }
    b2EdgeShape.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1;
    }
    b2EdgeShape.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2;
    }
    b2EdgeShape.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1;
    }
    b2EdgeShape.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2;
    }
    b2EdgeShape.prototype.GetFirstVertex = function (xf) {
        var tMat = xf.R;
        return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
    }
    b2EdgeShape.prototype.GetNextEdge = function () {
        return this.m_nextEdge;
    }
    b2EdgeShape.prototype.GetPrevEdge = function () {
        return this.m_prevEdge;
    }
    b2EdgeShape.prototype.Support = function (xf, dX, dY) {
        if (dX === undefined) dX = 0;
        if (dY === undefined) dY = 0;
        var tMat = xf.R;
        var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
        var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
        var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
        var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
        if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
            this.s_supportVec.x = v1X;
            this.s_supportVec.y = v1Y;
        }
        else {
            this.s_supportVec.x = v2X;
            this.s_supportVec.y = v2Y;
        }
        return this.s_supportVec;
    }
    b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_edgeShape;
        this.m_prevEdge = null;
        this.m_nextEdge = null;
        this.m_v1 = v1;
        this.m_v2 = v2;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
        this.m_length = this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
        this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
        this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
    }
    b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
        this.m_prevEdge = edge;
        this.m_coreV1 = core;
        this.m_cornerDir1 = cornerDir;
        this.m_cornerConvex1 = convex;
    }
    b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
        this.m_nextEdge = edge;
        this.m_coreV2 = core;
        this.m_cornerDir2 = cornerDir;
        this.m_cornerConvex2 = convex;
    }
    b2EdgeShape.prototype.Copy = function () {
        var s = new b2EdgeShape(this.m_v1, this.m_v2);

        return s;
    }
    b2MassData.b2MassData = function () {
        this.mass = 0.0;
        this.center = new b2Vec2(0, 0);
        this.I = 0.0;
    };
    Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
    b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b2PolygonShape.b2PolygonShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
    };
    b2PolygonShape.prototype.Copy = function () {
        var s = new b2PolygonShape();
        s.Set(this);
        return s;
    }
    b2PolygonShape.prototype.Set = function (other) {
        this.__super.Set.call(this, other);
        if (Box2D.is(other, b2PolygonShape)) {
            var other2 = (other instanceof b2PolygonShape ? other : null);
            this.m_centroid.SetV(other2.m_centroid);
            this.m_vertexCount = other2.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var i = 0; i < this.m_vertexCount; i++) {
                this.m_vertices[i].SetV(other2.m_vertices[i]);
                this.m_normals[i].SetV(other2.m_normals[i]);
            }
        }
    }

    b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var v = new Vector();
        var i = 0,
            tVec;
        for (i = 0;
             i < vertices.length; ++i) {
            tVec = vertices[i];
            v.push(tVec);
        }
        this.SetAsVector(v, vertexCount);
    }
    b2PolygonShape.AsArray = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsArray(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        if (vertexCount == 0) vertexCount = vertices.length;
        b2Settings.b2Assert(2 <= vertexCount);
        this.m_vertexCount = vertexCount;
        this.Reserve(vertexCount);
      
        // Find the right most point on the hull
        var i0 = 0;
        var x0 = vertices[0].x;
        for(var i = 1; i < vertexCount; i++) {
            var x = vertices[i].x;
            if(x > x0 || (x == x0 && vertices[i].y < vertices[i0].y)){
                i0 = i;
                x0 = x;
            }
        }
        var hull = [];
        var m = 0; 
        var ih = i0;
        while(true){
            hull[m] = ih;

            var ie = 0;
            for(var j = 1; j < vertexCount; j++) {
                if(ie == ih) {
                    ie = j;
                    continue;
                }
                var r = b2Math.SubtractVV(vertices[ie], vertices[hull[m]]);
                var v = b2Math.SubtractVV(vertices[j], vertices[hull[m]]);
                var c = b2Math.CrossVV(r, v);
                if(c < 0) {
                    ie = j;
                }

                // Collinearity check
                if(c == 0 && v.LengthSquared() > r.LengthSquared()) {
                    ie = j;
                }
            }
            ++m;
            ih = ie;

            if(ie == i0) {
                break;
            }
        }

        if(m < 3) {
            // Polygon is degenerate
            console.error("vertices is less then 3");
            this.SetAsBox(1.0, 1.0);
            return;
        }

        if(m < this.m_vertexCount) {
            console.error("some vertices have to be abandomed");
        }
        this.m_vertexCount = m;

        // Copy vertices
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(vertices[hull[i]]);
        }

        // Compute normals. Ensure the edges have non-zero length
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            var i1 = parseInt(i);
            var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
            var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
            b2Settings.b2Assert(edge.LengthSquared() > Box2D.MIN_VALUE);
            this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
            this.m_normals[i].Normalize();
        }

        //Compute the polygon centroid
        this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
    }
    b2PolygonShape.AsVector = function (vertices, vertexCount) {
        if (vertexCount === undefined) vertexCount = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsVector(vertices, vertexCount);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid.SetZero();
    }
    b2PolygonShape.AsBox = function (hx, hy) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsBox(hx, hy);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set((-hx), (-hy));
        this.m_vertices[1].Set(hx, (-hy));
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set((-hx), hy);
        this.m_normals[0].Set(0.0, (-1.0));
        this.m_normals[1].Set(1.0, 0.0);
        this.m_normals[2].Set(0.0, 1.0);
        this.m_normals[3].Set((-1.0), 0.0);
        this.m_centroid = center;
        var xf = new b2Transform();
        xf.position = center;
        xf.R.Set(angle);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
            this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
        }
    }
    b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
        if (hx === undefined) hx = 0;
        if (hy === undefined) hy = 0;
        if (center === undefined) center = null;
        if (angle === undefined) angle = 0.0;
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsOrientedBox(hx, hy, center, angle);
        return polygonShape;
    }
    b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(v1);
        this.m_vertices[1].SetV(v2);
        this.m_centroid.x = 0.5 * (v1.x + v2.x);
        this.m_centroid.y = 0.5 * (v1.y + v2.y);
        this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = (-this.m_normals[0].x);
        this.m_normals[1].y = (-this.m_normals[0].y);
    }
    b2PolygonShape.AsEdge = function (v1, v2) {
        var polygonShape = new b2PolygonShape();
        polygonShape.SetAsEdge(v1, v2);
        return polygonShape;
    }
    b2PolygonShape.prototype.TestPoint = function (xf, p) {
        var tVec;
        var tMat = xf.R;
        var tX = p.x - xf.position.x;
        var tY = p.y - xf.position.y;
        var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
        var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = pLocalX - tVec.x;
            tY = pLocalY - tVec.y;
            tVec = this.m_normals[i];
            var dot = (tVec.x * tX + tVec.y * tY);
            if (dot > 0.0) {
                return false;
            }
        }
        return true;
    }
    b2PolygonShape.prototype.RayCast = function (output, input, transform) {
        var lower = 0.0;
        var upper = input.maxFraction;
        var tX = 0;
        var tY = 0;
        var tMat;
        var tVec;
        tX = input.p1.x - transform.position.x;
        tY = input.p1.y - transform.position.y;
        tMat = transform.R;
        var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        tX = input.p2.x - transform.position.x;
        tY = input.p2.y - transform.position.y;
        tMat = transform.R;
        var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
        var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var index = parseInt((-1));
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = tVec.x - p1X;
            tY = tVec.y - p1Y;
            tVec = this.m_normals[i];
            var numerator = (tVec.x * tX + tVec.y * tY);
            var denominator = (tVec.x * dX + tVec.y * dY);
            if (denominator == 0.0) {
                if (numerator < 0.0) {
                    return false;
                }
            }
            else {
                if (denominator < 0.0 && numerator < lower * denominator) {
                    lower = numerator / denominator;
                    index = i;
                }
                else if (denominator > 0.0 && numerator < upper * denominator) {
                    upper = numerator / denominator;
                }
            }
            if (upper < lower - Box2D.MIN_VALUE) {
                return false;
            }
        }
        if (index >= 0) {
            output.fraction = lower;
            tMat = transform.R;
            tVec = this.m_normals[index];
            output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            return true;
        }
        return false;
    }
    b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
        var tMat = xf.R;
        var tVec = this.m_vertices[0];
        var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var upperX = lowerX;
        var upperY = lowerY;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            lowerX = lowerX < vX ? lowerX : vX;
            lowerY = lowerY < vY ? lowerY : vY;
            upperX = upperX > vX ? upperX : vX;
            upperY = upperY > vY ? upperY : vY;
        }
        aabb.lowerBound.x = lowerX - this.m_radius;
        aabb.lowerBound.y = lowerY - this.m_radius;
        aabb.upperBound.x = upperX + this.m_radius;
        aabb.upperBound.y = upperY + this.m_radius;
    }
    b2PolygonShape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
        if (this.m_vertexCount == 2) {
            massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
            massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
            massData.mass = 0.0;
            massData.I = 0.0;
            return;
        }
        var centerX = 0.0;
        var centerY = 0.0;
        var area = 0.0;
        var I = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var k_inv3 = 1.0 / 3.0;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            var p2 = this.m_vertices[i];
            var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = e1X * e2Y - e1Y * e2X;
            var triangleArea = 0.5 * D;area += triangleArea;
            centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
            centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
            var px = p1X;
            var py = p1Y;
            var ex1 = e1X;
            var ey1 = e1Y;
            var ex2 = e2X;
            var ey2 = e2Y;
            var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
            var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
        }
        massData.mass = density * area;
        centerX *= 1.0 / area;
        centerY *= 1.0 / area;
        massData.center.Set(centerX, centerY);
        massData.I = density * I;
    }
    b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        var normalL = b2Math.MulTMV(xf.R, normal);
        var offsetL = offset - b2Math.Dot(normal, xf.position);
        var depths = new Vector_a2j_Number();
        var diveCount = 0;
        var intoIndex = parseInt((-1));
        var outoIndex = parseInt((-1));
        var lastSubmerged = false;
        var i = 0;
        for (i = 0;
             i < this.m_vertexCount; ++i) {
            depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
            var isSubmerged = depths[i] < (-Box2D.MIN_VALUE);
            if (i > 0) {
                if (isSubmerged) {
                    if (!lastSubmerged) {
                        intoIndex = i - 1;
                        diveCount++;
                    }
                }
                else {
                    if (lastSubmerged) {
                        outoIndex = i - 1;
                        diveCount++;
                    }
                }
            }
            lastSubmerged = isSubmerged;
        }
        switch (diveCount) {
            case 0:
                if (lastSubmerged) {
                    var md = new b2MassData();
                    this.ComputeMass(md, 1);
                    c.SetV(b2Math.MulX(xf, md.center));
                    return md.mass;
                }
                else {
                    return 0;
                }
                break;
            case 1:
                if (intoIndex == (-1)) {
                    intoIndex = this.m_vertexCount - 1;
                }
                else {
                    outoIndex = this.m_vertexCount - 1;
                }
                break;
        }
        var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
        var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
        var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
        var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
        var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
        var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
        var area = 0;
        var center = new b2Vec2();
        var p2 = this.m_vertices[intoIndex2];
        var p3;
        i = intoIndex2;
        while (i != outoIndex2) {
            i = (i + 1) % this.m_vertexCount;
            if (i == outoIndex2) p3 = outoVec;
            else p3 = this.m_vertices[i];
            var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
            area += triangleArea;
            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
            p2 = p3;
        }
        center.Multiply(1 / area);
        c.SetV(b2Math.MulX(xf, center));
        return area;
    }
    b2PolygonShape.prototype.GetVertexCount = function () {
        return this.m_vertexCount;
    }
    b2PolygonShape.prototype.GetVertices = function () {
        return this.m_vertices;
    }
    b2PolygonShape.prototype.GetNormals = function () {
        return this.m_normals;
    }
    b2PolygonShape.prototype.GetSupport = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return bestIndex;
    }
    b2PolygonShape.prototype.GetSupportVertex = function (d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value;
            }
        }
        return this.m_vertices[bestIndex];
    }
    b2PolygonShape.prototype.Validate = function () {
        return false;
    }
    b2PolygonShape.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this);
        this.m_type = b2Shape.e_polygonShape;
        this.m_centroid = new b2Vec2();
        this.m_vertices = new Vector();
        this.m_normals = new Vector();
    }
    b2PolygonShape.prototype.Reserve = function (count) {
        if (count === undefined) count = 0;
        for (var i = parseInt(this.m_vertices.length); i < count; i++) {
            this.m_vertices[i] = new b2Vec2();
            this.m_normals[i] = new b2Vec2();
        }
    }
    b2PolygonShape.ComputeCentroid = function (vs, count) {
        if (count === undefined) count = 0;
        var c = new b2Vec2();
        var area = 0.0;
        var p1X = 0.0;
        var p1Y = 0.0;
        var inv3 = 1.0 / 3.0;
        for (var i = 0; i < count; ++i) {
            var p2 = vs[i];
            var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = (e1X * e2Y - e1Y * e2X);
            var triangleArea = 0.5 * D;area += triangleArea;
            c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
            c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
        }
        c.x *= 1.0 / area;
        c.y *= 1.0 / area;
        return c;
    }
    b2PolygonShape.ComputeOBB = function (obb, vs, count) {
        if (count === undefined) count = 0;
        var i = 0;
        var p = new Vector(count + 1);
        for (i = 0;
             i < count; ++i) {
            p[i] = vs[i];
        }
        p[count] = p[0];
        var minArea = Number.MAX_VALUE;
        for (i = 1;
             i <= count; ++i) {
            var root = p[parseInt(i - 1)];
            var uxX = p[i].x - root.x;
            var uxY = p[i].y - root.y;
            var length = Math.sqrt(uxX * uxX + uxY * uxY);
            uxX /= length;
            uxY /= length;
            var uyX = (-uxY);
            var uyY = uxX;
            var lowerX = Number.MAX_VALUE;
            var lowerY = Number.MAX_VALUE;
            var upperX = (-Number.MAX_VALUE);
            var upperY = (-Number.MAX_VALUE);
            for (var j = 0; j < count; ++j) {
                var dX = p[j].x - root.x;
                var dY = p[j].y - root.y;
                var rX = (uxX * dX + uxY * dY);
                var rY = (uyX * dX + uyY * dY);
                if (rX < lowerX) lowerX = rX;
                if (rY < lowerY) lowerY = rY;
                if (rX > upperX) upperX = rX;
                if (rY > upperY) upperY = rY;
            }
            var area = (upperX - lowerX) * (upperY - lowerY);
            if (area < 0.95 * minArea) {
                minArea = area;
                obb.R.col1.x = uxX;
                obb.R.col1.y = uxY;
                obb.R.col2.x = uyX;
                obb.R.col2.y = uyY;
                var centerX = 0.5 * (lowerX + upperX);
                var centerY = 0.5 * (lowerY + upperY);
                var tMat = obb.R;
                obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
                obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
                obb.extents.x = 0.5 * (upperX - lowerX);
                obb.extents.y = 0.5 * (upperY - lowerY);
            }
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
    });
    b2Shape.b2Shape = function () {};
    b2Shape.prototype.Copy = function () {
        return null;
    }
    b2Shape.prototype.Set = function (other) {
        this.m_radius = other.m_radius;
    }
    b2Shape.prototype.GetType = function () {
        return this.m_type;
    }
    b2Shape.prototype.TestPoint = function (xf, p) {
        return false;
    }
    b2Shape.prototype.RayCast = function (output, input, transform) {
        return false;
    }
    b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
    b2Shape.prototype.ComputeMass = function (massData, density) {
        if (density === undefined) density = 0;
    }
    b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
        if (offset === undefined) offset = 0;
        return 0;
    }
    b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
        var input = new b2DistanceInput();
        input.proxyA = new b2DistanceProxy();
        input.proxyA.Set(shape1);
        input.proxyB = new b2DistanceProxy();
        input.proxyB.Set(shape2);
        input.transformA = transform1;
        input.transformB = transform2;
        input.useRadii = true;
        var simplexCache = new b2SimplexCache();
        simplexCache.count = 0;
        var output = new b2DistanceOutput();
        b2Distance.Distance(output, simplexCache, input);
        return output.distance < 10.0 * Box2D.MIN_VALUE;
    }
    b2Shape.prototype.b2Shape = function () {
        this.m_type = b2Shape.e_unknownShape;
        this.m_radius = b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
        Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
        Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
        Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
        Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
        Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
        Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
        Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
    });
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Color.b2Color = function () {
        this._r = 0;
        this._g = 0;
        this._b = 0;
    };
    b2Color.prototype.b2Color = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    b2Color.prototype.Set = function (rr, gg, bb) {
        if (rr === undefined) rr = 0;
        if (gg === undefined) gg = 0;
        if (bb === undefined) bb = 0;
        this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
    Object.defineProperty(b2Color.prototype, 'r', {
        enumerable: false,
        configurable: true,
        set: function (rr) {
            if (rr === undefined) rr = 0;
            this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'g', {
        enumerable: false,
        configurable: true,
        set: function (gg) {
            if (gg === undefined) gg = 0;
            this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'b', {
        enumerable: false,
        configurable: true,
        set: function (bb) {
            if (bb === undefined) bb = 0;
            this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
        }
    });
    Object.defineProperty(b2Color.prototype, 'color', {
        enumerable: false,
        configurable: true,
        get: function () {
            return (this._r << 16) | (this._g << 8) | (this._b);
        }
    });
    b2Settings.b2Settings = function () {};
    b2Settings.b2MixFriction = function (friction1, friction2) {
        if (friction1 === undefined) friction1 = 0;
        if (friction2 === undefined) friction2 = 0;
        return Math.sqrt(friction1 * friction2);
    }
    b2Settings.b2MixRestitution = function (restitution1, restitution2) {
        if (restitution1 === undefined) restitution1 = 0;
        if (restitution2 === undefined) restitution2 = 0;
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
    b2Settings.b2Assert = function (a) {
        if (!a) {
            throw "Assertion Failed";
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.b2Settings.VERSION = "2.1alpha";
        Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
        Box2D.Common.b2Settings.b2_pi = Math.PI;
        Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
        Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
        Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
        Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_linearSlop = 0.005;
        Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
        Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
        Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
        Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
        Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
        Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
        Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
        Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
        Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
        Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
        Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
        Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
        Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
    });
})();
(function () {
    var b2AABB = Box2D.Collision.b2AABB,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3;

    b2Mat22.b2Mat22 = function () {
        this.col1 = new b2Vec2();
        this.col2 = new b2Vec2();
    };
    b2Mat22.prototype.b2Mat22 = function () {
        this.SetIdentity();
    }
    b2Mat22.FromAngle = function (angle) {
        if (angle === undefined) angle = 0;
        var mat = new b2Mat22();
        mat.Set(angle);
        return mat;
    }
    b2Mat22.FromVV = function (c1, c2) {
        var mat = new b2Mat22();
        mat.SetVV(c1, c2);
        return mat;
    }
    b2Mat22.prototype.Set = function (angle) {
        if (angle === undefined) angle = 0;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.col1.x = c;
        this.col2.x = (-s);
        this.col1.y = s;
        this.col2.y = c;
    }
    b2Mat22.prototype.SetVV = function (c1, c2) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
    }
    b2Mat22.prototype.Copy = function () {
        var mat = new b2Mat22();
        mat.SetM(this);
        return mat;
    }
    b2Mat22.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
    }
    b2Mat22.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
    }
    b2Mat22.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
    }
    b2Mat22.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
    }
    b2Mat22.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x);
    }
    b2Mat22.prototype.GetInverse = function (out) {
        var a = this.col1.x;
        var b = this.col2.x;
        var c = this.col1.y;
        var d = this.col2.y;
        var det = a * d - b * c;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.col1.x = det * d;
        out.col2.x = (-det * b);
        out.col1.y = (-det * c);
        out.col2.y = det * a;
        return out;
    }
    b2Mat22.prototype.Solve = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat22.prototype.Abs = function () {
        this.col1.Abs();
        this.col2.Abs();
    }
    b2Mat33.b2Mat33 = function () {
        this.col1 = new b2Vec3();
        this.col2 = new b2Vec3();
        this.col3 = new b2Vec3();
    };
    b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
        if (c1 === undefined) c1 = null;
        if (c2 === undefined) c2 = null;
        if (c3 === undefined) c3 = null;
        if (!c1 && !c2 && !c3) {
            this.col1.SetZero();
            this.col2.SetZero();
            this.col3.SetZero();
        }
        else {
            this.col1.SetV(c1);
            this.col2.SetV(c2);
            this.col3.SetV(c3);
        }
    }
    b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
        this.col3.SetV(c3);
    }
    b2Mat33.prototype.Copy = function () {
        return new b2Mat33(this.col1, this.col2, this.col3);
    }
    b2Mat33.prototype.SetM = function (m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
        this.col3.SetV(m.col3);
    }
    b2Mat33.prototype.AddM = function (m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col1.z += m.col1.z;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
        this.col2.z += m.col2.z;
        this.col3.x += m.col3.x;
        this.col3.y += m.col3.y;
        this.col3.z += m.col3.z;
    }
    b2Mat33.prototype.SetIdentity = function () {
        this.col1.x = 1.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 1.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 1.0;
    }
    b2Mat33.prototype.SetZero = function () {
        this.col1.x = 0.0;
        this.col2.x = 0.0;
        this.col3.x = 0.0;
        this.col1.y = 0.0;
        this.col2.y = 0.0;
        this.col3.y = 0.0;
        this.col1.z = 0.0;
        this.col2.z = 0.0;
        this.col3.z = 0.0;
    }
    b2Mat33.prototype.Solve22 = function (out, bX, bY) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out;
    }
    b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
        if (bX === undefined) bX = 0;
        if (bY === undefined) bY = 0;
        if (bZ === undefined) bZ = 0;
        var a11 = this.col1.x;
        var a21 = this.col1.y;
        var a31 = this.col1.z;
        var a12 = this.col2.x;
        var a22 = this.col2.y;
        var a32 = this.col2.z;
        var a13 = this.col3.x;
        var a23 = this.col3.y;
        var a33 = this.col3.z;
        var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
        if (det != 0.0) {
            det = 1.0 / det;
        }
        out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
        out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
        out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
        return out;
    }
    b2Math.b2Math = function () {};
    b2Math.IsValid = function (x) {
        if (x === undefined) x = 0;
        return isFinite(x);
    }
    b2Math.Dot = function (a, b) {
        return a.x * b.x + a.y * b.y;
    }
    b2Math.CrossVV = function (a, b) {
        return a.x * b.y - a.y * b.x;
    }
    b2Math.CrossVF = function (a, s) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.y, (-s * a.x));
        return v;
    }
    b2Math.CrossFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2((-s * a.y), s * a.x);
        return v;
    }
    b2Math.MulMV = function (A, v) {
        var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
        return u;
    }
    b2Math.MulTMV = function (A, v) {
        var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
        return u;
    }
    b2Math.MulX = function (T, v) {
        var a = b2Math.MulMV(T.R, v);
        a.x += T.position.x;
        a.y += T.position.y;
        return a;
    }
    b2Math.MulXT = function (T, v) {
        var a = b2Math.SubtractVV(v, T.position);
        var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
        a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
        a.x = tX;
        return a;
    }
    b2Math.AddVV = function (a, b) {
        var v = new b2Vec2(a.x + b.x, a.y + b.y);
        return v;
    }
    b2Math.SubtractVV = function (a, b) {
        var v = new b2Vec2(a.x - b.x, a.y - b.y);
        return v;
    }
    b2Math.Distance = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return Math.sqrt(cX * cX + cY * cY);
    }
    b2Math.DistanceSquared = function (a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return (cX * cX + cY * cY);
    }
    b2Math.MulFV = function (s, a) {
        if (s === undefined) s = 0;
        var v = new b2Vec2(s * a.x, s * a.y);
        return v;
    }
    b2Math.AddMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
        return C;
    }
    b2Math.MulMM = function (A, B) {
        var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
        return C;
    }
    b2Math.MulTMM = function (A, B) {
        var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
        var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
        var C = b2Mat22.FromVV(c1, c2);
        return C;
    }
    b2Math.Abs = function (a) {
        if (a === undefined) a = 0;
        return a > 0.0 ? a : (-a);
    }
    b2Math.AbsV = function (a) {
        var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
        return b;
    }
    b2Math.AbsM = function (A) {
        var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
        return B;
    }
    b2Math.Min = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a < b ? a : b;
    }
    b2Math.MinV = function (a, b) {
        var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
        return c;
    }
    b2Math.Max = function (a, b) {
        if (a === undefined) a = 0;
        if (b === undefined) b = 0;
        return a > b ? a : b;
    }
    b2Math.MaxV = function (a, b) {
        var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
        return c;
    }
    b2Math.Clamp = function (a, low, high) {
        if (a === undefined) a = 0;
        if (low === undefined) low = 0;
        if (high === undefined) high = 0;
        return a < low ? low : a > high ? high : a;
    }
    b2Math.ClampV = function (a, low, high) {
        return b2Math.MaxV(low, b2Math.MinV(a, high));
    }
    b2Math.Swap = function (a, b) {
        var tmp = a[0];
        a[0] = b[0];
        b[0] = tmp;
    }
    b2Math.Random = function () {
        return Math.random() * 2 - 1;
    }
    b2Math.RandomRange = function (lo, hi) {
        if (lo === undefined) lo = 0;
        if (hi === undefined) hi = 0;
        var r = Math.random();
        r = (hi - lo) * r + lo;
        return r;
    }
    b2Math.NextPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        x |= (x >> 1) & 0x7FFFFFFF;
        x |= (x >> 2) & 0x3FFFFFFF;
        x |= (x >> 4) & 0x0FFFFFFF;
        x |= (x >> 8) & 0x00FFFFFF;
        x |= (x >> 16) & 0x0000FFFF;
        return x + 1;
    }
    b2Math.IsPowerOfTwo = function (x) {
        if (x === undefined) x = 0;
        var result = x > 0 && (x & (x - 1)) == 0;
        return result;
    }
    Box2D.postDefs.push(function () {
        Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
        Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
        Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
    });
    b2Sweep.b2Sweep = function () {
        this.localCenter = new b2Vec2();
        this.c0 = new b2Vec2;
        this.c = new b2Vec2();
    };
    b2Sweep.prototype.Set = function (other) {
        this.localCenter.SetV(other.localCenter);
        this.c0.SetV(other.c0);
        this.c.SetV(other.c);
        this.a0 = other.a0;
        this.a = other.a;
        this.t0 = other.t0;
    }
    b2Sweep.prototype.Copy = function () {
        var copy = new b2Sweep();
        copy.localCenter.SetV(this.localCenter);
        copy.c0.SetV(this.c0);
        copy.c.SetV(this.c);
        copy.a0 = this.a0;
        copy.a = this.a;
        copy.t0 = this.t0;
        return copy;
    }
    b2Sweep.prototype.GetTransform = function (xf, alpha) {
        if (alpha === undefined) alpha = 0;
        xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
        xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
        var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
        xf.R.Set(angle);
        var tMat = xf.R;
        xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
        xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
    }
    b2Sweep.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        if (this.t0 < t && 1.0 - this.t0 > Box2D.MIN_VALUE) {
            var alpha = (t - this.t0) / (1.0 - this.t0);
            this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
            this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
            this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
            this.t0 = t;
        }
    }
    b2Transform.b2Transform = function () {
        this.position = new b2Vec2;
        this.R = new b2Mat22();
    };
    b2Transform.prototype.b2Transform = function (pos, r) {
        if (pos === undefined) pos = null;
        if (r === undefined) r = null;
        if (pos) {
            this.position.SetV(pos);
            this.R.SetM(r);
        }
    }
    b2Transform.prototype.Initialize = function (pos, r) {
        this.position.SetV(pos);
        this.R.SetM(r);
    }
    b2Transform.prototype.SetIdentity = function () {
        this.position.SetZero();
        this.R.SetIdentity();
    }
    b2Transform.prototype.Set = function (x) {
        this.position.SetV(x.position);
        this.R.SetM(x.R);
    }
    b2Transform.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x);
    }
    b2Vec2.b2Vec2 = function () {};
    b2Vec2.prototype.b2Vec2 = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetZero = function () {
        this.x = 0.0;
        this.y = 0.0;
    }
    b2Vec2.prototype.Set = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        this.x = x_;
        this.y = y_;
    }
    b2Vec2.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
    }
    b2Vec2.prototype.GetNegative = function () {
        return new b2Vec2((-this.x), (-this.y));
    }
    b2Vec2.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
    }
    b2Vec2.Make = function (x_, y_) {
        if (x_ === undefined) x_ = 0;
        if (y_ === undefined) y_ = 0;
        return new b2Vec2(x_, y_);
    }
    b2Vec2.prototype.Copy = function () {
        return new b2Vec2(this.x, this.y);
    }
    b2Vec2.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
    }
    b2Vec2.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
    }
    b2Vec2.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
    }
    b2Vec2.prototype.MulM = function (A) {
        var tX = this.x;
        this.x = A.col1.x * tX + A.col2.x * this.y;
        this.y = A.col1.y * tX + A.col2.y * this.y;
    }
    b2Vec2.prototype.MulTM = function (A) {
        var tX = b2Math.Dot(this, A.col1);
        this.y = b2Math.Dot(this, A.col2);
        this.x = tX;
    }
    b2Vec2.prototype.CrossVF = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = s * this.y;
        this.y = (-s * tX);
    }
    b2Vec2.prototype.CrossFV = function (s) {
        if (s === undefined) s = 0;
        var tX = this.x;
        this.x = (-s * this.y);
        this.y = s * tX;
    }
    b2Vec2.prototype.MinV = function (b) {
        this.x = this.x < b.x ? this.x : b.x;
        this.y = this.y < b.y ? this.y : b.y;
    }
    b2Vec2.prototype.MaxV = function (b) {
        this.x = this.x > b.x ? this.x : b.x;
        this.y = this.y > b.y ? this.y : b.y;
    }
    b2Vec2.prototype.Abs = function () {
        if (this.x < 0) this.x = (-this.x);
        if (this.y < 0) this.y = (-this.y);
    }
    b2Vec2.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.LengthSquared = function () {
        return (this.x * this.x + this.y * this.y);
    }
    b2Vec2.prototype.Normalize = function () {
        var length = Math.sqrt(this.x * this.x + this.y * this.y);
        if (length < Box2D.MIN_VALUE) {
            return 0.0;
        }
        var invLength = 1.0 / length;
        this.x *= invLength;
        this.y *= invLength;
        return length;
    }
    b2Vec2.prototype.IsValid = function () {
        return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
    }
    b2Vec3.b2Vec3 = function () {};
    b2Vec3.prototype.b2Vec3 = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetZero = function () {
        this.x = this.y = this.z = 0.0;
    }
    b2Vec3.prototype.Set = function (x, y, z) {
        if (x === undefined) x = 0;
        if (y === undefined) y = 0;
        if (z === undefined) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    b2Vec3.prototype.SetV = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
    }
    b2Vec3.prototype.GetNegative = function () {
        return new b2Vec3((-this.x), (-this.y), (-this.z));
    }
    b2Vec3.prototype.NegativeSelf = function () {
        this.x = (-this.x);
        this.y = (-this.y);
        this.z = (-this.z);
    }
    b2Vec3.prototype.Copy = function () {
        return new b2Vec3(this.x, this.y, this.z);
    }
    b2Vec3.prototype.Add = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
    }
    b2Vec3.prototype.Subtract = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
    }
    b2Vec3.prototype.Multiply = function (a) {
        if (a === undefined) a = 0;
        this.x *= a;
        this.y *= a;
        this.z *= a;
    }
})();
(function () {
    var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

    b2Body.b2Body = function () {
        this.m_xf = new b2Transform();
        this.m_sweep = new b2Sweep();
        this.m_linearVelocity = new b2Vec2();
        this.m_force = new b2Vec2();
    };
    
    b2Body.prototype.modifyGravity = function (gravity) {
    	return gravity;
    }

    b2Body.prototype.connectEdges = function (s1, s2, angle1) {
        if (angle1 === undefined) angle1 = 0;
        var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
        var coreOffset = Math.tan((angle2 - angle1) * 0.5);
        var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
        core = b2Math.SubtractVV(core, s2.GetNormalVector());
        core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
        core = b2Math.AddVV(core, s2.GetVertex1());
        var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
        cornerDir.Normalize();
        var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
        s1.SetNextEdge(s2, core, cornerDir, convex);
        s2.SetPrevEdge(s1, core, cornerDir, convex);
        return angle2;
    }
    b2Body.prototype.CreateFixture = function (def) {
        if (this.m_world.IsLocked() == true) {
            return null;
        }
        var fixture = new b2Fixture();
        fixture.Create(this, this.m_xf, def);
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.CreateProxy(broadPhase, this.m_xf);
        }
        fixture.m_next = this.m_fixtureList;
        this.m_fixtureList = fixture;
        ++this.m_fixtureCount;
        fixture.m_body = this;
        if (fixture.m_density > 0.0) {
            this.ResetMassData();
        }
        this.m_world.m_flags |= b2World.e_newFixture;
        return fixture;
    }
    b2Body.prototype.CreateFixture2 = function (shape, density) {
        if (density === undefined) density = 0.0;
        var def = new b2FixtureDef();
        def.shape = shape;
        def.density = density;
        return this.CreateFixture(def);
    }
    b2Body.prototype.DestroyFixture = function (fixture) {
        if (this.m_world.IsLocked() == true) {
            return;
        }
        var node = this.m_fixtureList;
        var ppF = null;
        var found = false;
        while (node != null) {
            if (node == fixture) {
                if (ppF) ppF.m_next = fixture.m_next;
                else this.m_fixtureList = fixture.m_next;
                found = true;
                break;
            }
            ppF = node;
            node = node.m_next;
        }
        var edge = this.m_contactList;
        while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            if (fixture == fixtureA || fixture == fixtureB) {
                this.m_world.m_contactManager.Destroy(c);
            }
        }
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.DestroyProxy(broadPhase);
        }
        else {}
        fixture.Destroy();
        fixture.m_body = null;
        fixture.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData();
    }
    b2Body.prototype.SetPositionAndAngle = function (position, angle) {
        if (angle === undefined) angle = 0;
        var f;
        if (this.m_world.IsLocked() == true) {
            return;
        }
        this.m_xf.R.Set(angle);
        this.m_xf.position.SetV(position);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_sweep.a0 = this.m_sweep.a = angle;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, this.m_xf, this.m_xf);
        }
        this.m_world.m_contactManager.FindNewContacts();
    }
    b2Body.prototype.SetTransform = function (xf) {
        this.SetPositionAndAngle(xf.position, xf.GetAngle());
    }
    b2Body.prototype.GetTransform = function () {
        return this.m_xf;
    }
    b2Body.prototype.GetPosition = function () {
        return this.m_xf.position;
    }
    b2Body.prototype.SetPosition = function (position) {
        this.SetPositionAndAngle(position, this.GetAngle());
    }
    b2Body.prototype.GetAngle = function () {
        return this.m_sweep.a;
    }
    b2Body.prototype.SetAngle = function (angle) {
        if (angle === undefined) angle = 0;
        this.SetPositionAndAngle(this.GetPosition(), angle);
    }
    b2Body.prototype.GetWorldCenter = function () {
        return this.m_sweep.c;
    }
    b2Body.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter;
    }
    b2Body.prototype.SetLinearVelocity = function (v) {
        if (this.m_type == b2Body.b2_staticBody) {
        	alert("Static body not support SetLinearVelocity");
            return;
        }
        this.m_linearVelocity.SetV(v);
    }
    b2Body.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity;
    }
    b2Body.prototype.SetAngularVelocity = function (omega) {
        if (omega === undefined) omega = 0;
        if (this.m_type == b2Body.b2_staticBody) {
        	alert("Static body not support SetAngularVelocity");
            return;
        }
        this.m_angularVelocity = omega;
    }
    b2Body.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity;
    }
    b2Body.prototype.GetDefinition = function () {
        var bd = new b2BodyDef();
        bd.type = this.GetType();
        bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
        bd.angle = this.GetAngle();
        bd.angularDamping = this.m_angularDamping;
        bd.angularVelocity = this.m_angularVelocity;
        bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
        bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
        bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
        bd.linearDamping = this.m_linearDamping;
        bd.linearVelocity.SetV(this.GetLinearVelocity());
        bd.position = this.GetPosition();
        bd.userData = this.GetUserData();
        return bd;
    }
    b2Body.prototype.ApplyForce = function (force, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_force.x += force.x;
        this.m_force.y += force.y;
        this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
    }
    b2Body.prototype.ApplyTorque = function (torque) {
        if (torque === undefined) torque = 0;
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_torque += torque;
    }
    b2Body.prototype.ApplyImpulse = function (impulse, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true);
        }
        this.m_linearVelocity.x += this.m_invMass * impulse.x;
        this.m_linearVelocity.y += this.m_invMass * impulse.y;
        this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
    }
    b2Body.prototype.Split = function (callback) {
        var linearVelocity = this.GetLinearVelocity().Copy();
        var angularVelocity = this.GetAngularVelocity();
        var center = this.GetWorldCenter();
        var body1 = this;
        var body2 = this.m_world.CreateBody(this.GetDefinition());
        var prev;
        for (var f = body1.m_fixtureList; f;) {
            if (callback(f)) {
                var next = f.m_next;
                if (prev) {
                    prev.m_next = next;
                }
                else {
                    body1.m_fixtureList = next;
                }
                body1.m_fixtureCount--;
                f.m_next = body2.m_fixtureList;
                body2.m_fixtureList = f;
                body2.m_fixtureCount++;
                f.m_body = body2;
                f = next;
            }
            else {
                prev = f;
                f = f.m_next;
            }
        }
        body1.ResetMassData();
        body2.ResetMassData();
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
        var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
        body1.SetLinearVelocity(velocity1);
        body2.SetLinearVelocity(velocity2);
        body1.SetAngularVelocity(angularVelocity);
        body2.SetAngularVelocity(angularVelocity);
        body1.SynchronizeFixtures();
        body2.SynchronizeFixtures();
        return body2;
    }
    b2Body.prototype.Merge = function (other) {
        var f;
        for (f = other.m_fixtureList;
             f;) {
            var next = f.m_next;
            other.m_fixtureCount--;
            f.m_next = this.m_fixtureList;
            this.m_fixtureList = f;
            this.m_fixtureCount++;
            f.m_body = body2;
            f = next;
        }
        body1.m_fixtureCount = 0;
        var body1 = this;
        var body2 = other;
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = body1.GetLinearVelocity().Copy();
        var velocity2 = body2.GetLinearVelocity().Copy();
        var angular1 = body1.GetAngularVelocity();
        var angular = body2.GetAngularVelocity();
        body1.ResetMassData();
        this.SynchronizeFixtures();
    }
    b2Body.prototype.GetMass = function () {
        return this.m_mass;
    }
    b2Body.prototype.GetInertia = function () {
        return this.m_I;
    }
    b2Body.prototype.GetMassData = function (data) {
        data.mass = this.m_mass;
        data.I = this.m_I;
        data.center.SetV(this.m_sweep.localCenter);
    }
    b2Body.prototype.SetMassData = function (massData) {
        b2Settings.b2Assert(this.m_world.IsLocked() == false);
        if (this.m_world.IsLocked() == true) {
            return;
        }
        if (this.m_type != b2Body.b2_dynamicBody) {
            return;
        }
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_mass = massData.mass;
        if (this.m_mass <= 0.0) {
            this.m_mass = 1.0;
        }
        this.m_invMass = 1.0 / this.m_mass;
        if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
            this.m_invI = 1.0 / this.m_I;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(massData.center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.ResetMassData = function () {
        this.m_mass = 0.0;
        this.m_invMass = 0.0;
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
            return;
        }
        var center = b2Vec2.Make(0, 0);
        for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (f.m_density == 0.0) {
                continue;
            }
            var massData = f.GetMassData();
            this.m_mass += massData.mass;
            center.x += massData.center.x * massData.mass;
            center.y += massData.center.y * massData.mass;
            this.m_I += massData.I;
        }
        if (this.m_mass > 0.0) {
            this.m_invMass = 1.0 / this.m_mass;
            center.x *= this.m_invMass;
            center.y *= this.m_invMass;
        }
        else {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
            this.m_I *= this.m_inertiaScale;
            b2Settings.b2Assert(this.m_I > 0);
            this.m_invI = 1.0 / this.m_I;
        }
        else {
            this.m_I = 0.0;
            this.m_invI = 0.0;
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
        this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
    }
    b2Body.prototype.GetWorldPoint = function (localPoint) {
        var A = this.m_xf.R;
        var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        u.x += this.m_xf.position.x;
        u.y += this.m_xf.position.y;
        return u;
    }
    b2Body.prototype.GetWorldVector = function (localVector) {
        return b2Math.MulMV(this.m_xf.R, localVector);
    }
    b2Body.prototype.GetLocalPoint = function (worldPoint) {
        return b2Math.MulXT(this.m_xf, worldPoint);
    }
    b2Body.prototype.GetLocalVector = function (worldVector) {
        return b2Math.MulTMV(this.m_xf.R, worldVector);
    }
    b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
        var A = this.m_xf.R;
        var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        worldPoint.x += this.m_xf.position.x;
        worldPoint.y += this.m_xf.position.y;
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
    }
    b2Body.prototype.GetLinearDamping = function () {
        return this.m_linearDamping;
    }
    b2Body.prototype.SetLinearDamping = function (linearDamping) {
        if (linearDamping === undefined) linearDamping = 0;
        this.m_linearDamping = linearDamping;
    }
    b2Body.prototype.GetAngularDamping = function () {
        return this.m_angularDamping;
    }
    b2Body.prototype.SetAngularDamping = function (angularDamping) {
        if (angularDamping === undefined) angularDamping = 0;
        this.m_angularDamping = angularDamping;
    }
    b2Body.prototype.SetType = function (type) {
        if (type === undefined) type = 0;
        if (this.m_type == type) {
            return;
        }
        this.m_type = type;
        this.ResetMassData();
        if (this.m_type == b2Body.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
        }
        this.SetAwake(true);
        this.m_force.SetZero();
        this.m_torque = 0.0;
        for (var ce = this.m_contactList; ce; ce = ce.next) {
            ce.contact.FlagForFiltering();
        }
    }
    b2Body.prototype.GetType = function () {
        return this.m_type;
    }
    b2Body.prototype.SetBullet = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_bulletFlag;
        }
    }
    b2Body.prototype.IsBullet = function () {
        return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
    }
    b2Body.prototype.SetSleepingAllowed = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_allowSleepFlag;
            this.SetAwake(true);
        }
    }
    b2Body.prototype.SetAwake = function (flag) {
        if (flag) {
            this.m_flags |= b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
        }
        else {
            this.m_flags &= ~b2Body.e_awakeFlag;
            this.m_sleepTime = 0.0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0.0;
            this.m_force.SetZero();
            this.m_torque = 0.0;
        }
    }
    b2Body.prototype.IsAwake = function () {
        return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
    }
    b2Body.prototype.SetFixedRotation = function (fixed) {
        if (fixed) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        else {
            this.m_flags &= ~b2Body.e_fixedRotationFlag;
        }
        this.ResetMassData();
    }
    b2Body.prototype.IsFixedRotation = function () {
        return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
    }
    b2Body.prototype.SetActive = function (flag) {
        if (flag == this.IsActive()) {
            return;
        }
        var broadPhase;
        var f;
        if (flag) {
            this.m_flags |= b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.CreateProxy(broadPhase, this.m_xf);
            }
        }
        else {
            this.m_flags &= ~b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList;
                 f; f = f.m_next) {
                f.DestroyProxy(broadPhase);
            }
            var ce = this.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.m_world.m_contactManager.Destroy(ce0.contact);
            }
            this.m_contactList = null;
        }
    }
    b2Body.prototype.IsActive = function () {
        return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
    }
    b2Body.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
    }
    b2Body.prototype.GetFixtureList = function () {
        return this.m_fixtureList;
    }
    b2Body.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2Body.prototype.GetControllerList = function () {
        return this.m_controllerList;
    }
    b2Body.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2Body.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Body.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Body.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Body.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Body.prototype.b2Body = function (bd, world) {
        this.m_flags = 0;
        if (bd.bullet) {
            this.m_flags |= b2Body.e_bulletFlag;
        }
        if (bd.fixedRotation) {
            this.m_flags |= b2Body.e_fixedRotationFlag;
        }
        if (bd.allowSleep) {
            this.m_flags |= b2Body.e_allowSleepFlag;
        }
        if (bd.awake) {
            this.m_flags |= b2Body.e_awakeFlag;
        }
        if (bd.active) {
            this.m_flags |= b2Body.e_activeFlag;
        }
        this.m_world = world;
        this.m_xf.position.SetV(bd.position);
        this.m_xf.R.Set(bd.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1.0;
        this.m_sweep.a0 = this.m_sweep.a = bd.angle;
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_contactList = null;
        this.m_controllerCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_linearVelocity.SetV(bd.linearVelocity);
        this.m_angularVelocity = bd.angularVelocity;
        this.m_linearDamping = bd.linearDamping;
        this.m_angularDamping = bd.angularDamping;
        this.m_force.Set(0.0, 0.0);
        this.m_torque = 0.0;
        this.m_sleepTime = 0.0;
        this.m_type = bd.type;
        if (this.m_type == b2Body.b2_dynamicBody) {
            this.m_mass = 1.0;
            this.m_invMass = 1.0;
        }
        else {
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
        }
        this.m_I = 0.0;
        this.m_invI = 0.0;
        this.m_inertiaScale = bd.inertiaScale;
        this.m_userData = bd.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0;
    }
    b2Body.prototype.SynchronizeFixtures = function () {
        var xf1 = b2Body.s_xf1;
        xf1.R.Set(this.m_sweep.a0);
        var tMat = xf1.R;
        var tVec = this.m_sweep.localCenter;
        xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var f;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList;
             f; f = f.m_next) {
            f.Synchronize(broadPhase, xf1, this.m_xf);
        }
    }
    b2Body.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    }
    b2Body.prototype.ShouldCollide = function (other) {
        if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
            return false;
        }
        for (var jn = this.m_jointList; jn; jn = jn.next) {
            if (jn.other == other) if (jn.joint.m_collideConnected == false) {
                return false;
            }
        }
        return true;
    }
    b2Body.prototype.Advance = function (t) {
        if (t === undefined) t = 0;
        this.m_sweep.Advance(t);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a = this.m_sweep.a0;
        this.SynchronizeTransform();
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
        Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
        Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
        Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
        Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
        Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
        Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
        Box2D.Dynamics.b2Body.b2_staticBody = 0;
        Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
        Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
    });
    b2BodyDef.b2BodyDef = function () {
        this.position = new b2Vec2();
        this.linearVelocity = new b2Vec2();
    };
    b2BodyDef.prototype.b2BodyDef = function () {
        this.userData = null;
        this.position.Set(0.0, 0.0);
        this.angle = 0.0;
        this.linearVelocity.Set(0, 0);
        this.angularVelocity = 0.0;
        this.linearDamping = 0.0;
        this.angularDamping = 0.0;
        this.allowSleep = true;
        this.awake = true;
        this.fixedRotation = false;
        this.bullet = false;
        this.type = b2Body.b2_staticBody;
        this.active = true;
        this.inertiaScale = 1.0;
    }
    b2ContactFilter.b2ContactFilter = function () {};
    b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
        var filter1 = fixtureA.GetFilterData();
        var filter2 = fixtureB.GetFilterData();
        if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
            return filter1.groupIndex > 0;
        }
        var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
        return collide;
    }
    b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
        if (!userData) return true;
        return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
    });
    b2ContactImpulse.b2ContactImpulse = function () {
        this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
    };
    b2ContactListener.b2ContactListener = function () {};
    b2ContactListener.prototype.BeginContact = function (contact) {}
    b2ContactListener.prototype.EndContact = function (contact) {}
    b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
    b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
    });
    b2ContactManager.b2ContactManager = function () {};
    b2ContactManager.prototype.b2ContactManager = function () {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
        this.m_contactListener = b2ContactListener.b2_defaultListener;
        this.m_contactFactory = new b2ContactFactory(this.m_allocator);
        this.m_broadPhase = new b2DynamicTreeBroadPhase();
    }
    b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
        var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
        var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA == bodyB) return;
        var edge = bodyB.GetContactList();
        while (edge) {
            if (edge.other == bodyA) {
                var fA = edge.contact.GetFixtureA();
                var fB = edge.contact.GetFixtureB();
                if (fA == fixtureA && fB == fixtureB) return;
                if (fA == fixtureB && fB == fixtureA) return;
            }
            edge = edge.next;
        }
        if (bodyB.ShouldCollide(bodyA) == false) {
            return;
        }
        if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
            return;
        }
        var c = this.m_contactFactory.Create(fixtureA, fixtureB);
        fixtureA = c.GetFixtureA();
        fixtureB = c.GetFixtureB();
        bodyA = fixtureA.m_body;
        bodyB = fixtureB.m_body;
        c.m_prev = null;
        c.m_next = this.m_world.m_contactList;
        if (this.m_world.m_contactList != null) {
            this.m_world.m_contactList.m_prev = c;
        }
        this.m_world.m_contactList = c;
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA;
        }
        bodyA.m_contactList = c.m_nodeA;
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB;
        }
        bodyB.m_contactList = c.m_nodeB;
        ++this.m_world.m_contactCount;
        return;
    }
    b2ContactManager.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
    }
    b2ContactManager.prototype.Destroy = function (c) {
        var fixtureA = c.GetFixtureA();
        var fixtureB = c.GetFixtureB();
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (c.IsTouching()) {
            this.m_contactListener.EndContact(c);
        }
        if (c.m_prev) {
            c.m_prev.m_next = c.m_next;
        }
        if (c.m_next) {
            c.m_next.m_prev = c.m_prev;
        }
        if (c == this.m_world.m_contactList) {
            this.m_world.m_contactList = c.m_next;
        }
        if (c.m_nodeA.prev) {
            c.m_nodeA.prev.next = c.m_nodeA.next;
        }
        if (c.m_nodeA.next) {
            c.m_nodeA.next.prev = c.m_nodeA.prev;
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next;
        }
        if (c.m_nodeB.prev) {
            c.m_nodeB.prev.next = c.m_nodeB.next;
        }
        if (c.m_nodeB.next) {
            c.m_nodeB.next.prev = c.m_nodeB.prev;
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next;
        }
        this.m_contactFactory.Destroy(c);
        --this.m_contactCount;
    }
    b2ContactManager.prototype.Collide = function () {
        var c = this.m_world.m_contactList;
        while (c) {
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
                c = c.GetNext();
                continue;
            }

			//Jim: If body is not active, skip it
            if (!bodyA.IsActive() || !bodyB.IsActive()){
                c = c.GetNext();
                continue;
            }

            if (c.m_flags & b2Contact.e_filterFlag) {
                if (bodyB.ShouldCollide(bodyA) == false) {
                    var cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
                    cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue;
                }
                c.m_flags &= ~b2Contact.e_filterFlag;
            }
            var proxyA = fixtureA.m_proxy;
            var proxyB = fixtureB.m_proxy;
            var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
            if (overlap == false) {
                cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue;
            }
            c.Update(this.m_contactListener);
            c = c.GetNext();
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
    });
    b2DebugDraw.b2DebugDraw = function () {};
    b2DebugDraw.prototype.b2DebugDraw = function () {}
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.GetFlags = function () {}
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
    }
    b2DebugDraw.prototype.SetSprite = function (sprite) {}
    b2DebugDraw.prototype.GetSprite = function () {}
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
    }
    b2DebugDraw.prototype.GetDrawScale = function () {}
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
    }
    b2DebugDraw.prototype.GetLineThickness = function () {}
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetAlpha = function () {}
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
    }
    b2DebugDraw.prototype.GetFillAlpha = function () {}
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
    }
    b2DebugDraw.prototype.GetXFormScale = function () {}
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (vertexCount === undefined) vertexCount = 0;
    }
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (radius === undefined) radius = 0;
    }
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
    b2DebugDraw.prototype.DrawTransform = function (xf) {}
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
        Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
        Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
        Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
        Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
        Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
    });
    b2DestructionListener.b2DestructionListener = function () {};
    b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
    b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
    b2FilterData.b2FilterData = function () {
        this.categoryBits = 0x0001;
        this.maskBits = 0xFFFF;
        this.groupIndex = 0;
    };
    b2FilterData.prototype.Copy = function () {
        var copy = new b2FilterData();
        copy.categoryBits = this.categoryBits;
        copy.maskBits = this.maskBits;
        copy.groupIndex = this.groupIndex;
        return copy;
    }
    b2Fixture.b2Fixture = function () {
        this.m_filter = new b2FilterData();
    };
    b2Fixture.prototype.GetType = function () {
        return this.m_shape.GetType();
    }
    b2Fixture.prototype.GetShape = function () {
        return this.m_shape;
    }
    b2Fixture.prototype.SetSensor = function (sensor) {
        if (this.m_isSensor == sensor) return;
        this.m_isSensor = sensor;
        if (this.m_body == null) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
            edge = edge.next;
        }
    }
    b2Fixture.prototype.IsSensor = function () {
        return this.m_isSensor;
    }
    b2Fixture.prototype.SetFilterData = function (filter) {
        this.m_filter = filter.Copy();
        if (this.m_body) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
            edge = edge.next;
        }
    }
    b2Fixture.prototype.GetFilterData = function () {
        return this.m_filter.Copy();
    }
    b2Fixture.prototype.GetBody = function () {
        return this.m_body;
    }
    b2Fixture.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Fixture.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Fixture.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Fixture.prototype.TestPoint = function (p) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
    }
    b2Fixture.prototype.RayCast = function (output, input) {
        return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
    }
    b2Fixture.prototype.GetMassData = function (massData) {
        if (massData === undefined) massData = null;
        if (massData == null) {
            massData = new b2MassData();
        }
        this.m_shape.ComputeMass(massData, this.m_density);
        return massData;
    }
    b2Fixture.prototype.SetDensity = function (density) {
        if (density === undefined) density = 0;
        this.m_density = density;
    }
    b2Fixture.prototype.GetDensity = function () {
        return this.m_density;
    }
    b2Fixture.prototype.GetFriction = function () {
        return this.m_friction;
    }
    b2Fixture.prototype.SetFriction = function (friction) {
        if (friction === undefined) friction = 0;
        this.m_friction = friction;
    }
    b2Fixture.prototype.GetRestitution = function () {
        return this.m_restitution;
    }
    b2Fixture.prototype.SetRestitution = function (restitution) {
        if (restitution === undefined) restitution = 0;
        this.m_restitution = restitution;
    }
    b2Fixture.prototype.GetAABB = function () {
        return this.m_aabb;
    }
    b2Fixture.prototype.b2Fixture = function () {
        this.m_aabb = new b2AABB();
        this.m_userData = null;
        this.m_body = null;
        this.m_next = null;
        this.m_shape = null;
        this.m_density = 0.0;
        this.m_friction = 0.0;
        this.m_restitution = 0.0;
    }
    b2Fixture.prototype.Create = function (body, xf, def) {
        this.m_userData = def.userData;
        this.m_friction = def.friction;
        this.m_restitution = def.restitution;
        this.m_body = body;
        this.m_next = null;
        this.m_filter = def.filter.Copy();
        this.m_isSensor = def.isSensor;
        this.m_shape = def.shape.Copy();
        this.m_density = def.density;
    }
    b2Fixture.prototype.Destroy = function () {
        this.m_shape = null;
    }
    b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
        this.m_shape.ComputeAABB(this.m_aabb, xf);
        this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
    }
    b2Fixture.prototype.DestroyProxy = function (broadPhase) {
        if (this.m_proxy == null) {
            return;
        }
        broadPhase.DestroyProxy(this.m_proxy);
        this.m_proxy = null;
    }
    b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
        if (!this.m_proxy) return;
        var aabb1 = new b2AABB();
        var aabb2 = new b2AABB();
        this.m_shape.ComputeAABB(aabb1, transform1);
        this.m_shape.ComputeAABB(aabb2, transform2);
        this.m_aabb.Combine(aabb1, aabb2);
        var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
        broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
    }
    b2FixtureDef.b2FixtureDef = function () {
        this.filter = new b2FilterData();
    };
    b2FixtureDef.prototype.b2FixtureDef = function () {
        this.shape = null;
        this.userData = null;
        this.friction = 0.2;
        this.restitution = 0.0;
        this.density = 0.0;
        this.filter.categoryBits = 0x0001;
        this.filter.maskBits = 0xFFFF;
        this.filter.groupIndex = 0;
        this.isSensor = false;
    }
    b2Island.b2Island = function () {};
    b2Island.prototype.b2Island = function () {
        this.m_bodies = new Vector();
        this.m_contacts = new Vector();
        this.m_joints = new Vector();
    }
    b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
        if (bodyCapacity === undefined) bodyCapacity = 0;
        if (contactCapacity === undefined) contactCapacity = 0;
        if (jointCapacity === undefined) jointCapacity = 0;
        var i = 0;
        this.m_bodyCapacity = bodyCapacity;
        this.m_contactCapacity = contactCapacity;
        this.m_jointCapacity = jointCapacity;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_allocator = allocator;
        this.m_listener = listener;
        this.m_contactSolver = contactSolver;
        for (i = this.m_bodies.length;
             i < bodyCapacity; i++)
            this.m_bodies[i] = null;
        for (i = this.m_contacts.length;
             i < contactCapacity; i++)
            this.m_contacts[i] = null;
        for (i = this.m_joints.length;
             i < jointCapacity; i++)
            this.m_joints[i] = null;
    }
    b2Island.prototype.Clear = function () {
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
    }
    b2Island.prototype.Solve = function (step, gravity, allowSleep) {
        var i = 0;
        var j = 0;
        var b;
        var joint;
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() != b2Body.b2_dynamicBody) continue;
            var g = b.modifyGravity(gravity);
            b.m_linearVelocity.x += step.dt * (g.x + b.m_invMass * b.m_force.x);
            b.m_linearVelocity.y += step.dt * (g.y + b.m_invMass * b.m_force.y);
            b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
            b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
            b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
        }
        this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        contactSolver.InitVelocityConstraints(step);
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.InitVelocityConstraints(step);
        }
        for (i = 0;
             i < step.velocityIterations; ++i) {
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                joint.SolveVelocityConstraints(step);
            }
            contactSolver.SolveVelocityConstraints();
        }
        for (i = 0;
             i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.FinalizeVelocityConstraints();
        }
        contactSolver.FinalizeVelocityConstraints();
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = step.dt * b.m_linearVelocity.x;
            var translationY = step.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
            }
            var rotation = step.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
            b.m_sweep.a += step.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        for (i = 0;
             i < step.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
        if (allowSleep) {
            var minSleepTime = Number.MAX_VALUE;
            var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
            var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
            for (i = 0;
                 i < this.m_bodyCount; ++i) {
                b = this.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                    b.m_sleepTime = 0.0;
                    minSleepTime = 0.0;
                }
                else {
                    b.m_sleepTime += step.dt;
                    minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
                }
            }
            if (minSleepTime >= b2Settings.b2_timeToSleep) {
                for (i = 0;
                     i < this.m_bodyCount; ++i) {
                    b = this.m_bodies[i];
                    b.SetAwake(false);
                }
            }
        }
    }
    b2Island.prototype.SolveTOI = function (subStep) {
        var i = 0;
        var j = 0;
        this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        for (i = 0;
             i < this.m_jointCount; ++i) {
            this.m_joints[i].InitVelocityConstraints(subStep);
        }
        for (i = 0;
             i < subStep.velocityIterations; ++i) {
            contactSolver.SolveVelocityConstraints();
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                this.m_joints[j].SolveVelocityConstraints(subStep);
            }
        }
        for (i = 0;
             i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = subStep.dt * b.m_linearVelocity.x;
            var translationY = subStep.dt * b.m_linearVelocity.y;
            if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            }
            var rotation = subStep.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0.0) {
                    b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
                }
                else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
            b.m_sweep.a += subStep.dt * b.m_angularVelocity;
            b.SynchronizeTransform();
        }
        var k_toiBaumgarte = 0.75;
        for (i = 0;
             i < subStep.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
            var jointsOkay = true;
            for (j = 0;
                 j < this.m_jointCount; ++j) {
                var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                break;
            }
        }
        this.Report(contactSolver.m_constraints);
    }
    b2Island.prototype.Report = function (constraints) {
        if (this.m_listener == null) {
            return;
        }
        for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            var cc = constraints[i];
            for (var j = 0; j < cc.pointCount; ++j) {
                b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
                b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
            }
            this.m_listener.PostSolve(c, b2Island.s_impulse);
        }
    }
    b2Island.prototype.AddBody = function (body) {
        body.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = body;
    }
    b2Island.prototype.AddContact = function (contact) {
        this.m_contacts[this.m_contactCount++] = contact;
    }
    b2Island.prototype.AddJoint = function (joint) {
        this.m_joints[this.m_jointCount++] = joint;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
    });
    b2TimeStep.b2TimeStep = function () {};
    b2TimeStep.prototype.Set = function (step) {
        this.dt = step.dt;
        this.inv_dt = step.inv_dt;
        this.positionIterations = step.positionIterations;
        this.velocityIterations = step.velocityIterations;
        this.warmStarting = step.warmStarting;
    }
    b2World.b2World = function () {
        this.s_stack = new Vector();
        this.m_contactManager = new b2ContactManager();
        this.m_contactSolver = new b2ContactSolver();
        this.m_island = new b2Island();
    };
    b2World.prototype.b2World = function (gravity, doSleep) {
        this.m_destructionListener = null;
        this.m_debugDraw = null;
        this.m_bodyList = null;
        this.m_contactList = null;
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_controllerCount = 0;
        b2World.m_warmStarting = true;
        b2World.m_continuousPhysics = true;
        this.m_allowSleep = doSleep;
        gravity.y = gravity.y;
        this.m_gravity = gravity;
        this.m_inv_dt0 = 0.0;
        this.m_contactManager.m_world = this;
        var bd = new b2BodyDef();
        this.m_groundBody = this.CreateBody(bd);
    }
    b2World.prototype.SetDestructionListener = function (listener) {
        this.m_destructionListener = listener;
    }
    b2World.prototype.SetContactFilter = function (filter) {
        this.m_contactManager.m_contactFilter = filter;
    }
    b2World.prototype.SetContactListener = function (listener) {
        this.m_contactManager.m_contactListener = listener;
    }
    b2World.prototype.SetDebugDraw = function (debugDraw) {
        this.m_debugDraw = debugDraw;
    }
    b2World.prototype.SetBroadPhase = function (broadPhase) {
        var oldBroadPhase = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = broadPhase;
        for (var b = this.m_bodyList; b; b = b.m_next) {
            for (var f = b.m_fixtureList; f; f = f.m_next) {
                f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
            }
        }
    }
    b2World.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate();
    }
    b2World.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount();
    }
    b2World.prototype.CreateBody = function (def) {
        if (this.IsLocked() == true) {
            return null;
        }
        var b = new b2Body(def, this);
        b.m_prev = null;
        b.m_next = this.m_bodyList;
        if (this.m_bodyList) {
            this.m_bodyList.m_prev = b;
        }
        this.m_bodyList = b;
        ++this.m_bodyCount;
        return b;
    }
    b2World.prototype.DestroyBody = function (b) {
        if (this.IsLocked() == true) {
            return;
        }
        var jn = b.m_jointList;
        while (jn) {
            var jn0 = jn;
            jn = jn.next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
            }
            this.DestroyJoint(jn0.joint);
        }
        var coe = b.m_controllerList;
        while (coe) {
            var coe0 = coe;
            coe = coe.nextController;
            coe0.controller.RemoveBody(b);
        }
        var ce = b.m_contactList;
        while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact);
        }
        b.m_contactList = null;
        var f = b.m_fixtureList;
        while (f) {
            var f0 = f;
            f = f.m_next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeFixture(f0);
            }
            f0.DestroyProxy(this.m_contactManager.m_broadPhase);
            f0.Destroy();
        }
        b.m_fixtureList = null;
        b.m_fixtureCount = 0;
        if (b.m_prev) {
            b.m_prev.m_next = b.m_next;
        }
        if (b.m_next) {
            b.m_next.m_prev = b.m_prev;
        }
        if (b == this.m_bodyList) {
            this.m_bodyList = b.m_next;
        }--this.m_bodyCount;
    }
    b2World.prototype.CreateJoint = function (def) {
        var j = b2Joint.Create(def, null);
        j.m_prev = null;
        j.m_next = this.m_jointList;
        if (this.m_jointList) {
            this.m_jointList.m_prev = j;
        }
        this.m_jointList = j;
        ++this.m_jointCount;
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.m_bodyB;
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.m_bodyA.m_jointList;
        if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
        j.m_bodyA.m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.m_bodyA;
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.m_bodyB.m_jointList;
        if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
        j.m_bodyB.m_jointList = j.m_edgeB;
        var bodyA = def.bodyA;
        var bodyB = def.bodyB;
        if (def.collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
        return j;
    }
    b2World.prototype.DestroyJoint = function (j) {
        var collideConnected = j.m_collideConnected;
        if (j.m_prev) {
            j.m_prev.m_next = j.m_next;
        }
        if (j.m_next) {
            j.m_next.m_prev = j.m_prev;
        }
        if (j == this.m_jointList) {
            this.m_jointList = j.m_next;
        }
        var bodyA = j.m_bodyA;
        var bodyB = j.m_bodyB;
        bodyA.SetAwake(true);
        bodyB.SetAwake(true);
        if (j.m_edgeA.prev) {
            j.m_edgeA.prev.next = j.m_edgeA.next;
        }
        if (j.m_edgeA.next) {
            j.m_edgeA.next.prev = j.m_edgeA.prev;
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next;
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        if (j.m_edgeB.prev) {
            j.m_edgeB.prev.next = j.m_edgeB.next;
        }
        if (j.m_edgeB.next) {
            j.m_edgeB.next.prev = j.m_edgeB.prev;
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next;
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        b2Joint.Destroy(j, null);
        --this.m_jointCount;
        if (collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering();
                }
                edge = edge.next;
            }
        }
    }
    b2World.prototype.AddController = function (c) {
        c.m_next = this.m_controllerList;
        c.m_prev = null;
        this.m_controllerList = c;
        c.m_world = this;
        this.m_controllerCount++;
        return c;
    }
    b2World.prototype.RemoveController = function (c) {
        if (c.m_prev) c.m_prev.m_next = c.m_next;
        if (c.m_next) c.m_next.m_prev = c.m_prev;
        if (this.m_controllerList == c) this.m_controllerList = c.m_next;
        this.m_controllerCount--;
    }
    b2World.prototype.CreateController = function (controller) {
        if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
        controller.m_next = this.m_controllerList;
        controller.m_prev = null;
        if (this.m_controllerList) this.m_controllerList.m_prev = controller;
        this.m_controllerList = controller;
        ++this.m_controllerCount;
        controller.m_world = this;
        return controller;
    }
    b2World.prototype.DestroyController = function (controller) {
        controller.Clear();
        if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
        if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
        if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
        --this.m_controllerCount;
    }
    b2World.prototype.SetWarmStarting = function (flag) {
        b2World.m_warmStarting = flag;
    }
    b2World.prototype.SetContinuousPhysics = function (flag) {
        b2World.m_continuousPhysics = flag;
    }
    b2World.prototype.GetBodyCount = function () {
        return this.m_bodyCount;
    }
    b2World.prototype.GetJointCount = function () {
        return this.m_jointCount;
    }
    b2World.prototype.GetContactCount = function () {
        return this.m_contactCount;
    }
    b2World.prototype.SetGravity = function (gravity) {
        this.m_gravity = gravity;
    }
    b2World.prototype.GetGravity = function () {
        return this.m_gravity;
    }
    b2World.prototype.GetGroundBody = function () {
        return this.m_groundBody;
    }
    b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
        if (dt === undefined) dt = 0;
        if (velocityIterations === undefined) velocityIterations = 0;
        if (positionIterations === undefined) positionIterations = 0;
        if (this.m_flags & b2World.e_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_flags &= ~b2World.e_newFixture;
        }
        this.m_flags |= b2World.e_locked;
        var step = b2World.s_timestep2;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0.0) {
            step.inv_dt = 1.0 / dt;
        }
        else {
            step.inv_dt = 0.0;
        }
        step.dtRatio = this.m_inv_dt0 * dt;
        step.warmStarting = b2World.m_warmStarting;
        this.m_contactManager.Collide();
        if (step.dt > 0.0) {
            this.Solve(step);
        }
        if (b2World.m_continuousPhysics && step.dt > 0.0) {
            this.SolveTOI(step);
        }
        if (step.dt > 0.0) {
            this.m_inv_dt0 = step.inv_dt;
        }
        this.m_flags &= ~b2World.e_locked;
    }
    b2World.prototype.ClearForces = function () {
        for (var body = this.m_bodyList; body; body = body.m_next) {
            body.m_force.SetZero();
            body.m_torque = 0.0;
        }
    }
    b2World.prototype.DrawDebugData = function () {
        if (this.m_debugDraw == null) {
            return;
        }
        this.m_debugDraw.m_sprite.graphics.clear();
        var flags = this.m_debugDraw.GetFlags();
        var i = 0;
        var b;
        var f;
        var s;
        var j;
        var bp;
        var invQ = new b2Vec2;
        var x1 = new b2Vec2;
        var x2 = new b2Vec2;
        var xf;
        var b1 = new b2AABB();
        var b2 = new b2AABB();
        var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
        var color = new b2Color(0, 0, 0);
        if (flags & b2DebugDraw.e_shapeBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b.m_xf;
                for (f = b.GetFixtureList();
                     f; f = f.m_next) {
                    s = f.GetShape();
                    if (b.IsActive() == false) {
                        color.Set(0.5, 0.5, 0.3);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_staticBody) {
                        color.Set(0.5, 0.9, 0.5);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.GetType() == b2Body.b2_kinematicBody) {
                        color.Set(0.5, 0.5, 0.9);
                        this.DrawShape(s, xf, color);
                    }
                    else if (b.IsAwake() == false) {
                        color.Set(0.6, 0.6, 0.6);
                        this.DrawShape(s, xf, color);
                    }
                    else {
                        color.Set(0.9, 0.7, 0.7);
                        this.DrawShape(s, xf, color);
                    }
                }
            }
        }
        if (flags & b2DebugDraw.e_jointBit) {
            for (j = this.m_jointList;
                 j; j = j.m_next) {
                this.DrawJoint(j);
            }
        }
        if (flags & b2DebugDraw.e_controllerBit) {
            for (var c = this.m_controllerList; c; c = c.m_next) {
                c.Draw(this.m_debugDraw);
            }
        }
        if (flags & b2DebugDraw.e_pairBit) {
            color.Set(0.3, 0.9, 0.9);
            for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
                var fixtureA = contact.GetFixtureA();
                var fixtureB = contact.GetFixtureB();
                var cA = fixtureA.GetAABB().GetCenter();
                var cB = fixtureB.GetAABB().GetCenter();
                this.m_debugDraw.DrawSegment(cA, cB, color);
            }
        }
        if (flags & b2DebugDraw.e_aabbBit) {
            bp = this.m_contactManager.m_broadPhase;
            vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
            for (b = this.m_bodyList;
                 b; b = b.GetNext()) {
                if (b.IsActive() == false) {
                    continue;
                }
                for (f = b.GetFixtureList();
                     f; f = f.GetNext()) {
                    var aabb = bp.GetFatAABB(f.m_proxy);
                    vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                    vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                    vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                    vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                    this.m_debugDraw.DrawPolygon(vs, 4, color);
                }
            }
        }
        if (flags & b2DebugDraw.e_centerOfMassBit) {
            for (b = this.m_bodyList;
                 b; b = b.m_next) {
                xf = b2World.s_xf;
                xf.R = b.m_xf.R;
                xf.position = b.GetWorldCenter();
                this.m_debugDraw.DrawTransform(xf);
            }
        }
    }
    b2World.prototype.QueryAABB = function (callback, aabb) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            return callback(broadPhase.GetUserData(proxy));
        };
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryShape = function (callback, shape, transform) {
        var __this = this;
        if (transform === undefined) transform = null;
        if (transform == null) {
            transform = new b2Transform();
            transform.SetIdentity();
        }
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        shape.ComputeAABB(aabb, transform);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.QueryPoint = function (callback, p) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
            if (fixture.TestPoint(p)) return callback(fixture);
            return true;
        };
        var aabb = new b2AABB();
        aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
        aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
        broadPhase.Query(WorldQueryWrapper, aabb);
    }
    b2World.prototype.RayCast = function (callback, point1, point2) {
        var __this = this;
        var broadPhase = __this.m_contactManager.m_broadPhase;
        var output = new b2RayCastOutput;

        function RayCastWrapper(input, proxy) {
            var userData = broadPhase.GetUserData(proxy);
            var fixture = (userData instanceof b2Fixture ? userData : null);
            var hit = fixture.RayCast(output, input);
            if (hit) {
                var fraction = output.fraction;
                var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
                return callback(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
        };
        var input = new b2RayCastInput(point1, point2);
        broadPhase.RayCast(RayCastWrapper, input);
    }
    b2World.prototype.RayCastOne = function (point1, point2) {
        var __this = this;
        var result;

        function RayCastOneWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result = fixture;
            return fraction;
        };
        __this.RayCast(RayCastOneWrapper, point1, point2);
        return result;
    }
    b2World.prototype.RayCastAll = function (point1, point2) {
        var __this = this;
        var result = new Vector();

        function RayCastAllWrapper(fixture, point, normal, fraction) {
            if (fraction === undefined) fraction = 0;
            result[result.length] = fixture;
            return 1;
        };
        __this.RayCast(RayCastAllWrapper, point1, point2);
        return result;
    }
    b2World.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2World.prototype.GetJointList = function () {
        return this.m_jointList;
    }
    b2World.prototype.GetContactList = function () {
        return this.m_contactList;
    }
    b2World.prototype.IsLocked = function () {
        return (this.m_flags & b2World.e_locked) > 0;
    }
    b2World.prototype.Solve = function (step) {
        var b;
        for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
            controller.Step(step);
        }
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
        }
        for (var c = this.m_contactList; c; c = c.m_next) {
            c.m_flags &= ~b2Contact.e_islandFlag;
        }
        for (var j = this.m_jointList; j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        var stackSize = parseInt(this.m_bodyCount);
        var stack = this.s_stack;
        for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
            if (seed.m_flags & b2Body.e_islandFlag) {
                continue;
            }
            if (seed.IsAwake() == false || seed.IsActive() == false) {
                continue;
            }
            if (seed.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (stackCount > 0) {
                b = stack[--stackCount];
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue;
                }
                var other;
                for (var ce = b.m_contactList; ce; ce = ce.next) {
                    if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(ce.contact);
                    ce.contact.m_flags |= b2Contact.e_islandFlag;
                    other = ce.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jn = b.m_jointList; jn; jn = jn.next) {
                    if (jn.joint.m_islandFlag == true) {
                        continue;
                    }
                    other = jn.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jn.joint);
                    jn.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            island.Solve(step, this.m_gravity, this.m_allowSleep);
            for (var i = 0; i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    b.m_flags &= ~b2Body.e_islandFlag;
                }
            }
        }
        for (i = 0;
             i < stack.length; ++i) {
            if (!stack[i]) break;
            stack[i] = null;
        }
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            if (b.IsAwake() == false || b.IsActive() == false) {
                continue;
            }
            if (b.GetType() == b2Body.b2_staticBody) {
                continue;
            }
            b.SynchronizeFixtures();
        }
        this.m_contactManager.FindNewContacts();
    }
    b2World.prototype.SolveTOI = function (step) {
        var b;
        var fA;
        var fB;
        var bA;
        var bB;
        var cEdge;
        var j;
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var queue = b2World.s_queue;
        for (b = this.m_bodyList;
             b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
            b.m_sweep.t0 = 0.0;
        }
        var c;
        for (c = this.m_contactList;
             c; c = c.m_next) {
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
        }
        for (j = this.m_jointList;
             j; j = j.m_next) {
            j.m_islandFlag = false;
        }
        for (;;) {
            var minContact = null;
            var minTOI = 1.0;
            for (c = this.m_contactList;
                 c; c = c.m_next) {
                if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
                    continue;
                }
                var toi = 1.0;
                if (c.m_flags & b2Contact.e_toiFlag) {
                    toi = c.m_toi;
                }
                else {
                    fA = c.m_fixtureA;
                    fB = c.m_fixtureB;
                    bA = fA.m_body;
                    bB = fB.m_body;
                    if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                        continue;
                    }
                    var t0 = bA.m_sweep.t0;
                    if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                        t0 = bB.m_sweep.t0;
                        bA.m_sweep.Advance(t0);
                    }
                    else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                        t0 = bA.m_sweep.t0;
                        bB.m_sweep.Advance(t0);
                    }
                    toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
                    b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
                    if (toi > 0.0 && toi < 1.0) {
                        toi = (1.0 - toi) * t0 + toi;
                        if (toi > 1) toi = 1;
                    }
                    c.m_toi = toi;
                    c.m_flags |= b2Contact.e_toiFlag;
                }
                if (Box2D.MIN_VALUE < toi && toi < minTOI) {
                    minContact = c;
                    minTOI = toi;
                }
            }
            if (minContact == null || 1.0 - 100.0 * Box2D.MIN_VALUE < minTOI) {
                break;
            }
            fA = minContact.m_fixtureA;
            fB = minContact.m_fixtureB;
            bA = fA.m_body;
            bB = fB.m_body;
            b2World.s_backupA.Set(bA.m_sweep);
            b2World.s_backupB.Set(bB.m_sweep);
            bA.Advance(minTOI);
            bB.Advance(minTOI);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_flags &= ~b2Contact.e_toiFlag;
            if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
                bA.m_sweep.Set(b2World.s_backupA);
                bB.m_sweep.Set(b2World.s_backupB);
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();
                continue;
            }
            if (minContact.IsTouching() == false) {
                continue;
            }
            var seed = bA;
            if (seed.GetType() != b2Body.b2_dynamicBody) {
                seed = bB;
            }
            island.Clear();
            var queueStart = 0;
            var queueSize = 0;
            queue[queueStart + queueSize++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (queueSize > 0) {
                b = queue[queueStart++];
                --queueSize;
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true);
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    if (island.m_contactCount == island.m_contactCapacity) {
                        break;
                    }
                    if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                        continue;
                    }
                    if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                        continue;
                    }
                    island.AddContact(cEdge.contact);
                    cEdge.contact.m_flags |= b2Contact.e_islandFlag;
                    var other = cEdge.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue;
                    }
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
                for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
                    if (island.m_jointCount == island.m_jointCapacity) continue;
                    if (jEdge.joint.m_islandFlag == true) continue;
                    other = jEdge.other;
                    if (other.IsActive() == false) {
                        continue;
                    }
                    island.AddJoint(jEdge.joint);
                    jEdge.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) continue;
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true);
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag;
                }
            }
            var subStep = b2World.s_timestep;
            subStep.warmStarting = false;
            subStep.dt = (1.0 - minTOI) * step.dt;
            subStep.inv_dt = 1.0 / subStep.dt;
            subStep.dtRatio = 0.0;
            subStep.velocityIterations = step.velocityIterations;
            subStep.positionIterations = step.positionIterations;
            island.SolveTOI(subStep);
            var i = 0;
            for (i = 0;
                 i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                b.m_flags &= ~b2Body.e_islandFlag;
                if (b.IsAwake() == false) {
                    continue;
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue;
                }
                b.SynchronizeFixtures();
                for (cEdge = b.m_contactList;
                     cEdge; cEdge = cEdge.next) {
                    cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
                }
            }
            for (i = 0;
                 i < island.m_contactCount; ++i) {
                c = island.m_contacts[i];
                c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
            }
            for (i = 0;
                 i < island.m_jointCount; ++i) {
                j = island.m_joints[i];
                j.m_islandFlag = false;
            }
            this.m_contactManager.FindNewContacts();
        }
    }
    b2World.prototype.DrawJoint = function (joint) {
        var b1 = joint.GetBodyA();
        var b2 = joint.GetBodyB();
        var xf1 = b1.m_xf;
        var xf2 = b2.m_xf;
        var x1 = xf1.position;
        var x2 = xf2.position;
        var p1 = joint.GetAnchorA();
        var p2 = joint.GetAnchorB();
        var color = b2World.s_jointColor;
        switch (joint.m_type) {
            case b2Joint.e_distanceJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            case b2Joint.e_pulleyJoint:
            {
                var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
                var s1 = pulley.GetGroundAnchorA();
                var s2 = pulley.GetGroundAnchorB();
                this.m_debugDraw.DrawSegment(s1, p1, color);
                this.m_debugDraw.DrawSegment(s2, p2, color);
                this.m_debugDraw.DrawSegment(s1, s2, color);
            }
                break;
            case b2Joint.e_mouseJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            default:
                if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
                this.m_debugDraw.DrawSegment(p1, p2, color);
                if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
        }
    }
    b2World.prototype.DrawShape = function (shape, xf, color) {
        switch (shape.m_type) {
            case b2Shape.e_circleShape:
            {
                var circle = ((shape instanceof b2CircleShape ? shape : null));
                var center = b2Math.MulX(xf, circle.m_p);
                var radius = circle.m_radius;
                var axis = xf.R.col1;
                this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
            }
                break;
            case b2Shape.e_polygonShape:
            {
                var i = 0;
                var poly = ((shape instanceof b2PolygonShape ? shape : null));
                var vertexCount = parseInt(poly.GetVertexCount());
                var localVertices = poly.GetVertices();
                var vertices = new Vector(vertexCount);
                for (i = 0;
                     i < vertexCount; ++i) {
                    vertices[i] = b2Math.MulX(xf, localVertices[i]);
                }
                this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
            }
                break;
            case b2Shape.e_edgeShape:
            {
                var edge = (shape instanceof b2EdgeShape ? shape : null);
                this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
        Box2D.Dynamics.b2World.s_xf = new b2Transform();
        Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
        Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
        Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
        Box2D.Dynamics.b2World.s_queue = new Vector();
        Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
        Box2D.Dynamics.b2World.e_newFixture = 0x0001;
        Box2D.Dynamics.b2World.e_locked = 0x0002;
    });
})();
(function () {
    var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
        b2Contact = Box2D.Dynamics.Contacts.b2Contact,
        b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
        b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
        b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
        b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
        b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
        b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
        b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
        b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
        b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2AABB = Box2D.Collision.b2AABB,
        b2Bound = Box2D.Collision.b2Bound,
        b2BoundValues = Box2D.Collision.b2BoundValues,
        b2Collision = Box2D.Collision.b2Collision,
        b2ContactID = Box2D.Collision.b2ContactID,
        b2ContactPoint = Box2D.Collision.b2ContactPoint,
        b2Distance = Box2D.Collision.b2Distance,
        b2DistanceInput = Box2D.Collision.b2DistanceInput,
        b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
        b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
        b2DynamicTree = Box2D.Collision.b2DynamicTree,
        b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
        b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
        b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
        b2Manifold = Box2D.Collision.b2Manifold,
        b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
        b2Point = Box2D.Collision.b2Point,
        b2RayCastInput = Box2D.Collision.b2RayCastInput,
        b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
        b2Segment = Box2D.Collision.b2Segment,
        b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
        b2Simplex = Box2D.Collision.b2Simplex,
        b2SimplexCache = Box2D.Collision.b2SimplexCache,
        b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
        b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
        b2TOIInput = Box2D.Collision.b2TOIInput,
        b2WorldManifold = Box2D.Collision.b2WorldManifold,
        ClipVertex = Box2D.Collision.ClipVertex,
        Features = Box2D.Collision.Features,
        IBroadPhase = Box2D.Collision.IBroadPhase;

    Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2CircleContact.b2CircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2CircleContact.Create = function (allocator) {
        return new b2CircleContact();
    }
    b2CircleContact.Destroy = function (contact, allocator) {}
    b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
//        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_edgeShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
    }
    b2CircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2Contact.b2Contact = function () {
        this.m_nodeA = new b2ContactEdge();
        this.m_nodeB = new b2ContactEdge();
        this.m_manifold = new b2Manifold();
        this.m_oldManifold = new b2Manifold();
    };
    b2Contact.prototype.GetManifold = function () {
        return this.m_manifold;
    }
    b2Contact.prototype.GetWorldManifold = function (worldManifold) {
        var bodyA = this.m_fixtureA.GetBody();
        var bodyB = this.m_fixtureB.GetBody();
        var shapeA = this.m_fixtureA.GetShape();
        var shapeB = this.m_fixtureB.GetShape();
        worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
    }
    b2Contact.prototype.IsTouching = function () {
        return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
    }
    b2Contact.prototype.IsContinuous = function () {
        return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
    }
    b2Contact.prototype.SetSensor = function (sensor) {
        if (sensor) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_sensorFlag;
        }
    }
    b2Contact.prototype.IsSensor = function () {
        return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
    }
    b2Contact.prototype.SetEnabled = function (flag) {
        if (flag) {
            this.m_flags |= b2Contact.e_enabledFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_enabledFlag;
        }
    }
    b2Contact.prototype.IsEnabled = function () {
        return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
    }
    b2Contact.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Contact.prototype.GetFixtureA = function () {
        return this.m_fixtureA;
    }
    b2Contact.prototype.GetFixtureB = function () {
        return this.m_fixtureB;
    }
    b2Contact.prototype.FlagForFiltering = function () {
        this.m_flags |= b2Contact.e_filterFlag;
    }
    b2Contact.prototype.b2Contact = function () {}
    b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
        if (fixtureA === undefined) fixtureA = null;
        if (fixtureB === undefined) fixtureB = null;
        this.m_flags = b2Contact.e_enabledFlag;
        if (!fixtureA || !fixtureB) {
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            return;
        }
        if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
            this.m_flags |= b2Contact.e_sensorFlag;
        }
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
        }
        this.m_fixtureA = fixtureA;
        this.m_fixtureB = fixtureB;
        this.m_manifold.m_pointCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_nodeA.contact = null;
        this.m_nodeA.prev = null;
        this.m_nodeA.next = null;
        this.m_nodeA.other = null;
        this.m_nodeB.contact = null;
        this.m_nodeB.prev = null;
        this.m_nodeB.next = null;
        this.m_nodeB.other = null;
    }
    b2Contact.prototype.Update = function (listener) {
        var tManifold = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = tManifold;
        this.m_flags |= b2Contact.e_enabledFlag;
        var touching = false;
        var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
        var bodyA = this.m_fixtureA.m_body;
        var bodyB = this.m_fixtureB.m_body;
        var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & b2Contact.e_sensorFlag) {
            if (aabbOverlap) {
                var shapeA = this.m_fixtureA.GetShape();
                var shapeB = this.m_fixtureB.GetShape();
                var xfA = bodyA.GetTransform();
                var xfB = bodyB.GetTransform();
                touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
            }
            this.m_manifold.m_pointCount = 0;
        }
        else {
            if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
                this.m_flags |= b2Contact.e_continuousFlag;
            }
            else {
                this.m_flags &= ~b2Contact.e_continuousFlag;
            }
            if (aabbOverlap) {
                this.Evaluate();
                touching = this.m_manifold.m_pointCount > 0;
                for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
                    var mp2 = this.m_manifold.m_points[i];
                    mp2.m_normalImpulse = 0.0;
                    mp2.m_tangentImpulse = 0.0;
                    var id2 = mp2.m_id;
                    for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                        var mp1 = this.m_oldManifold.m_points[j];
                        if (mp1.m_id.key == id2.key) {
                            mp2.m_normalImpulse = mp1.m_normalImpulse;
                            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                            break;
                        }
                    }
                }
            }
            else {
                this.m_manifold.m_pointCount = 0;
            }
            if (touching != wasTouching) {
                bodyA.SetAwake(true);
                bodyB.SetAwake(true);
            }
        }
        if (touching) {
            this.m_flags |= b2Contact.e_touchingFlag;
        }
        else {
            this.m_flags &= ~b2Contact.e_touchingFlag;
        }
        if (wasTouching == false && touching == true) {
            listener.BeginContact(this);
        }
        if (wasTouching == true && touching == false) {
            listener.EndContact(this);
        }
        if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
            listener.PreSolve(this, this.m_oldManifold);
        }
    }
    b2Contact.prototype.Evaluate = function () {}
    b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
        b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        b2Contact.s_input.sweepA = sweepA;
        b2Contact.s_input.sweepB = sweepB;
        b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
        return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
        Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
        Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
        Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
        Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
        Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
        Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
        Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
    });
    b2ContactConstraint.b2ContactConstraint = function () {
        this.localPlaneNormal = new b2Vec2();
        this.localPoint = new b2Vec2();
        this.normal = new b2Vec2();
        this.normalMass = new b2Mat22();
        this.K = new b2Mat22();
    };
    b2ContactConstraint.prototype.b2ContactConstraint = function () {
        this.points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.points[i] = new b2ContactConstraintPoint();
        }
    }
    b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
        this.localPoint = new b2Vec2();
        this.rA = new b2Vec2();
        this.rB = new b2Vec2();
    };
    b2ContactEdge.b2ContactEdge = function () {};
    b2ContactFactory.b2ContactFactory = function () {};
    b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
        this.m_allocator = allocator;
        this.InitializeRegisters();
    }
    b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
        if (type1 === undefined) type1 = 0;
        if (type2 === undefined) type2 = 0;
        this.m_registers[type1][type2].createFcn = createFcn;
        this.m_registers[type1][type2].destroyFcn = destroyFcn;
        this.m_registers[type1][type2].primary = true;
        if (type1 != type2) {
            this.m_registers[type2][type1].createFcn = createFcn;
            this.m_registers[type2][type1].destroyFcn = destroyFcn;
            this.m_registers[type2][type1].primary = false;
        }
    }
    b2ContactFactory.prototype.InitializeRegisters = function () {
        this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
        for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
            this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
            for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
                this.m_registers[i][j] = new b2ContactRegister();
            }
        }
        this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
        this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
        this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
    }
    b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
        var type1 = parseInt(fixtureA.GetType());
        var type2 = parseInt(fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        var c;
        //jim: use array to replace list
        if (reg.pool && reg.pool.length > 0) {
            c = reg.pool.pop();
            c.Reset(fixtureA, fixtureB);
            c.destroyed = false;
            return c;
        }
        var createFcn = reg.createFcn;
        if (createFcn != null) {
            if (reg.primary) {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureA, fixtureB);
                return c;
            }
            else {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureB, fixtureA);
                return c;
            }
        }
        else {
            return null;
        }
    }
    b2ContactFactory.prototype.Destroy = function (contact) {
        if (contact.m_manifold.m_pointCount > 0) {
            contact.m_fixtureA.m_body.SetAwake(true);
            contact.m_fixtureB.m_body.SetAwake(true);
        }
        var type1 = parseInt(contact.m_fixtureA.GetType());
        var type2 = parseInt(contact.m_fixtureB.GetType());
        var reg = this.m_registers[type1][type2];
        //jim: use array to replace list
        if(!reg.pool) {
        	reg.pool = [];
        }
        contact.destroyed = true;
        reg.pool.push(contact);

        var destroyFcn = reg.destroyFcn;
        destroyFcn(contact, this.m_allocator);
    }
    b2ContactRegister.b2ContactRegister = function () {};
    b2ContactResult.b2ContactResult = function () {
        this.position = new b2Vec2();
        this.normal = new b2Vec2();
        this.id = new b2ContactID();
    };
    b2ContactSolver.b2ContactSolver = function () {
        this.m_step = new b2TimeStep();
        this.m_constraints = new Vector();
    };
    b2ContactSolver.prototype.b2ContactSolver = function () {}
    b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
        if (contactCount === undefined) contactCount = 0;
        var contact;
        this.m_step.Set(step);
        this.m_allocator = allocator;
        var i = 0;
        var tVec;
        var tMat;
        this.m_constraintCount = contactCount;
        while (this.m_constraints.length < this.m_constraintCount) {
            this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
        }
        for (i = 0;
             i < contactCount; ++i) {
            contact = contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            var manifold = contact.GetManifold();
            var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
            var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
            var vAX = bodyA.m_linearVelocity.x;
            var vAY = bodyA.m_linearVelocity.y;
            var vBX = bodyB.m_linearVelocity.x;
            var vBY = bodyB.m_linearVelocity.y;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            b2Settings.b2Assert(manifold.m_pointCount > 0);
            b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
            var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
            var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
            var cc = this.m_constraints[i];
            cc.bodyA = bodyA;
            cc.bodyB = bodyB;
            cc.manifold = manifold;
            cc.normal.x = normalX;
            cc.normal.y = normalY;
            cc.pointCount = manifold.m_pointCount;
            cc.friction = friction;
            cc.restitution = restitution;
            cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
            cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
            cc.localPoint.x = manifold.m_localPoint.x;
            cc.localPoint.y = manifold.m_localPoint.y;
            cc.radius = radiusA + radiusB;
            cc.type = manifold.m_type;
            for (var k = 0; k < cc.pointCount; ++k) {
                var cp = manifold.m_points[k];
                var ccp = cc.points[k];
                ccp.normalImpulse = cp.m_normalImpulse;
                ccp.tangentImpulse = cp.m_tangentImpulse;
                ccp.localPoint.SetV(cp.m_localPoint);
                var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
                var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
                var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
                var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
                var rnA = rAX * normalY - rAY * normalX;
                var rnB = rBX * normalY - rBY * normalX;
                rnA *= rnA;
                rnB *= rnB;
                var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
                ccp.normalMass = 1.0 / kNormal;
                var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
                kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
                ccp.equalizedMass = 1.0 / kEqualized;
                var tangentX = normalY;
                var tangentY = (-normalX);
                var rtA = rAX * tangentY - rAY * tangentX;
                var rtB = rBX * tangentY - rBY * tangentX;
                rtA *= rtA;
                rtB *= rtB;
                var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
                ccp.tangentMass = 1.0 / kTangent;
                ccp.velocityBias = 0.0;
                var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
                var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
                var vRel = cc.normal.x * tX + cc.normal.y * tY;
                if (vRel < (-b2Settings.b2_velocityThreshold)) {
                    ccp.velocityBias += (-cc.restitution * vRel);
                }
            }
            if (cc.pointCount == 2) {
                var ccp1 = cc.points[0];
                var ccp2 = cc.points[1];
                var invMassA = bodyA.m_invMass;
                var invIA = bodyA.m_invI;
                var invMassB = bodyB.m_invMass;
                var invIB = bodyB.m_invI;
                var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
                var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
                var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
                var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
                var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
                var k_maxConditionNumber = 100.0;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    cc.K.col1.Set(k11, k12);
                    cc.K.col2.Set(k12, k22);
                    cc.K.GetInverse(cc.normalMass);
                }
                else {
                    cc.pointCount = 1;
                }
            }
        }
    }
    b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
        var tVec;
        var tVec2;
        var tMat;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var tX = 0;
            var j = 0;
            var tCount = 0;
            if (step.warmStarting) {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp = c.points[j];
                    ccp.normalImpulse *= step.dtRatio;
                    ccp.tangentImpulse *= step.dtRatio;
                    var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
                    var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
                    bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                    bodyA.m_linearVelocity.x -= invMassA * PX;
                    bodyA.m_linearVelocity.y -= invMassA * PY;
                    bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                    bodyB.m_linearVelocity.x += invMassB * PX;
                    bodyB.m_linearVelocity.y += invMassB * PY;
                }
            }
            else {
                tCount = c.pointCount;
                for (j = 0;
                     j < tCount; ++j) {
                    var ccp2 = c.points[j];
                    ccp2.normalImpulse = 0.0;
                    ccp2.tangentImpulse = 0.0;
                }
            }
        }
    }
    b2ContactSolver.prototype.SolveVelocityConstraints = function () {
        var j = 0;
        var ccp;
        var rAX = 0;
        var rAY = 0;
        var rBX = 0;
        var rBY = 0;
        var dvX = 0;
        var dvY = 0;
        var vn = 0;
        var vt = 0;
        var lambda = 0;
        var maxFriction = 0;
        var newImpulse = 0;
        var PX = 0;
        var PY = 0;
        var dX = 0;
        var dY = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var tMat;
        var tVec;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            var vA = bodyA.m_linearVelocity;
            var vB = bodyB.m_linearVelocity;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var friction = c.friction;
            var tX = 0;
            for (j = 0;
                 j < c.pointCount; j++) {
                ccp = c.points[j];
                dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
                dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
                vt = dvX * tangentX + dvY * tangentY;
                lambda = ccp.tangentMass * (-vt);
                maxFriction = friction * ccp.normalImpulse;
                newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
                lambda = newImpulse - ccp.tangentImpulse;
                PX = lambda * tangentX;
                PY = lambda * tangentY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.tangentImpulse = newImpulse;
            }
            var tCount = parseInt(c.pointCount);
            if (c.pointCount == 1) {
                ccp = c.points[0];
                dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
                dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
                vn = dvX * normalX + dvY * normalY;
                lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
                newImpulse = ccp.normalImpulse + lambda;
                newImpulse = newImpulse > 0 ? newImpulse : 0.0;
                lambda = newImpulse - ccp.normalImpulse;
                PX = lambda * normalX;
                PY = lambda * normalY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.normalImpulse = newImpulse;
            }
            else {
                var cp1 = c.points[0];
                var cp2 = c.points[1];
                var aX = cp1.normalImpulse;
                var aY = cp2.normalImpulse;
                var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
                var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
                var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
                var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
                var vn1 = dv1X * normalX + dv1Y * normalY;
                var vn2 = dv2X * normalX + dv2Y * normalY;
                var bX = vn1 - cp1.velocityBias;
                var bY = vn2 - cp2.velocityBias;
                tMat = c.K;
                bX -= tMat.col1.x * aX + tMat.col2.x * aY;
                bY -= tMat.col1.y * aX + tMat.col2.y * aY;
                var k_errorTol = 0.001;
                for (;;) {
                    tMat = c.normalMass;
                    var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
                    var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
                    if (xX >= 0.0 && xY >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = (-cp1.normalMass * bX);
                    xY = 0.0;
                    vn1 = 0.0;
                    vn2 = c.K.col1.y * xX + bY;
                    if (xX >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = (-cp2.normalMass * bY);
                    vn1 = c.K.col2.x * xY + bX;
                    vn2 = 0.0;
                    if (xY >= 0.0 && vn1 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    xX = 0.0;
                    xY = 0.0;
                    vn1 = bX;
                    vn2 = bY;
                    if (vn1 >= 0.0 && vn2 >= 0.0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break;
                    }
                    break;
                }
            }
            bodyA.m_angularVelocity = wA;
            bodyB.m_angularVelocity = wB;
        }
    }
    b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var m = c.manifold;
            for (var j = 0; j < c.pointCount; ++j) {
                var point1 = m.m_points[j];
                var point2 = c.points[j];
                point1.m_normalImpulse = point2.normalImpulse;
                point1.m_tangentImpulse = point2.tangentImpulse;
            }
        }
    }
    b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var minSeparation = 0.0;
        for (var i = 0; i < this.m_constraintCount; i++) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_mass * bodyA.m_invMass;
            var invIA = bodyA.m_mass * bodyA.m_invI;
            var invMassB = bodyB.m_mass * bodyB.m_invMass;
            var invIB = bodyB.m_mass * bodyB.m_invI;
            b2ContactSolver.s_psm.Initialize(c);
            var normal = b2ContactSolver.s_psm.m_normal;
            for (var j = 0; j < c.pointCount; j++) {
                var ccp = c.points[j];
                var point = b2ContactSolver.s_psm.m_points[j];
                var separation = b2ContactSolver.s_psm.m_separations[j];
                var rAX = point.x - bodyA.m_sweep.c.x;
                var rAY = point.y - bodyA.m_sweep.c.y;
                var rBX = point.x - bodyB.m_sweep.c.x;
                var rBY = point.y - bodyB.m_sweep.c.y;
                minSeparation = minSeparation < separation ? minSeparation : separation;
                var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
                var impulse = (-ccp.equalizedMass * C);
                var PX = impulse * normal.x;
                var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
                bodyA.m_sweep.c.y -= invMassA * PY;
                bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
                bodyA.SynchronizeTransform();
                bodyB.m_sweep.c.x += invMassB * PX;
                bodyB.m_sweep.c.y += invMassB * PY;
                bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
                bodyB.SynchronizeTransform();
            }
        }
        return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
    });
    Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2EdgeAndCircleContact.Create = function (allocator) {
        return new b2EdgeAndCircleContact();
    }
    b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
    b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2EdgeAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX = 0;
        var dY = 0;
        var positionX = 0;
        var positionY = 0;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
        var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
        var dist = 0;
        var radius = edge.m_radius + circle.m_radius;
        tVec = edge.m_normal;
        var separation = tVec.x * dX + tVec.y * dY;
        var v1 = edge.m_v1;
        var v2 = edge.m_v2;
        if (separation < Number.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(edge.m_normal);
            manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
            manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return;
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0.0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
        else {
            var faceCenterX = 0.5 * (v1.x + v2.x);
            var faceCenterY = 0.5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * tVec.x + (cLocalY - faceCenterY) * tVec.y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = tVec.x;
            manifold.m_localPlaneNormal.y = tVec.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
        }
    }
    Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
    b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2NullContact.b2NullContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2NullContact.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this);
    }
    b2NullContact.prototype.Evaluate = function () {}
    Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndCircleContact.Create = function (allocator) {
        return new b2PolyAndCircleContact();
    }
    b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
    b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
    }
    b2PolyAndCircleContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.m_body;
        var bB = this.m_fixtureB.m_body;
        b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolyAndEdgeContact.Create = function (allocator) {
        return new b2PolyAndEdgeContact();
    }
    b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
    b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
    }
    b2PolyAndEdgeContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
    Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
    b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    b2PolygonContact.b2PolygonContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
    };
    b2PolygonContact.Create = function (allocator) {
        return new b2PolygonContact();
    }
    b2PolygonContact.Destroy = function (contact, allocator) {}
    b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
        this.__super.Reset.call(this, fixtureA, fixtureB);
    }
    b2PolygonContact.prototype.Evaluate = function () {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
    }
    b2PositionSolverManifold.b2PositionSolverManifold = function () {};
    b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new b2Vec2();
        this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
        this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2();
        }
    }
    b2PositionSolverManifold.prototype.Initialize = function (cc) {
        b2Settings.b2Assert(cc.pointCount > 0);
        var i = 0;
        var clipPointX = 0;
        var clipPointY = 0;
        var tMat;
        var tVec;
        var planePointX = 0;
        var planePointY = 0;
        switch (cc.type) {
            case b2Manifold.e_circles:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.points[0].localPoint;
                var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                var dX = pointBX - pointAX;
                var dY = pointBY - pointAY;
                var d2 = dX * dX + dY * dY;
                if (d2 > Box2D.MIN_VALUE * Box2D.MIN_VALUE) {
                    var d = Math.sqrt(d2);
                    this.m_normal.x = dX / d;
                    this.m_normal.y = dY / d;
                }
                else {
                    this.m_normal.x = 1.0;
                    this.m_normal.y = 0.0;
                }
                this.m_points[0].x = 0.5 * (pointAX + pointBX);
                this.m_points[0].y = 0.5 * (pointAY + pointBY);
                this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
            }
                break;
            case b2Manifold.e_faceA:
            {
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyA.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyB.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].x = clipPointX;
                    this.m_points[i].y = clipPointY;
                }
            }
                break;
            case b2Manifold.e_faceB:
            {
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPlaneNormal;
                this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tMat = cc.bodyB.m_xf.R;
                tVec = cc.localPoint;
                planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tMat = cc.bodyA.m_xf.R;
                for (i = 0;
                     i < cc.pointCount; ++i) {
                    tVec = cc.points[i].localPoint;
                    clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                    this.m_points[i].Set(clipPointX, clipPointY);
                }
                this.m_normal.x *= (-1);
                this.m_normal.y *= (-1);
            }
                break;
        }
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
    });
})();
(function () {
    var b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
        b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
        b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
        b2MassData = Box2D.Collision.Shapes.b2MassData,
        b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
        b2Shape = Box2D.Collision.Shapes.b2Shape,
        b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
        b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
        b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
        b2Controller = Box2D.Dynamics.Controllers.b2Controller,
        b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
        b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
        b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

    Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
    b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2BuoyancyController.b2BuoyancyController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.normal = new b2Vec2(0, (-1));
        this.offset = 0;
        this.density = 0;
        this.velocity = new b2Vec2(0, 0);
        this.linearDrag = 2;
        this.angularDrag = 1;
        this.useDensity = false;
        this.useWorldGravity = true;
        this.gravity = null;
    };
    b2BuoyancyController.prototype.Step = function (step) {
        if (!this.m_bodyList) return;
        if (this.useWorldGravity) {
            this.gravity = this.GetWorld().GetGravity().Copy();
        }
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (body.IsAwake() == false) {
                continue;
            }
            var areac = new b2Vec2();
            var massc = new b2Vec2();
            var area = 0.0;
            var mass = 0.0;
            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
                var sc = new b2Vec2();
                var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
                area += sarea;
                areac.x += sarea * sc.x;
                areac.y += sarea * sc.y;
                var shapeDensity = 0;
                if (this.useDensity) {
                    shapeDensity = 1;
                }
                else {
                    shapeDensity = 1;
                }
                mass += sarea * shapeDensity;
                massc.x += sarea * sc.x * shapeDensity;
                massc.y += sarea * sc.y * shapeDensity;
            }
            areac.x /= area;
            areac.y /= area;
            massc.x /= mass;
            massc.y /= mass;
            if (area < Box2D.MIN_VALUE) continue;
            var buoyancyForce = this.gravity.GetNegative();
            buoyancyForce.Multiply(this.density * area);
            body.ApplyForce(buoyancyForce, massc);
            var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
            dragForce.Subtract(this.velocity);
            dragForce.Multiply((-this.linearDrag * area));
            body.ApplyForce(dragForce, areac);
            body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
        }
    }
    b2BuoyancyController.prototype.Draw = function (debugDraw) {
        var r = 1000;
        var p1 = new b2Vec2();
        var p2 = new b2Vec2();
        p1.x = this.normal.x * this.offset + this.normal.y * r;
        p1.y = this.normal.y * this.offset - this.normal.x * r;
        p2.x = this.normal.x * this.offset - this.normal.y * r;
        p2.y = this.normal.y * this.offset + this.normal.x * r;
        var color = new b2Color(0, 0, 1);
        debugDraw.DrawSegment(p1, p2, color);
    }
    Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantAccelController.b2ConstantAccelController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.A = new b2Vec2(0, 0);
    };
    b2ConstantAccelController.prototype.Step = function (step) {
        var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
        }
    }
    Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
    b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2ConstantForceController.b2ConstantForceController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.F = new b2Vec2(0, 0);
    };
    b2ConstantForceController.prototype.Step = function (step) {
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.ApplyForce(this.F, body.GetWorldCenter());
        }
    }
    b2Controller.b2Controller = function () {};
    b2Controller.prototype.Step = function (step) {}
    b2Controller.prototype.Draw = function (debugDraw) {}
    b2Controller.prototype.AddBody = function (body) {
        var edge = new b2ControllerEdge();
        edge.controller = this;
        edge.body = body;
        edge.nextBody = this.m_bodyList;
        edge.prevBody = null;
        this.m_bodyList = edge;
        if (edge.nextBody) edge.nextBody.prevBody = edge;
        this.m_bodyCount++;
        edge.nextController = body.m_controllerList;
        edge.prevController = null;
        body.m_controllerList = edge;
        if (edge.nextController) edge.nextController.prevController = edge;
        body.m_controllerCount++;
    }
    b2Controller.prototype.RemoveBody = function (body) {
        var edge = body.m_controllerList;
        while (edge && edge.controller != this)
            edge = edge.nextController;
        if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
        if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
        if (edge.nextController) edge.nextController.prevController = edge.prevController;
        if (edge.prevController) edge.prevController.nextController = edge.nextController;
        if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
        if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
        body.m_controllerCount--;
        this.m_bodyCount--;
    }
    b2Controller.prototype.Clear = function () {
        while (this.m_bodyList)
            this.RemoveBody(this.m_bodyList.body);
    }
    b2Controller.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Controller.prototype.GetWorld = function () {
        return this.m_world;
    }
    b2Controller.prototype.GetBodyList = function () {
        return this.m_bodyList;
    }
    b2ControllerEdge.b2ControllerEdge = function () {};
    Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
    b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2GravityController.b2GravityController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.G = 1;
        this.invSqr = true;
    };
    b2GravityController.prototype.Step = function (step) {
        var i = null;
        var body1 = null;
        var p1 = null;
        var mass1 = 0;
        var j = null;
        var body2 = null;
        var p2 = null;
        var dx = 0;
        var dy = 0;
        var r2 = 0;
        var f = null;
        if (this.invSqr) {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Box2D.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
        else {
            for (i = this.m_bodyList;
                 i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = this.m_bodyList;
                     j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Box2D.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply((-1));
                    if (body2.IsAwake()) body2.ApplyForce(f, p2);
                }
            }
        }
    }
    Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
    b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    b2TensorDampingController.b2TensorDampingController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.T = new b2Mat22();
        this.maxTimestep = 0;
    };
    b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
        if (xDamping === undefined) xDamping = 0;
        if (yDamping === undefined) yDamping = 0;
        this.T.col1.x = (-xDamping);
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = (-yDamping);
        if (xDamping > 0 || yDamping > 0) {
            this.maxTimestep = 1 / Math.max(xDamping, yDamping);
        }
        else {
            this.maxTimestep = 0;
        }
    }
    b2TensorDampingController.prototype.Step = function (step) {
        var timestep = step.dt;
        if (timestep <= Box2D.MIN_VALUE) return;
        if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) {
                continue;
            }
            var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
        }
    }
})();
(function () {
    var b2Color = Box2D.Common.b2Color,
        b2internal = Box2D.Common.b2internal,
        b2Settings = Box2D.Common.b2Settings,
        b2Mat22 = Box2D.Common.Math.b2Mat22,
        b2Mat33 = Box2D.Common.Math.b2Mat33,
        b2Math = Box2D.Common.Math.b2Math,
        b2Sweep = Box2D.Common.Math.b2Sweep,
        b2Transform = Box2D.Common.Math.b2Transform,
        b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2Vec3 = Box2D.Common.Math.b2Vec3,
        b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
        b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
        b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
        b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
        b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
        b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
        b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
        b2Joint = Box2D.Dynamics.Joints.b2Joint,
        b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
        b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
        b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
        b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
        b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
        b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
        b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
        b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
        b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
        b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
        b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
        b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
        b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
        b2ContactListener = Box2D.Dynamics.b2ContactListener,
        b2ContactManager = Box2D.Dynamics.b2ContactManager,
        b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
        b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
        b2FilterData = Box2D.Dynamics.b2FilterData,
        b2Fixture = Box2D.Dynamics.b2Fixture,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2Island = Box2D.Dynamics.b2Island,
        b2TimeStep = Box2D.Dynamics.b2TimeStep,
        b2World = Box2D.Dynamics.b2World;

    Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
    b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2DistanceJoint.b2DistanceJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u = new b2Vec2();
    };
    b2DistanceJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2DistanceJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
    }
    b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2DistanceJoint.prototype.GetLength = function () {
        return this.m_length;
    }
    b2DistanceJoint.prototype.SetLength = function (length) {
        if (length === undefined) length = 0;
        this.m_length = length;
    }
    b2DistanceJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2DistanceJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2DistanceJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_length = def.length;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = 0.0;
        this.m_gamma = 0.0;
        this.m_bias = 0.0;
    }
    b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        if (length > b2Settings.b2_linearSlop) {
            this.m_u.Multiply(1.0 / length);
        }
        else {
            this.m_u.SetZero();
        }
        var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
        var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
        var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
        this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
        if (this.m_frequencyHz > 0.0) {
            var C = length - this.m_length;
            var omega = 2.0 * Math.PI * this.m_frequencyHz;
            var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            this.m_gamma = step.dt * (d + step.dt * k);
            this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
            this.m_bias = C * step.dt * k * this.m_gamma;
            this.m_mass = invMass + this.m_gamma;
            this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            var PX = this.m_impulse * this.m_u.x;
            var PY = this.m_impulse * this.m_u.y;
            bA.m_linearVelocity.x -= bA.m_invMass * PX;
            bA.m_linearVelocity.y -= bA.m_invMass * PY;
            bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
            bB.m_linearVelocity.x += bB.m_invMass * PX;
            bB.m_linearVelocity.y += bB.m_invMass * PY;
            bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
        var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
        var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
        var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
        var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
        var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
        this.m_impulse += impulse;
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_linearVelocity.x -= bA.m_invMass * PX;
        bA.m_linearVelocity.y -= bA.m_invMass * PY;
        bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_linearVelocity.x += bB.m_invMass * PX;
        bB.m_linearVelocity.y += bB.m_invMass * PY;
        bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
    }
    b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        if (this.m_frequencyHz > 0.0) {
            return true;
        }
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(dX * dX + dY * dY);
        dX /= length;
        dY /= length;
        var C = length - this.m_length;
        C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
        var impulse = (-this.m_mass * C);
        this.m_u.Set(dX, dY);
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_sweep.c.x -= bA.m_invMass * PX;
        bA.m_sweep.c.y -= bA.m_invMass * PY;
        bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_sweep.c.x += bB.m_invMass * PX;
        bB.m_sweep.c.y += bB.m_invMass * PY;
        bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return b2Math.Abs(C) < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2DistanceJointDef.b2DistanceJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_distanceJoint;
        this.length = 1.0;
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
        var dX = anchorB.x - anchorA.x;
        var dY = anchorB.y - anchorA.y;
        this.length = Math.sqrt(dX * dX + dY * dY);
        this.frequencyHz = 0.0;
        this.dampingRatio = 0.0;
    }
    Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
    b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2FrictionJoint.b2FrictionJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_linearMass = new b2Mat22();
        this.m_linearImpulse = new b2Vec2();
    };
    b2FrictionJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2FrictionJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
    }
    b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_angularImpulse;
    }
    b2FrictionJoint.prototype.SetMaxForce = function (force) {
        if (force === undefined) force = 0;
        this.m_maxForce = force;
    }
    b2FrictionJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxTorque = torque;
    }
    b2FrictionJoint.prototype.GetMaxTorque = function () {
        return this.m_maxTorque;
    }
    b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0.0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0.0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque;
    }
    b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var K = new b2Mat22();
        K.col1.x = mA + mB;
        K.col2.x = 0.0;
        K.col1.y = 0.0;
        K.col2.y = mA + mB;
        K.col1.x += iA * rAY * rAY;
        K.col2.x += (-iA * rAX * rAY);
        K.col1.y += (-iA * rAX * rAY);
        K.col2.y += iA * rAX * rAX;
        K.col1.x += iB * rBY * rBY;
        K.col2.x += (-iB * rBX * rBY);
        K.col1.y += (-iB * rBX * rBY);
        K.col2.y += iB * rBX * rBX;
        K.GetInverse(this.m_linearMass);
        this.m_angularMass = iA + iB;
        if (this.m_angularMass > 0.0) {
            this.m_angularMass = 1.0 / this.m_angularMass;
        }
        if (step.warmStarting) {
            this.m_linearImpulse.x *= step.dtRatio;
            this.m_linearImpulse.y *= step.dtRatio;
            this.m_angularImpulse *= step.dtRatio;
            var P = this.m_linearImpulse;
            bA.m_linearVelocity.x -= mA * P.x;
            bA.m_linearVelocity.y -= mA * P.y;
            bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
            bB.m_linearVelocity.x += mB * P.x;
            bB.m_linearVelocity.y += mB * P.y;
            bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
        }
        else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0.0;
        }
    }
    b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var maxImpulse = 0; {
            var Cdot = wB - wA;
            var impulse = (-this.m_angularMass * Cdot);
            var oldImpulse = this.m_angularImpulse;
            maxImpulse = step.dt * this.m_maxTorque;
            this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_angularImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse;
        } {
            var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
            var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
            var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
            var oldImpulseV = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(impulseV);
            maxImpulse = step.dt * this.m_maxForce;
            if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                this.m_linearImpulse.Normalize();
                this.m_linearImpulse.Multiply(maxImpulse);
            }
            impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
            vA.x -= mA * impulseV.x;
            vA.y -= mA * impulseV.y;
            wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
            vB.x += mB * impulseV.x;
            vB.y += mB * impulseV.y;
            wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
        }
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2FrictionJointDef.b2FrictionJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_frictionJoint;
        this.maxForce = 0.0;
        this.maxTorque = 0.0;
    }
    b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
    }
    Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
    b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2GearJoint.b2GearJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_J = new b2Jacobian();
    };
    b2GearJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2GearJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
    }
    b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        var tMat = this.m_bodyB.m_xf.R;
        var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
        var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
        var tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var PX = this.m_impulse * this.m_J.linearB.x;
        var PY = this.m_impulse * this.m_J.linearB.y;
        return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
    }
    b2GearJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2GearJoint.prototype.SetRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_ratio = ratio;
    }
    b2GearJoint.prototype.b2GearJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var type1 = parseInt(def.joint1.m_type);
        var type2 = parseInt(def.joint2.m_type);
        this.m_revolute1 = null;
        this.m_prismatic1 = null;
        this.m_revolute2 = null;
        this.m_prismatic2 = null;
        var coordinate1 = 0;
        var coordinate2 = 0;
        this.m_ground1 = def.joint1.GetBodyA();
        this.m_bodyA = def.joint1.GetBodyB();
        if (type1 == b2Joint.e_revoluteJoint) {
            this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        this.m_ground2 = def.joint2.GetBodyA();
        this.m_bodyB = def.joint2.GetBodyB();
        if (type2 == b2Joint.e_revoluteJoint) {
            this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
            this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        this.m_ratio = def.ratio;
        this.m_constant = coordinate1 + this.m_ratio * coordinate2;
        this.m_impulse = 0.0;
    }
    b2GearJoint.prototype.InitVelocityConstraints = function (step) {
        var g1 = this.m_ground1;
        var g2 = this.m_ground2;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var ugX = 0;
        var ugY = 0;
        var rX = 0;
        var rY = 0;
        var tMat;
        var tVec;
        var crug = 0;
        var tX = 0;
        var K = 0.0;
        this.m_J.SetZero();
        if (this.m_revolute1) {
            this.m_J.angularA = (-1.0);
            K += bA.m_invI;
        }
        else {
            tMat = g1.m_xf.R;
            tVec = this.m_prismatic1.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bA.m_xf.R;
            rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearA.Set((-ugX), (-ugY));
            this.m_J.angularA = (-crug);
            K += bA.m_invMass + bA.m_invI * crug * crug;
        }
        if (this.m_revolute2) {
            this.m_J.angularB = (-this.m_ratio);
            K += this.m_ratio * this.m_ratio * bB.m_invI;
        }
        else {
            tMat = g2.m_xf.R;
            tVec = this.m_prismatic2.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bB.m_xf.R;
            rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
            this.m_J.angularB = (-this.m_ratio * crug);
            K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
        }
        this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
        if (step.warmStarting) {
            bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
            bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
            bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
            bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
            bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
            bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
        }
        else {
            this.m_impulse = 0.0;
        }
    }
    b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
        var impulse = (-this.m_mass * Cdot);
        this.m_impulse += impulse;
        bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
    }
    b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var linearError = 0.0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var coordinate1 = 0;
        var coordinate2 = 0;
        if (this.m_revolute1) {
            coordinate1 = this.m_revolute1.GetJointAngle();
        }
        else {
            coordinate1 = this.m_prismatic1.GetJointTranslation();
        }
        if (this.m_revolute2) {
            coordinate2 = this.m_revolute2.GetJointAngle();
        }
        else {
            coordinate2 = this.m_prismatic2.GetJointTranslation();
        }
        var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
        var impulse = (-this.m_mass * C);
        bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2GearJointDef.b2GearJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    };
    b2GearJointDef.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_gearJoint;
        this.joint1 = null;
        this.joint2 = null;
        this.ratio = 1.0;
    }
    b2Jacobian.b2Jacobian = function () {
        this.linearA = new b2Vec2();
        this.linearB = new b2Vec2();
    };
    b2Jacobian.prototype.SetZero = function () {
        this.linearA.SetZero();
        this.angularA = 0.0;
        this.linearB.SetZero();
        this.angularB = 0.0;
    }
    b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        this.linearA.SetV(x1);
        this.angularA = a1;
        this.linearB.SetV(x2);
        this.angularB = a2;
    }
    b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
        if (a1 === undefined) a1 = 0;
        if (a2 === undefined) a2 = 0;
        return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
    }
    b2Joint.b2Joint = function () {
        this.m_edgeA = new b2JointEdge();
        this.m_edgeB = new b2JointEdge();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
    };
    b2Joint.prototype.GetType = function () {
        return this.m_type;
    }
    b2Joint.prototype.GetAnchorA = function () {
        return null;
    }
    b2Joint.prototype.GetAnchorB = function () {
        return null;
    }
    b2Joint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return null;
    }
    b2Joint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2Joint.prototype.GetBodyA = function () {
        return this.m_bodyA;
    }
    b2Joint.prototype.GetBodyB = function () {
        return this.m_bodyB;
    }
    b2Joint.prototype.GetNext = function () {
        return this.m_next;
    }
    b2Joint.prototype.GetUserData = function () {
        return this.m_userData;
    }
    b2Joint.prototype.SetUserData = function (data) {
        this.m_userData = data;
    }
    b2Joint.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
    }
    b2Joint.Create = function (def, allocator) {
        var joint = null;
        switch (def.type) {
            case b2Joint.e_distanceJoint:
            {
                joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
            }
                break;
            case b2Joint.e_mouseJoint:
            {
                joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
            }
                break;
            case b2Joint.e_prismaticJoint:
            {
                joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
            }
                break;
            case b2Joint.e_revoluteJoint:
            {
                joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
            }
                break;
            case b2Joint.e_pulleyJoint:
            {
                joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
            }
                break;
            case b2Joint.e_gearJoint:
            {
                joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
            }
                break;
            case b2Joint.e_lineJoint:
            {
                joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
            }
                break;
            case b2Joint.e_weldJoint:
            {
                joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
            }
                break;
            case b2Joint.e_frictionJoint:
            {
                joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
            }
                break;
            default:
                break;
        }
        return joint;
    }
    b2Joint.Destroy = function (joint, allocator) {}
    b2Joint.prototype.b2Joint = function (def) {
        b2Settings.b2Assert(def.bodyA != def.bodyB);
        this.m_type = def.type;
        this.m_prev = null;
        this.m_next = null;
        this.m_bodyA = def.bodyA;
        this.m_bodyB = def.bodyB;
        this.m_collideConnected = def.collideConnected;
        this.m_islandFlag = false;
        this.m_userData = def.userData;
    }
    b2Joint.prototype.InitVelocityConstraints = function (step) {}
    b2Joint.prototype.SolveVelocityConstraints = function (step) {}
    b2Joint.prototype.FinalizeVelocityConstraints = function () {}
    b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return false;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
        Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
        Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
        Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
        Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
        Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
        Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
        Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
        Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
        Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
        Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
        Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
        Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
        Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
    });
    b2JointDef.b2JointDef = function () {};
    b2JointDef.prototype.b2JointDef = function () {
        this.type = b2Joint.e_unknownJoint;
        this.userData = null;
        this.bodyA = null;
        this.bodyB = null;
        this.collideConnected = false;
    }
    b2JointEdge.b2JointEdge = function () {};
    Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
    b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2LineJoint.b2LineJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat22();
        this.m_impulse = new b2Vec2();
    };
    b2LineJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2LineJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
    }
    b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2LineJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2LineJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2LineJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2LineJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2LineJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2LineJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2LineJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2LineJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2LineJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2LineJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2LineJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2LineJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2LineJoint.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce;
    }
    b2LineJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2LineJoint.prototype.b2LineJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2LineJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            this.m_motorMass = this.m_motorMass > Box2D.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.y = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.y = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
            }
            var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
            var f2r = 0;
            if (this.m_K.col1.x != 0.0) {
                f2r = b / this.m_K.col1.x + f1.x;
            }
            else {
                f2r = f1.x;
            }
            this.m_impulse.x = f2r;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y * this.m_a1;
            L2 = df.x * this.m_s2 + df.y * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = 0;
            if (this.m_K.col1.x != 0.0) {
                df2 = ((-Cdot1)) / this.m_K.col1.x;
            }
            else {
                df2 = 0.0;
            }
            this.m_impulse.x += df2;
            PX = df2 * this.m_perp.x;
            PY = df2 * this.m_perp.y;
            L1 = df2 * this.m_s1;
            L2 = df2 * this.m_s2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec2();
        var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1));
        angularError = 0.0;
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve(impulse, (-C1), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var impulse1 = 0;
            if (k11 != 0.0) {
                impulse1 = ((-C1)) / k11;
            }
            else {
                impulse1 = 0.0;
            }
            impulse.x = impulse1;
            impulse.y = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2LineJointDef.b2LineJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2LineJointDef.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_lineJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
    }
    Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
    b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2MouseJoint.b2MouseJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.m_localAnchor = new b2Vec2();
        this.m_target = new b2Vec2();
        this.m_impulse = new b2Vec2();
        this.m_mass = new b2Mat22();
        this.m_C = new b2Vec2();
    };
    b2MouseJoint.prototype.GetAnchorA = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
    }
    b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2MouseJoint.prototype.GetTarget = function () {
        return this.m_target;
    }
    b2MouseJoint.prototype.SetTarget = function (target) {
        if (this.m_bodyB.IsAwake() == false) {
            this.m_bodyB.SetAwake(true);
        }
        this.m_target = target;
    }
    b2MouseJoint.prototype.GetMaxForce = function () {
        return this.m_maxForce;
    }
    b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
        if (maxForce === undefined) maxForce = 0;
        this.m_maxForce = maxForce;
    }
    b2MouseJoint.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
    }
    b2MouseJoint.prototype.SetFrequency = function (hz) {
        if (hz === undefined) hz = 0;
        this.m_frequencyHz = hz;
    }
    b2MouseJoint.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
    }
    b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
        if (ratio === undefined) ratio = 0;
        this.m_dampingRatio = ratio;
    }
    b2MouseJoint.prototype.b2MouseJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_target.SetV(def.target);
        var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
        var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
        var tMat = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
        this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
        this.m_maxForce = def.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_beta = 0.0;
        this.m_gamma = 0.0;
    }
    b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var mass = b.GetMass();
        var omega = 2.0 * Math.PI * this.m_frequencyHz;
        var d = 2.0 * mass * this.m_dampingRatio * omega;
        var k = mass * omega * omega;
        this.m_gamma = step.dt * (d + step.dt * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
        this.m_beta = step.dt * k * this.m_gamma;
        var tMat;tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var invMass = b.m_invMass;
        var invI = b.m_invI;this.K1.col1.x = invMass;
        this.K1.col2.x = 0.0;
        this.K1.col1.y = 0.0;
        this.K1.col2.y = invMass;
        this.K2.col1.x = invI * rY * rY;
        this.K2.col2.x = (-invI * rX * rY);
        this.K2.col1.y = (-invI * rX * rY);
        this.K2.col2.y = invI * rX * rX;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
        b.m_angularVelocity *= 0.98;
        this.m_impulse.x *= step.dtRatio;
        this.m_impulse.y *= step.dtRatio;
        b.m_linearVelocity.x += invMass * this.m_impulse.x;
        b.m_linearVelocity.y += invMass * this.m_impulse.y;
        b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
    }
    b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
        var b = this.m_bodyB;
        var tMat;
        var tX = 0;
        var tY = 0;
        tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rX + tMat.col2.x * rY);
        rY = (tMat.col1.y * rX + tMat.col2.y * rY);
        rX = tX;
        var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
        var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
        tMat = this.m_mass;
        tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
        var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
        var oldImpulseX = this.m_impulse.x;
        var oldImpulseY = this.m_impulse.y;
        this.m_impulse.x += impulseX;
        this.m_impulse.y += impulseY;
        var maxImpulse = step.dt * this.m_maxForce;
        if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
        }
        impulseX = this.m_impulse.x - oldImpulseX;
        impulseY = this.m_impulse.y - oldImpulseY;
        b.m_linearVelocity.x += b.m_invMass * impulseX;
        b.m_linearVelocity.y += b.m_invMass * impulseY;
        b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
    }
    b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        return true;
    }
    Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2MouseJointDef.b2MouseJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.target = new b2Vec2();
    };
    b2MouseJointDef.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_mouseJoint;
        this.maxForce = 0.0;
        this.frequencyHz = 5.0;
        this.dampingRatio = 0.7;
    }
    Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PrismaticJoint.b2PrismaticJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_localXAxis1 = new b2Vec2();
        this.m_localYAxis1 = new b2Vec2();
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_K = new b2Mat33();
        this.m_impulse = new b2Vec3();
    };
    b2PrismaticJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PrismaticJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
    }
    b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.y;
    }
    b2PrismaticJoint.prototype.GetJointTranslation = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation;
    }
    b2PrismaticJoint.prototype.GetJointSpeed = function () {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
        return speed;
    }
    b2PrismaticJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2PrismaticJoint.prototype.EnableLimit = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag;
    }
    b2PrismaticJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
    }
    b2PrismaticJoint.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
    }
    b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper;
    }
    b2PrismaticJoint.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
    }
    b2PrismaticJoint.prototype.EnableMotor = function (flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag;
    }
    b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2PrismaticJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
        if (force === undefined) force = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force;
    }
    b2PrismaticJoint.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
    }
    b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = (-this.m_localXAxis1.y);
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorMass = 0.0;
        this.m_motorImpulse = 0.0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero();
    }
    b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            if (this.m_motorMass > Box2D.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2;
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX = 0;
        var PY = 0;
        var L1 = 0;
        var L2 = 0;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        var Cdot1Y = w2 - w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
            }
            var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
            var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
            var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
            f2r.x += f1.x;
            f2r.y += f1.y;
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            df.z = this.m_impulse.z - f1.z;
            PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
            L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        else {
            var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
            this.m_impulse.x += df2.x;
            this.m_impulse.y += df2.y;
            PX = df2.x * this.m_perp.x;
            PY = df2.x * this.m_perp.y;
            L1 = df2.x * this.m_s1 + df2.y;
            L2 = df2.x * this.m_s2 + df2.y;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2;
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var limitC = 0;
        var oldLimitImpulse = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX = 0;
        var m1 = 0;
        var m2 = 0;
        var i1 = 0;
        var i2 = 0;
        var linearError = 0.0;
        var angularError = 0.0;
        var active = false;
        var C2 = 0.0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true;
            }
            else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
                linearError = this.m_lowerTranslation - translation;
                active = true;
            }
            else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true;
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec3();
        var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
        var C1Y = a2 - a1 - this.m_refAngle;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
        angularError = b2Math.Abs(C1Y);
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        }
        else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var k12 = i1 * this.m_s1 + i2 * this.m_s2;
            var k22 = i1 + i2;
            this.m_K.col1.Set(k11, k12, 0.0);
            this.m_K.col2.Set(k12, k22, 0.0);
            var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0.0;
        }
        var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PrismaticJointDef.b2PrismaticJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2();
    };
    b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_prismaticJoint;
        this.localAxisA.Set(1.0, 0.0);
        this.referenceAngle = 0.0;
        this.enableLimit = false;
        this.lowerTranslation = 0.0;
        this.upperTranslation = 0.0;
        this.enableMotor = false;
        this.maxMotorForce = 0.0;
        this.motorSpeed = 0.0;
    }
    b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
    b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2PulleyJoint.b2PulleyJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new b2Vec2();
        this.m_groundAnchor2 = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_u1 = new b2Vec2();
        this.m_u2 = new b2Vec2();
    };
    b2PulleyJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2PulleyJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
    }
    b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return 0.0;
    }
    b2PulleyJoint.prototype.GetGroundAnchorA = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a;
    }
    b2PulleyJoint.prototype.GetGroundAnchorB = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a;
    }
    b2PulleyJoint.prototype.GetLength1 = function () {
        var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetLength2 = function () {
        var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY);
    }
    b2PulleyJoint.prototype.GetRatio = function () {
        return this.m_ratio;
    }
    b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        var tMat;
        var tX = 0;
        var tY = 0;
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_ratio = def.ratio;
        this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
        this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
        this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
        this.m_impulse = 0.0;
        this.m_limitImpulse1 = 0.0;
        this.m_limitImpulse2 = 0.0;
    }
    b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(p1X - s1X, p1Y - s1Y);
        this.m_u2.Set(p2X - s2X, p2Y - s2Y);
        var length1 = this.m_u1.Length();
        var length2 = this.m_u2.Length();
        if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
        }
        else {
            this.m_u1.SetZero();
        }
        if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
        }
        else {
            this.m_u2.SetZero();
        }
        var C = this.m_constant - length1 - this.m_ratio * length2;
        if (C > 0.0) {
            this.m_state = b2Joint.e_inactiveLimit;
            this.m_impulse = 0.0;
        }
        else {
            this.m_state = b2Joint.e_atUpperLimit;
        }
        if (length1 < this.m_maxLength1) {
            this.m_limitState1 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse1 = 0.0;
        }
        else {
            this.m_limitState1 = b2Joint.e_atUpperLimit;
        }
        if (length2 < this.m_maxLength2) {
            this.m_limitState2 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse2 = 0.0;
        }
        else {
            this.m_limitState2 = b2Joint.e_atUpperLimit;
        }
        var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
        var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
        this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
        this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1.0 / this.m_limitMass1;
        this.m_limitMass2 = 1.0 / this.m_limitMass2;
        this.m_pulleyMass = 1.0 / this.m_pulleyMass;
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            this.m_limitImpulse1 *= step.dtRatio;
            this.m_limitImpulse2 *= step.dtRatio;
            var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
            var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
            var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
            var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        else {
            this.m_impulse = 0.0;
            this.m_limitImpulse1 = 0.0;
            this.m_limitImpulse2 = 0.0;
        }
    }
    b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var v1X = 0;
        var v1Y = 0;
        var v2X = 0;
        var v2Y = 0;
        var P1X = 0;
        var P1Y = 0;
        var P2X = 0;
        var P2Y = 0;
        var Cdot = 0;
        var impulse = 0;
        var oldImpulse = 0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
            impulse = this.m_pulleyMass * ((-Cdot));
            oldImpulse = this.m_impulse;
            this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
            impulse = this.m_impulse - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            P2X = (-this.m_ratio * impulse * this.m_u2.x);
            P2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
            v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
            Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
            impulse = (-this.m_limitMass1 * Cdot);
            oldImpulse = this.m_limitImpulse1;
            this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
            impulse = this.m_limitImpulse1 - oldImpulse;
            P1X = (-impulse * this.m_u1.x);
            P1Y = (-impulse * this.m_u1.y);
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
            v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
            Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
            impulse = (-this.m_limitMass2 * Cdot);
            oldImpulse = this.m_limitImpulse2;
            this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
            impulse = this.m_limitImpulse2 - oldImpulse;
            P2X = (-impulse * this.m_u2.x);
            P2Y = (-impulse * this.m_u2.y);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
        }
    }
    b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var p1X = 0;
        var p1Y = 0;
        var p2X = 0;
        var p2Y = 0;
        var length1 = 0;
        var length2 = 0;
        var C = 0;
        var impulse = 0;
        var oldImpulse = 0;
        var oldLimitPositionImpulse = 0;
        var tX = 0;
        var linearError = 0.0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length1 = this.m_u1.Length();
            length2 = this.m_u2.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.Multiply(1.0 / length1);
            }
            else {
                this.m_u1.SetZero();
            }
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.Multiply(1.0 / length2);
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_constant - length1 - this.m_ratio * length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_pulleyMass * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            p2X = (-this.m_ratio * impulse * this.m_u2.x);
            p2Y = (-this.m_ratio * impulse * this.m_u2.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            length1 = this.m_u1.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.x *= 1.0 / length1;
                this.m_u1.y *= 1.0 / length1;
            }
            else {
                this.m_u1.SetZero();
            }
            C = this.m_maxLength1 - length1;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass1 * C);
            p1X = (-impulse * this.m_u1.x);
            p1Y = (-impulse * this.m_u1.y);
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bA.SynchronizeTransform();
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length2 = this.m_u2.Length();
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.x *= 1.0 / length2;
                this.m_u2.y *= 1.0 / length2;
            }
            else {
                this.m_u2.SetZero();
            }
            C = this.m_maxLength2 - length2;
            linearError = b2Math.Max(linearError, (-C));
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            impulse = (-this.m_limitMass2 * C);
            p2X = (-impulse * this.m_u2.x);
            p2Y = (-impulse * this.m_u2.y);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bB.SynchronizeTransform();
        }
        return linearError < b2Settings.b2_linearSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
    });
    Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2PulleyJointDef.b2PulleyJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.groundAnchorA = new b2Vec2();
        this.groundAnchorB = new b2Vec2();
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_pulleyJoint;
        this.groundAnchorA.Set((-1.0), 1.0);
        this.groundAnchorB.Set(1.0, 1.0);
        this.localAnchorA.Set((-1.0), 0.0);
        this.localAnchorB.Set(1.0, 0.0);
        this.lengthA = 0.0;
        this.maxLengthA = 0.0;
        this.lengthB = 0.0;
        this.maxLengthB = 0.0;
        this.ratio = 1.0;
        this.collideConnected = true;
    }
    b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
        if (r === undefined) r = 0;
        this.bodyA = bA;
        this.bodyB = bB;
        this.groundAnchorA.SetV(gaA);
        this.groundAnchorB.SetV(gaB);
        this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
        var d1X = anchorA.x - gaA.x;
        var d1Y = anchorA.y - gaA.y;
        this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
        var d2X = anchorB.x - gaB.x;
        var d2Y = anchorB.y - gaB.y;
        this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
        this.ratio = r;
        var C = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
        this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
    }
    Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
    b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2RevoluteJoint.b2RevoluteJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b2Mat22();
        this.K1 = new b2Mat22();
        this.K2 = new b2Mat22();
        this.K3 = new b2Mat22();
        this.impulse3 = new b2Vec3();
        this.impulse2 = new b2Vec2();
        this.reduced = new b2Vec2();
        this.m_localAnchor1 = new b2Vec2();
        this.m_localAnchor2 = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2RevoluteJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    }
    b2RevoluteJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    }
    b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2RevoluteJoint.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
    }
    b2RevoluteJoint.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
    }
    b2RevoluteJoint.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
    }
    b2RevoluteJoint.prototype.EnableLimit = function (flag) {
        this.m_enableLimit = flag;
    }
    b2RevoluteJoint.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle;
    }
    b2RevoluteJoint.prototype.GetUpperLimit = function () {
        return this.m_upperAngle;
    }
    b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
        if (lower === undefined) lower = 0;
        if (upper === undefined) upper = 0;
        this.m_lowerAngle = lower;
        this.m_upperAngle = upper;
    }
    b2RevoluteJoint.prototype.IsMotorEnabled = function () {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        return this.m_enableMotor;
    }
    b2RevoluteJoint.prototype.EnableMotor = function (flag) {
        this.m_enableMotor = flag;
    }
    b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
        if (speed === undefined) speed = 0;
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed;
    }
    b2RevoluteJoint.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
    }
    b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
        if (torque === undefined) torque = 0;
        this.m_maxMotorTorque = torque;
    }
    b2RevoluteJoint.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque;
    }
    b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = 0.0;
        this.m_lowerAngle = def.lowerAngle;
        this.m_upperAngle = def.upperAngle;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
    }
    b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        if (this.m_enableMotor || this.m_enableLimit) {}
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
        r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
        r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
        r2X = tX;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
        this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
        this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
        this.m_mass.col3.y = r1X * i1 + r2X * i2;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = i1 + i2;
        this.m_motorMass = 1.0 / (i1 + i2);
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0.0;
        }
        if (this.m_enableLimit) {
            var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
                this.m_limitState = b2Joint.e_equalLimits;
            }
            else if (jointAngle <= this.m_lowerAngle) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atLowerLimit;
            }
            else if (jointAngle >= this.m_upperAngle) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_impulse.z = 0.0;
                }
                this.m_limitState = b2Joint.e_atUpperLimit;
            }
            else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0.0;
            }
        }
        else {
            this.m_limitState = b2Joint.e_inactiveLimit;
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x;
            var PY = this.m_impulse.y;
            bA.m_linearVelocity.x -= m1 * PX;
            bA.m_linearVelocity.y -= m1 * PY;
            bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
            bB.m_linearVelocity.x += m2 * PX;
            bB.m_linearVelocity.y += m2 * PY;
            bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0.0;
        }
    }
    b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX = 0;
        var newImpulse = 0;
        var r1X = 0;
        var r1Y = 0;
        var r2X = 0;
        var r2Y = 0;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = w2 - w1 - this.m_motorSpeed;
            var impulse = this.m_motorMass * ((-Cdot));
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            w1 -= i1 * impulse;
            w2 += i2 * impulse;
        }
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            var Cdot2 = w2 - w1;
            this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
            if (this.m_limitState == b2Joint.e_equalLimits) {
                this.m_impulse.Add(this.impulse3);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse < 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse > 0.0) {
                    this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = (-this.m_impulse.z);
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0.0;
                }
            }
            v1.x -= m1 * this.impulse3.x;
            v1.y -= m1 * this.impulse3.y;
            w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
            v2.x += m2 * this.impulse3.x;
            v2.y += m2 * this.impulse3.y;
            w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
        }
        else {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
            var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
            this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
            this.m_impulse.x += this.impulse2.x;
            this.m_impulse.y += this.impulse2.y;
            v1.x -= m1 * this.impulse2.x;
            v1.y -= m1 * this.impulse2.y;
            w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
            v2.x += m2 * this.impulse2.x;
            v2.y += m2 * this.impulse2.y;
            w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2;
    }
    b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var oldLimitImpulse = 0;
        var C = 0;
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var angularError = 0.0;
        var positionError = 0.0;
        var tX = 0;
        var impulseX = 0;
        var impulseY = 0;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            var limitImpulse = 0.0;
            if (this.m_limitState == b2Joint.e_equalLimits) {
                C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
                angularError = b2Math.Abs(C);
            }
            else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                C = angle - this.m_lowerAngle;
                angularError = (-C);
                C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
                limitImpulse = (-this.m_motorMass * C);
            }
            else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                C = angle - this.m_upperAngle;
                angularError = C;
                C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
                limitImpulse = (-this.m_motorMass * C);
            }
            bA.m_sweep.a -= bA.m_invI * limitImpulse;
            bB.m_sweep.a += bB.m_invI * limitImpulse;
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        } {
            tMat = bA.m_xf.R;
            var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
            r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
            r1X = tX;
            tMat = bB.m_xf.R;
            var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
            r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
            r2X = tX;
            var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            var CLengthSquared = CX * CX + CY * CY;
            var CLength = Math.sqrt(CLengthSquared);
            positionError = CLength;
            var invMass1 = bA.m_invMass;
            var invMass2 = bB.m_invMass;
            var invI1 = bA.m_invI;
            var invI2 = bB.m_invI;
            var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
            if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
                var uX = CX / CLength;
                var uY = CY / CLength;
                var k = invMass1 + invMass2;
                var m = 1.0 / k;
                impulseX = m * ((-CX));
                impulseY = m * ((-CY));
                var k_beta = 0.5;
                bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
                bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
                bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
                bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
                CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
                CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            }
            this.K1.col1.x = invMass1 + invMass2;
            this.K1.col2.x = 0.0;
            this.K1.col1.y = 0.0;
            this.K1.col2.y = invMass1 + invMass2;
            this.K2.col1.x = invI1 * r1Y * r1Y;
            this.K2.col2.x = (-invI1 * r1X * r1Y);
            this.K2.col1.y = (-invI1 * r1X * r1Y);
            this.K2.col2.y = invI1 * r1X * r1X;
            this.K3.col1.x = invI2 * r2Y * r2Y;
            this.K3.col2.x = (-invI2 * r2X * r2Y);
            this.K3.col1.y = (-invI2 * r2X * r2Y);
            this.K3.col2.y = invI2 * r2X * r2X;
            this.K.SetM(this.K1);
            this.K.AddM(this.K2);
            this.K.AddM(this.K3);
            this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
            impulseX = b2RevoluteJoint.tImpulse.x;
            impulseY = b2RevoluteJoint.tImpulse.y;
            bA.m_sweep.c.x -= bA.m_invMass * impulseX;
            bA.m_sweep.c.y -= bA.m_invMass * impulseY;
            bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
            bB.m_sweep.c.x += bB.m_invMass * impulseX;
            bB.m_sweep.c.y += bB.m_invMass * impulseY;
            bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
        }
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
    });
    Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2RevoluteJointDef.b2RevoluteJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_revoluteJoint;
        this.localAnchorA.Set(0.0, 0.0);
        this.localAnchorB.Set(0.0, 0.0);
        this.referenceAngle = 0.0;
        this.lowerAngle = 0.0;
        this.upperAngle = 0.0;
        this.maxMotorTorque = 0.0;
        this.motorSpeed = 0.0;
        this.enableLimit = false;
        this.enableMotor = false;
    }
    b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
    Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
    b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    b2WeldJoint.b2WeldJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_impulse = new b2Vec3();
        this.m_mass = new b2Mat33();
    };
    b2WeldJoint.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
    }
    b2WeldJoint.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
    }
    b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
    }
    b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
        if (inv_dt === undefined) inv_dt = 0;
        return inv_dt * this.m_impulse.z;
    }
    b2WeldJoint.prototype.b2WeldJoint = function (def) {
        this.__super.b2Joint.call(this, def);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new b2Mat33();
    }
    b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_impulse.z *= step.dtRatio;
            bA.m_linearVelocity.x -= mA * this.m_impulse.x;
            bA.m_linearVelocity.y -= mA * this.m_impulse.y;
            bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
            bB.m_linearVelocity.x += mB * this.m_impulse.x;
            bB.m_linearVelocity.y += mB * this.m_impulse.y;
            bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
        }
        else {
            this.m_impulse.SetZero();
        }
    }
    b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
        var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
        var Cdot2 = wB - wA;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
        this.m_impulse.Add(impulse);
        vA.x -= mA * impulse.x;
        vA.y -= mA * impulse.y;
        wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        vB.x += mB * impulse.x;
        vB.y += mB * impulse.y;
        wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB;
    }
    b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
        if (baumgarte === undefined) baumgarte = 0;
        var tMat;
        var tX = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
        rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
        rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
        var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
        var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
        var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
        var angularError = b2Math.Abs(C2);
        if (positionError > k_allowedStretch) {
            iA *= 1.0;
            iB *= 1.0;
        }
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
        this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        var impulse = new b2Vec3();
        this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
        bA.m_sweep.c.x -= mA * impulse.x;
        bA.m_sweep.c.y -= mA * impulse.y;
        bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        bB.m_sweep.c.x += mB * impulse.x;
        bB.m_sweep.c.y += mB * impulse.y;
        bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
    }
    Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
    b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    b2WeldJointDef.b2WeldJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
    };
    b2WeldJointDef.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = b2Joint.e_weldJoint;
        this.referenceAngle = 0.0;
    }
    b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
    }
})();
(function () {
    var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
    b2DebugDraw.b2DebugDraw = function () {
        this.m_drawScale = 1.0;
        this.m_lineThickness = 1.0;
        this.m_alpha = 1.0;
        this.m_fillAlpha = 1.0;
        this.m_xformScale = 1.0;
        var __this = this;
        //#WORKAROUND
        this.m_sprite = {
            graphics: {
                clear: function () {
                    __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
                }
            }
        };
    };
    b2DebugDraw.prototype._color = function (color, alpha) {
        return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
    };
    b2DebugDraw.prototype.b2DebugDraw = function () {
        this.m_drawFlags = 0;
    };
    b2DebugDraw.prototype.SetFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags = flags;
    };
    b2DebugDraw.prototype.GetFlags = function () {
        return this.m_drawFlags;
    };
    b2DebugDraw.prototype.AppendFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags |= flags;
    };
    b2DebugDraw.prototype.ClearFlags = function (flags) {
        if (flags === undefined) flags = 0;
        this.m_drawFlags &= ~flags;
    };
    b2DebugDraw.prototype.SetSprite = function (sprite) {
        this.m_ctx = sprite;
    };
    b2DebugDraw.prototype.GetSprite = function () {
        return this.m_ctx;
    };
    b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
        if (drawScale === undefined) drawScale = 0;
        this.m_drawScale = drawScale;
    };
    b2DebugDraw.prototype.GetDrawScale = function () {
        return this.m_drawScale;
    };
    b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
        if (lineThickness === undefined) lineThickness = 0;
        this.m_lineThickness = lineThickness;
        this.m_ctx.strokeWidth = lineThickness;
    };
    b2DebugDraw.prototype.GetLineThickness = function () {
        return this.m_lineThickness;
    };
    b2DebugDraw.prototype.SetAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_alpha = alpha;
    };
    b2DebugDraw.prototype.GetAlpha = function () {
        return this.m_alpha;
    };
    b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
        if (alpha === undefined) alpha = 0;
        this.m_fillAlpha = alpha;
    };
    b2DebugDraw.prototype.GetFillAlpha = function () {
        return this.m_fillAlpha;
    };
    b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
        if (xformScale === undefined) xformScale = 0;
        this.m_xformScale = xformScale;
    };
    b2DebugDraw.prototype.GetXFormScale = function () {
        return this.m_xformScale;
    };
    b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
        if (!vertexCount) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        for (var i = 1; i < vertexCount; i++) {
            s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
        }
        s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
        if (!radius) return;
        var s = this.m_ctx;
        var drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
        if (!radius) return;
        var s = this.m_ctx,
            drawScale = this.m_drawScale,
            cx = center.x * drawScale,
            cy = center.y * drawScale;
        s.moveTo(0, 0);
        s.beginPath();
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.fillStyle = this._color(color.color, this.m_fillAlpha);
        s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
        s.moveTo(cx, cy);
        s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
        s.closePath();
        s.fill();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.strokeStyle = this._color(color.color, this.m_alpha);
        s.beginPath();
        s.moveTo(p1.x * drawScale, p1.y * drawScale);
        s.lineTo(p2.x * drawScale, p2.y * drawScale);
        s.closePath();
        s.stroke();
    };
    b2DebugDraw.prototype.DrawTransform = function (xf) {
        var s = this.m_ctx,
            drawScale = this.m_drawScale;
        s.beginPath();
        s.strokeStyle = this._color(0xff0000, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

        s.strokeStyle = this._color(0xff00, this.m_alpha);
        s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
        s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
        s.closePath();
        s.stroke();
    };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;

if (typeof require !== 'undefined' && typeof module !== 'undefined') {
    module.exports = Box2D;
}
    
window.b2Color = Box2D.Common.b2Color,
window.b2internal = Box2D.Common.b2internal,
window.b2Settings = Box2D.Common.b2Settings,
window.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
window.b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
window.b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
window.b2MassData = Box2D.Collision.Shapes.b2MassData,
window.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
window.b2Shape = Box2D.Collision.Shapes.b2Shape,
window.b2Mat22 = Box2D.Common.Math.b2Mat22,
window.b2Mat33 = Box2D.Common.Math.b2Mat33,
window.b2Math = Box2D.Common.Math.b2Math,
window.b2Sweep = Box2D.Common.Math.b2Sweep,
window.b2Transform = Box2D.Common.Math.b2Transform,
window.b2Vec2 = Box2D.Common.Math.b2Vec2,
window.b2Vec3 = Box2D.Common.Math.b2Vec3,
window.b2Body = Box2D.Dynamics.b2Body,
window.b2BodyDef = Box2D.Dynamics.b2BodyDef,
window.b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
window.b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
window.b2ContactListener = Box2D.Dynamics.b2ContactListener,
window.b2ContactManager = Box2D.Dynamics.b2ContactManager,
window.b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
window.b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
window.b2FilterData = Box2D.Dynamics.b2FilterData,
window.b2Fixture = Box2D.Dynamics.b2Fixture,
window.b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
window.b2Island = Box2D.Dynamics.b2Island,
window.b2TimeStep = Box2D.Dynamics.b2TimeStep,
window.b2World = Box2D.Dynamics.b2World,
window.b2AABB = Box2D.Collision.b2AABB,
window.b2Bound = Box2D.Collision.b2Bound,
window.b2BoundValues = Box2D.Collision.b2BoundValues,
window.b2Collision = Box2D.Collision.b2Collision,
window.b2ContactID = Box2D.Collision.b2ContactID,
window.b2ContactPoint = Box2D.Collision.b2ContactPoint,
window.b2Distance = Box2D.Collision.b2Distance,
window.b2DistanceInput = Box2D.Collision.b2DistanceInput,
window.b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
window.b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
window.b2DynamicTree = Box2D.Collision.b2DynamicTree,
window.b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
window.b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
window.b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
window.b2Manifold = Box2D.Collision.b2Manifold,
window.b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
window.b2Point = Box2D.Collision.b2Point,
window.b2RayCastInput = Box2D.Collision.b2RayCastInput,
window.b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
window.b2Segment = Box2D.Collision.b2Segment,
window.b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
window.b2Simplex = Box2D.Collision.b2Simplex,
window.b2SimplexCache = Box2D.Collision.b2SimplexCache,
window.b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
window.b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
window.b2TOIInput = Box2D.Collision.b2TOIInput,
window.b2WorldManifold = Box2D.Collision.b2WorldManifold,
window.b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
window.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
window.b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
window.b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
window.b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
window.b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
window.b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
window.b2Joint = Box2D.Dynamics.Joints.b2Joint,
window.b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
window.b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
window.b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
window.b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
window.b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
window.b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
window.b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
window.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
window.b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
window.b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
window.b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
window.b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
window.b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
window.b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

function RubeCantk(scene) {
    this.cantkScene = scene;
    this.PTM = scene.pixelsPerMeter;
    this.world = scene.world;
    this.lastMousePosPixel = { x: 0, y: 0 };
    this.mousePosWorld = { x: 0, y: 0 };
    this.mouseDownQueryCallback = null;
    this.mouseJointGroundBody = null;
    this.mouseJoint = null;
    this.debugDraw = null;
}

var hasOwnProperty = function(obj, property) {
	return typeof (obj[property]) !== 'undefined'
};

RubeCantk.prototype.getWorldPointFromPixelPoint = function(pixelPoint) {
    return {                
        x: (pixelPoint.x)/this.PTM,
        y: (pixelPoint.y)/this.PTM
    };
}

RubeCantk.prototype.getPixelPointFromWorldPoint = function(worldPoint) {
    return {                
        x: (this.worldPoint.x * this.PTM),
        y: (this.worldPoint.y * this.PTM)
    };
}

RubeCantk.prototype.updateMousePos = function(event) {
    this.mousePosWorld = this.getWorldPointFromPixelPoint(event.point);        
}

RubeCantk.MouseDownQueryCallback = function() {
    this.m_fixture = null;
    this.m_point = new b2Vec2();
}

RubeCantk.MouseDownQueryCallback.prototype.ReportFixture = function(fixture) {
    if(fixture.GetBody().GetType() == 2) { //dynamic bodies only
        if ( fixture.TestPoint(this.m_point) ) {
            this.m_fixture = fixture;
            return false;
        }
    }
    return true;
};

RubeCantk.prototype.tryStartMouseJoint = function() {
    if ( this.mouseJoint != null )
        return;
   
    // Make a small box.
    var aabb = new b2AABB();
    var d = 0.001;
    aabb.lowerBound.Set(this.mousePosWorld.x - d, this.mousePosWorld.y - d);
    aabb.upperBound.Set(this.mousePosWorld.x + d, this.mousePosWorld.y + d);
    
    // Query the this.world for overlapping shapes.            
    this.mouseDownQueryCallback.m_fixture = null;
    this.mouseDownQueryCallback.m_point.Set(this.mousePosWorld.x, this.mousePosWorld.y);
    this.world.QueryAABB(function(fixture){
    	if (fixture.GetBody().GetType() != b2Body.b2_staticBody) {
			if (fixture.GetShape().TestPoint(
					fixture.GetBody().GetTransform(), this.mousePosWorld)) {
				 this.mouseDownQueryCallback.m_fixture = fixture;
				 selectedBody = fixture.GetBody();
				return false;
			}
		}
    	selectedBody = undefined;
		return true;
    }.bind(this), aabb);

    if (this.mouseDownQueryCallback.m_fixture)
    {
        var body = this.mouseDownQueryCallback.m_fixture.GetBody();
        var md = new b2MouseJointDef();
        md.bodyA = this.mouseJointGroundBody;
        md.bodyB = body;
        md.target.Set(this.mousePosWorld.x, this.mousePosWorld.y);
        md.maxForce = 300 * body.GetMass();
        md.collideConnected = true;
        
        this.mouseJoint = this.world.CreateJoint(md);
        body.SetAwake(false);
    }
}

RubeCantk.prototype.setAssetsLoader = function(assetsLoader) {
    this.assetsLoader = assetsLoader;
}

RubeCantk.prototype.onImageAssetLoaded = function(image, data, index) {
    var element = ShapeFactoryGet().createShape("ui-image", "from RUBE");
    element.setAnchor(0.5, 0.5);
    element.isUIRubeImage = true;
    element.name = image.name || "ui-image";
    image.element = element;
    element.setZIndex(index);

    element.setImageSrc(data.src);
    element.w = data.width;
    element.h = data.height;
    image.pixelHeight = element.h;
    element.images.display = UIElement.IMAGE_DISPLAY_SCALE;
    this.cantkScene.addChild(element);
    
    if(this.createdCallback) {
        this.createdCallback(element);
    } 
}

RubeCantk.prototype.createRube = function(worldJso, options) {    
    //set debug draw
    if(!worldJso) {
        return;
    }
    options = options || {};
    this.createdCallback = options.createdCallback;
 
    var scene = this.cantkScene;
    function overridePhysicsValue(key) {
        if(worldJso[key] !== undefined) {
            scene[key] = worldJso[key];
        }
    }
    var keys = [
        "allowSleep",
        "autoClearForce",
        "positionIterations",
        "velocityIterations",
        "warmStarting",
        "subStepping",
        "stepsPerSecond",
    ];
    var length = keys.length;
    for(var i = 0; i < length; i++) {
        //overridePhysicsValue(keys[i]);
    }

    if(!scene.world) {
        scene.setEnablePhysics(true);
        scene.startPhysics(); 
    }

    this.world = scene.world;
    if(!this.world) {
        console.error("Start physics failed, igrone RUBE json");

        return;
    }
    this.loadSceneFromRUBE(worldJso, this.world, scene);

    this.interactive = options.interactive || true; 

    if(this.world.images) {
        for (var i = 0; i < this.world.images.length; i++) {
            (function(i) {
                var index = i;
                var image = this.world.images[i];
                var src = this.world.images[i].file;
                this.assetsLoader.loadImage(basename(src), function(data) {
                    this.onImageAssetLoaded(image, data, index);
                }.bind(this));
            }.bind(this))(i)
        }
    }
        
    this.mouseJointGroundBody = this.world.CreateBody( new b2BodyDef() );
    this.mouseDownQueryCallback = new RubeCantk.MouseDownQueryCallback();
 
    if(this.interactive) { 
        scene.addEventListener("pointerdown", this.onPointerDown.bind(this));
        scene.addEventListener("pointermove", this.onPointerMove.bind(this));
        scene.addEventListener("pointerup", this.onPointerUp.bind(this));
    }
    var debug = options.debug || true;
    if(debug) {
        var debugDraw = new b2DebugDraw;
        debugDraw.SetSprite(UIElement.getMainCanvas().getContext("2d"));
        debugDraw.SetDrawScale(Physics.pixelsPerMeter);
        debugDraw.SetFillAlpha(0.3);
        debugDraw.SetLineThickness(1.0);
        debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
        this.debugDraw = debugDraw;
        this.world.SetDebugDraw(debugDraw);
    }
    scene.addEventListener("updatetransform", this.onUpdateTransform.bind(this));
}

RubeCantk.prototype.onPointerDown = function(event) {
    if(!event || event.beforeChild) {
        return;
    }
    this.updateMousePos(event);
    
    this.tryStartMouseJoint();
   
    this.lastMousePosPixel = {x:event.point.x, y:event.point.y};
}

RubeCantk.prototype.onPointerMove = function(event) {
    if(!event || event.beforeChild) {
        return;
    }

    this.updateMousePos(event);
    if (this.cantkScene.pointerDown) {
        if ( this.mouseJoint != null ) {
            // move mouse joint
            this.mouseJoint.SetTarget( this.mousePosWorld );
        }
    }
    
    this.lastMousePosPixel = {x:event.point.x, y:event.point.y};
}

RubeCantk.prototype.onPointerUp = function(event) {
    if(!event || event.beforeChild) {
        return;
    }

    if ( this.mouseJoint ) {
        this.world.DestroyJoint(this.mouseJoint);
        this.mouseJoint = null;
    }
}

RubeCantk.prototype.positionImages = function() {
    var images = this.world.images;
    if ( this.world.images ) {
        var length = images.length; 
        var PTM = this.PTM;
        for (var i = 0; i < length; i++) {
            var image = images[i];
            element = image.element;
            if(!element) {
                continue;
            }
            
            element.setRotation(image.angle);
            var imageScale = PTM / image.pixelHeight * image.scale;
            element.setScale(image.aspectScale * imageScale, imageScale);
            if(image.flip ) {
                element.scale.x *= -1;
            }

            if(image.body ) {
                var ic = new b2Vec2(image.center.x, -image.center.y);
                var imageWorldCenter = image.body.GetWorldPoint(ic);
                element.setPosition(imageWorldCenter.x, imageWorldCenter.y);
                element.setRotation(image.body.GetAngle() + image.angle);
                if(image.body.element) {
                    image.body.element.setVisible(false);
                }
            }
            else {
                // no body
                element.setPosition(this.pCenter.x + image.center.x, this.pCenter.y);
            }
            element.x *= PTM;
            element.y *= PTM;
        }
    }
}

RubeCantk.prototype.onUpdateTransform = function() {
    this.positionImages();
}

// remove the body and all related images/sprites
RubeCantk.prototype.removeBodyFromScene = function(body) {
    var imagesToRemove = [];
    for (i = 0; i < this.world.images.length; i++) {
        if ( this.world.images[i].body == body )
            imagesToRemove.push(this.world.images[i]);
    }
    for (var i = 0; i < imagesToRemove.length; i++) {
        imagesToRemove[i].element.remove(true);
        removeFromArray(this.world.images, imagesToRemove[i]);
    }
    if(body.element){
        body.element.remove(true);
    }
    this.world.DestroyBody( body );
}

// remove an image/sprite from the scene
RubeCantk.prototype.removeImageFromScene = function(image) {
    image.element.remove(true);
    removeFromArray(this.world.images, image);
}

RubeCantk.prototype.getVerticesArray = function(vertices) {
    var complex = false;
    if(ClockWise(vertices) === CLOCKWISE) {
        console.warn("clock wise polygon");
        vertices.reverse();
    }
    if(Convex(vertices) === CONCAVE) {
        complex = true;
    }
    
    var array = complex ? process(vertices) : vertices;
    return {complex: complex, vertices: array};
}

RubeCantk.prototype.loadFixtureFromRUBE = function(body, fixtureJso) {
	// console.log(fixtureJso);
	var fd = new b2FixtureDef();
	if (hasOwnProperty(fixtureJso, 'friction'))
		fd.friction = fixtureJso.friction;
	if (hasOwnProperty(fixtureJso, 'density'))
		fd.density = fixtureJso.density;
	if (hasOwnProperty(fixtureJso, 'restitution'))
		fd.restitution = fixtureJso.restitution;
	if (hasOwnProperty(fixtureJso, 'sensor'))
		fd.isSensor = fixtureJso.sensor;
	if (hasOwnProperty(fixtureJso, 'filter-categoryBits'))
		fd.filter.categoryBits = fixtureJso['filter-categoryBits'];
	if (hasOwnProperty(fixtureJso, 'filter-maskBits'))
		fd.filter.maskBits = fixtureJso['filter-maskBits'];
	if (hasOwnProperty(fixtureJso, 'filter-groupIndex'))
		fd.filter.groupIndex = fixtureJso['filter-groupIndex'];
	if (hasOwnProperty(fixtureJso, 'circle')) {
		fd.shape = new b2CircleShape();
		fd.shape.m_radius = fixtureJso.circle.radius;
		if (fixtureJso.circle.center)
			fd.shape.m_p.SetV(fixtureJso.circle.center);
        fd.shape.m_p.y *= -1;
		var fixture = body.CreateFixture(fd);
		if (fixtureJso.name)
			fixture.name = fixtureJso.name;
	} else if (hasOwnProperty(fixtureJso, 'polygon')) {
		fd.shape = new b2PolygonShape();
		var verts = [];
		for (v = 0; v < fixtureJso.polygon.vertices.x.length; v++)
			verts.push(new b2Vec2(fixtureJso.polygon.vertices.x[v],
					-fixtureJso.polygon.vertices.y[v]));
        var result = this.getVerticesArray(verts);
        if(result.complex) {
            console.error("input vertices has convex polygon?");
        } else {
            verts = result.vertices;
        }
        
		fd.shape.SetAsArray(verts, verts.length);
		var fixture = body.CreateFixture(fd);
		if (fixture && fixtureJso.name)
			fixture.name = fixtureJso.name;
	} else if (hasOwnProperty(fixtureJso, 'chain')) {
		fd.shape = new b2PolygonShape();
		var lastVertex = new b2Vec2();
		for (v = 0; v < fixtureJso.chain.vertices.x.length; v++) {
			var thisVertex = new b2Vec2(fixtureJso.chain.vertices.x[v],
					fixtureJso.chain.vertices.y[v]);
			if (v > 0) {
				fd.shape.SetAsEdge(lastVertex, thisVertex);
				var fixture = body.CreateFixture(fd);
				if (fixtureJso.name)
					fixture.name = fixtureJso.name;
			}
			lastVertex = thisVertex;
		}
	} else {
		console.log("Could not find shape type for fixture");
	}

	if (fixture) {
		if (hasOwnProperty(fixtureJso, 'customProperties'))
			fixture.customProperties = fixtureJso.customProperties;
	}
}

RubeCantk.prototype.loadBodyFromRUBE = function(bodyJso, world, cantkScene) {
    if ( ! bodyJso.hasOwnProperty('type') ) {
        console.log("Body does not have a 'type' property");
        return null;
    }    

    var bd = new b2BodyDef();
    if ( bodyJso.type == 2 )
        bd.type = b2Body.b2_dynamicBody;
    else if ( bodyJso.type == 1 )
        bd.type = b2Body.b2_kinematicBody;
    else
        bd.type = b2Body.b2_staticBody;

    var angle = (bodyJso.angle || 0);
    if (hasOwnProperty(bodyJso, 'angularVelocity')) {
        bd.angularVelocity = bodyJso.angularVelocity; 
        bd.angularVelocity.y *= -1;
    }

    if (hasOwnProperty(bodyJso, 'angularDamping')) {
        bd.angularDamping = bodyJso.angularDamping;
    }
    
    bd.awake = (bodyJso.awake || false);
    bd.bullet = (bodyJso.bullet || false);
    bd.fixedRotation = (bodyJso.fixedRotation || false);
    if (hasOwnProperty(bodyJso, 'linearDamping')) {
        bd.linearDamping = bodyJso.linearDamping;
    }

    if ( bodyJso.hasOwnProperty('linearVelocity') && bodyJso.linearVelocity instanceof Object ) {
        bd.linearVelocity = (parseVec( bodyJso.linearVelocity ));
        bd.linearVelocity.y *= -1;
    }
    else {
        bd.linearVelocity = (new b2Vec2(0,0));
    }

    var pCenter = {x: Physics.toMeter(cantkScene.w >> 1), y:Physics.toMeter(cantkScene.h >> 1)};
    this.pCenter = pCenter;
    var position;
    if ( bodyJso.hasOwnProperty('position') && bodyJso.position instanceof Object ) {
        var p = parseVec(bodyJso.position );
        position = (new b2Vec2(pCenter.x + p.x, pCenter.y - p.y));
    } else
        position = (new b2Vec2(pCenter.x, pCenter.y));

    if (bodyJso.hasOwnProperty('gravityScale') && !isNaN(parseFloat(bodyJso.gravityScale)) && isFinite(bodyJso.gravityScale)) {
        bd.gravityScale = bodyJso.gravityScale;
    } else {
        bd.gravityScale = 1;
    }

    var body = world.CreateBody(bd);
    body.gravityScale = bd.gravityScale;
    var md = new b2MassData();
    md.mass = (bodyJso['massData-mass'] || 0);
    if ( bodyJso.hasOwnProperty('massData-center') && bodyJso['massData-center'] instanceof Object )
        md.center = (parseVec(bodyJso['massData-center']));
    else
        md.center = (new b2Vec2(0,0));

    md.I = (bodyJso['massData-I'] || 0);

    body.SetMassData(md);
    
    if ( bodyJso.hasOwnProperty('fixture') ) {
        for (var k = 0; k < bodyJso['fixture'].length; k++) {
            var fixtureJso = bodyJso['fixture'][k];
            this.loadFixtureFromRUBE(body, fixtureJso);
        }
    }
    body.SetPositionAndAngle(position, -angle);
    body.SetAngle(-angle);
    if ( bodyJso.hasOwnProperty('name') )
        body.name = bodyJso.name;
    if ( bodyJso.hasOwnProperty('customProperties') )
        body.customProperties = bodyJso.customProperties;
    return body;
}

function getVectorValue(val) {
    if ( val instanceof Object )
        return val;
    else
        return { x:0, y:0 };
}

function parseVec(obj) {
    if (obj instanceof Object)
      return new b2Vec2(obj.x || 0, obj.y || 0);
    else
      return new b2Vec2(0,0);
}

function makeClone(obj) {
  var newObj = (obj instanceof Array) ? [] : {};
  for (var i in obj) {
    if (obj[i] && typeof obj[i] == "object") 
      newObj[i] = makeClone(obj[i]);
    else
        newObj[i] = obj[i];
  }
  return newObj;
};

RubeCantk.prototype.loadJointCommonProperties = function(jd, jointJso, loadedBodies) {
	jd.bodyA = loadedBodies[jointJso.bodyA];
	jd.bodyB = loadedBodies[jointJso.bodyB];
	jd.localAnchorA.SetV(getVectorValue(jointJso.anchorA));
	jd.localAnchorA.y *= -1;
    jd.localAnchorB.SetV(getVectorValue(jointJso.anchorB));
	jd.localAnchorB.y *= -1;
	if (jointJso.collideConnected)
		jd.collideConnected = jointJso.collideConnected;
}

RubeCantk.prototype.loadJointFromRUBE = function(jointJso, world, loadedBodies) {
	if (!hasOwnProperty(jointJso, 'type')) {
		console.log("Joint does not have a 'type' property");
		return null;
	}
	if (jointJso.bodyA >= loadedBodies.length) {
		console.log("Index for bodyA is invalid: " + jointJso.bodyA);
		return null;
	}
	if (jointJso.bodyB >= loadedBodies.length) {
		console.log("Index for bodyB is invalid: " + jointJso.bodyB);
		return null;
	}

	var joint = null;
	if (jointJso.type == "revolute") {
		var jd = new b2RevoluteJointDef();
		this.loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'refAngle'))
			jd.referenceAngle = jointJso.refAngle;
		if (hasOwnProperty(jointJso, 'lowerLimit'))
			jd.lowerAngle = jointJso.lowerLimit;
		if (hasOwnProperty(jointJso, 'upperLimit'))
			jd.upperAngle = jointJso.upperLimit;
		if (hasOwnProperty(jointJso, 'maxMotorTorque'))
			jd.maxMotorTorque = jointJso.maxMotorTorque;
		if (hasOwnProperty(jointJso, 'motorSpeed'))
			jd.motorSpeed = -1 * jointJso.motorSpeed;
		if (hasOwnProperty(jointJso, 'enableLimit'))
			jd.enableLimit = jointJso.enableLimit;
		if (hasOwnProperty(jointJso, 'enableMotor'))
			jd.enableMotor = jointJso.enableMotor;
		joint = world.CreateJoint(jd);
	} else if (jointJso.type == "distance" || jointJso.type == "rope") {
		if (jointJso.type == "rope")
			console.log("Replacing unsupported rope joint with distance joint!");
		var jd = new b2DistanceJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'length'))
			jd.length = jointJso.length;
		if (hasOwnProperty(jointJso, 'dampingRatio'))
			jd.dampingRatio = jointJso.dampingRatio;
		if (hasOwnProperty(jointJso, 'frequency'))
			jd.frequencyHz = jointJso.frequency;
		joint = world.CreateJoint(jd);
	} else if (jointJso.type == "prismatic") {
		var jd = new b2PrismaticJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'localAxisA'))
			jd.localAxisA.SetV(getVectorValue(jointJso.localAxisA));
		if (hasOwnProperty(jointJso, 'refAngle'))
			jd.referenceAngle = jointJso.refAngle;
		if (hasOwnProperty(jointJso, 'enableLimit'))
			jd.enableLimit = jointJso.enableLimit;
		if (hasOwnProperty(jointJso, 'lowerLimit'))
			jd.lowerTranslation = jointJso.lowerLimit;
		if (hasOwnProperty(jointJso, 'upperLimit'))
			jd.upperTranslation = jointJso.upperLimit;
		if (hasOwnProperty(jointJso, 'enableMotor'))
			jd.enableMotor = jointJso.enableMotor;
		if (hasOwnProperty(jointJso, 'maxMotorForce'))
			jd.maxMotorForce = jointJso.maxMotorForce;
		if (hasOwnProperty(jointJso, 'motorSpeed'))
			jd.motorSpeed = jointJso.motorSpeed;
		joint = world.CreateJoint(jd);
	} else if (jointJso.type == "wheel") {
		// Make a fake wheel joint using a line joint and a distance joint.
		// Return the line joint because it has the linear motor controls.
		// Use ApplyTorque on the bodies to spin the wheel...

		var jd = new b2DistanceJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		jd.length = 0.0;
		if (hasOwnProperty(jointJso, 'springDampingRatio'))
			jd.dampingRatio = jointJso.springDampingRatio;
		if (hasOwnProperty(jointJso, 'springFrequency'))
			jd.frequencyHz = jointJso.springFrequency;
		world.CreateJoint(jd);

		jd = new b2LineJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'localAxisA'))
			jd.localAxisA.SetV(getVectorValue(jointJso.localAxisA));

		joint = world.CreateJoint(jd);
	} else if (jointJso.type == "friction") {
		var jd = new b2FrictionJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'maxForce'))
			jd.maxForce = jointJso.maxForce;
		if (hasOwnProperty(jointJso, 'maxTorque'))
			jd.maxTorque = jointJso.maxTorque;
		joint = world.CreateJoint(jd);
	} else if (jointJso.type == "weld") {
		var jd = new b2WeldJointDef();
		loadJointCommonProperties(jd, jointJso, loadedBodies);
		if (hasOwnProperty(jointJso, 'referenceAngle'))
			jd.referenceAngle = jointJso.referenceAngle;
		joint = world.CreateJoint(jd);
	} else {
		console.log("Unsupported joint type: " + jointJso.type);
		console.log(jointJso);
	}
	if (joint) {
		if (jointJso.name)
			joint.name = jointJso.name;
		if (hasOwnProperty(jointJso, 'customProperties'))
			joint.customProperties = jointJso.customProperties;
	}
	return joint;

}

RubeCantk.prototype.loadImageFromRUBE = function(imageJso, world, loadedBodies) {
	var image = makeClone(imageJso);

	if (image.hasOwnProperty('body') && image.body >= 0)
		image.body = loadedBodies[image.body];// change index to the actual
												// body
	else
		image.body = null;

	if (!image.hasOwnProperty('aspectScale'))
		image.aspectScale = 1;
	if (!image.hasOwnProperty('angle'))
		image.angle = 0;
	if (!image.hasOwnProperty('colorTint'))
		image.colorTint = [ 255, 255, 255, 255 ];

	image.center = new b2Vec2();
	image.center.SetV(getVectorValue(imageJso.center));

	return image;
}

//load the scene into an already existing world variable
RubeCantk.prototype.loadSceneFromRUBE = function(worldJso, world, cantkScene) {
    var success = true;
    
    var loadedBodies = [];
    if ( hasOwnProperty(worldJso, 'body') ) {
        for (var i = 0; i < worldJso.body.length; i++) {
            var bodyJso = worldJso.body[i];
            var body = this.loadBodyFromRUBE(bodyJso, world, cantkScene);
            if ( body ) {
                loadedBodies.push( body );
                if(cantkScene) {
                    var rubeBody = cantkScene.onCreateRUBEBody(body);
                    if(this.createdCallback) {
                        this.createdCallback(rubeBody);
                    }
                }
            }
            else
                success = false;
        }
    }
    
    var loadedJoints = [];
    if ( hasOwnProperty(worldJso, 'joint') ) {
        for (var i = 0; i < worldJso.joint.length; i++) {
            var jointJso = worldJso.joint[i];
            var joint = this.loadJointFromRUBE(jointJso, world, loadedBodies);
            if ( joint ) {
                loadedJoints.push( joint );
                if(cantkScene) {
                    cantkScene.onRUBEJointCreated(joint);
                }
            }
            //else
            //    success = false;
        }
    }
    
	var loadedImages = [];
	if (hasOwnProperty(worldJso, 'image')) {
		for (var i = 0; i < worldJso.image.length; i++) {
			var imageJso = worldJso.image[i];
			var image = this.loadImageFromRUBE(imageJso, world, loadedBodies);
			if (image)
				loadedImages.push(image);
			else
				success = false;
		}
		world.images = loadedImages;
	}

    return success;
}

function getNamedBody(world, name) {
	for (b = world.m_bodyList; b; b = b.m_next) {
		if (b.name == name)
			return b;
	}
	return null;
}

function getNamedBodies(world, name) {
    var bodies = [];
    for (b = world.m_bodyList; b; b = b.m_next) {
        if ( b.name == name )
            bodies.push(b);
    }
    return bodies;
}

function getNamedFixtures(world, name) {
    var fixtures = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
        for (var f = b.m_fixtureList; f; f = f.m_next) {
            if ( f.name == name )
                fixtures.push(f);
        }
    }
    return fixtures;
}

function getNamedJoints(world, name) {
    var joints = [];
    for (var j = world.m_jointList; j; j = j.m_next) {
        if ( j.name == name )
            joints.push(j);
    }
    return joints;
}

function getNamedImages(world, name) {
	var images = [];
	for (i = 0; i < world.images.length; i++) {
		if (world.images[i].name == name)
			images.push(world.images[i]);
	}
	return images;
}


//custom properties
function getBodiesByCustomProperty(world, propertyType, propertyName, valueToMatch) {
    var bodies = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
        if ( ! b.hasOwnProperty('customProperties') )
            continue;
        for (var i = 0; i < b.customProperties.length; i++) {
            if ( ! b.customProperties[i].hasOwnProperty("name") )
                continue;
            if ( ! b.customProperties[i].hasOwnProperty(propertyType) )
                continue;
            if ( b.customProperties[i].name == propertyName &&
                 b.customProperties[i][propertyType] == valueToMatch)
                bodies.push(b);
        }        
    }
    return bodies;
}

function hasCustomProperty(item, propertyType, propertyName) {
    if ( !item.hasOwnProperty('customProperties') )
        return false;
    for (var i = 0; i < item.customProperties.length; i++) {
        if ( ! item.customProperties[i].hasOwnProperty("name") )
            continue;
        if ( ! item.customProperties[i].hasOwnProperty(propertyType) )
            continue;
        return true;
    }
    return false;
}

function getCustomProperty(item, propertyType, propertyName, defaultValue) {
    if ( !item.hasOwnProperty('customProperties') )
        return defaultValue;
    for (var i = 0; i < item.customProperties.length; i++) {
        if ( ! item.customProperties[i].hasOwnProperty("name") )
            continue;
        if ( ! item.customProperties[i].hasOwnProperty(propertyType) )
            continue;
        if ( item.customProperties[i].name == propertyName )
            return item.customProperties[i][propertyType];
    }
    return defaultValue;
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @class egret.Matrix
 * @classdesc
 * Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。
 * 您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
 * @extends egret.HashObject
 * @includeExample egret/geom/Matrix.ts
 */
var Matrix = (function () {
    /**
     * 创建一个 egret.Matrix 对象
     * @method egret.Matrix#constructor
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值。
     * @param b {number} 旋转或倾斜图像时影响像素沿 y 轴定位的值。
     * @param c {number} 旋转或倾斜图像时影响像素沿 x 轴定位的值。
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值。
     * @param tx {number} 沿 x 轴平移每个点的距离。
     * @param ty {number} 沿 y 轴平移每个点的距离。
     */
    function Matrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    var __egretProto__ = Matrix.prototype;
    /**
     * 前置矩阵
     * @method egret.Matrix#prepend
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param b {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param c {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param tx {number} 沿 x 轴平移每个点的距离
     * @param ty {number} 沿 y 轴平移每个点的距离
     * @returns {egret.Matrix}
     */
    __egretProto__.prepend = function (a, b, c, d, tx, ty) {
        var tx1 = this.tx;
        if (a != 1 || b != 0 || c != 0 || d != 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = a1 * a + this.b * c;
            this.b = a1 * b + this.b * d;
            this.c = c1 * a + this.d * c;
            this.d = c1 * b + this.d * d;
        }
        this.tx = tx1 * a + this.ty * c + tx;
        this.ty = tx1 * b + this.ty * d + ty;
        return this;
    };
    /**
     * 后置矩阵
     * @method egret.Matrix#append
     * @param a {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param b {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param c {number} 缩放或旋转图像时影响像素沿 x 轴定位的值
     * @param d {number} 缩放或旋转图像时影响像素沿 y 轴定位的值
     * @param tx {number} 沿 x 轴平移每个点的距离
     * @param ty {number} 沿 y 轴平移每个点的距离
     * @returns {egret.Matrix}
     */
    __egretProto__.append = function (a, b, c, d, tx, ty) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        if (a != 1 || b != 0 || c != 0 || d != 1) {
            this.a = a * a1 + b * c1;
            this.b = a * b1 + b * d1;
            this.c = c * a1 + d * c1;
            this.d = c * b1 + d * d1;
        }
        this.tx = tx * a1 + ty * c1 + this.tx;
        this.ty = tx * b1 + ty * d1 + this.ty;
        return this;
    };
    /**
     * 前置矩阵
     * @method egret.Matrix#prependTransform
     * @param x {number} x值
     * @param y {number} y值
     * @param scaleX {number} 水平缩放
     * @param scaleY {number} 垂直缩放
     * @param rotation {number} 旋转
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @param regX {number} x值偏移
     * @param regY {number} y值偏移
     * @returns {egret.Matrix}
     */
    __egretProto__.prependTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        if (rotation % 360) {
            var r = rotation; // * Matrix.DEG_TO_RAD;
            var cos = egret.NumberUtils.cos(r);
            var sin = egret.NumberUtils.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (regX || regY) {
            // append the registration offset:
            this.tx -= regX;
            this.ty -= regY;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single prepend operation?
            //                skewX *= Matrix.DEG_TO_RAD;
            //                skewY *= Matrix.DEG_TO_RAD;
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
            this.prepend(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), x, y);
        }
        else {
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        return this;
    };
    /**
     * 后置矩阵
     * @method egret.Matrix#appendTransform
     * @param x {number} x值
     * @param y {number} y值
     * @param scaleX {number} 水平缩放
     * @param scaleY {number} 垂直缩放
     * @param rotation {number} 旋转
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @param regX {number} x值偏移
     * @param regY {number} y值偏移
     * @returns {egret.Matrix}
     */
    __egretProto__.appendTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        if (rotation % 360) {
            var r = rotation; // * Matrix.DEG_TO_RAD;
            var cos = egret.NumberUtils.cos(r);
            var sin = egret.NumberUtils.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single append?
            //                skewX *= Matrix.DEG_TO_RAD;
            //                skewY *= Matrix.DEG_TO_RAD;
            this.append(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), x, y);
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
        }
        else {
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        if (regX || regY) {
            // prepend the registration offset:
            this.tx -= regX * this.a + regY * this.c;
            this.ty -= regX * this.b + regY * this.d;
        }
        return this;
    };
    /**
     * 对 Matrix 对象应用旋转转换。
     * 矩阵旋转，以角度制为单位
     * @method egret.Matrix#rotate
     * @param angle {number} 角度
     * @returns {egret.Matrix}
     */
    __egretProto__.rotate = function (angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
    };
    /**
     * 矩阵斜切，以角度值为单位
     * @method egret.Matrix#skew
     * @param skewX {number} x方向斜切
     * @param skewY {number} y方向斜切
     * @returns {egret.Matrix}
     */
    __egretProto__.skew = function (skewX, skewY) {
        //            skewX = skewX * Matrix.DEG_TO_RAD;
        //            skewY = skewY * Matrix.DEG_TO_RAD;
        this.append(egret.NumberUtils.cos(skewY), egret.NumberUtils.sin(skewY), -egret.NumberUtils.sin(skewX), egret.NumberUtils.cos(skewX), 0, 0);
        return this;
    };
    /**
     * 矩阵缩放
     * @method egret.Matrix#scale
     * @param x {number} 水平缩放
     * @param y {number} 垂直缩放
     * @returns {egret.Matrix}
     */
    __egretProto__.scale = function (x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    };
    /**
     * 沿 x 和 y 轴平移矩阵，由 x 和 y 参数指定。
     * @method egret.Matrix#translate
     * @param x {number} 沿 x 轴向右移动的量（以像素为单位）。
     * @param y {number} 沿 y 轴向下移动的量（以像素为单位）。
     * @returns {egret.Matrix}
     */
    __egretProto__.translate = function (x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    };
    /**
     * 为每个矩阵属性设置一个值，该值将导致 null 转换。
     * 通过应用恒等矩阵转换的对象将与原始对象完全相同。
     * 调用 identity() 方法后，生成的矩阵具有以下属性：a=1、b=0、c=0、d=1、tx=0 和 ty=0。
     * @method egret.Matrix#identity
     * @returns {egret.Matrix}
     */
    __egretProto__.identity = function () {
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
    };
    /**
     * 矩阵重置为目标矩阵
     * @method egret.Matrix#identityMatrix
     * @param matrix {egret.Matrix} 重置的目标矩阵
     * @returns {egret.Matrix}
     * @deprecated
     */
    __egretProto__.identityMatrix = function (matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    };
    /**
     * 执行原始矩阵的逆转换。
     * 您可以将一个逆矩阵应用于对象来撤消在应用原始矩阵时执行的转换。
     * @method egret.Matrix#invert
     * @returns {egret.Matrix}
     */
    __egretProto__.invert = function () {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
    };
    /**
     * 根据一个矩阵，返回某个点在该矩阵上的坐标
     * @method egret.Matrix.transformCoords
     * @param matrix {egret.Matrix}
     * @param x {number}
     * @param y {number}
     * @returns {numberPoint}
     * @stable C 该方法以后可能删除
     * @deprecated
     */
    Matrix.transformCoords = function (matrix, x, y) {
        var resultPoint = egret.Point.identity;
        resultPoint.x = matrix.a * x + matrix.c * y + matrix.tx;
        resultPoint.y = matrix.d * y + matrix.b * x + matrix.ty;
        //        resultPoint.x = matrix.a * x + matrix.c * y - matrix.tx;
        //        resultPoint.y = matrix.d * y + matrix.b * x - matrix.ty;
        return resultPoint;
    };
    /**
     * @private
     */
    __egretProto__.toArray = function (transpose) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        if (transpose) {
            this.array[0] = this.a;
            this.array[1] = this.b;
            this.array[2] = 0;
            this.array[3] = this.c;
            this.array[4] = this.d;
            this.array[5] = 0;
            this.array[6] = this.tx;
            this.array[7] = this.ty;
            this.array[8] = 1;
        }
        else {
            this.array[0] = this.a;
            this.array[1] = this.b;
            this.array[2] = this.tx;
            this.array[3] = this.c;
            this.array[4] = this.d;
            this.array[5] = this.ty;
            this.array[6] = 0;
            this.array[7] = 0;
            this.array[8] = 1;
        }
        return this.array;
    };
    /**
     * 将 Matrix 的成员设置为指定值
     * @method egret.Matrix#setTo
     * @param aa {number} 要将 Matrix 设置为的值
     * @param ba {number} 要将 Matrix 设置为的值
     * @param ca {number} 要将 Matrix 设置为的值
     * @param da {number} 要将 Matrix 设置为的值
     * @param txa {number} 要将 Matrix 设置为的值
     * @param tya {number} 要将 Matrix 设置为的值
     */
    __egretProto__.setTo = function (aa, ba, ca, da, txa, tya) {
        this.a = aa;
        this.b = ba;
        this.c = ca;
        this.d = da;
        this.tx = txa;
        this.ty = tya;
    };
    /**
     * 将源 Matrix 对象中的所有矩阵数据复制到调用方 Matrix 对象中。
     * @method egret.Matrix#copyFrom
     * @param sourceMatrix {egret.Matrix} 要从中复制数据的 Matrix 对象
     */
    __egretProto__.copyFrom = function (sourceMatrix) {
        this.identityMatrix(sourceMatrix);
    };
    /**
     * 返回一个新的 Matrix 对象，它是此矩阵的克隆，带有与所含对象完全相同的副本。
     * @method egret.Matrix#clone
     * @returns {Matrix} 一个 Matrix 对象
     */
    __egretProto__.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    };
    /**
     * 将某个矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
     * @method egret.Matrix#concat
     * @param m {egret.Matrix} 要连接到源矩阵的矩阵
     */
    __egretProto__.concat = function (m) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var ty1 = this.ty;
        var a2 = m.a;
        var b2 = m.b;
        var c2 = m.c;
        var d2 = m.d;
        var tx2 = m.tx;
        var ty2 = m.ty;
        var a = a1 * a2;
        var b = 0;
        var c = 0;
        var d = d1 * d2;
        var tx = tx1 * a2 + tx2;
        var ty = ty1 * d2 + ty2;
        if (b1 != 0 || c1 != 0 || b2 != 0 || c2 != 0) {
            a += b1 * c2;
            d += c1 * b2;
            b += a1 * b2 + b1 * d2;
            c += c1 * a2 + d1 * c2;
            tx += ty1 * c2;
            ty += tx1 * b2;
        }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * 如果给定预转换坐标空间中的点，则此方法返回发生转换后该点的坐标。
     * 与使用 transformPoint() 方法应用的标准转换不同，deltaTransformPoint() 方法的转换不考虑转换参数 tx 和 ty。
     * @method egret.Matrix#deltaTransformPoint
     * @param point {egret.Point} 想要获得其矩阵转换结果的点
     * @returns {egret.Point} 由应用矩阵转换所产生的点
     */
    __egretProto__.deltaTransformPoint = function (point) {
        var self = this;
        var x = self.a * point.x + self.c * point.y;
        var y = self.b * point.x + self.d * point.y;
        return new egret.Point(x, y);
    };
    /**
     * 返回将 Matrix 对象表示的几何转换应用于指定点所产生的结果。
     * @method egret.Matrix#transformPoint
     * @param point {egret.Point} 想要获得其矩阵转换结果的点
     * @returns {egret.Point} 由应用矩阵转换所产生的点
     */
    __egretProto__.transformPoint = function (point) {
        var self = this;
        var x = self.a * point.x + self.c * point.y + self.tx;
        var y = self.b * point.x + self.d * point.y + self.ty;
        return new egret.Point(x, y);
    };
    /**
     * 返回列出该 Matrix 对象属性的文本值。
     * @method egret.Matrix#toString
     * @returns {egret.Point} 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
     */
    __egretProto__.toString = function () {
        return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
    };
    /**
     * 包括用于缩放、旋转和转换的参数。当应用于矩阵时，该方法会基于这些参数设置矩阵的值。
     * @method egret.Matrix#createBox
     * @param scaleX {number} 水平缩放所用的系数
     * @param scaleY {number} 垂直缩放所用的系数
     * @param rotation {number} 旋转量（以弧度为单位）
     * @param tx {number} 沿 x 轴向右平移（移动）的像素数
     * @param ty {number} 沿 y 轴向下平移（移动）的像素数
     */
    __egretProto__.createBox = function (scaleX, scaleY, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        var self = this;
        if (rotation !== 0) {
            rotation = rotation / egret.Matrix.DEG_TO_RAD;
            var u = egret.NumberUtils.cos(rotation);
            var v = egret.NumberUtils.sin(rotation);
            self.a = u * scaleX;
            self.b = v * scaleY;
            self.c = -v * scaleX;
            self.d = u * scaleY;
        }
        else {
            self.a = scaleX;
            self.b = 0;
            self.c = 0;
            self.d = scaleY;
        }
        self.tx = tx;
        self.ty = ty;
    };
    /**
     * 创建 Graphics 类的 beginGradientFill() 和 lineGradientStyle() 方法所需的矩阵的特定样式。
     * 宽度和高度被缩放为 scaleX/scaleY 对，而 tx/ty 值偏移了宽度和高度的一半。
     * @method egret.Matrix#createGradientBox
     * @param width {number} 渐变框的宽度
     * @param height {number} 渐变框的高度
     * @param rotation {number} 旋转量（以弧度为单位）
     * @param tx {number} 沿 x 轴向右平移的距离（以像素为单位）。此值将偏移 width 参数的一半
     * @param ty {number} 沿 y 轴向下平移的距离（以像素为单位）。此值将偏移 height 参数的一半
     */
    __egretProto__.createGradientBox = function (width, height, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
    };
    /**
     * 引擎内部用于函数传递返回值的全局 Matrix 对象，开发者请勿随意修改此对象
     * @member {egret.Matrix} egret.Matrix.identity
     */
    Matrix.identity = new Matrix();
    /**
     * @private
     */
    Matrix.DEG_TO_RAD = Math.PI / 180;
    return Matrix;
})();
var NumberUtils = (function () {
    function NumberUtils() {
    }
    var __egretProto__ = NumberUtils.prototype;
    /**
     * @private
     */
    NumberUtils.isNumber = function (value) {
        return typeof (value) === "number" && !isNaN(value);
    };
    /**
     * 得到对应角度值的sin近似值
     * @param value {number} 角度值
     * @returns {number} sin值
     */
    NumberUtils.sin = function (value) {
        var valueFloor = Math.floor(value);
        var valueCeil = valueFloor + 1;
        var resultFloor = NumberUtils.sinInt(valueFloor);
        var resultCeil = NumberUtils.sinInt(valueCeil);
        return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
    };
    NumberUtils.sinInt = function (value) {
        value = value % 360;
        if (value < 0) {
            value += 360;
        }
        if (value < 90) {
            return egret_sin_map[value];
        }
        if (value < 180) {
            return egret_cos_map[value - 90];
        }
        if (value < 270) {
            return -egret_sin_map[value - 180];
        }
        return -egret_cos_map[value - 270];
    };
    /**
     * 得到对应角度值的cos近似值
     * @param value {number} 角度值
     * @returns {number} cos值
     */
    NumberUtils.cos = function (value) {
        var valueFloor = Math.floor(value);
        var valueCeil = valueFloor + 1;
        var resultFloor = NumberUtils.cosInt(valueFloor);
        var resultCeil = NumberUtils.cosInt(valueCeil);
        return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
    };
    NumberUtils.cosInt = function (value) {
        value = value % 360;
        if (value < 0) {
            value += 360;
        }
        if (value < 90) {
            return egret_cos_map[value];
        }
        if (value < 180) {
            return -egret_sin_map[value - 90];
        }
        if (value < 270) {
            return -egret_cos_map[value - 180];
        }
        return egret_sin_map[value - 270];
    };
    return NumberUtils;
})();
var egret_sin_map = {};
var egret_cos_map = {};
for (var NumberUtils_i = 0; NumberUtils_i <= 90; NumberUtils_i++) {
    egret_sin_map[NumberUtils_i] = Math.sin(NumberUtils_i * Matrix.DEG_TO_RAD);
    egret_cos_map[NumberUtils_i] = Math.cos(NumberUtils_i * Matrix.DEG_TO_RAD);
}
/**
 * @class egret.Rectangle
 * @classdesc 矩形类
 * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
 * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
 * 但是，right 和 bottom 属性与这四个属性是整体相关的。例如，如果更改 right 属性的值，则 width 属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化。
 * @extends egret.HashObject
 * @includeExample egret/geom/Rectangle.ts
 */
var Rectangle = (function () {
    /**
     * 创建一个 egret.Rectangle 对象。
     * 其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。如果调用此函数时不使用任何参数，将创建一个 x、y、width 和 height 属性均设置为 0 的矩形。
     * @method egret.Rectangle#constructor
     * @param x {number} 矩形左上角的 x 坐标。
     * @param y {number} 矩形左上角的 y 坐标。
     * @param width {number} 矩形的宽度（以像素为单位）。
     * @param height {number} 矩形的高度（以像素为单位）。
     */
    function Rectangle(x, y, width, height) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    var __egretProto__ = Rectangle.prototype;
    Object.defineProperty(__egretProto__, "left", {
        /**
         * 矩形左上角的 x 坐标。
         * @member {number} egret.Rectangle#left
         */
        get: function () {
            return this.x;
        },
        set: function (value) {
            this.width += this.x - value;
            this.x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "right", {
        /**
         * x 和 width 属性的和。
         * @member {number} egret.Rectangle#right
         */
        get: function () {
            return this.x + this.width;
        },
        set: function (value) {
            this.width = value - this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "top", {
        /**
         * 矩形左上角的 y 坐标。
         * @member {number} egret.Rectangle#top
         */
        get: function () {
            return this.y;
        },
        set: function (value) {
            this.height += this.y - value;
            this.y = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "bottom", {
        /**
         * y 和 height 属性的和。
         * @member {number} egret.Rectangle#bottom
         */
        get: function () {
            return this.y + this.height;
        },
        set: function (value) {
            this.height = value - this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "topLeft", {
        /**
         * 由该点的 x 和 y 坐标确定的 Rectangle 对象左上角的位置。
         * @member {number} egret.Rectangle#topLeft
         */
        get: function () {
            return new egret.Point(this.left, this.top);
        },
        set: function (value) {
            this.top = value.y;
            this.left = value.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(__egretProto__, "bottomRight", {
        /**
         * 由 right 和 bottom 属性的值确定的 Rectangle 对象的右下角的位置。
         * @member {number} egret.Rectangle#bottomRight
         */
        get: function () {
            return new egret.Point(this.right, this.bottom);
        },
        set: function (value) {
            this.bottom = value.y;
            this.right = value.x;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 举行类初始化赋值，开发者尽量调用此方法复用Rectangle对象，而不是每次需要的时候都重新创建
     * @method egret.Rectangle#initialize
     * @param x {number} 矩形的x轴
     * @param y {number} 矩形的y轴
     * @param width {number} 矩形的宽度
     * @param height {number} 矩形的高度
     * @returns {egret.Rectangle}
     * @deprecated
     */
    __egretProto__.initialize = function (x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
    };
    /**
     * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
     * @method egret.Rectangle#contains
     * @param x {number} 检测点的x轴
     * @param y {number} 检测点的y轴
     * @returns {boolean} 如果检测点位于矩形内，返回true，否则，返回false
     */
    __egretProto__.contains = function (x, y) {
        return this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y;
    };
    /**
     * 确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
     * @method egret.Rectangle#intersects
     * @param toIntersect {egret.Rectangle} 要与此 Rectangle 对象比较的 Rectangle 对象。
     * @returns {boolean} 如果两个矩形相交，返回true，否则返回false
     */
    __egretProto__.intersects = function (toIntersect) {
        return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right) && Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
    };
    /**
     * 将 Rectangle 对象的所有属性设置为 0。
     * @method egret.Rectangle#setEmpty
     */
    __egretProto__.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    };
    /**
     * 克隆矩形对象
     * @method egret.Rectangle#clone
     * @returns {egret.Rectangle} 返回克隆后的矩形
     */
    __egretProto__.clone = function () {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };
    /**
     * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
     * 此方法与 Rectangle.contains() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#containsPoint
     * @param point {egret.Point} 包含点对象
     * @returns {boolean} 如果包含，返回true，否则返回false
     */
    __egretProto__.containsPoint = function (point) {
        if (this.x < point.x && this.x + this.width > point.x && this.y < point.y && this.y + this.height > point.y) {
            return true;
        }
        return false;
    };
    /**
     * 将 Rectangle 的成员设置为指定值
     * @method egret.Rectangle#setTo
     * @param xa {number} 要将 Rectangle 设置为的值
     * @param ya {number} 要将 Rectangle 设置为的值
     * @param widtha {number} 要将 Rectangle 设置为的值
     * @param heighta {number} 要将 Rectangle 设置为的值
     */
    __egretProto__.setTo = function (xa, ya, widtha, heighta) {
        this.initialize(xa, ya, widtha, heighta);
    };
    /**
     * 将源 Rectangle 对象中的所有矩形数据复制到调用方 Rectangle 对象中
     * @method egret.Rectangle#copyFrom
     * @param sourceRect {egret.Rectangle} 要从中复制数据的 Rectangle 对象
     */
    __egretProto__.copyFrom = function (sourceRect) {
        this.x = sourceRect.x;
        this.y = sourceRect.y;
        this.width = sourceRect.width;
        this.height = sourceRect.height;
    };
    /**
     * 按指定量增加 Rectangle 对象的大小（以像素为单位）
     * 保持 Rectangle 对象的中心点不变，使用 dx 值横向增加它的大小，使用 dy 值纵向增加它的大小。
     * @method egret.Rectangle#inflate
     * @param dx {number} Rectangle 对象横向增加的值。
     * @param dy {number} Rectangle 对象纵向增加的值。
     */
    __egretProto__.inflate = function (dx, dy) {
        this.x -= dx;
        this.width += 2 * dx;
        this.y -= dy;
        this.height += 2 * dy;
    };
    /**
     * 确定此 Rectangle 对象是否为空
     * @method egret.Rectangle#isEmpty
     * @returns {boolean} 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false
     */
    __egretProto__.isEmpty = function () {
        return this.width == 0 || this.height == 0;
    };
    /**
     * 确定此 Rectangle 对象内是否包含由 rect 参数指定的 Rectangle 对象。
     * 如果一个 Rectangle 对象完全在另一个 Rectangle 的边界内，我们说第二个 Rectangle 包含第一个 Rectangle。
     * @method egret.Rectangle#containsRect
     * @param rect {egret.Rectangle} 所检查的 Rectangle 对象
     * @returns {boolean} 如果此 Rectangle 对象包含您指定的 Rectangle 对象，则返回 true 值，否则返回 false。
     */
    __egretProto__.containsRect = function (rect) {
        var r1 = rect.x + rect.width;
        var b1 = rect.y + rect.height;
        var r2 = this.x + this.width;
        var b2 = this.y + this.height;
        return (rect.x >= this.x) && (rect.x < r2) && (rect.y >= this.y) && (rect.y < b2) && (r1 > this.x) && (r1 <= r2) && (b1 > this.y) && (b1 <= b2);
    };
    /**
     * 确定在 toCompare 参数中指定的对象是否等于此 Rectangle 对象。
     * 此方法将某个对象的 x、y、width 和 height 属性与此 Rectangle 对象所对应的相同属性进行比较。
     * @method egret.Rectangle#equals
     * @param toCompare {egret.Rectangle} 要与此 Rectangle 对象进行比较的矩形
     * @returns {boolean} 如果对象具有与此 Rectangle 对象完全相同的 x、y、width 和 height 属性值，则返回 true 值，否则返回 false。
     */
    __egretProto__.equals = function (toCompare) {
        if (this === toCompare) {
            return true;
        }
        return this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height;
    };
    /**
     * 增加 Rectangle 对象的大小。此方法与 Rectangle.inflate() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#inflatePoint
     * @param point {egret.Point} 此 Point 对象的 x 属性用于增加 Rectangle 对象的水平尺寸。y 属性用于增加 Rectangle 对象的垂直尺寸。
     */
    __egretProto__.inflatePoint = function (point) {
        this.inflate(point.x, point.y);
    };
    /**
     * 如果在 toIntersect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。
     * 如果矩形不相交，则此方法返回一个空的 Rectangle 对象，其属性设置为 0。
     * @method egret.Rectangle#intersection
     * @param toIntersect {egret.Rectangle} 要与此 Rectangle 对象比较的 Rectangle 对象。
     * @returns {egret.Rectangle} 等于交集区域的 Rectangle 对象。如果该矩形不相交，则此方法返回一个空的 Rectangle 对象；即，其 x、y、width 和 height 属性均设置为 0 的矩形。
     */
    __egretProto__.intersection = function (toIntersect) {
        var result = this.clone();
        var x0 = result.x;
        var y0 = result.y;
        var x1 = toIntersect.x;
        var y1 = toIntersect.y;
        var l = Math.max(x0, x1);
        var r = Math.min(x0 + result.width, x1 + toIntersect.width);
        if (l <= r) {
            var t = Math.max(y0, y1);
            var b = Math.min(y0 + result.height, y1 + toIntersect.height);
            if (t <= b) {
                result.setTo(l, t, r - l, b - t);
                return result;
            }
        }
        result.setEmpty();
        return result;
    };
    /**
     * 按指定量调整 Rectangle 对象的位置（由其左上角确定）。
     * @method egret.Rectangle#offset
     * @param dx {number} 将 Rectangle 对象的 x 值移动此数量。
     * @param dy {number} 将 Rectangle 对象的 t 值移动此数量。
     */
    __egretProto__.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    /**
     * 将 Point 对象用作参数来调整 Rectangle 对象的位置。此方法与 Rectangle.offset() 方法类似，只不过它采用 Point 对象作为参数。
     * @method egret.Rectangle#offsetPoint
     * @param point {egret.Point} 要用于偏移此 Rectangle 对象的 Point 对象。
     */
    __egretProto__.offsetPoint = function (point) {
        this.offset(point.x, point.y);
    };
    /**
     * 生成并返回一个字符串，该字符串列出 Rectangle 对象的水平位置和垂直位置以及高度和宽度。
     * @method egret.Rectangle#toString
     * @returns {string} 一个字符串，它列出了 Rectangle 对象的下列各个属性的值：x、y、width 和 height。
     */
    __egretProto__.toString = function () {
        return "(x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
    };
    /**
     * 通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
     * @method egret.Rectangle#union
     * @param toUnion {egret.Rectangle} 要添加到此 Rectangle 对象的 Rectangle 对象。
     * @returns {egret.Rectangle} 充当两个矩形的联合的新 Rectangle 对象。
     */
    __egretProto__.union = function (toUnion) {
        var result = this.clone();
        if (toUnion.isEmpty()) {
            return result;
        }
        if (result.isEmpty()) {
            result.copyFrom(toUnion);
            return result;
        }
        var l = Math.min(result.x, toUnion.x);
        var t = Math.min(result.y, toUnion.y);
        result.setTo(l, t, Math.max(result.right, toUnion.right) - l, Math.max(result.bottom, toUnion.bottom) - t);
        return result;
    };
    /**
     * 引擎内部用于函数传递返回值的全局 Rectangle 对象，开发者请勿随意修改此对象
     * @member {egret.Rectangle} egret.Rectangle.identity
     */
    Rectangle.identity = new Rectangle(0, 0, 0, 0);
    return Rectangle;
})();
function DisplayObject() {
    this.visible;
    this.parent;
    this.name;
    this.x;
    this.y;
    this.width;
    this.height;
    this.scaleX;
    this.scaleY;
    this.anchorX;
    this.anchorY;
    this.anchorOffsetX;
    this.anchorOffsetY;
    this.rotation;
    this.alpha;
    this.worldAlpha;
    this.blendMode;
    this.needDraw;

    this.localMatrix;
    this.worldTransform;
}

DisplayObject.create = function() {
    var obj = new DisplayObject();
    obj.init();
    return obj;
};

var BlendMode = {
	NORMAL: "normal",
	ADD: "add",
	ERASE: "erase",
    ERASE_REVERSE: "eraseReverse"
};

DisplayObject.prototype.blendModes = {};
DisplayObject.prototype.blendModes[BlendMode.NORMAL] = "source-over";
DisplayObject.prototype.blendModes[BlendMode.ADD] = "lighter";
DisplayObject.prototype.blendModes[BlendMode.ERASE] = "destination-out";
DisplayObject.prototype.blendModes[BlendMode.ERASE_REVERSE] = "destination-in";

DisplayObject.prototype.init = function() {
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.anchorOffsetX = 0;
    this.anchorOffsetY = 0;
    this.anchorX = 0;
    this.anchorY = 0;
    this.skewX = 0;
    this.skewY = 0;
    this.name = "";
    this.rotation = 0;
    this.alpha = 1;
    this.worldAlpha = 1;
    this.blendMode = null;
    this.parent = null;
    this.visible = true;
    this.needDraw = false;
    this.localMatrix = null;
    this.worldTransform = new Matrix();
};

DisplayObject.prototype.setParent = function(parent) {
    this.parent = parent;
    return this;
};

DisplayObject.prototype.getParent = function() {
    return this.parent;
};

DisplayObject.prototype.setScale = function(scaleX, scaleY) {
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    return this;
};

DisplayObject.prototype.setAnchorOffset = function(ox, oy) {
    this.anchorOffsetX = ox;
    this.anchorOffsetY = oy;
    return this;
};

DisplayObject.prototype.setAnchor = function(x, y) {
    this.anchorX = x;
    this.anchorY = y;
    return this;
};

DisplayObject.prototype.isVisible = function() {
    return this.visible;
};

DisplayObject.prototype.setVisible = function(v) {
    this.visible = v;
    return this;
};

DisplayObject.prototype.setRotation = function(r) {
    this.rotation = r;
    return this;
};

DisplayObject.prototype.setAlpha = function(alpha) {
    this.alpha = alpha;
    return this;
};

DisplayObject.prototype.setSkewX = function(kx) {
    this.skewX = kx;
    return this;
};

DisplayObject.prototype.setSkewY = function(ky) {
    this.skewY = ky;
    return this;
};

DisplayObject.prototype.setBlend = function(b) {
    this.blendMode = b;
    return this;
};

DisplayObject.prototype.getBlend = function(b) {
    return this.blendMode;
};

DisplayObject.prototype.setWidth = function(w) {
    this.width = w;
    return this;
};

DisplayObject.prototype.getWidth = function() {
    return this.width;
};

DisplayObject.prototype.setHeight = function(h) {
    this.height = h;
    return this;
};

DisplayObject.prototype.getHeight = function() {
    return this.height;
};

DisplayObject.prototype.setWorldAlpha = function(alpha) {
    this.worldAlpha = alpha;
    return this;
};

DisplayObject.prototype.getWorldAlpha = function() {
    return this.worldAlpha;
};

DisplayObject.prototype.needDraw = function() {
    return !!this.needDraw;
};

DisplayObject.prototype.setNeedDraw = function(b) {
    this.needDraw = b;
    return this;
};

DisplayObject.prototype.setTransform = function(matrix) {
    this.localMatrix = matrix;
    return this;
};

DisplayObject.prototype.draw = function(ctx) {
    var matrix,
        blendMode;

    if(!this.visible) {
        return;
    }

    if(this.blendMode) {
        blendMode =  this.blendModes[this.blendMode];
    }
    else {
        blendMode = this.blendModes[BlendMode.NORMAL];
    }

    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.globalCompositeOperation = blendMode;
    matrix = this.worldTransform;
    ctx.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
    this.drawSelf(ctx);
    ctx.restore();

    return;
};

DisplayObject.prototype.getOffsetPoint = function() {
    var regX = this.anchorOffsetX;
    var regY = this.anchorOffsetY;

    return {x: regX, y: regY};
};


DisplayObject.prototype.calcWorldTransform = function() {
    var parent;
    var transform;
    var localMatrix;

    parent = this.parent;
    localMatrix = this.localMatrix;
    transform = this.worldTransform;
    if(parent) {
        transform.identityMatrix(parent.worldTransform);
    }
    else {
        transform.identityMatrix(new Matrix);
    }
    var offset = this.getOffsetPoint();
    var anchorX = offset.x;
    var anchorY = offset.y;

    if(localMatrix) {
        transform.append(localMatrix.a, localMatrix.b,
            localMatrix.c, localMatrix.d, localMatrix.tx, localMatrix.ty);
        transform.append(1, 0, 0, 1, -anchorX, -anchorY);
    }
    else {
        transform.appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, anchorX, anchorY);
    }

    if(parent) {
        this.worldAlpha = parent.worldAlpha * this.alpha;
    }
    else {
        this.worldAlpha = this.alpha;
    }

    return;
};

DisplayObject.prototype.doTransform = function(ctx) {
    if(!this.visible) {
        return;
    }

    this.calcWorldTransform();

    if(this.needDraw) {
        this.draw(ctx);
    }

    return;
};
function DisplayObjectContainer() {
    DisplayObject.call(this);
    this.children;
    this.isContainer;
}

__extends(DisplayObjectContainer, DisplayObject);

DisplayObjectContainer.prototype.init = function() {
    DisplayObject.prototype.init.call(this);
    this.children = [];
    this.visible = true;
    this.isContainer = true;
};

DisplayObjectContainer.prototype.getChildCount = function() {
    return this.children.length;
};

DisplayObjectContainer.prototype.addChild = function(child, index) {
    var num;

    num = this.children.length;
    if(child.parent === this) {
        num--;
    }

    return this.addChildAt(child, num);
};

DisplayObjectContainer.prototype.addChildAt = function(child, index) {
    if(child === this) {
        return;
    }

    if(child.parent === this) {
        this.setChildIndex(child, index);
    }
    else {
        if(child.parent) {
            this.parent.removeChild(child);
        }
        this.children.splice(index, 0, child);
        child.setParent(this);
    }

    return child;
};

DisplayObjectContainer.prototype.setChildIndex = function(child, index) {
    var idx;

    idx = this.children.indexOf(child);
    if(idx >= 0) {
        this.children.splice(idx, 1);
        if(index < 0 || this.children.length <= index) {
            this.children.push(child);
        }
        else {
            this.children.splice(index, 0, child);
        }
    }

    return;
};

DisplayObjectContainer.prototype.removeAllChild = function() {
    this.children = [];
};

DisplayObjectContainer.prototype.removeChild = function(child) {
    var index;

    index = this.children.indexOf(child);
    if(index >= 0) {
        return this.removeChildByIndex(index);
    }

    return;
};

DisplayObjectContainer.prototype.removeChildByIndex = function(index) {
    var child;

    child = this.children[index];
    child.setParent(null);
    this.children.splice(index, 1);

    return child;
};

DisplayObjectContainer.prototype.getChildIndex = function(child) {
    return this.children.indexOf(child);
};

DisplayObjectContainer.prototype.updateTransform = function(ctx) {
    if(!this.visible) {
        return;
    }

    this.doTransform(ctx);
    if(this.isContainer && this.children.length) {
        for(var i = 0, len = this.children.length; i < len; i++) {
            var it = this.children[i];
            if(it.isContainer) {
                it.updateTransform(ctx);
            }
            else {
                it.doTransform(ctx);
            }
        }
    }
};

DisplayObjectContainer.prototype.drawSelf = function(ctx) {
    //TODO
};

DisplayObjectContainer.create = function() {
    var container = new DisplayObjectContainer();
    container.init();

    return container;
};
var MainContext = (function () {
    function MainContext() {
        this.timeScale = 1;
        this.container = null;
    }

    MainContext.prototype.setObjectContainer = function(container) {
    	this.container = container;
    }

    MainContext.prototype.run = function() {
		var me = this;
		var oldTime = Date.now();

		function doEnter() {
			var currentTime = Date.now();
			var advanceTime = currentTime - oldTime;

			me.renderLoop(advanceTime);
        	dragonBones.WorldClock.clock.advanceTime(advanceTime / 1000);

			window.requestAnimationFrame(doEnter);
			oldTime = currentTime;
		}

		window.requestAnimationFrame(doEnter);
	}

	MainContext.prototype.setScale = function(scaleX, scaleY) {
		this.container.scaleX = scaleX;
		this.container.scaleY = scaleY;
	}

	MainContext.prototype.setPosition = function(x, y) {
		this.container.x = x;
		this.container.y = y;
	}

    MainContext.prototype.renderLoop = function (canvas) {
        this.container.updateTransform(canvas);
    }

    return MainContext;
})();

MainContext.instance = new MainContext;
function Bitmap() {
    DisplayObject.call(this);
    this.texture;
    this.needDraw;
}

__extends(Bitmap, DisplayObject);

Bitmap.prototype.init = function() {
    DisplayObject.prototype.init.call(this);
    this.needDraw = true;
};

Bitmap.prototype.setTexture = function(texture) {
    this.texture = texture;
    if(texture) {
        this.setWidth(texture.dw);
        this.setHeight(texture.dh);
    }
    return this;
};

Bitmap.prototype.getTexture = function() {
    return this.texture;
};

Bitmap.prototype.drawSelf = function(ctx) {
    var dw;
    var dh;
    var dx;
    var dy;
    var sx;
    var sy;
    var sw;
    var sh;
    var texure;

    if(!this.texture) {
        return;
    }

    texture = this.texture;
    dw = texture.dw;
    dh = texture.dh;
    dx = texture.dx;
    dy = texture.dy;
    sx = texture.sx;
    sy = texture.sy;
    sw = texture.sw;
    sh = texture.sh;

    ctx.drawImage(texture.texture, sx, sy, sw, sh, dx, dy, dw, dh);

    return;
};

Bitmap.create = function(name) {
    var bitmap = new Bitmap();
    bitmap.xname = name;
    bitmap.init();
    return bitmap;
};
var __define = this.__define || function (o, p, g, s) {   Object.defineProperty(o, p, { configurable:true, enumerable:true, get:g,set:s }) };
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DragonBones
     * @classdesc
     * DragonBones
     */
    var DragonBones = (function () {
        function DragonBones() {
        }
        var d = __define,c=DragonBones,p=c.prototype;
        /**
         * DragonBones当前数据格式版本
         */
        DragonBones.DATA_VERSION = "4.0";
        DragonBones.DATA_VERSION_4_5 = "4.5";
        /**
         *
         */
        DragonBones.PARENT_COORDINATE_DATA_VERSION = "3.0";
        DragonBones.VERSION = "4.5.10";
        return DragonBones;
    }());
    dragonBones.DragonBones = DragonBones;
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Animation
     * @classdesc
     * Animation实例隶属于Armature,用于控制Armature的动画播放。
     * @see dragonBones.Bone
     * @see dragonBones.Armature
     * @see dragonBones.AnimationState
     * @see dragonBones.AnimationData
     *
     * @example
       <pre>
       //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        armatureDisplay.x = 200;
        armatureDisplay.y = 500;
        //把它添加到舞台上
        this.addChild(armatureDisplay);



        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName:string = armature.animation.animationList[0];

        var animation:dragonBones.Animation = armature.animation;

        //gotoAndPlay的用法：动画播放，播放一遍
        animation.gotoAndPlay(curAnimationName,0,-1,1);

        //gotoAndStop的用法：
        //curAnimationName = armature.animation.animationList[1];
        //动画停在第二个动画的第0.2秒的位置
        //animation.gotoAndStop(curAnimationName,0.2);
        //动画停在第二个动画的一半的位置，如果第三个参数大于0，会忽略第二个参数
        //animation.gotoAndStop(curAnimationName,0, 0.5);
        //继续播放
        //animation.play();
        //暂停播放
        //animation.stop();

        //动画融合
        //animation.gotoAndPlay(curAnimationName,0,-1,0,0,"group1");

        //var animationState:dragonBones.AnimationState = armature.animation.getState(curAnimationName);
        //animationState.addBoneMask("neck",true);
        //播放第二个动画， 放到group "Squat"里
        //curAnimationName = armature.animation.animationList[1];
        //armature.animation.gotoAndPlay(curAnimationName,0,-1,0,0,"group2",dragonBones.Animation.SAME_GROUP);
        //animationState = armature.animation.getState(curAnimationName);
        //animationState.addBoneMask("hip",true);//“hip”是骨架的根骨骼的名字
        //animationState.removeBoneMask("neck",true);
        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Animation = (function () {
        /**
         * 创建一个新的Animation实例并赋给传入的Armature实例
         * @param armature {Armature} 骨架实例
         */
        function Animation(armature) {
            /** @private */
            this._animationStateCount = 0;
            /** @private */
            this._updateTimelineStates = false;
            /** @private */
            this._updateFFDTimelineStates = false;
            this._armature = armature;
            this._animationList = [];
            this._animationStateList = [];
            this._timeScale = 1;
            this._isPlaying = false;
            this.tweenEnabled = true;
        }
        var d = __define,c=Animation,p=c.prototype;
        /**
         * 回收Animation实例用到的所有资源
         */
        p.dispose = function () {
            if (!this._armature) {
                return;
            }
            this._resetAnimationStateList();
            this._animationList.length = 0;
            this._armature = null;
            this._animationDataList = null;
            this._animationList = null;
            this._animationStateList = null;
        };
        p._resetAnimationStateList = function () {
            var i = this._animationStateList.length;
            var animationState;
            while (i--) {
                animationState = this._animationStateList[i];
                animationState._resetTimelineStateList();
                dragonBones.AnimationState._returnObject(animationState);
            }
            this._animationStateList.length = 0;
        };
        /**
         * 开始播放指定名称的动画。
         * 要播放的动画将经过指定时间的淡入过程，然后开始播放，同时之前播放的动画会经过相同时间的淡出过程。
         * @param animationName {string} 指定播放动画的名称.
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param playTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         * @param layer {number} 动画所处的层
         * @param group {string} 动画所处的组
         * @param fadeOutMode {string} 动画淡出模式 (none, sameLayer, sameGroup, sameLayerAndGroup, all).默认值：sameLayerAndGroup
         * @param pauseFadeOut {boolean} 动画淡出时暂停播放
         * @param pauseFadeIn {boolean} 动画淡入时暂停播放
         * @returns {AnimationState} 动画播放状态实例
         * @see dragonBones.AnimationState.
         */
        p.gotoAndPlay = function (animationName, fadeInTime, duration, playTimes, layer, group, fadeOutMode, pauseFadeOut, pauseFadeIn) {
            if (fadeInTime === void 0) { fadeInTime = -1; }
            if (duration === void 0) { duration = -1; }
            if (playTimes === void 0) { playTimes = NaN; }
            if (layer === void 0) { layer = 0; }
            if (group === void 0) { group = null; }
            if (fadeOutMode === void 0) { fadeOutMode = Animation.SAME_LAYER_AND_GROUP; }
            if (pauseFadeOut === void 0) { pauseFadeOut = true; }
            if (pauseFadeIn === void 0) { pauseFadeIn = true; }
            if (!this._animationDataList) {
                return null;
            }
            var i = this._animationDataList.length;
            var animationData;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    animationData = this._animationDataList[i];
                    break;
                }
            }
            if (!animationData) {
                return null;
            }
            var needUpdate = this._isPlaying == false;
            this._isPlaying = true;
            this._isFading = true;
            //
            fadeInTime = fadeInTime < 0 ? (animationData.fadeTime < 0 ? 0.3 : animationData.fadeTime) : fadeInTime;
            var durationScale;
            if (duration < 0) {
                durationScale = animationData.scale < 0 ? 1 : animationData.scale;
            }
            else {
                durationScale = duration * 1000 / animationData.duration;
            }
            playTimes = isNaN(playTimes) ? animationData.playTimes : playTimes;
            //根据fadeOutMode,选择正确的animationState执行fadeOut
            var animationState;
            switch (fadeOutMode) {
                case Animation.NONE:
                    break;
                case Animation.SAME_LAYER:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.layer == layer) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
                case Animation.SAME_GROUP:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.group == group) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
                case Animation.ALL:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        animationState.fadeOut(fadeInTime, pauseFadeOut);
                    }
                    break;
                case Animation.SAME_LAYER_AND_GROUP:
                default:
                    i = this._animationStateList.length;
                    while (i--) {
                        animationState = this._animationStateList[i];
                        if (animationState.layer == layer && animationState.group == group) {
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                    }
                    break;
            }
            this._lastAnimationState = dragonBones.AnimationState._borrowObject();
            this._lastAnimationState._layer = layer;
            this._lastAnimationState._group = group;
            this._lastAnimationState.autoTween = this.tweenEnabled;
            this._lastAnimationState._fadeIn(this._armature, animationData, fadeInTime, 1 / durationScale, playTimes, pauseFadeIn);
            this.addState(this._lastAnimationState);
            //控制子骨架播放同名动画
            var slotList = this._armature.getSlots(false);
            i = slotList.length;
            while (i--) {
                var slot = slotList[i];
                if (slot.childArmature) {
                    slot.childArmature.animation.gotoAndPlay(animationName, fadeInTime);
                }
            }
            if (needUpdate) {
                this._armature.advanceTime(0);
            }
            return this._lastAnimationState;
        };
        /**
         * 播放指定名称的动画并停止于某个时间点
         * @param animationName {string} 指定播放的动画名称.
         * @param time {number} 动画停止的绝对时间
         * @param normalizedTime {number} 动画停止的相对动画总时间的系数，这个参数和time参数是互斥的（例如 0.2：动画停止总时间的20%位置） 默认值：-1 意味着使用绝对时间。
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：0
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param layer {string} 动画所处的层
         * @param group {string} 动画所处的组
         * @param fadeOutMode {string} 动画淡出模式 (none, sameLayer, sameGroup, sameLayerAndGroup, all).默认值：sameLayerAndGroup
         * @returns {AnimationState} 动画播放状态实例
         * @see dragonBones.AnimationState.
         */
        p.gotoAndStop = function (animationName, time, normalizedTime, fadeInTime, duration, layer, group, fadeOutMode) {
            if (normalizedTime === void 0) { normalizedTime = -1; }
            if (fadeInTime === void 0) { fadeInTime = 0; }
            if (duration === void 0) { duration = -1; }
            if (layer === void 0) { layer = 0; }
            if (group === void 0) { group = null; }
            if (fadeOutMode === void 0) { fadeOutMode = Animation.ALL; }
            var animationState = this.gotoAndPlay(animationName, fadeInTime, duration, NaN, layer, group, fadeOutMode);
            if (normalizedTime >= 0) {
                animationState.setCurrentTime(animationState.totalTime * normalizedTime);
            }
            else {
                animationState.setCurrentTime(time);
            }
            animationState.lastFrameAutoTween = false;
            animationState.stop();
            return animationState;
        };
        /**
         * 从当前位置继续播放动画
         */
        p.play = function () {
            if (!this._animationDataList || this._animationDataList.length == 0) {
                return;
            }
            if (!this._lastAnimationState) {
                this.gotoAndPlay(this._animationDataList[0].name);
            }
            else if (!this._isPlaying) {
                this._isPlaying = true;
            }
            else {
                this.gotoAndPlay(this._lastAnimationState.name);
            }
        };
        /**
         * 暂停动画播放
         */
        p.stop = function () {
            this._isPlaying = false;
        };
        /**
         * 获得指定名称的 AnimationState 实例.
         * @returns {AnimationState} AnimationState 实例.
         * @see dragonBones..AnimationState.
         */
        p.getState = function (name, layer) {
            if (layer === void 0) { layer = 0; }
            var i = this._animationStateList.length;
            while (i--) {
                var animationState = this._animationStateList[i];
                if (animationState.name == name && animationState.layer == layer) {
                    return animationState;
                }
            }
            return null;
        };
        /**
         * 检查是否包含指定名称的动画.
         * @returns {boolean}.
         */
        p.hasAnimation = function (animationName) {
            var i = this._animationDataList.length;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @private
         */
        p._advanceTime = function (passedTime) {
            if (!this._isPlaying) {
                return;
            }
            if (this._updateTimelineStates) {
                this._updateTimelineStates = false;
                this.updateTimelineStates();
            }
            else if (this._updateFFDTimelineStates) {
                this._updateFFDTimelineStates = false;
                this.updateFFDTimelineStates();
            }
            var isFading = false;
            passedTime *= this._timeScale;
            var i = this._animationStateList.length;
            while (i--) {
                var animationState = this._animationStateList[i];
                if (animationState._advanceTime(passedTime)) {
                    this.removeState(animationState);
                }
                else if (animationState.fadeState != 1) {
                    isFading = true;
                }
            }
            this._isFading = isFading;
        };
        /**
         * @private
         */
        p.updateTimelineStates = function () {
            var i = this._animationStateList.length;
            while (i--) {
                this._animationStateList[i]._updateTimelineStates();
            }
        };
        /**
         * @private
         */
        p.updateFFDTimelineStates = function () {
            var i = this._animationStateList.length;
            while (i--) {
                this._animationStateList[i]._updateFFDTimeline();
            }
        };
        p.addState = function (animationState) {
            if (this._animationStateList.indexOf(animationState) < 0) {
                this._animationStateList.unshift(animationState);
                this._animationStateCount = this._animationStateList.length;
            }
        };
        p.removeState = function (animationState) {
            var index = this._animationStateList.indexOf(animationState);
            if (index >= 0) {
                this._animationStateList.splice(index, 1);
                dragonBones.AnimationState._returnObject(animationState);
                if (this._lastAnimationState == animationState) {
                    if (this._animationStateList.length > 0) {
                        this._lastAnimationState = this._animationStateList[0];
                    }
                    else {
                        this._lastAnimationState = null;
                    }
                }
                this._animationStateCount = this._animationStateList.length;
            }
        };
        d(p, "movementList"
            /**
            * 不推荐的API.推荐使用 animationList.
            */
            ,function () {
                return this._animationList;
            }
        );
        d(p, "movementID"
            /**
            * 不推荐的API.推荐使用 lastAnimationName.
            */
            ,function () {
                return this.lastAnimationName;
            }
        );
        d(p, "lastAnimationState"
            /**
             * 最近播放的 AnimationState 实例。
             * @member {AnimationState} dragonBones.Animation#lastAnimationState
             * @see dragonBones.AnimationState
             */
            ,function () {
                return this._lastAnimationState;
            }
        );
        d(p, "lastAnimationName"
            /**
             * 最近播放的动画名称.
             * @member {string} dragonBones.Animation#lastAnimationName
             */
            ,function () {
                return this._lastAnimationState ? this._lastAnimationState.name : null;
            }
        );
        d(p, "animationList"
            /**
             * 所有动画名称列表.
             * @member {string[]} dragonBones.Animation#animationList
             */
            ,function () {
                return this._animationList;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.Animation#isPlaying
             */
            ,function () {
                return this._isPlaying && !this.isComplete;
            }
        );
        d(p, "isComplete"
            /**
             * 最近播放的动画是否播放完成.
             * @member {boolean} dragonBones.Animation#isComplete
             */
            ,function () {
                if (this._lastAnimationState) {
                    if (!this._lastAnimationState.isComplete) {
                        return false;
                    }
                    var i = this._animationStateList.length;
                    while (i--) {
                        if (!this._animationStateList[i].isComplete) {
                            return false;
                        }
                    }
                    return true;
                }
                return true;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放倍数
             * @member {number} dragonBones.Animation#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        d(p, "animationDataList"
            /**
             * 包含的所有动画数据列表
             * @member {AnimationData[]} dragonBones.Animation#animationDataList
             * @see dragonBones.AnimationData.
             */
            ,function () {
                return this._animationDataList;
            }
            ,function (value) {
                this._animationDataList = value;
                this._animationList.length = 0;
                for (var i = 0, len = this._animationDataList.length; i < len; i++) {
                    var animationData = this._animationDataList[i];
                    this._animationList[this._animationList.length] = animationData.name;
                }
            }
        );
        Animation.NONE = "none";
        Animation.SAME_LAYER = "sameLayer";
        Animation.SAME_GROUP = "sameGroup";
        Animation.SAME_LAYER_AND_GROUP = "sameLayerAndGroup";
        Animation.ALL = "all";
        return Animation;
    }());
    dragonBones.Animation = Animation;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationState
     * @classdesc
     * AnimationState 实例由 Animation 实例播放动画时产生， 可以对单个动画的播放进行最细致的调节。
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        armatureDisplay.x = 200;
        armatureDisplay.y = 500;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName:string = armature.animation.animationList[0];
        //播放这个动画
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //获取animationState可以对动画进行更多控制；
        var animationState:dragonBones.AnimationState = armature.animation.getState(curAnimationName);

        //下面的代码实现人物的脖子和头动，但是其他部位不动
        animationState.addBoneMask("neck",true);
        //下面的代码实现人物的身体动，但是脖子和头不动
        //animationState.addBoneMask("hip",true);//“hip”是骨架的根骨骼的名字
        //animationState.removeBoneMask("neck",true);
        //下面的代码实现动画幅度减小的效果
        //animationState.weight = 0.5;

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
           dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var AnimationState = (function () {
        function AnimationState() {
            /** @private */
            this._layer = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._currentPlayTimes = 0;
            this._totalTime = 0;
            this._currentTime = 0;
            this._lastTime = 0;
            //-1 beforeFade, 0 fading, 1 fadeComplete
            this._fadeState = 0;
            this._playTimes = 0;
            this._timelineStateList = [];
            this._slotTimelineStateList = [];
            this._ffdTimelineStateList = [];
            this._boneMasks = [];
        }
        var d = __define,c=AnimationState,p=c.prototype;
        /** @private */
        AnimationState._borrowObject = function () {
            if (AnimationState._pool.length == 0) {
                return new AnimationState();
            }
            return AnimationState._pool.pop();
        };
        /** @private */
        AnimationState._returnObject = function (animationState) {
            animationState.clear();
            if (AnimationState._pool.indexOf(animationState) < 0) {
                AnimationState._pool[AnimationState._pool.length] = animationState;
            }
        };
        /** @private */
        AnimationState._clear = function () {
            var i = AnimationState._pool.length;
            while (i--) {
                AnimationState._pool[i].clear();
            }
            AnimationState._pool.length = 0;
            dragonBones.TimelineState._clear();
        };
        p.clear = function () {
            this._resetTimelineStateList();
            this._boneMasks.length = 0;
            this._armature = null;
            this._clip = null;
        };
        p._resetTimelineStateList = function () {
            var i = this._timelineStateList.length;
            while (i--) {
                dragonBones.TimelineState._returnObject(this._timelineStateList[i]);
            }
            this._timelineStateList.length = 0;
            i = this._slotTimelineStateList.length;
            while (i--) {
                dragonBones.SlotTimelineState._returnObject(this._slotTimelineStateList[i]);
            }
            this._slotTimelineStateList.length = 0;
            i = this._ffdTimelineStateList.length;
            while (i--) {
                dragonBones.FFDTimelineState._returnObject(this._ffdTimelineStateList[i]);
            }
            this._ffdTimelineStateList.length = 0;
        };
        //骨架装配
        /**
         * 检查指定名称的骨头是否在遮罩中。只有在遮罩中的骨头动画才会被播放
         * @param boneName {string} dragonBones.AnimationState#containsBoneMask
         * @returns {boolean}
         */
        p.containsBoneMask = function (boneName) {
            return this._boneMasks.length == 0 || this._boneMasks.indexOf(boneName) >= 0;
        };
        /**
         * 将一个骨头加入遮罩。只有加入遮罩的骨头的动画才会被播放，如果没有骨头加入遮罩，则所有骨头的动画都会播放。通过这个API可以实现只播放角色的一部分.
         * @param boneName {string} 骨头名称.
         * @param ifInvolveChildBones {boolean} 是否影响子骨头。默认值：true.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.addBoneMask = function (boneName, ifInvolveChildBones) {
            if (ifInvolveChildBones === void 0) { ifInvolveChildBones = true; }
            this.addBoneToBoneMask(boneName);
            if (ifInvolveChildBones) {
                var currentBone = this._armature.getBone(boneName);
                if (currentBone) {
                    var boneList = this._armature.getBones(false);
                    var i = boneList.length;
                    while (i--) {
                        var tempBone = boneList[i];
                        if (currentBone.contains(tempBone)) {
                            this.addBoneToBoneMask(tempBone.name);
                        }
                    }
                }
            }
            this._updateTimelineStates();
            return this;
        };
        /**
         * 将一个指定名称的骨头从遮罩中移除.
         * @param boneName {string} 骨头名称.
         * @param ifInvolveChildBones {boolean} 是否影响子骨头。默认值：true.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.removeBoneMask = function (boneName, ifInvolveChildBones) {
            if (ifInvolveChildBones === void 0) { ifInvolveChildBones = true; }
            this.removeBoneFromBoneMask(boneName);
            if (ifInvolveChildBones) {
                var currentBone = this._armature.getBone(boneName);
                if (currentBone) {
                    var boneList = this._armature.getBones(false);
                    var i = boneList.length;
                    while (i--) {
                        var tempBone = boneList[i];
                        if (currentBone.contains(tempBone)) {
                            this.removeBoneFromBoneMask(tempBone.name);
                        }
                    }
                }
            }
            this._updateTimelineStates();
            return this;
        };
        /**
         * 清空骨头遮罩.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.removeAllMixingTransform = function () {
            this._boneMasks.length = 0;
            this._updateTimelineStates();
            return this;
        };
        p.addBoneToBoneMask = function (boneName) {
            if (this._clip.getTimeline(boneName) && this._boneMasks.indexOf(boneName) < 0) {
                this._boneMasks.push(boneName);
            }
        };
        p.removeBoneFromBoneMask = function (boneName) {
            var index = this._boneMasks.indexOf(boneName);
            if (index >= 0) {
                this._boneMasks.splice(index, 1);
            }
        };
        /**
         * @private
         * Update timeline state based on mixing transforms and clip.
         */
        p._updateTimelineStates = function () {
            var timelineState;
            var slotTimelineState;
            var ffdTimelineState;
            var i = this._timelineStateList.length;
            var len;
            while (i--) {
                timelineState = this._timelineStateList[i];
                if (!this._armature.getBone(timelineState.name)) {
                    this.removeTimelineState(timelineState);
                }
            }
            i = this._slotTimelineStateList.length;
            while (i--) {
                slotTimelineState = this._slotTimelineStateList[i];
                if (!this._armature.getSlot(slotTimelineState.name)) {
                    this.removeSlotTimelineState(slotTimelineState);
                }
            }
            if (this._boneMasks.length > 0) {
                i = this._timelineStateList.length;
                while (i--) {
                    timelineState = this._timelineStateList[i];
                    if (this._boneMasks.indexOf(timelineState.name) < 0) {
                        this.removeTimelineState(timelineState);
                    }
                }
                for (i = 0, len = this._boneMasks.length; i < len; i++) {
                    var timelineName = this._boneMasks[i];
                    this.addTimelineState(timelineName);
                }
            }
            else {
                for (i = 0, len = this._clip.timelineList.length; i < len; i++) {
                    var timeline = this._clip.timelineList[i];
                    this.addTimelineState(timeline.name);
                }
            }
            for (i = 0, len = this._clip.slotTimelineList.length; i < len; i++) {
                var slotTimeline = this._clip.slotTimelineList[i];
                this.addSlotTimelineState(slotTimeline.name);
            }
            this._updateFFDTimeline();
        };
        /**
         * @private
         */
        p._updateFFDTimeline = function () {
            var i = 0, l = 0;
            var ffdTimelineState;
            var slot;
            var timelines = {};
            l = this._ffdTimelineStateList.length;
            for (i = 0; i < l; ++i) {
                ffdTimelineState = this._ffdTimelineStateList[i];
                slot = this._armature.getSlot(ffdTimelineState.name);
                if (!slot || slot.displayIndex != ffdTimelineState.displayIndex) {
                    this._ffdTimelineStateList.splice(i, 1);
                    dragonBones.FFDTimelineState._returnObject(timelineState);
                }
                else {
                    timelines[ffdTimelineState.name] = ffdTimelineState;
                }
            }
            if (this._clip.ffdTimelineList) {
                l = this._clip.ffdTimelineList.length;
                for (i = 0; i < l; ++i) {
                    var ffdTimeline = this._clip.ffdTimelineList[i];
                    //TODO:换肤 原始 display 匹配
                    slot = this._armature.getSlot(ffdTimeline.name);
                    if (!timelines[ffdTimeline.name] && slot && slot.displayList.length > 0 && slot.displayIndex >= 0 && slot.displayIndex == ffdTimeline.displayIndex) {
                        /*for each(var eachState:FFDTimelineState in _ffdTimelineStateList)
                        {
                        if(eachState.name == timeline.name)
                        {
                        return;
                        }
                        }*/
                        var timelineState = dragonBones.FFDTimelineState._borrowObject();
                        timelineState._fadeIn(slot, this, ffdTimeline);
                        this._ffdTimelineStateList.push(timelineState);
                        timelines[ffdTimeline.name] = timelineState;
                    }
                }
            }
            var slots = this._armature.getSlots(false);
            for (i = 0, l = slots.length; i < l; ++i) {
                slot = slots[i];
                if (slot._meshData && !timelines[slot.name]) {
                    slot._updateFFD(null, 0);
                }
            }
        };
        p.addTimelineState = function (timelineName) {
            var bone = this._armature.getBone(timelineName);
            if (bone) {
                for (var i = 0, len = this._timelineStateList.length; i < len; i++) {
                    var eachState = this._timelineStateList[i];
                    if (eachState.name == timelineName) {
                        return;
                    }
                }
                var timelineState = dragonBones.TimelineState._borrowObject();
                timelineState._fadeIn(bone, this, this._clip.getTimeline(timelineName));
                this._timelineStateList.push(timelineState);
            }
        };
        p.removeTimelineState = function (timelineState) {
            var index = this._timelineStateList.indexOf(timelineState);
            this._timelineStateList.splice(index, 1);
            dragonBones.TimelineState._returnObject(timelineState);
        };
        p.addSlotTimelineState = function (timelineName) {
            var slot = this._armature.getSlot(timelineName);
            if (slot) {
                for (var i = 0, len = this._slotTimelineStateList.length; i < len; i++) {
                    var eachState = this._slotTimelineStateList[i];
                    if (eachState.name == timelineName) {
                        return;
                    }
                }
                var timelineState = dragonBones.SlotTimelineState._borrowObject();
                timelineState._fadeIn(slot, this, this._clip.getSlotTimeline(timelineName));
                this._slotTimelineStateList.push(timelineState);
            }
        };
        p.removeSlotTimelineState = function (timelineState) {
            var index = this._slotTimelineStateList.indexOf(timelineState);
            this._slotTimelineStateList.splice(index, 1);
            dragonBones.SlotTimelineState._returnObject(timelineState);
        };
        //动画
        /**
         * 播放当前动画。如果动画已经播放完毕, 将不会继续播放.
         * @returns {AnimationState} 动画播放状态实例
         */
        p.play = function () {
            this._isPlaying = true;
            return this;
        };
        /**
         * 暂停当前动画的播放。
         * @returns {AnimationState} 动画播放状态实例
         */
        p.stop = function () {
            this._isPlaying = false;
            return this;
        };
        /** @private */
        p._fadeIn = function (armature, clip, fadeTotalTime, timeScale, playTimes, pausePlayhead) {
            this._armature = armature;
            this._clip = clip;
            this._pausePlayheadInFade = pausePlayhead;
            this._name = this._clip.name;
            this._totalTime = this._clip.duration;
            this.autoTween = this._clip.autoTween;
            this.setTimeScale(timeScale);
            this.setPlayTimes(playTimes);
            //reset
            this._isComplete = false;
            this._currentFrameIndex = -1;
            this._currentPlayTimes = -1;
            if (Math.round(this._totalTime * this._clip.frameRate * 0.001) < 2 || timeScale == Infinity) {
                this._currentTime = this._totalTime;
            }
            else {
                this._currentTime = -1;
            }
            this._time = 0;
            this._boneMasks.length = 0;
            //fade start
            this._isFadeOut = false;
            this._fadeWeight = 0;
            this._fadeTotalWeight = 1;
            this._fadeState = -1;
            this._fadeCurrentTime = 0;
            this._fadeBeginTime = this._fadeCurrentTime;
            this._fadeTotalTime = fadeTotalTime * this._timeScale;
            //default
            this._isPlaying = true;
            this.displayControl = true;
            this.lastFrameAutoTween = true;
            this.additiveBlending = false;
            this.weight = 1;
            this.fadeOutTime = fadeTotalTime;
            this._updateTimelineStates();
            return this;
        };
        /**
         * 淡出当前动画
         * @param fadeTotalTime {number} 淡出时间
         * @param pausePlayhead {boolean} 淡出时动画是否暂停。
         */
        p.fadeOut = function (fadeTotalTime, pausePlayhead) {
            if (!this._armature) {
                return null;
            }
            if (isNaN(fadeTotalTime) || fadeTotalTime < 0) {
                fadeTotalTime = 0;
            }
            this._pausePlayheadInFade = pausePlayhead;
            if (this._isFadeOut) {
                if (fadeTotalTime > this._fadeTotalTime / this._timeScale - (this._fadeCurrentTime - this._fadeBeginTime)) {
                    //如果已经在淡出中，新的淡出需要更长的淡出时间，则忽略
                    //If the animation is already in fade out, the new fade out will be ignored.
                    return this;
                }
            }
            else {
                //第一次淡出
                //The first time to fade out.
                for (var i = 0, len = this._timelineStateList.length; i < len; i++) {
                    var timelineState = this._timelineStateList[i];
                    timelineState._fadeOut();
                }
            }
            //fade start
            this._isFadeOut = true;
            this._fadeTotalWeight = this._fadeWeight;
            this._fadeState = -1;
            this._fadeBeginTime = this._fadeCurrentTime;
            this._fadeTotalTime = this._fadeTotalWeight >= 0 ? fadeTotalTime * this._timeScale : 0;
            //default
            this.displayControl = false;
            return this;
        };
        /** @private */
        p._advanceTime = function (passedTime) {
            passedTime *= this._timeScale;
            this.advanceFadeTime(passedTime);
            if (this._fadeWeight) {
                this.advanceTimelinesTime(passedTime);
            }
            return this._isFadeOut && this._fadeState == 1;
        };
        p.advanceFadeTime = function (passedTime) {
            var fadeStartFlg = false;
            var fadeCompleteFlg = false;
            if (this._fadeBeginTime >= 0) {
                var fadeState = this._fadeState;
                this._fadeCurrentTime += passedTime < 0 ? -passedTime : passedTime;
                if (this._fadeCurrentTime >= this._fadeBeginTime + this._fadeTotalTime) {
                    //fade完全结束之后触发
                    //TODO 研究明白为什么要下次再触发
                    if (this._fadeWeight == 1 ||
                        this._fadeWeight == 0) {
                        fadeState = 1;
                        if (this._pausePlayheadInFade) {
                            this._pausePlayheadInFade = false;
                            this._currentTime = -1;
                        }
                    }
                    this._fadeWeight = this._isFadeOut ? 0 : 1;
                }
                else if (this._fadeCurrentTime >= this._fadeBeginTime) {
                    //fading
                    fadeState = 0;
                    //暂时只支持线性淡入淡出
                    //Currently only support Linear fadein and fadeout
                    this._fadeWeight = (this._fadeCurrentTime - this._fadeBeginTime) / this._fadeTotalTime * this._fadeTotalWeight;
                    if (this._isFadeOut) {
                        this._fadeWeight = this._fadeTotalWeight - this._fadeWeight;
                    }
                }
                else {
                    //before fade
                    fadeState = -1;
                    this._fadeWeight = this._isFadeOut ? 1 : 0;
                }
                if (this._fadeState != fadeState) {
                    //_fadeState == -1 && (fadeState == 0 || fadeState == 1)
                    if (this._fadeState == -1) {
                        fadeStartFlg = true;
                    }
                    //(_fadeState == -1 || _fadeState == 0) && fadeState == 1
                    if (fadeState == 1) {
                        fadeCompleteFlg = true;
                    }
                    this._fadeState = fadeState;
                }
            }
            var event;
            if (fadeStartFlg) {
                if (this._isFadeOut) {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_OUT)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_OUT);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
                else {
                    //动画开始，先隐藏不需要的骨头
                    this.hideBones();
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_IN)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_IN);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
            }
            if (fadeCompleteFlg) {
                if (this._isFadeOut) {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_OUT_COMPLETE)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_OUT_COMPLETE);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
                else {
                    if (this._armature.hasEventListener(dragonBones.AnimationEvent.FADE_IN_COMPLETE)) {
                        event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.FADE_IN_COMPLETE);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }
            }
        };
        p.advanceTimelinesTime = function (passedTime) {
            if (this._isPlaying && !this._pausePlayheadInFade) {
                this._time += passedTime;
            }
            var startFlg = false;
            var completeFlg = false;
            var loopCompleteFlg = false;
            var isThisComplete = false;
            var currentPlayTimes = 0;
            var currentTime = this._time * 1000;
            if (this._playTimes == 0) {
                isThisComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = this._playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    isThisComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    isThisComplete = true;
                }
                else {
                    isThisComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (isThisComplete) {
                    currentTime = this._totalTime;
                }
            }
            //update timeline
            this._isComplete = isThisComplete;
            var progress = this._time * 1000 / this._totalTime;
            var i = 0;
            var len = 0;
            for (i = 0, len = this._timelineStateList.length; i < len; i++) {
                var timeline = this._timelineStateList[i];
                timeline._update(progress);
                this._isComplete = timeline._isComplete && this._isComplete;
            }
            for (i = 0, len = this._slotTimelineStateList.length; i < len; i++) {
                var slotTimeline = this._slotTimelineStateList[i];
                slotTimeline._update(progress);
                this._isComplete = timeline._isComplete && this._isComplete;
            }
            for (i = 0, len = this._ffdTimelineStateList.length; i < len; i++) {
                var ffdTimeline = this._ffdTimelineStateList[i];
                ffdTimeline._update(progress);
                this._isComplete = ffdTimeline._isComplete && this._isComplete;
            }
            //update main timeline
            if (this._currentTime != currentTime) {
                if (this._currentPlayTimes != currentPlayTimes) {
                    if (this._currentPlayTimes > 0 && currentPlayTimes > 1) {
                        loopCompleteFlg = true;
                    }
                    this._currentPlayTimes = currentPlayTimes;
                }
                if (this._currentTime < 0) {
                    startFlg = true;
                }
                if (this._isComplete) {
                    completeFlg = true;
                }
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                /*
                if(isThisComplete)
                {
                currentTime = _totalTime * 0.999999;
                }
                //[0, _totalTime)
                */
                this.updateMainTimeline(isThisComplete);
            }
            var event;
            if (startFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.START)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.START);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
            }
            if (completeFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.COMPLETE);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
                if (this.autoFadeOut) {
                    this.fadeOut(this.fadeOutTime, true);
                }
            }
            else if (loopCompleteFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.LOOP_COMPLETE);
                    event.animationState = this;
                    this._armature._eventList.push(event);
                }
            }
        };
        p.updateMainTimeline = function (isThisComplete) {
            var frameList = this._clip.frameList;
            if (frameList.length > 0) {
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._clip.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (isThisComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = frameList[this._currentFrameIndex];
                    if (prevFrame) {
                        this._armature._arriveAtFrame(prevFrame, null, this, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._armature._arriveAtFrame(currentFrame, null, this, false);
                }
            }
        };
        p.hideBones = function () {
            for (var i = 0, len = this._clip.hideTimelineNameMap.length; i < len; i++) {
                var timelineName = this._clip.hideTimelineNameMap[i];
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    bone._hideSlots();
                }
            }
            var slotTimelineName;
            for (i = 0, len = this._clip.hideSlotTimelineNameMap.length; i < len; i++) {
                slotTimelineName = this._clip.hideSlotTimelineNameMap[i];
                var slot = this._armature.getSlot(slotTimelineName);
                if (slot) {
                    slot._resetToOrigin();
                }
            }
        };
        //属性访问
        p.setAdditiveBlending = function (value) {
            this.additiveBlending = value;
            return this;
        };
        p.setAutoFadeOut = function (value, fadeOutTime) {
            if (fadeOutTime === void 0) { fadeOutTime = -1; }
            this.autoFadeOut = value;
            if (fadeOutTime >= 0) {
                this.fadeOutTime = fadeOutTime * this._timeScale;
            }
            return this;
        };
        p.setWeight = function (value) {
            if (isNaN(value) || value < 0) {
                value = 1;
            }
            this.weight = value;
            return this;
        };
        p.setFrameTween = function (autoTween, lastFrameAutoTween) {
            this.autoTween = autoTween;
            this.lastFrameAutoTween = lastFrameAutoTween;
            return this;
        };
        p.setCurrentTime = function (value) {
            if (value < 0 || isNaN(value)) {
                value = 0;
            }
            this._time = value;
            this._currentTime = this._time * 1000;
            return this;
        };
        p.setTimeScale = function (value) {
            if (isNaN(value) || value == Infinity) {
                value = 1;
            }
            this._timeScale = value;
            return this;
        };
        p.setPlayTimes = function (value) {
            if (value === void 0) { value = 0; }
            //如果动画只有一帧  播放一次就可以
            if (Math.round(this._totalTime * 0.001 * this._clip.frameRate) < 2) {
                this._playTimes = value < 0 ? -1 : 1;
            }
            else {
                this._playTimes = value < 0 ? -value : value;
            }
            this.autoFadeOut = value < 0 ? true : false;
            return this;
        };
        d(p, "name"
            /**
             * 动画的名字
             * @member {string} dragonBones.AnimationState#name
             */
            ,function () {
                return this._name;
            }
        );
        d(p, "layer"
            /**
             * 动画所在的层
             * @member {number} dragonBones.AnimationState#layer
             */
            ,function () {
                return this._layer;
            }
        );
        d(p, "group"
            /**
             * 动画所在的组
             * @member {string} dragonBones.AnimationState#group
             */
            ,function () {
                return this._group;
            }
        );
        d(p, "clip"
            /**
             * 动画包含的动画数据
             * @member {AnimationData} dragonBones.AnimationState#clip
             */
            ,function () {
                return this._clip;
            }
        );
        d(p, "isComplete"
            /**
             * 是否播放完成
             * @member {boolean} dragonBones.AnimationState#isComplete
             */
            ,function () {
                return this._isComplete;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.AnimationState#isPlaying
             */
            ,function () {
                return (this._isPlaying && !this._isComplete);
            }
        );
        d(p, "currentPlayTimes"
            /**
             * 当前播放次数
             * @member {number} dragonBones.AnimationState#currentPlayTimes
             */
            ,function () {
                return this._currentPlayTimes < 0 ? 0 : this._currentPlayTimes;
            }
        );
        d(p, "totalTime"
            /**
             * 动画总时长（单位：秒）
             * @member {number} dragonBones.AnimationState#totalTime
             */
            ,function () {
                return this._totalTime * 0.001;
            }
        );
        d(p, "currentTime"
            /**
             * 动画当前播放时间（单位：秒）
             * @member {number} dragonBones.AnimationState#currentTime
             */
            ,function () {
                return this._currentTime < 0 ? 0 : this._currentTime * 0.001;
            }
        );
        d(p, "fadeWeight"
            ,function () {
                return this._fadeWeight;
            }
        );
        d(p, "fadeState"
            ,function () {
                return this._fadeState;
            }
        );
        d(p, "fadeTotalTime"
            ,function () {
                return this._fadeTotalTime;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放系数。用于调节动画播放速度
             * @member {number} dragonBones.AnimationState#timeScale
             */
            ,function () {
                return this._timeScale;
            }
        );
        d(p, "playTimes"
            /**
             * 播放次数 (0:循环播放， >0:播放次数)
             * @member {number} dragonBones.AnimationState#playTimes
             */
            ,function () {
                return this._playTimes;
            }
        );
        AnimationState._pool = [];
        return AnimationState;
    }());
    dragonBones.AnimationState = AnimationState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /** @private */
    var FFDTimelineState = (function () {
        function FFDTimelineState() {
            /** @private */
            this.skin = null;
            this.name = null;
            this.displayIndex = 0;
            this._isComplete = false;
            this._animationState = null;
            this._totalTime = 0;
            this._currentTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._tweenEasing = NaN;
            this._tweenCurve = null;
            this._tweenVertices = false;
            this._offset = 0;
            this._durationVertices = [];
            this._updateVertices = [];
            this._rawAnimationScale = 1;
            this._updateMode = 0;
            this._slot = null;
            this._timelineData = null;
        }
        var d = __define,c=FFDTimelineState,p=c.prototype;
        /** @private */
        FFDTimelineState._borrowObject = function () {
            if (FFDTimelineState._pool.length == 0) {
                return new FFDTimelineState();
            }
            return FFDTimelineState._pool.pop();
        };
        /** @private */
        FFDTimelineState._returnObject = function (timeline) {
            if (FFDTimelineState._pool.indexOf(timeline) < 0) {
                FFDTimelineState._pool[FFDTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        FFDTimelineState._clear = function () {
            var i = FFDTimelineState._pool.length;
            while (i--) {
                FFDTimelineState._pool[i].clear();
            }
            FFDTimelineState._pool.length = 0;
        };
        p.clear = function () {
            this._slot = null;
            this._animationState = null;
            this._timelineData = null;
        };
        //动画开始结束
        /** @private */
        p._fadeIn = function (slot, animationState, timelineData) {
            this._slot = slot;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this.skin = timelineData.skin;
            this.displayIndex = timelineData.displayIndex;
            this._totalTime = this._timelineData.duration;
            this._rawAnimationScale = this._animationState.clip.scale;
            this._isComplete = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
        };
        /** @private */
        p._fadeOut = function () {
        };
        //动画进行中
        /** @private */
        p._update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    if (currentTime >= 0) {
                        currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                    }
                    else {
                        currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                    }
                }
            }
            if (this._currentTime != currentTime) {
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration) {
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this.updateToNextFrame(currentPlayTimes);
                }
                if (this._tweenEasing == this._tweenEasing) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (!this._animationState.lastFrameAutoTween ||
                    (this._animationState.playTimes &&
                        this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                        ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999))) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.clip.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                this._offset = currentFrame.offset < nextFrame.offset ? currentFrame.offset : nextFrame.offset;
                var end = currentFrame.offset + currentFrame.vertices.length > nextFrame.offset + nextFrame.vertices.length ?
                    currentFrame.offset + currentFrame.vertices.length :
                    nextFrame.offset + nextFrame.vertices.length;
                this._durationVertices.length = end - this._offset;
                var curVertex;
                var nextVertex;
                this._tweenVertices = false;
                for (var i = this._offset; i < end; i++) {
                    curVertex = 0;
                    nextVertex = 0;
                    if (currentFrame.offset <= i && currentFrame.vertices.length + currentFrame.offset > i) {
                        curVertex = Number(currentFrame.vertices[i - currentFrame.offset]);
                    }
                    if (nextFrame.offset <= i && nextFrame.vertices.length + nextFrame.offset > i) {
                        nextVertex = Number(nextFrame.vertices[i - nextFrame.offset]);
                    }
                    this._durationVertices[i - this._offset] = nextVertex - curVertex;
                    if (this._durationVertices[i - this._offset] != 0) {
                        this._tweenVertices = true;
                    }
                }
            }
            else {
                this._tweenVertices = false;
                this._slot._updateFFD(currentFrame.vertices, currentFrame.offset);
            }
        };
        p.updateTween = function () {
            var currentFrame = this._timelineData.frameList[this._currentFrameIndex];
            if (this._tweenVertices && this._animationState.displayControl) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                var end = this._offset + this._durationVertices.length;
                this._updateVertices.length = this._durationVertices.length;
                var curVertex;
                for (var i = this._offset; i < end; i++) {
                    curVertex = 0;
                    if (currentFrame.offset <= i && currentFrame.vertices.length + currentFrame.offset > i) {
                        curVertex = Number(currentFrame.vertices[i - currentFrame.offset]);
                    }
                    this._updateVertices[i - this._offset] = curVertex + this._durationVertices[i - this._offset] * progress;
                }
                this._slot._updateFFD(this._updateVertices, this._offset);
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = this._timelineData.frameList[0];
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenVertices = false;
            if (this._animationState.displayControl) {
                this._slot._updateFFD(currentFrame.vertices, currentFrame.offset);
            }
        };
        FFDTimelineState._pool = [];
        return FFDTimelineState;
    }());
    dragonBones.FFDTimelineState = FFDTimelineState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimelineState
     * @classdesc
     * SlotTimelineState 负责计算 Slot 的时间轴动画。
     * SlotTimelineState 实例隶属于 AnimationState. AnimationState在创建时会为每个包含动作的 Slot生成一个 SlotTimelineState 实例.
     * @see dragonBones.Animation
     * @see dragonBones.AnimationState
     * @see dragonBones.Slot
     */
    var SlotTimelineState = (function () {
        function SlotTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=SlotTimelineState,p=c.prototype;
        /** @private */
        SlotTimelineState._borrowObject = function () {
            if (SlotTimelineState._pool.length == 0) {
                return new SlotTimelineState();
            }
            return SlotTimelineState._pool.pop();
        };
        /** @private */
        SlotTimelineState._returnObject = function (timeline) {
            if (SlotTimelineState._pool.indexOf(timeline) < 0) {
                SlotTimelineState._pool[SlotTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        SlotTimelineState._clear = function () {
            var i = SlotTimelineState._pool.length;
            while (i--) {
                SlotTimelineState._pool[i].clear();
            }
            SlotTimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._slot) {
                this._slot = null;
            }
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
        };
        //动画开始结束
        /** @private */
        p._fadeIn = function (slot, animationState, timelineData) {
            this._slot = slot;
            this._armature = this._slot.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._rawAnimationScale = this._animationState.clip.scale;
            this._isComplete = false;
            this._blendEnabled = false;
            this._tweenColor = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
        };
        /** @private */
        p._fadeOut = function () {
        };
        //动画进行中
        /** @private */
        p._update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    if (currentTime >= 0) {
                        currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                    }
                    else {
                        currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                    }
                }
            }
            if (this._currentTime != currentTime) {
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration) {
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._slot._arriveAtFrame(prevFrame, this, this._animationState, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._slot._arriveAtFrame(currentFrame, this, this._animationState, false);
                    this._blendEnabled = currentFrame.displayIndex >= 0;
                    if (this._blendEnabled) {
                        this.updateToNextFrame(currentPlayTimes);
                    }
                    else {
                        this._tweenEasing = NaN;
                        this._tweenColor = false;
                    }
                }
                if (this._blendEnabled) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (!this._animationState.lastFrameAutoTween ||
                    (this._animationState.playTimes &&
                        this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                        ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999))) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.clip.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //color
                if (currentFrame.color && nextFrame.color) {
                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset - currentFrame.color.alphaOffset;
                    this._durationColor.redOffset = nextFrame.color.redOffset - currentFrame.color.redOffset;
                    this._durationColor.greenOffset = nextFrame.color.greenOffset - currentFrame.color.greenOffset;
                    this._durationColor.blueOffset = nextFrame.color.blueOffset - currentFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - currentFrame.color.alphaMultiplier;
                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - currentFrame.color.redMultiplier;
                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - currentFrame.color.greenMultiplier;
                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - currentFrame.color.blueMultiplier;
                    if (this._durationColor.alphaOffset ||
                        this._durationColor.redOffset ||
                        this._durationColor.greenOffset ||
                        this._durationColor.blueOffset ||
                        this._durationColor.alphaMultiplier ||
                        this._durationColor.redMultiplier ||
                        this._durationColor.greenMultiplier ||
                        this._durationColor.blueMultiplier) {
                        this._tweenColor = true;
                    }
                    else {
                        this._tweenColor = false;
                    }
                }
                else if (currentFrame.color) {
                    this._tweenColor = true;
                    this._durationColor.alphaOffset = -currentFrame.color.alphaOffset;
                    this._durationColor.redOffset = -currentFrame.color.redOffset;
                    this._durationColor.greenOffset = -currentFrame.color.greenOffset;
                    this._durationColor.blueOffset = -currentFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = 1 - currentFrame.color.alphaMultiplier;
                    this._durationColor.redMultiplier = 1 - currentFrame.color.redMultiplier;
                    this._durationColor.greenMultiplier = 1 - currentFrame.color.greenMultiplier;
                    this._durationColor.blueMultiplier = 1 - currentFrame.color.blueMultiplier;
                }
                else if (nextFrame.color) {
                    this._tweenColor = true;
                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset;
                    this._durationColor.redOffset = nextFrame.color.redOffset;
                    this._durationColor.greenOffset = nextFrame.color.greenOffset;
                    this._durationColor.blueOffset = nextFrame.color.blueOffset;
                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - 1;
                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - 1;
                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - 1;
                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - 1;
                }
                else {
                    this._tweenColor = false;
                }
            }
            else {
                this._tweenColor = false;
            }
            if (!this._tweenColor && this._animationState.displayControl) {
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset, currentFrame.color.redOffset, currentFrame.color.greenOffset, currentFrame.color.blueOffset, currentFrame.color.alphaMultiplier, currentFrame.color.redMultiplier, currentFrame.color.greenMultiplier, currentFrame.color.blueMultiplier, true);
                }
                else if (this._slot._isColorChanged) {
                    this._slot._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenColor && this._animationState.displayControl) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, currentFrame.color.redOffset + this._durationColor.redOffset * progress, currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true);
                }
                else {
                    this._slot._updateDisplayColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, 1 + this._durationColor.alphaMultiplier * progress, 1 + this._durationColor.redMultiplier * progress, 1 + this._durationColor.greenMultiplier * progress, 1 + this._durationColor.blueMultiplier * progress, true);
                }
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._slot._arriveAtFrame(currentFrame, this, this._animationState, false);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenColor = false;
            this._blendEnabled = currentFrame.displayIndex >= 0;
            if (this._blendEnabled) {
                /**
                 * <使用绝对数据>
                 * 单帧的timeline，第一个关键帧的transform为0
                 * timeline.originTransform = firstFrame.transform;
                 * eachFrame.transform = eachFrame.transform - timeline.originTransform;
                 * firstFrame.transform == 0;
                 *
                 * <使用相对数据>
                 * 使用相对数据时，timeline.originTransform = 0，第一个关键帧的transform有可能不为 0
                 */
                if (this._animationState.displayControl) {
                    if (currentFrame.color) {
                        this._slot._updateDisplayColor(currentFrame.color.alphaOffset, currentFrame.color.redOffset, currentFrame.color.greenOffset, currentFrame.color.blueOffset, currentFrame.color.alphaMultiplier, currentFrame.color.redMultiplier, currentFrame.color.greenMultiplier, currentFrame.color.blueMultiplier, true);
                    }
                    else if (this._slot._isColorChanged) {
                        this._slot._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                    }
                }
            }
        };
        SlotTimelineState.HALF_PI = Math.PI * 0.5;
        SlotTimelineState.DOUBLE_PI = Math.PI * 2;
        SlotTimelineState._pool = [];
        return SlotTimelineState;
    }());
    dragonBones.SlotTimelineState = SlotTimelineState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TimelineState
     * @classdesc
     * TimelineState 负责计算 Bone 的时间轴动画。
     * TimelineState 实例隶属于 AnimationState. AnimationState在创建时会为每个包含动作的 Bone生成一个 TimelineState 实例.
     * @see dragonBones.Animation
     * @see dragonBones.AnimationState
     * @see dragonBones.Bone
     */
    var TimelineState = (function () {
        function TimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._lastTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._transform = new dragonBones.DBTransform();
            this._pivot = new dragonBones.Point();
            this._durationTransform = new dragonBones.DBTransform();
            this._durationPivot = new dragonBones.Point();
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=TimelineState,p=c.prototype;
        /** @private */
        TimelineState._borrowObject = function () {
            if (TimelineState._pool.length == 0) {
                return new TimelineState();
            }
            return TimelineState._pool.pop();
        };
        /** @private */
        TimelineState._returnObject = function (timeline) {
            if (TimelineState._pool.indexOf(timeline) < 0) {
                TimelineState._pool[TimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        TimelineState._clear = function () {
            var i = TimelineState._pool.length;
            while (i--) {
                TimelineState._pool[i].clear();
            }
            TimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._bone) {
                this._bone._removeState(this);
                this._bone = null;
            }
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
            this._originTransform = null;
            this._originPivot = null;
        };
        //动画开始结束
        /** @private */
        p._fadeIn = function (bone, animationState, timelineData) {
            this._bone = bone;
            this._armature = this._bone.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this._originTransform = this._timelineData.originTransform;
            this._originPivot = this._timelineData.originPivot;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._rawAnimationScale = this._animationState.clip.scale;
            this._isComplete = false;
            this._tweenTransform = false;
            this._tweenScale = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            this._transform.x = 0;
            this._transform.y = 0;
            this._transform.scaleX = 1;
            this._transform.scaleY = 1;
            this._transform.skewX = 0;
            this._transform.skewY = 0;
            this._pivot.x = 0;
            this._pivot.y = 0;
            this._durationTransform.x = 0;
            this._durationTransform.y = 0;
            this._durationTransform.scaleX = 1;
            this._durationTransform.scaleY = 1;
            this._durationTransform.skewX = 0;
            this._durationTransform.skewY = 0;
            this._durationPivot.x = 0;
            this._durationPivot.y = 0;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
            this._bone._addState(this);
        };
        /** @private */
        p._fadeOut = function () {
            this._transform.skewX = dragonBones.TransformUtil.formatRadian(this._transform.skewX);
            this._transform.skewY = dragonBones.TransformUtil.formatRadian(this._transform.skewY);
        };
        //动画进行中
        /** @private */
        p._update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                if (currentTime >= 0) {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
                else {
                    currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                }
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    if (currentTime >= 0) {
                        currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                    }
                    else {
                        currentTime -= Math.ceil(currentTime / this._totalTime) * this._totalTime;
                    }
                }
            }
            if (this._currentTime != currentTime) {
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._bone._arriveAtFrame(prevFrame, this, this._animationState, true);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._bone._arriveAtFrame(currentFrame, this, this._animationState, false);
                    this.updateToNextFrame(currentPlayTimes);
                }
                this.updateTween();
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (!this._animationState.lastFrameAutoTween ||
                    (this._animationState.playTimes &&
                        this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                        ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999))) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.clip.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //transform
                this._durationTransform.x = nextFrame.transform.x - currentFrame.transform.x;
                this._durationTransform.y = nextFrame.transform.y - currentFrame.transform.y;
                this._durationTransform.skewX = nextFrame.transform.skewX - currentFrame.transform.skewX;
                this._durationTransform.skewY = nextFrame.transform.skewY - currentFrame.transform.skewY;
                this._durationTransform.scaleX = nextFrame.transform.scaleX - currentFrame.transform.scaleX + nextFrame.scaleOffset.x;
                this._durationTransform.scaleY = nextFrame.transform.scaleY - currentFrame.transform.scaleY + nextFrame.scaleOffset.y;
                this._durationTransform.normalizeRotation();
                if (nextFrameIndex == 0) {
                    this._durationTransform.skewX = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewX);
                    this._durationTransform.skewY = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewY);
                }
                this._durationPivot.x = nextFrame.pivot.x - currentFrame.pivot.x;
                this._durationPivot.y = nextFrame.pivot.y - currentFrame.pivot.y;
                if (this._durationTransform.x ||
                    this._durationTransform.y ||
                    this._durationTransform.skewX ||
                    this._durationTransform.skewY ||
                    this._durationTransform.scaleX ||
                    this._durationTransform.scaleY ||
                    this._durationPivot.x ||
                    this._durationPivot.y) {
                    this._tweenTransform = true;
                    this._tweenScale = currentFrame.tweenScale;
                }
                else {
                    this._tweenTransform = false;
                    this._tweenScale = false;
                }
            }
            else {
                this._tweenTransform = false;
                this._tweenScale = false;
            }
            if (!this._tweenTransform) {
                if (this._animationState.additiveBlending) {
                    this._transform.x = currentFrame.transform.x;
                    this._transform.y = currentFrame.transform.y;
                    this._transform.skewX = currentFrame.transform.skewX;
                    this._transform.skewY = currentFrame.transform.skewY;
                    this._transform.scaleX = currentFrame.transform.scaleX;
                    this._transform.scaleY = currentFrame.transform.scaleY;
                    this._pivot.x = currentFrame.pivot.x;
                    this._pivot.y = currentFrame.pivot.y;
                }
                else {
                    this._transform.x = this._originTransform.x + currentFrame.transform.x;
                    this._transform.y = this._originTransform.y + currentFrame.transform.y;
                    this._transform.skewX = this._originTransform.skewX + currentFrame.transform.skewX;
                    this._transform.skewY = this._originTransform.skewY + currentFrame.transform.skewY;
                    this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                    this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                    this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                    this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
                }
                this._bone.invalidUpdate();
            }
            else if (!this._tweenScale) {
                if (this._animationState.additiveBlending) {
                    this._transform.scaleX = currentFrame.transform.scaleX;
                    this._transform.scaleY = currentFrame.transform.scaleY;
                }
                else {
                    this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                    this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenTransform) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                var currentTransform = currentFrame.transform;
                var currentPivot = currentFrame.pivot;
                if (this._animationState.additiveBlending) {
                    //additive blending
                    this._transform.x = currentTransform.x + this._durationTransform.x * progress;
                    this._transform.y = currentTransform.y + this._durationTransform.y * progress;
                    this._transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress;
                    this._transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress;
                    if (this._tweenScale) {
                        this._transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress;
                        this._transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress;
                    }
                    this._pivot.x = currentPivot.x + this._durationPivot.x * progress;
                    this._pivot.y = currentPivot.y + this._durationPivot.y * progress;
                }
                else {
                    //normal blending
                    this._transform.x = this._originTransform.x + currentTransform.x + this._durationTransform.x * progress;
                    this._transform.y = this._originTransform.y + currentTransform.y + this._durationTransform.y * progress;
                    this._transform.skewX = this._originTransform.skewX + currentTransform.skewX + this._durationTransform.skewX * progress;
                    this._transform.skewY = this._originTransform.skewY + currentTransform.skewY + this._durationTransform.skewY * progress;
                    if (this._tweenScale) {
                        this._transform.scaleX = this._originTransform.scaleX * currentTransform.scaleX + this._durationTransform.scaleX * progress;
                        this._transform.scaleY = this._originTransform.scaleY * currentTransform.scaleY + this._durationTransform.scaleY * progress;
                    }
                    this._pivot.x = this._originPivot.x + currentPivot.x + this._durationPivot.x * progress;
                    this._pivot.y = this._originPivot.y + currentPivot.y + this._durationPivot.y * progress;
                }
                this._bone.invalidUpdate();
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._bone._arriveAtFrame(currentFrame, this, this._animationState, false);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenTransform = false;
            this._tweenScale = false;
            this._tweenColor = false;
            /**
             * <使用绝对数据>
             * 单帧的timeline，第一个关键帧的transform为0
             * timeline.originTransform = firstFrame.transform;
             * eachFrame.transform = eachFrame.transform - timeline.originTransform;
             * firstFrame.transform == 0;
             *
             * <使用相对数据>
             * 使用相对数据时，timeline.originTransform = 0，第一个关键帧的transform有可能不为 0
             */
            if (this._animationState.additiveBlending) {
                this._transform.x = currentFrame.transform.x;
                this._transform.y = currentFrame.transform.y;
                this._transform.skewX = currentFrame.transform.skewX;
                this._transform.skewY = currentFrame.transform.skewY;
                this._transform.scaleX = currentFrame.transform.scaleX;
                this._transform.scaleY = currentFrame.transform.scaleY;
                this._pivot.x = currentFrame.pivot.x;
                this._pivot.y = currentFrame.pivot.y;
            }
            else {
                this._transform.x = this._originTransform.x + currentFrame.transform.x;
                this._transform.y = this._originTransform.y + currentFrame.transform.y;
                this._transform.skewX = this._originTransform.skewX + currentFrame.transform.skewX;
                this._transform.skewY = this._originTransform.skewY + currentFrame.transform.skewY;
                this._transform.scaleX = this._originTransform.scaleX * currentFrame.transform.scaleX;
                this._transform.scaleY = this._originTransform.scaleY * currentFrame.transform.scaleY;
                this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
            }
            this._bone.invalidUpdate();
        };
        TimelineState.HALF_PI = Math.PI * 0.5;
        TimelineState.DOUBLE_PI = Math.PI * 2;
        TimelineState._pool = [];
        return TimelineState;
    }());
    dragonBones.TimelineState = TimelineState;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.WorldClock
     * @classdesc
     * WorldClock 提供时钟的支持，为控制每个加入时钟的 IAnimatable 对象正确的播放动画。
     * 一般来说，每当 Armature 被创建出来后，只需要将之加入 WorldClock,之后只需要控制 WorldClock 的前进，就可以实现所有 Armature 的动画前进了
     * @see dragonBones.IAnimatable
     * @see dragonBones.Armature
     */
    var WorldClock = (function () {
        /**
         * 创建一个新的 WorldClock 实例。
         * 一般来说，不需要单独创建 WorldClock 的实例，可以直接使用 WorldClock.clock 静态实例就可以了。
         * @param time {number} 开始时间
         * @param timeScale {number} 时间缩放系数
         */
        function WorldClock(time, timeScale) {
            if (time === void 0) { time = -1; }
            if (timeScale === void 0) { timeScale = 1; }
            this._time = time >= 0 ? time : new Date().getTime() * 0.001;
            this._timeScale = isNaN(timeScale) ? 1 : timeScale;
            this._animatableList = [];
        }
        var d = __define,c=WorldClock,p=c.prototype;
        d(p, "time"
            ,function () {
                return this._time;
            }
        );
        d(p, "timeScale"
            /**
             * 时间缩放系数。用于实现动画的变速播放
             * @member {number} dragonBones.WorldClock#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        /**
         * 检查是否包含指定的 IAnimatable 实例
         * @param animatable {IAnimatable} IAnimatable 实例
         * @returns {boolean}
         */
        p.contains = function (animatable) {
            return this._animatableList.indexOf(animatable) >= 0;
        };
        /**
         * 将一个 IAnimatable 实例加入到时钟
         * @param animatable {IAnimatable} IAnimatable 实例
         */
        p.add = function (animatable) {
            if (animatable && this._animatableList.indexOf(animatable) == -1) {
                this._animatableList.push(animatable);
            }
        };
        /**
         * 将一个 IAnimatable 实例从时钟中移除
         * @param animatable {IAnimatable} IAnimatable 实例
         */
        p.remove = function (animatable) {
            var index = this._animatableList.indexOf(animatable);
            if (index >= 0) {
                this._animatableList[index] = null;
            }
        };
        /**
         * 从时钟中移除所有的 IAnimatable 实例.
         */
        p.clear = function () {
            this._animatableList.length = 0;
        };
        /**
         * 更新所有包含的 IAnimatable 实例，将他们的动画向前播放指定的时间。一般来说，这个方法需要在 ENTERFRAME 事件的响应函数中被调用
         * @param passedTime {number} 前进的时间，默认值为-1，DragonBones会自动为你计算当前帧与上一帧的时间差
         */
        p.advanceTime = function (passedTime) {
            if (passedTime === void 0) { passedTime = -1; }
            if (passedTime < 0) {
                passedTime = new Date().getTime() * 0.001 - this._time;
            }
            passedTime *= this._timeScale;
            this._time += passedTime;
            this._length = this._animatableList.length;
            if (this._length == 0) {
                return;
            }
            this._currentIndex = 0;
            for (this._i = 0; this._i < this._length; this._i++) {
                this._animatable = this._animatableList[this._i];
                if (this._animatable) {
                    if (this._currentIndex != this._i) {
                        this._animatableList[this._currentIndex] = this._animatable;
                        this._animatableList[this._i] = null;
                    }
                    this._animatable.advanceTime(passedTime);
                    this._currentIndex++;
                }
            }
            if (this._currentIndex != this._i) {
                this._length = this._animatableList.length;
                while (this._i < this._length) {
                    this._animatableList[this._currentIndex++] = this._animatableList[this._i++];
                }
                this._animatableList.length = this._currentIndex;
            }
        };
        /**
         * 可以直接使用的全局静态时钟实例.
         * @type dragonBones.WorldClock
         */
        WorldClock.clock = new WorldClock();
        return WorldClock;
    }());
    dragonBones.WorldClock = WorldClock;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.EventDispatcher
     * @classdesc
     * 事件派发者
     */
    //var EventDispatcher = (function (_super) {
    //    __extends(EventDispatcher, _super);
    //    function EventDispatcher(target) {
    //        if (target === void 0) { target = null; }
    //        _super.call(this, target);
    //    }
    //    var d = __define,c=EventDispatcher;p=c.prototype;
    //    return EventDispatcher;
    //})(egret.EventDispatcher);
	var EventDispatcher = (function () {
        function EventDispatcher() {
        }
        EventDispatcher.prototype.hasEventListener = function (type) {
            if (this._listenersMap && this._listenersMap[type]) {
                return true;
            }
            return false;
        };

        EventDispatcher.prototype.addEventListener = function (type, listener) {
            if (type && listener) {
                if (!this._listenersMap) {
                    this._listenersMap = {};
                }
                var listeners = this._listenersMap[type];
                if (listeners) {
                    this.removeEventListener(type, listener);
                }
                if (listeners) {
                    listeners.push(listener);
                } else {
                    this._listenersMap[type] = [listener];
                }
            }
        };

        EventDispatcher.prototype.removeEventListener = function (type, listener) {
            if (!this._listenersMap || !type || !listener) {
                return;
            }
            var listeners = this._listenersMap[type];
            if (listeners) {
                var length = listeners.length;
                for (var i = 0; i < length; i++) {
                	//FIX BY LC
                    //if (listeners[i] == listener) {
                    if (listeners[i].toString() === listener.toString()) {
                        if (length == 1) {
                            listeners.length = 0;
                            //FIX BY LC
                            //delete this._listenersMap[type];
                        } else {
                            listeners.splice(i, 1);
                        }
                    }
                }
            }
        };

        EventDispatcher.prototype.removeAllEventListeners = function (type) {
            if (type) {
                delete this._listenersMap[type];
            } else {
                this._listenersMap = null;
            }
        };

        EventDispatcher.prototype.dispatchEvent = function (event) {
            if (event) {
                var listeners = this._listenersMap[event.type];
                if (listeners) {
                    event.target = this;
                    var listenersCopy = listeners.concat();
                    var length = listeners.length;
                    for (var i = 0; i < length; i++) {
                        listenersCopy[i](event);
                    }
                }
            }
        };
        return EventDispatcher;
    })();
    dragonBones.EventDispatcher = EventDispatcher;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var SoundEventManager = (function (_super) {
        __extends(SoundEventManager, _super);
        function SoundEventManager() {
            _super.call(this);
            if (SoundEventManager._instance) {
                throw new Error("Singleton already constructed!");
            }
        }
        var d = __define,c=SoundEventManager,p=c.prototype;
        SoundEventManager.getInstance = function () {
            if (!SoundEventManager._instance) {
                SoundEventManager._instance = new SoundEventManager();
            }
            return SoundEventManager._instance;
        };
        return SoundEventManager;
    }(dragonBones.EventDispatcher));
    dragonBones.SoundEventManager = SoundEventManager;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Armature
     * @classdesc
     * Armature 是 DragonBones 骨骼动画系统的核心。他包含需要加到场景的显示对象，所有的骨骼逻辑和动画系统
     * A Armature instance is the core of the skeleton animation system. It contains the object to display, all sub-bones and the object animation(s).
     * @extends dragonBones.EventDispatcher
     * @see dragonBones.ArmatureData
     * @example
     * <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);
        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Armature = (function (_super) {
        __extends(Armature, _super);
        function Armature(display) {
            _super.call(this);
            this._boneIKList = [];
            this._display = display;
            this._animation = new dragonBones.Animation(this);
            this._slotsZOrderChanged = false;
            this._slotList = [];
            this._boneList = [];
            this._eventList = [];
            this._ikList = [];
            this._delayDispose = false;
            this._lockDispose = false;
            this._armatureData = null;
        }
        var d = __define,c=Armature,p=c.prototype;
        d(p, "armatureData"
            /**
             * 骨架数据。
             * @member {ArmatureData} dragonBones.Armature#armatureData
             */
            ,function () {
                return this._armatureData;
            }
        );
        d(p, "display"
            /**
             * 骨架显示对象。骨架创建出来后，需要把该显示对象加到场景中才能显示骨架。
             * 使用根据不同的渲染引擎，显示对象的类型可能不同。
             * @member {any} dragonBones.Armature#display
             */
            ,function () {
                return this._display;
            }
        );
        /**
         * 不推荐的API,使用 display 属性代替。
         */
        p.getDisplay = function () {
            return this._display;
        };
        d(p, "animation"
            /**
             * 骨架的动画实例。
             * @member {Animation} dragonBones.Armature#animation
             */
            ,function () {
                return this._animation;
            }
        );
        /**
         * 清理骨架实例
         */
        p.dispose = function () {
            this._delayDispose = true;
            if (!this._animation || this._lockDispose) {
                return;
            }
            this.userData = null;
            this._animation.dispose();
            var i = this._slotList.length;
            while (i--) {
                this._slotList[i].dispose();
            }
            i = this._boneList.length;
            while (i--) {
                this._boneList[i].dispose();
            }
            i = this._ikList.length;
            while (i--) {
                this._ikList[i].dispose();
            }
            this._armatureData = null;
            this._animation = null;
            this._slotList = null;
            this._boneList = null;
            this._eventList = null;
            this._ikList = null;
            //_display = null;
        };
        /**
         * 在下一帧强制更新指定名称的 Bone 及其包含的所有 Slot 的动画。
         * @param boneName {string} 骨头名。 默认值：null，相当于更新所有骨头。
         */
        p.invalidUpdate = function (boneName) {
            if (boneName === void 0) { boneName = null; }
            if (boneName) {
                var bone = this.getBone(boneName);
                if (bone) {
                    bone.invalidUpdate();
                }
            }
            else {
                var i = this._boneList.length;
                while (i--) {
                    this._boneList[i].invalidUpdate();
                }
            }
        };
        /**
         * 使用这个方法更新动画状态。一般来说，这个方法需要在 ENTERFRAME 事件的响应函数中被调用
         * @param passedTime 动画向前播放的时间（单位：秒）
         */
        p.advanceTime = function (passedTime) {
            this._lockDispose = true;
            this._animation._advanceTime(passedTime);
            passedTime *= this._animation.timeScale; //_animation's time scale will impact childArmature
            this._isFading = this._animation._isFading;
            var len = this._boneIKList.length;
            var bone;
            var j;
            var jLen;
            for (this._i = 0; this._i < len; this._i++) {
                for (j = 0, jLen = this._boneIKList[this._i].length; j < jLen; j++) {
                    bone = this._boneIKList[this._i][j];
                    if (bone.isIKConstraint) {
                        var ikCon = this._ikList[this._i - 1];
                        if (ikCon.bones[0].name == bone.name) {
                            bone._update(this._isFading);
                            bone.rotationIK = bone.global.rotation;
                            if (ikCon.bones.length > 1) {
                                ikCon.bones[1]._update(this._isFading);
                                ikCon.bones[1].rotationIK = ikCon.bones[1].global.rotation;
                            }
                            ikCon.compute();
                        }
                        bone.adjustGlobalTransformMatrixByIK();
                    }
                    else {
                        bone._update(this._isFading);
                        bone.rotationIK = bone.global.rotation;
                    }
                }
            }
            this._i = this._slotList.length;
            while (this._i--) {
                this._tmpSlot = this._slotList[this._i];
                this._tmpSlot._update();
                if (this._tmpSlot._isShowDisplay) {
                    var childArmature = this._tmpSlot.childArmature;
                    if (childArmature) {
                        childArmature.advanceTime(passedTime);
                    }
                }
            }
            if (this._slotsZOrderChanged) {
                this.updateSlotsZOrder();
                if (this.hasEventListener(dragonBones.ArmatureEvent.Z_ORDER_UPDATED)) {
                    this.dispatchEvent(new dragonBones.ArmatureEvent(dragonBones.ArmatureEvent.Z_ORDER_UPDATED));
                }
            }
            if (this._eventList.length > 0) {
                for (this._i = 0, this._len = this._eventList.length; this._i < this._len; this._i++) {
                    var event = this._eventList[this._i];
                    this.dispatchEvent(event);
                }
                this._eventList.length = 0;
            }
            this._lockDispose = false;
            if (this._delayDispose) {
                this.dispose();
            }
        };
        p.resetAnimation = function () {
            this.animation.stop();
            this.animation._resetAnimationStateList();
            for (var i = 0, len = this._boneList.length; i < len; i++) {
                this._boneList[i]._removeAllStates();
            }
        };
        /**
         * 获取骨架包含的所有插槽
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Slot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._slotList.concat() : this._slotList;
        };
        /**
         * 获取指定名称的 Slot
         * @param slotName {string} Slot名称
         * @returns {Slot}
         */
        p.getSlot = function (slotName) {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var slot = this._slotList[i];
                if (slot.name == slotName) {
                    return slot;
                }
            }
            return null;
        };
        /**
         * 获取包含指定显示对象的 Slot
         * @param displayObj {any} 显示对象实例
         * @returns {Slot}
         */
        p.getSlotByDisplay = function (displayObj) {
            if (displayObj) {
                var length = this._slotList.length;
                for (var i = 0; i < length; i++) {
                    var slot = this._slotList[i];
                    if (slot.display == displayObj) {
                        return slot;
                    }
                }
            }
            return null;
        };
        /**
         * 为指定名称的 Bone 添加一个子 Slot
         * @param slot {Slot} Slot 实例
         * @param boneName {string}
         * @see dragonBones.Bone
         */
        p.addSlot = function (slot, boneName) {
            var bone = this.getBone(boneName);
            if (bone) {
                bone.addSlot(slot);
            }
            else {
                throw new Error();
            }
        };
        /**
         * 移除指定的Slot
         * @param slot {Slot} Slot 实例
         */
        p.removeSlot = function (slot) {
            if (!slot || slot.armature != this) {
                throw new Error();
            }
            slot.parent.removeSlot(slot);
        };
        /**
         * 移除指定名称的Slot
         * @param slotName {string} Slot 名称
         * @returns {Slot} 被成功移除的 Slot 实例
         */
        p.removeSlotByName = function (slotName) {
            var slot = this.getSlot(slotName);
            if (slot) {
                this.removeSlot(slot);
            }
            return slot;
        };
        /**
         * 获取骨架包含的所有Bone
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Bone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._boneList.concat() : this._boneList;
        };
        /**
         * 获取指定名称的 Bone
         * @param boneName {string} Bone名称
         * @returns {Bone}
         */
        p.getBone = function (boneName) {
            var length = this._boneList.length;
            for (var i = 0; i < length; i++) {
                var bone = this._boneList[i];
                if (bone.name == boneName) {
                    return bone;
                }
            }
            return null;
        };
        /**
         * 获取包含指定显示对象的 Bone
         * @param display {any} 显示对象实例
         * @returns {Bone}
         */
        p.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot ? slot.parent : null;
        };
        /**
         * 在骨架中为指定名称的 Bone 添加一个子 Bone
         * @param bone {Bone} Bone 实例
         * @param parentName {string} 父骨头名称 默认：null
         * @param updateLater {boolean} 是否延迟更新 默认：false，当需要一次添加很多Bone时，开启延迟更新能够提高效率
         */
        p.addBone = function (bone, parentName, updateLater) {
            if (parentName === void 0) { parentName = null; }
            if (updateLater === void 0) { updateLater = false; }
            var parentBone;
            if (parentName) {
                parentBone = this.getBone(parentName);
                if (!parentBone) {
                    throw new Error();
                }
            }
            if (parentBone) {
                parentBone.addChildBone(bone, updateLater);
            }
            else {
                if (bone.parent) {
                    bone.parent.removeChildBone(bone, updateLater);
                }
                bone._setArmature(this);
                if (!updateLater) {
                    this._updateAnimationAfterBoneListChanged();
                }
            }
        };
        /**
         * 移除指定的 Bone
         * @param bone {Bone} Bone 实例
         * @param updateLater {boolean} 是否延迟更新 默认：false，当需要一次移除很多Bone时，开启延迟更新能够提高效率
         */
        p.removeBone = function (bone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!bone || bone.armature != this) {
                throw new Error();
            }
            if (bone.parent) {
                bone.parent.removeChildBone(bone, updateLater);
            }
            else {
                bone._setArmature(null);
                if (!updateLater) {
                    this._updateAnimationAfterBoneListChanged(false);
                }
            }
        };
        /**
         * 移除指定名称的 Bone
         * @param boneName {string} Bone 名称
         * @returns {Bone} 被成功移除的 Bone 实例
         */
        p.removeBoneByName = function (boneName) {
            var bone = this.getBone(boneName);
            if (bone) {
                this.removeBone(bone);
            }
            return bone;
        };
        /** @private */
        p._addBoneToBoneList = function (bone) {
            if (this._boneList.indexOf(bone) < 0) {
                this._boneList[this._boneList.length] = bone;
            }
        };
        /** @private */
        p._removeBoneFromBoneList = function (bone) {
            var index = this._boneList.indexOf(bone);
            if (index >= 0) {
                this._boneList.splice(index, 1);
            }
        };
        /** @private */
        p._addSlotToSlotList = function (slot) {
            if (this._slotList.indexOf(slot) < 0) {
                this._slotList[this._slotList.length] = slot;
            }
        };
        /** @private */
        p._removeSlotFromSlotList = function (slot) {
            var index = this._slotList.indexOf(slot);
            if (index >= 0) {
                this._slotList.splice(index, 1);
            }
        };
        /**
         * 按照显示层级为所有 Slot 排序
         */
        p.updateSlotsZOrder = function () {
            this._slotList.sort(this.sortSlot);
            var i = this._slotList.length;
            while (i--) {
                var slot = this._slotList[i];
                if (slot._isShowDisplay) {
                    //_display 实际上是container, 这个方法就是把原来的显示对象放到container中的第一个
                    slot._addDisplayToContainer(this._display);
                }
            }
            this._slotsZOrderChanged = false;
        };
        p._updateAnimationAfterBoneListChanged = function (ifNeedSortBoneList) {
            if (ifNeedSortBoneList === void 0) { ifNeedSortBoneList = true; }
            if (ifNeedSortBoneList) {
                this.sortBoneList();
            }
            this._animation._updateTimelineStates = true;
        };
        p.sortBoneList = function () {
            var i = this._boneList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var level = 0;
                var bone = this._boneList[i];
                var boneParent = bone;
                while (boneParent) {
                    level++;
                    boneParent = boneParent.parent;
                }
                helpArray[i] = [level, bone];
            }
            helpArray.sort(dragonBones.ArmatureData.sortBoneDataHelpArrayDescending);
            i = helpArray.length;
            while (i--) {
                this._boneList[i] = helpArray[i][1];
            }
            helpArray.length = 0;
        };
        /** @private When AnimationState enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            if (frame.event && this.hasEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT);
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this._eventList.push(frameEvent);
            }
            if (frame.sound && Armature._soundManager.hasEventListener(dragonBones.SoundEvent.SOUND)) {
                var soundEvent = new dragonBones.SoundEvent(dragonBones.SoundEvent.SOUND);
                soundEvent.armature = this;
                soundEvent.animationState = animationState;
                soundEvent.sound = frame.sound;
                Armature._soundManager.dispatchEvent(soundEvent);
            }
            //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
            //后续会扩展更多的action，目前只有gotoAndPlay的含义
            if (frame.action) {
                if (animationState.displayControl) {
                    this.animation.gotoAndPlay(frame.action);
                }
            }
        };
        p.sortSlot = function (slot1, slot2) {
            return slot1.zOrder < slot2.zOrder ? 1 : -1;
        };
        /**
         * 获取Animation实例
         * @returns {any} Animation实例
         */
        p.getAnimation = function () {
            return this._animation;
        };
        p.getIKs = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._ikList.concat() : this._ikList;
        };
        p.buildIK = function () {
            var ikConstraintData;
            this._ikList.length = 0;
            for (var i = 0, len = this._armatureData.ikDataList.length; i < len; i++) {
                ikConstraintData = this._armatureData.ikDataList[i];
                this._ikList.push(new dragonBones.IKConstraint(ikConstraintData, this));
            }
        };
        p.updateBoneCache = function () {
            this._boneList.reverse();
            var temp = {};
            var ikConstraintsCount = this._ikList.length;
            var arrayCount = ikConstraintsCount + 1;
            var i;
            var len;
            var j;
            var jLen;
            var bone;
            var currentBone;
            this._boneIKList = [];
            while (this._boneIKList.length < arrayCount) {
                this._boneIKList[this._boneIKList.length] = [];
            }
            temp[this._boneList[0].name] = 0;
            for (i = 0, len = this._ikList.length; i < len; i++) {
                temp[this._ikList[i].bones[0].name] = i + 1;
            }
            next: for (i = 0, len = this._boneList.length; i < len; i++) {
                bone = this._boneList[i];
                currentBone = bone;
                while (currentBone) {
                    if (currentBone.parent == null) {
                        temp[currentBone.name] = 0;
                    }
                    if (temp.hasOwnProperty(currentBone.name)) {
                        this._boneIKList[temp[currentBone.name]].push(bone);
                        continue next;
                    }
                    currentBone = currentBone.parent;
                }
            }
        };
        p.getIKTargetData = function (bone) {
            var target = [];
            var ik;
            for (var i = 0, len = this._ikList.length; i < len; i++) {
                ik = this._ikList[i];
                if (bone.name == ik.target.name) {
                    target.push(ik);
                }
            }
            return target;
        };
        /**
         * The instance dispatch sound event.
         */
        Armature._soundManager = dragonBones.SoundEventManager.getInstance();
        return Armature;
    }(dragonBones.EventDispatcher));
    dragonBones.Armature = Armature;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Matrix
     * @classdesc
     * Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
     * 这些转换类型统称为仿射转换。仿射转换在转换时保持线条笔直，因此平行线保持平行。
     * 转换矩阵对象为具有如下内容的 3 x 3 的矩阵：
     *  a  c  tx
     *  b  d  ty
     *  u  v  w
     * 在传统的转换矩阵中，u、v 和 w 属性具有其他功能。Matrix 类只能在二维空间中操作，因此始终假定属性值 u 和 v 为 0.0，属性值 w 为 1.0。矩阵的有效值如下：
     *  a  c  tx
     *  b  d  ty
     *  0  0  1
     * 您可以获取和设置 Matrix 对象的全部六个其他属性的值：a、b、c、d、tx 和 ty。
     * Matrix 类支持四种主要类型的转换：平移、缩放、旋转和倾斜。您可以使用特定的方法来设置这些转换的其中三个，如下表中所述：
     * 转换	              矩阵值                      说明
     * 平移（置换）	                            将图像 tx 像素向右移动，将 ty 像素向下移动。
     *                   1  0  tx
     *                   0  1  ty
     *                   0  0  1
     * 缩放                                     将每个像素的位置乘以 x 轴的 sx 和 y 轴的 sy，从而调整图像的大小。
     *                   Sx  0  0
     *                   0  Sy  0
     *                   0  0   1
     * 旋转                                     将图像旋转一个以弧度为单位的角度 q。
     *                   cos(q)  -sin(q)  0
     *                   sin(q)  cos(q)   0
     *                   0         0      1
     * 倾斜或剪切                               以平行于 x 轴或 y 轴的方向逐渐滑动图像。Matrix 对象的 b 属性表示斜角沿 y 轴的正切；Matrix 对象的 c 属性表示斜角沿 x 轴的正切。
     *                  0        tan(skewX) 0
     *                  tan(skewY)  0       0
     *                   0          0       1
     * 每个转换函数都将更改当前矩阵的属性，所以您可以有效地合并多个转换。为此，请先调用多个转换函数，再将矩阵应用于其显示对象目标（通过使用该显示对象的 transform 属性）。
     */
    var Matrix = (function () {
        /**
         *构造函数，实例化一个Matrix，默认为是一个单位矩阵
         */
        function Matrix() {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
        }
        var d = __define,c=Matrix,p=c.prototype;
        /**
         *执行原始矩阵的逆转换。逆矩阵和单位矩阵相乘会得到的单位矩阵
         */
        p.invert = function () {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
        };
        /**
         *将某个矩阵与当前矩阵相乘，从而将这两个矩阵的几何效果有效地结合在一起。
         * 右乘，其几何意义是将两次几何变换变成一次
         * @param m
         */
        p.concat = function (m) {
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var tx1 = this.tx;
            var ty1 = this.ty;
            if (ma != 1 || mb != 0 || mc != 0 || md != 1) {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                this.a = a1 * ma + b1 * mc;
                this.b = a1 * mb + b1 * md;
                this.c = c1 * ma + d1 * mc;
                this.d = c1 * mb + d1 * md;
            }
            this.tx = tx1 * ma + ty1 * mc + m.tx;
            this.ty = tx1 * mb + ty1 * md + m.ty;
        };
        p.copyFrom = function (m) {
            this.tx = m.tx;
            this.ty = m.ty;
            this.a = m.a;
            this.b = m.b;
            this.c = m.c;
            this.d = m.d;
        };
        /**@private*/
        p.transformPoint = function (x, y, result, delta) {
            if (delta === void 0) { delta = false; }
            result.x = this.a * x + this.c * y;
            result.y = this.b * x + this.d * y;
            if (!delta) {
                result.x += this.tx;
                result.y += this.ty;
            }
        };
        return Matrix;
    }());
    dragonBones.Matrix = Matrix;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBTransform
     * @classdesc
     * Dragonbones中使用的transform
     * 可以表示位移，旋转，缩放三种属性
     */
    var DBTransform = (function () {
        /**
         * 创建一个 DBTransform 实例.
         */
        function DBTransform() {
            this.x = 0;
            this.y = 0;
            this.skewX = 0;
            this.skewY = 0;
            this.scaleX = 1;
            this.scaleY = 1;
        }
        var d = __define,c=DBTransform,p=c.prototype;
        d(p, "rotation"
            /**
             * 旋转，用弧度表示
             * @member {number} dragonBones.DBTransform#rotation
             */
            ,function () {
                return this.skewX;
            }
            ,function (value) {
                this.skewX = this.skewY = value;
            }
        );
        /**
         * 拷贝传入的transfrom实例的所有属性
         * @param node
         */
        p.copy = function (transform) {
            this.x = transform.x;
            this.y = transform.y;
            this.skewX = transform.skewX;
            this.skewY = transform.skewY;
            this.scaleX = transform.scaleX;
            this.scaleY = transform.scaleY;
        };
        /**
         * transform加法
         * @param node
         */
        p.add = function (transform) {
            this.x += transform.x;
            this.y += transform.y;
            this.skewX += transform.skewX;
            this.skewY += transform.skewY;
            this.scaleX *= transform.scaleX;
            this.scaleY *= transform.scaleY;
        };
        /**
         * transform减法
         * @param node
         */
        p.minus = function (transform) {
            this.x -= transform.x;
            this.y -= transform.y;
            this.skewX -= transform.skewX;
            this.skewY -= transform.skewY;
            this.scaleX /= transform.scaleX;
            this.scaleY /= transform.scaleY;
        };
        p.normalizeRotation = function () {
            this.skewX = dragonBones.TransformUtil.normalizeRotation(this.skewX);
            this.skewY = dragonBones.TransformUtil.normalizeRotation(this.skewY);
        };
        p.clone = function () {
            var output = new DBTransform();
            output.copy(this);
            return output;
        };
        /**
         * 把DBTransform的所有属性转成用String类型表示
         * @return 一个字符串包含有DBTransform的所有属性
         */
        p.toString = function () {
            var string = "x:" + this.x + " y:" + this.y + " skewX:" + this.skewX + " skewY:" + this.skewY + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
            return string;
        };
        return DBTransform;
    }());
    dragonBones.DBTransform = DBTransform;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBObject
     * @classdesc
     * DBObject 是 Bone 和 Slot 的基类
     * @see dragonBones.Bone
     * @see dragonBones.Slot
     */
    var DBObject = (function () {
        function DBObject() {
            this._globalTransformMatrix = new dragonBones.Matrix();
            this._global = new dragonBones.DBTransform();
            this._origin = new dragonBones.DBTransform();
            this._offset = new dragonBones.DBTransform();
            this._offset.scaleX = this._offset.scaleY = 1;
            this._visible = true;
            this._armature = null;
            this._parent = null;
            this.userData = null;
            this.inheritRotation = true;
            this.inheritScale = true;
            this.inheritTranslation = true;
        }
        var d = __define,c=DBObject,p=c.prototype;
        d(p, "global"
            /**
             * 相对世界坐标的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#global
             */
            ,function () {
                return this._global;
            }
        );
        d(p, "origin"
            /**
             * 骨架数据中的原始的相对父亲的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#origin
             */
            ,function () {
                return this._origin;
            }
        );
        d(p, "offset"
            /**
             * 用于运行时动态调整的 DBTransform 实例。
             * @member {DBTransform} dragonBones.DBObject#offset
             */
            ,function () {
                return this._offset;
            }
        );
        d(p, "armature"
            /**
             * The armature this DBObject instance belongs to.
             */
            ,function () {
                return this._armature;
            }
        );
        /** @private */
        p._setArmature = function (value) {
            this._armature = value;
        };
        d(p, "parent"
            /**
             * Indicates the Bone instance that directly contains this DBObject instance if any.
             */
            ,function () {
                return this._parent;
            }
        );
        /** @private */
        p._setParent = function (value) {
            this._parent = value;
        };
        /**
         * 清理使用的资源用于垃圾回收
         */
        p.dispose = function () {
            this.userData = null;
            this._globalTransformMatrix = null;
            this._global = null;
            this._origin = null;
            this._offset = null;
            this._armature = null;
            this._parent = null;
        };
        p._calculateRelativeParentTransform = function () {
        };
        p._calculateParentTransform = function () {
            if (this.parent && (this.inheritTranslation || this.inheritRotation || this.inheritScale)) {
                var parentGlobalTransform = this._parent._globalTransformForChild;
                var parentGlobalTransformMatrix = this._parent._globalTransformMatrixForChild;
                /*
                if(!this.inheritTranslation || !this.inheritRotation || !this.inheritScale)
                {
                    parentGlobalTransform = DBObject._tempParentGlobalTransform;
                    parentGlobalTransform.copy(this._parent._globalTransformForChild);
                    if(!this.inheritTranslation)
                    {
                        parentGlobalTransform.x = 0;
                        parentGlobalTransform.y = 0;
                    }
                    if(!this.inheritScale)
                    {
                        parentGlobalTransform.scaleX = 1;
                        parentGlobalTransform.scaleY = 1;
                    }
                    if(!this.inheritRotation)
                    {
                        parentGlobalTransform.skewX = 0;
                        parentGlobalTransform.skewY = 0;
                    }

                    parentGlobalTransformMatrix = DBObject._tempParentGlobalTransformMatrix;
                    TransformUtil.transformToMatrix(parentGlobalTransform, parentGlobalTransformMatrix, true);
                }
                */
                return dragonBones.ParentTransformObject.create().setTo(parentGlobalTransform, parentGlobalTransformMatrix);
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return null;
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                //计算绝对坐标
                var x = this._global.x;
                var y = this._global.y;
                this._global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                this._global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;
                if (this.inheritRotation) {
                    this._global.skewX += parentGlobalTransform.skewX;
                    this._global.skewY += parentGlobalTransform.skewY;
                }
                if (this.inheritScale) {
                    this._global.scaleX *= parentGlobalTransform.scaleX;
                    this._global.scaleY *= parentGlobalTransform.scaleY;
                }
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return output;
        };
        DBObject._tempParentGlobalTransformMatrix = new dragonBones.Matrix();
        DBObject._tempParentGlobalTransform = new dragonBones.DBTransform();
        return DBObject;
    }());
    dragonBones.DBObject = DBObject;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Bone
     * @classdesc
     * Bone 实例代表 Armature 中的一个骨头。一个Armature实例可以由很多 Bone组成。
     * Bone 在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移旋转缩放的实现
     * @extends dragonBones.DBObject
     * @see dragonBones.Armature
     * @see dragonBones.Slot
     * @see dragonBones.BoneData
     *
     * @example
       <pre>
        //获取动画数据 本例使用Knight例子.
        //资源下载地址http://dragonbones.github.io/download_forwarding.html?download_url=downloads/dragonbonesdemos_v2.4.zip
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
        //这个资源需要自己准备
        var horseHat = RES.getRes("horseHat");
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[1].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        armatureDisplay.x = 200;
        armatureDisplay.y = 300;
        this.addChild(armatureDisplay);

        //以下四句代码，实现给骨骼添加slot的功能
        //1.获取马头的骨骼
        var horseHead:dragonBones.Bone = armature.getBone("horseHead");
        //2.创建一个slot
        var horseHatSlot:dragonBones.EgretSlot = new dragonBones.EgretSlot();
        //3.给这个slot赋一个图片
        horseHatSlot.display = new egret.Bitmap(horseHat);
        //4.把这个slot添加到骨骼上
        horseHead.addSlot(horseHatSlot);

        //以下3句代码，实现了子骨骼的获取和播放子骨架的动画
        //1.获取包含子骨架的骨骼
        var weaponBone:dragonBones.Bone = armature.getBone("armOutside");
        //2.获取骨骼上的子骨架
        var childArmature:dragonBones.Armature = weaponBone.childArmature;
        //3.播放子骨架的动画
        childArmature.animation.gotoAndPlay("attack_sword_1",0,-1,0);


        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Bone = (function (_super) {
        __extends(Bone, _super);
        function Bone() {
            _super.call(this);
            /**
             * 标记是否将offset中的平移分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetTranslationToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetTranslationToChild = true;
            /**
             * 标记是否将offset中的旋转分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetRotationToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetRotationToChild = true;
            /**
             * 标记是否将offset中的缩放分量作用到子骨头
             * 默认值：true
             * @member {true} dragonBones.Bone#applyOffsetScaleToChild
             * @see dragonBones.Bone#offset
             */
            this.applyOffsetScaleToChild = false;
            this.isIKConstraint = false;
            this.childrenBones = [];
            /** @private */
            this._needUpdate = 0;
            this._tween = new dragonBones.DBTransform();
            this._tweenPivot = new dragonBones.Point();
            this._tween.scaleX = this._tween.scaleY = 1;
            this._boneList = [];
            this._slotList = [];
            this._timelineStateList = [];
            this._needUpdate = 2;
            this._isColorChanged = false;
        }
        var d = __define,c=Bone,p=c.prototype;
        Bone.initWithBoneData = function (boneData) {
            var outputBone = new Bone();
            outputBone.name = boneData.name;
            outputBone.length = boneData.length;
            outputBone.inheritRotation = boneData.inheritRotation;
            outputBone.inheritScale = boneData.inheritScale;
            outputBone.origin.copy(boneData.transform);
            return outputBone;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._boneList) {
                return;
            }
            _super.prototype.dispose.call(this);
            var i = this._boneList.length;
            while (i--) {
                this._boneList[i].dispose();
            }
            i = this._slotList.length;
            while (i--) {
                this._slotList[i].dispose();
            }
            this._tween = null;
            this._tweenPivot = null;
            this._boneList = null;
            this._slotList = null;
            this._timelineStateList = null;
        };
        //骨架装配
        /**
         * 检查是否包含指定的 Bone 或者 Slot
         * @param child {DBObject} Bone 实例 或者 Slot 实例
         * @returns {boolean}
         */
        p.contains = function (child) {
            if (!child) {
                throw new Error();
            }
            if (child == this) {
                return false;
            }
            var ancestor = child;
            while (!(ancestor == this || ancestor == null)) {
                ancestor = ancestor.parent;
            }
            return ancestor == this;
        };
        /**
         * 添加指定的 Bone 实例做为当前 Bone 实例的子骨头
         * @param childBone {Bone} 需要添加的 Bone 实例
         * @param updateLater {boolean} 是否延迟更新。默认false。当需要一次性添加很多 Bone 时，开启延迟更新能够提高效率
         */
        p.addChildBone = function (childBone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!childBone) {
                throw new Error();
            }
            if (childBone == this || childBone.contains(this)) {
                throw new Error();
            }
            if (childBone.parent == this) {
                return;
            }
            if (childBone.parent) {
                childBone.parent.removeChildBone(childBone, updateLater);
            }
            this._boneList[this._boneList.length] = childBone;
            childBone._setParent(this);
            childBone._setArmature(this._armature);
            var index = this.childrenBones.indexOf(childBone);
            if (index < 0) {
                this.childrenBones.push(childBone);
            }
            if (this._armature && !updateLater) {
                this._armature._updateAnimationAfterBoneListChanged();
            }
        };
        /**
         * 从当前 Bone 实例中移除指定的子骨头
         * @param childBone {Bone} 需要移除的 Bone 实例
         * @param updateLater {boolean} 是否延迟更新。默认false。当需要一次性移除很多 Bone 时，开启延迟更新能够提高效率
         */
        p.removeChildBone = function (childBone, updateLater) {
            if (updateLater === void 0) { updateLater = false; }
            if (!childBone) {
                throw new Error();
            }
            var index = this._boneList.indexOf(childBone);
            if (index < 0) {
                throw new Error();
            }
            this._boneList.splice(index, 1);
            childBone._setParent(null);
            childBone._setArmature(null);
            var indexs = this.childrenBones.indexOf(childBone);
            if (indexs >= 0) {
                this.childrenBones.splice(indexs, 1);
            }
            if (this._armature && !updateLater) {
                this._armature._updateAnimationAfterBoneListChanged(false);
            }
        };
        /**
         * 向当前 Bone 实例中添加指定的 Slot 实例
         * @param childSlot {Slot} 需要添加的 Slot 实例
         */
        p.addSlot = function (childSlot) {
            if (!childSlot) {
                throw new Error();
            }
            if (childSlot.parent) {
                childSlot.parent.removeSlot(childSlot);
            }
            this._slotList[this._slotList.length] = childSlot;
            childSlot._setParent(this);
            childSlot.setArmature(this._armature);
        };
        /**
         * 从当前 Bone 实例中移除指定的 Slot 实例
         * @param childSlot {Slot} 需要移除的 Slot 实例
         */
        p.removeSlot = function (childSlot) {
            if (!childSlot) {
                throw new Error();
            }
            var index = this._slotList.indexOf(childSlot);
            if (index < 0) {
                throw new Error();
            }
            this._slotList.splice(index, 1);
            childSlot._setParent(null);
            childSlot.setArmature(null);
        };
        /** @private */
        p._setArmature = function (value) {
            if (this._armature == value) {
                return;
            }
            if (this._armature) {
                this._armature._removeBoneFromBoneList(this);
                this._armature._updateAnimationAfterBoneListChanged(false);
            }
            this._armature = value;
            if (this._armature) {
                this._armature._addBoneToBoneList(this);
            }
            var i = this._boneList.length;
            while (i--) {
                this._boneList[i]._setArmature(this._armature);
            }
            i = this._slotList.length;
            while (i--) {
                this._slotList[i].setArmature(this._armature);
            }
        };
        /**
         * 获取当前骨头包含的所有 Bone 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Bone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._boneList.concat() : this._boneList;
        };
        /**
         * 获取当前骨头包含的所有 Slot 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {Slot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._slotList.concat() : this._slotList;
        };
        //动画
        /**
         * 在下一帧强制更新当前 Bone 实例及其包含的所有 Slot 的动画。
         */
        p.invalidUpdate = function () {
            this._needUpdate = 2;
            this.operationInvalidUpdate(this);
            var i;
            var len;
            for (i = 0, len = this.childrenBones.length; i < len; i++) {
                if (this.childrenBones[i]._needUpdate != 2) {
                    this.operationInvalidUpdate(this.childrenBones[i]);
                    this.childrenBones[i].invalidUpdate();
                }
            }
        };
        p.operationInvalidUpdate = function (bone) {
            var arr = this.armature.getIKTargetData(bone);
            var i;
            var len;
            var j;
            var jLen;
            var ik;
            var bo;
            for (i = 0, len = arr.length; i < len; i++) {
                ik = arr[i];
                for (j = 0, jLen = ik.bones.length; j < jLen; j++) {
                    bo = ik.bones[j];
                    if (bo._needUpdate != 2) {
                        bo.invalidUpdate();
                    }
                }
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.scaleX = this._origin.scaleX * this._tween.scaleX * this._offset.scaleX;
            this._global.scaleY = this._origin.scaleY * this._tween.scaleY * this._offset.scaleY;
            this._global.skewX = this._origin.skewX + this._tween.skewX + this._offset.skewX;
            this._global.skewY = this._origin.skewY + this._tween.skewY + this._offset.skewY;
            this._global.x = this._origin.x + this._tween.x + this._offset.x;
            this._global.y = this._origin.y + this._tween.y + this._offset.y;
        };
        /** @private */
        p._update = function (needUpdate) {
            if (needUpdate === void 0) { needUpdate = false; }
            this._needUpdate--;
            if (needUpdate || this._needUpdate > 0 || (this._parent && this._parent._needUpdate > 0)) {
                this._needUpdate = 1;
            }
            else {
                return;
            }
            this.updataLocalTransform();
            this.updateGlobalTransform();
        };
        p.updataLocalTransform = function () {
            this.blendingTimeline();
            this._calculateRelativeParentTransform();
        };
        p.updateGlobalTransform = function () {
            //计算global
            var result = this._updateGlobal();
            var parentGlobalTransform;
            var parentGlobalTransformMatrix;
            if (result) {
                parentGlobalTransform = result.parentGlobalTransform;
                parentGlobalTransformMatrix = result.parentGlobalTransformMatrix;
                result.release();
            }
            //计算globalForChild
            var ifExistOffsetTranslation = this._offset.x != 0 || this._offset.y != 0;
            var ifExistOffsetScale = this._offset.scaleX != 1 || this._offset.scaleY != 1;
            var ifExistOffsetRotation = this._offset.skewX != 0 || this._offset.skewY != 0;
            if ((!ifExistOffsetTranslation || this.applyOffsetTranslationToChild) &&
                (!ifExistOffsetScale || this.applyOffsetScaleToChild) &&
                (!ifExistOffsetRotation || this.applyOffsetRotationToChild)) {
                this._globalTransformForChild = this._global;
                this._globalTransformMatrixForChild = this._globalTransformMatrix;
            }
            else {
                if (!this._tempGlobalTransformForChild) {
                    this._tempGlobalTransformForChild = new dragonBones.DBTransform();
                }
                this._globalTransformForChild = this._tempGlobalTransformForChild;
                if (!this._tempGlobalTransformMatrixForChild) {
                    this._tempGlobalTransformMatrixForChild = new dragonBones.Matrix();
                }
                this._globalTransformMatrixForChild = this._tempGlobalTransformMatrixForChild;
                this._globalTransformForChild.x = this._origin.x + this._tween.x;
                this._globalTransformForChild.y = this._origin.y + this._tween.y;
                this._globalTransformForChild.scaleX = this._origin.scaleX * this._tween.scaleX;
                this._globalTransformForChild.scaleY = this._origin.scaleY * this._tween.scaleY;
                this._globalTransformForChild.skewX = this._origin.skewX + this._tween.skewX;
                this._globalTransformForChild.skewY = this._origin.skewY + this._tween.skewY;
                if (this.applyOffsetTranslationToChild) {
                    this._globalTransformForChild.x += this._offset.x;
                    this._globalTransformForChild.y += this._offset.y;
                }
                if (this.applyOffsetScaleToChild) {
                    this._globalTransformForChild.scaleX *= this._offset.scaleX;
                    this._globalTransformForChild.scaleY *= this._offset.scaleY;
                }
                if (this.applyOffsetRotationToChild) {
                    this._globalTransformForChild.skewX += this._offset.skewX;
                    this._globalTransformForChild.skewY += this._offset.skewY;
                }
                dragonBones.TransformUtil.transformToMatrix(this._globalTransformForChild, this._globalTransformMatrixForChild);
                if (parentGlobalTransformMatrix) {
                    this._globalTransformMatrixForChild.concat(parentGlobalTransformMatrix);
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrixForChild, this._globalTransformForChild, this._globalTransformForChild.scaleX * parentGlobalTransform.scaleX >= 0, this._globalTransformForChild.scaleY * parentGlobalTransform.scaleY >= 0);
                }
            }
        };
        /** @private */
        p._updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this._slotList[i];
                childSlot._updateDisplayColor(aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier);
            }
            this._isColorChanged = colorChanged;
        };
        p.adjustGlobalTransformMatrixByIK = function () {
            if (!this.parent) {
                return;
            }
            this.updataLocalTransform();
            this._global.rotation = this.rotationIK - this.parentBoneRotation;
            this.updateGlobalTransform();
            //this.global.rotation = this.rotationIK;
            //TransformUtil.transformToMatrix(this.global, this._globalTransformMatrix);
            //this._globalTransformForChild.rotation = this.rotationIK;
            //TransformUtil.transformToMatrix(this._globalTransformForChild, this._globalTransformMatrixForChild);
        };
        /** @private */
        p._hideSlots = function () {
            var length = this._slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this._slotList[i];
                childSlot._changeDisplay(-1);
            }
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            var displayControl = animationState.displayControl &&
                (!this.displayController || this.displayController == animationState.name) &&
                animationState.containsBoneMask(this.name);
            if (displayControl) {
                var tansformFrame = frame;
                var displayIndex = tansformFrame.displayIndex;
                var childSlot;
                if (frame.event && this._armature.hasEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT)) {
                    var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.BONE_FRAME_EVENT);
                    frameEvent.bone = this;
                    frameEvent.animationState = animationState;
                    frameEvent.frameLabel = frame.event;
                    this._armature._eventList.push(frameEvent);
                }
                if (frame.sound && Bone._soundManager.hasEventListener(dragonBones.SoundEvent.SOUND)) {
                    var soundEvent = new dragonBones.SoundEvent(dragonBones.SoundEvent.SOUND);
                    soundEvent.armature = this._armature;
                    soundEvent.animationState = animationState;
                    soundEvent.sound = frame.sound;
                    Bone._soundManager.dispatchEvent(soundEvent);
                }
                //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
                //后续会扩展更多的action，目前只有gotoAndPlay的含义
                if (frame.action) {
                    var length1 = this._slotList.length;
                    for (var i1 = 0; i1 < length1; i1++) {
                        childSlot = this._slotList[i1];
                        var childArmature = childSlot.childArmature;
                        if (childArmature) {
                            childArmature.animation.gotoAndPlay(frame.action);
                        }
                    }
                }
            }
        };
        p._updateGlobal = function () {
            if (!this._armature._skewEnable) {
                return _super.prototype._updateGlobal.call(this);
            }
            //this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null && output.parentGlobalTransformMatrix && output.parentGlobalTransform) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                var scaleXF = this._global.scaleX * parentGlobalTransform.scaleX > 0;
                var scaleYF = this._global.scaleY * parentGlobalTransform.scaleY > 0;
                var relativeRotation = this._global.rotation;
                var relativeScaleX = this._global.scaleX;
                var relativeScaleY = this._global.scaleY;
                var parentRotation = this.parentBoneRotation;
                this._localTransform = this._global;
                if (this.inheritScale && !this.inheritRotation) {
                    if (parentRotation != 0) {
                        this._localTransform = this._localTransform.clone();
                        this._localTransform.rotation -= parentRotation;
                    }
                }
                dragonBones.TransformUtil.transformToMatrix(this._localTransform, this._globalTransformMatrix);
                this._globalTransformMatrix.concat(parentMatrix);
                if (this.inheritScale) {
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, scaleXF, scaleYF);
                }
                else {
                    dragonBones.TransformUtil.matrixToTransformPosition(this._globalTransformMatrix, this._global);
                    this._global.scaleX = this._localTransform.scaleX;
                    this._global.scaleY = this._localTransform.scaleY;
                    this._global.rotation = this._localTransform.rotation + (this.inheritRotation ? parentRotation : 0);
                    dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
                }
            }
            return output;
        };
        /** @private */
        p._addState = function (timelineState) {
            if (this._timelineStateList.indexOf(timelineState) < 0) {
                this._timelineStateList.push(timelineState);
                this._timelineStateList.sort(this.sortState);
            }
        };
        /** @private */
        p._removeState = function (timelineState) {
            var index = this._timelineStateList.indexOf(timelineState);
            if (index >= 0) {
                this._timelineStateList.splice(index, 1);
            }
        };
        /** @private */
        p._removeAllStates = function () {
            this._timelineStateList.length = 0;
        };
        p.blendingTimeline = function () {
            var timelineState;
            var transform;
            var pivot;
            var weight;
            var i = this._timelineStateList.length;
            if (i == 1) {
                timelineState = this._timelineStateList[0];
                weight = timelineState._animationState.weight * timelineState._animationState.fadeWeight;
                timelineState._weight = weight;
                transform = timelineState._transform;
                pivot = timelineState._pivot;
                this._tween.x = transform.x * weight;
                this._tween.y = transform.y * weight;
                this._tween.skewX = transform.skewX * weight;
                this._tween.skewY = transform.skewY * weight;
                this._tween.scaleX = 1 + (transform.scaleX - 1) * weight;
                this._tween.scaleY = 1 + (transform.scaleY - 1) * weight;
                this._tweenPivot.x = pivot.x * weight;
                this._tweenPivot.y = pivot.y * weight;
            }
            else if (i > 1) {
                var x = 0;
                var y = 0;
                var skewX = 0;
                var skewY = 0;
                var scaleX = 1;
                var scaleY = 1;
                var pivotX = 0;
                var pivotY = 0;
                var weigthLeft = 1;
                var layerTotalWeight = 0;
                var prevLayer = this._timelineStateList[i - 1]._animationState.layer;
                var currentLayer = 0;
                //Traversal the layer from up to down
                //layer由高到低依次遍历
                while (i--) {
                    timelineState = this._timelineStateList[i];
                    currentLayer = timelineState._animationState.layer;
                    if (prevLayer != currentLayer) {
                        if (layerTotalWeight >= weigthLeft) {
                            timelineState._weight = 0;
                            break;
                        }
                        else {
                            weigthLeft -= layerTotalWeight;
                        }
                    }
                    prevLayer = currentLayer;
                    weight = timelineState._animationState.weight * timelineState._animationState.fadeWeight * weigthLeft;
                    timelineState._weight = weight;
                    if (weight) {
                        transform = timelineState._transform;
                        pivot = timelineState._pivot;
                        x += transform.x * weight;
                        y += transform.y * weight;
                        skewX += transform.skewX * weight;
                        skewY += transform.skewY * weight;
                        scaleX += (transform.scaleX - 1) * weight;
                        scaleY += (transform.scaleY - 1) * weight;
                        pivotX += pivot.x * weight;
                        pivotY += pivot.y * weight;
                        layerTotalWeight += weight;
                    }
                }
                this._tween.x = x;
                this._tween.y = y;
                this._tween.skewX = skewX;
                this._tween.skewY = skewY;
                this._tween.scaleX = scaleX;
                this._tween.scaleY = scaleY;
                this._tweenPivot.x = pivotX;
                this._tweenPivot.y = pivotY;
            }
        };
        p.sortState = function (state1, state2) {
            return state1._animationState.layer < state2._animationState.layer ? -1 : 1;
        };
        d(p, "childArmature"
            /**
             * 不推荐的API,建议使用 slot.childArmature 替代
             */
            ,function () {
                if (this.slot) {
                    return this.slot.childArmature;
                }
                return null;
            }
        );
        d(p, "display"
            /**
             * 不推荐的API,建议使用 slot.display 替代
             */
            ,function () {
                if (this.slot) {
                    return this.slot.display;
                }
                return null;
            }
            ,function (value) {
                if (this.slot) {
                    this.slot.display = value;
                }
            }
        );
        d(p, "node"
            /**
             * 不推荐的API,建议使用 offset 替代
             */
            ,function () {
                return this._offset;
            }
        );
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    var length = this._slotList.length;
                    for (var i = 0; i < length; i++) {
                        var childSlot = this._slotList[i];
                        childSlot._updateDisplayVisible(this._visible);
                    }
                }
            }
        );
        d(p, "slot"
            /**
             * 返回当前 Bone 实例包含的第一个 Slot 实例
             * @member {Slot} dragonBones.Bone#slot
             */
            ,function () {
                return this._slotList.length > 0 ? this._slotList[0] : null;
            }
        );
        d(p, "parentBoneRotation"
            ,function () {
                return this.parent ? this.parent.rotationIK : 0;
            }
        );
        /**
         * The instance dispatch sound event.
         */
        Bone._soundManager = dragonBones.SoundEventManager.getInstance();
        return Bone;
    }(dragonBones.DBObject));
    dragonBones.Bone = Bone;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var IKConstraint = (function () {
        function IKConstraint(data, armatureData) {
            this.animationCacheBend = 0;
            this.animationCacheWeight = -1;
            this.ikdata = data;
            this.armature = armatureData;
            this.weight = data.weight;
            this.bendDirection = (data.bendPositive ? 1 : -1);
            this.bones = [];
            var bone;
            if (data.chain) {
                bone = armatureData.getBone(data.bones).parent;
                bone.isIKConstraint = true;
                this.bones.push(bone);
            }
            bone = armatureData.getBone(data.bones);
            bone.isIKConstraint = true;
            this.bones.push(bone);
            this.target = armatureData.getBone(data.target);
        }
        var d = __define,c=IKConstraint,p=c.prototype;
        p.dispose = function () {
        };
        p.compute = function () {
            switch (this.bones.length) {
                case 1:
                    var weig1 = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    this.compute1(this.bones[0], this.target, weig1);
                    break;
                case 2:
                    var bend = this.animationCacheBend != 0 ? this.animationCacheBend : this.bendDirection;
                    var weig = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    var tt = this.compute2(this.bones[0], this.bones[1], this.target.global.x, this.target.global.y, bend, weig);
                    this.bones[0].rotationIK = this.bones[0].origin.rotation + (tt.x - this.bones[0].origin.rotation) * weig + this.bones[0].parent.rotationIK;
                    this.bones[1].rotationIK = this.bones[1].origin.rotation + (tt.y - this.bones[1].origin.rotation) * weig + this.bones[0].rotationIK;
                    break;
            }
        };
        p.compute1 = function (bone, target, weightA) {
            var parentRotation = (!bone.inheritRotation || bone.parent == null) ? 0 : bone.parent.global.rotation;
            var rotation = bone.global.rotation;
            var rotationIK = Math.atan2(target.global.y - bone.global.y, target.global.x - bone.global.x);
            bone.rotationIK = rotation + (rotationIK - rotation) * weightA;
        };
        p.compute2 = function (parent, child, targetX, targetY, bendDirection, weightA) {
            //添加斜切后的算法，现在用的
            if (weightA == 0) {
                return new dragonBones.Point(parent.global.rotation, child.global.rotation);
            }
            var tt = new dragonBones.Point();
            /**父的绝对坐标**/
            var p1 = new dragonBones.Point(parent.global.x, parent.global.y);
            /**子的绝对坐标**/
            var p2 = new dragonBones.Point(child.global.x, child.global.y);
            var matrix = new dragonBones.Matrix();
            dragonBones.TransformUtil.transformToMatrix(parent.parent.global, matrix);
            matrix.invert();
            var targetPoint = dragonBones.TransformUtil.applyMatrixToPoint(new dragonBones.Point(targetX, targetY), matrix, true);
            targetX = targetPoint.x;
            targetY = targetPoint.y;
            p1 = dragonBones.TransformUtil.applyMatrixToPoint(p1, matrix, true);
            p2 = dragonBones.TransformUtil.applyMatrixToPoint(p2, matrix, true);
            var psx = parent.origin.scaleX;
            var psy = parent.origin.scaleY;
            var csx = child.origin.scaleX;
            var childX = p2.x - p1.x;
            var childY = p2.y - p1.y;
            /**d1的长度**/
            var len1 = Math.sqrt(childX * childX + childY * childY);
            var parentAngle;
            var childAngle;
            var sign = 1;
            var offset1 = 0;
            var offset2 = 0;
            if (psx < 0) {
                psx = -psx;
                offset1 = Math.PI;
                sign = -1;
            }
            else {
                offset1 = 0;
                sign = 1;
            }
            if (psy < 0) {
                psy = -psy;
                sign = -sign;
            }
            if (csx < 0) {
                csx = -csx;
                offset2 = Math.PI;
            }
            else {
                offset2 = 0;
            }
            bendDirection = sign * bendDirection;
            outer: if (Math.abs(psx - psy) <= 0.001) {
                var childlength = child.length;
                var len2 = childlength * csx;
                targetX = targetX - p1.x;
                targetY = targetY - p1.y;
                var cosDenom = 2 * len1 * len2;
                var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                childAngle = Math.acos(cos) * bendDirection;
                var adjacent = len1 + len2 * cos;
                var opposite = len2 * Math.sin(childAngle);
                parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);
            }
            else {
                var l1 = len1;
                var tx = targetX - p1.x;
                var ty = targetY - p1.y;
                var l2 = child.length * child.origin.scaleX;
                var a = psx * l2;
                var b = psy * l2;
                var ta = Math.atan2(ty, tx);
                var aa = a * a;
                var bb = b * b;
                var ll = l1 * l1;
                var dd = tx * tx + ty * ty;
                var c0 = bb * ll + aa * dd - aa * bb;
                var c1 = -2 * bb * l1;
                var c2 = bb - aa;
                var d = c1 * c1 - 4 * c2 * c0;
                if (d >= 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0) {
                        q = -q;
                    }
                    q = -(c1 + q) / 2;
                    var r0 = q / c2;
                    var r1 = c0 / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        var y1 = Math.sqrt(dd - r * r) * bendDirection;
                        parentAngle = ta - Math.atan2(y1, r);
                        childAngle = Math.atan2(y1 / psy, (r - l1) / psx);
                        break outer;
                    }
                }
                var minAngle = 0;
                var minDist = Number.MAX_VALUE;
                var minX = 0;
                var minY = 0;
                var maxAngle = 0;
                var maxDist = 0;
                var maxX = 0;
                var maxY = 0;
                var x2 = l1 + a;
                var dist = x2 * x2;
                if (dist > maxDist) {
                    maxAngle = 0;
                    maxDist = dist;
                    maxX = x2;
                }
                x2 = l1 - a;
                dist = x2 * x2;
                if (dist < minDist) {
                    minAngle = Math.PI;
                    minDist = dist;
                    minX = x2;
                }
                var angle1 = Math.acos(-a * l1 / (aa - bb));
                x2 = a * Math.cos(angle1) + l1;
                var y2 = b * Math.sin(angle1);
                dist = x2 * x2 + y2 * y2;
                if (dist < minDist) {
                    minAngle = angle1;
                    minDist = dist;
                    minX = x2;
                    minY = y2;
                }
                if (dist > maxDist) {
                    maxAngle = angle1;
                    maxDist = dist;
                    maxX = x2;
                    maxY = y2;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    parentAngle = ta - Math.atan2(minY * bendDirection, minX);
                    childAngle = minAngle * bendDirection;
                }
                else {
                    parentAngle = ta - Math.atan2(maxY * bendDirection, maxX);
                    childAngle = maxAngle * bendDirection;
                }
            }
            var cx = child.origin.x;
            var cy = child.origin.y * psy;
            var initalRotation = Math.atan2(cy, cx) * sign;
            tt.x = parentAngle - initalRotation + offset1;
            tt.y = (childAngle + initalRotation) * sign + offset2;
            this.normalize(tt.x);
            this.normalize(tt.y);
            return tt;
        };
        p.normalize = function (rotation) {
            if (rotation > Math.PI) {
                rotation -= Math.PI * 2;
            }
            else if (rotation < -Math.PI) {
                rotation += Math.PI * 2;
            }
        };
        return IKConstraint;
    }());
    dragonBones.IKConstraint = IKConstraint;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Slot
     * @classdesc
     * Slot 实例是骨头上的一个插槽，是显示图片的容器。
     * 一个 Bone 上可以有多个Slot，每个Slot中同一时间都会有一张图片用于显示，不同的Slot中的图片可以同时显示。
     * 每个 Slot 中可以包含多张图片，同一个 Slot 中的不同图片不能同时显示，但是可以在动画进行的过程中切换，用于实现帧动画。
     * @extends dragonBones.DBObject
     * @see dragonBones.Armature
     * @see dragonBones.Bone
     * @see dragonBones.SlotData
     *
     * @example
       <pre>
        //获取动画数据 本例使用Knight例子.
        //资源下载地址http://dragonbones.github.io/download_forwarding.html?download_url=downloads/dragonbonesdemos_v2.4.zip
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");
        //这个资源需要自己准备
        var horseHat = RES.getRes("horseHat");
        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[1].name;
        //从工厂里创建出Armature
        var armature:dragonBones.Armature = factory.buildArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        armatureDisplay.x = 200;
        armatureDisplay.y = 300;
        this.addChild(armatureDisplay);

        //以下四句代码，实现给骨骼添加slot的功能
        //1.获取马头的骨骼
        var horseHead:dragonBones.Bone = armature.getBone("horseHead");
        //2.创建一个slot
        var horseHatSlot:dragonBones.EgretSlot = new dragonBones.EgretSlot();
        //3.给这个slot赋一个图片
        horseHatSlot.display = new egret.Bitmap(horseHat);
        //4.把这个slot添加到骨骼上
        horseHead.addSlot(horseHatSlot);

        //以下3句代码，实现了子骨骼的获取和播放子骨架的动画
        //1.获取包含子骨架的骨骼
        var weaponBone:dragonBones.Bone = armature.getBone("armOutside");
        //2.获取骨骼上的子骨架
        var childArmature:dragonBones.Armature = weaponBone.childArmature;
        //3.播放子骨架的动画
        childArmature.animation.gotoAndPlay("attack_sword_1",0,-1,0);


        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var Slot = (function (_super) {
        __extends(Slot, _super);
        function Slot() {
            _super.call(this);
            /**
             * @private
             */
            this.isMeshEnabled = false;
            this._currentDisplayIndex = 0;
            /** @private */
            this._ffdChanged = false;
            /** @private */
            this._ffdVertices = null;
            /** @private */
            this._meshBones = null;
            /** @private */
            this._meshData = null;
            /**
             * @private
             */
            this._ffdOffset = 0;
            this._displayList = [];
            this._currentDisplayIndex = -1;
            this._originZOrder = 0;
            this._tweenZOrder = 0;
            this._offsetZOrder = 0;
            this._isShowDisplay = false;
            this._colorTransform = new dragonBones.ColorTransform();
            this._displayDataList = null;
            //_childArmature = null;
            this._currentDisplay = null;
            this.inheritRotation = true;
            this.inheritScale = true;
        }
        var d = __define,c=Slot,p=c.prototype;
        d(p, "displayIndex"
            /** @private */
            ,function () {
                return this._currentDisplayIndex;
            }
        );
        /**
         * 通过传入 SlotData 初始化Slot
         * @param slotData
         */
        p.initWithSlotData = function (slotData) {
            this.name = slotData.name;
            this.blendMode = slotData.blendMode;
            this._defaultGotoAndPlay = slotData.gotoAndPlay;
            this._originZOrder = slotData.zOrder;
            this._displayDataList = slotData.displayDataList;
            this._originDisplayIndex = slotData.displayIndex;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._displayList) {
                return;
            }
            _super.prototype.dispose.call(this);
            this._displayList.length = 0;
            this._displayDataList = null;
            this._displayList = null;
            this._currentDisplay = null;
            //_childArmature = null;
        };
        //骨架装配
        /** @private */
        p.setArmature = function (value) {
            if (this._armature == value) {
                return;
            }
            if (this._armature) {
                this._armature._removeSlotFromSlotList(this);
            }
            this._armature = value;
            if (this._armature) {
                this._armature._addSlotToSlotList(this);
                this._armature._slotsZOrderChanged = true;
                this._addDisplayToContainer(this._armature.display);
            }
            else {
                this._removeDisplayFromContainer();
            }
        };
        //动画
        /** @private */
        p._update = function () {
            if (this._parent._needUpdate > 0 || this._needUpdate || this._ffdChanged || this.isMeshUpdate()) {
                var result = this._updateGlobal();
                if (result) {
                    result.release();
                }
                this._updateTransform();
                if (this._meshData) {
                    this._updateMesh();
                }
                this._needUpdate = false;
            }
        };
        p.isMeshUpdate = function () {
            if (this._meshData && this._meshBones.length) {
                for (var i = 0, l = this._meshBones.length; i < l; ++i) {
                    var bone = this._meshBones[i];
                    if (bone._needUpdate > 0) {
                        return true;
                    }
                }
            }
            return false;
        };
        p._calculateRelativeParentTransform = function () {
            this._global.scaleX = this._origin.scaleX * this._offset.scaleX;
            this._global.scaleY = this._origin.scaleY * this._offset.scaleY;
            this._global.skewX = this._origin.skewX + this._offset.skewX;
            this._global.skewY = this._origin.skewY + this._offset.skewY;
            this._global.x = this._origin.x + this._offset.x + this._parent._tweenPivot.x;
            this._global.y = this._origin.y + this._offset.y + this._parent._tweenPivot.y;
        };
        p.updateChildArmatureAnimation = function () {
            if (this.childArmature) {
                if (this._isShowDisplay) {
                    var curAnimation = this._gotoAndPlay;
                    if (curAnimation == null) {
                        curAnimation = this._defaultGotoAndPlay;
                        if (curAnimation == null) {
                            this.childArmature.armatureData.defaultAnimation;
                        }
                    }
                    if (curAnimation == null) {
                        if (this._armature && this._armature.animation.lastAnimationState) {
                            curAnimation = this._armature.animation.lastAnimationState.name;
                        }
                    }
                    if (curAnimation && this.childArmature.animation.hasAnimation(curAnimation)) {
                        this.childArmature.animation.gotoAndPlay(curAnimation);
                    }
                    else {
                        this.childArmature.animation.play();
                    }
                }
                else {
                    this.childArmature.animation.stop();
                    this.childArmature.animation._lastAnimationState = null;
                }
            }
        };
        /** @private */
        p._changeDisplay = function (displayIndex) {
            if (displayIndex === void 0) { displayIndex = 0; }
            if (displayIndex < 0) {
                if (this._isShowDisplay) {
                    this._isShowDisplay = false;
                    this._removeDisplayFromContainer();
                    this.updateChildArmatureAnimation();
                    this._armature.animation._updateFFDTimelineStates = true;
                }
            }
            else if (this._displayList.length > 0) {
                var length = this._displayList.length;
                if (displayIndex >= length) {
                    displayIndex = length - 1;
                }
                if (this._currentDisplayIndex != displayIndex) {
                    this._isShowDisplay = true;
                    this._currentDisplayIndex = displayIndex;
                    this._updateSlotDisplay();
                    this.updateChildArmatureAnimation();
                    if (this._displayDataList &&
                        this._displayDataList.length > 0 &&
                        this._currentDisplayIndex < this._displayDataList.length) {
                        this._origin.copy(this._displayDataList[this._currentDisplayIndex].transform);
                    }
                    this._needUpdate = true;
                    this._armature.animation._updateFFDTimelineStates = true;
                }
                else if (!this._isShowDisplay) {
                    this._isShowDisplay = true;
                    if (this._armature) {
                        this._armature._slotsZOrderChanged = true;
                        this._addDisplayToContainer(this._armature.display);
                    }
                    this.updateChildArmatureAnimation();
                    this._armature.animation._updateFFDTimelineStates = true;
                }
            }
            // update _ffdVertices length
            if (this._currentDisplayIndex >= 0 && this._armature.animation._updateFFDTimelineStates) {
                var displayData = this._displayDataList[this._currentDisplayIndex];
                if (displayData.type == dragonBones.DisplayData.MESH) {
                    this._meshData = displayData;
                }
                else {
                    this._meshData = null;
                }
                if (this._meshData) {
                    if (this._meshBones) {
                        this._meshBones.length = this._meshData.bones.length;
                    }
                    else {
                        this._meshBones = [];
                    }
                    for (var i = 0, l = this._meshData.bones.length; i < l; ++i) {
                        var boneData = this._meshData.bones[i];
                        this._meshBones[i] = this._armature.getBone(boneData.name);
                    }
                }
                else {
                    if (this._ffdVertices) {
                        this._ffdVertices.length = 0;
                    }
                    if (this._meshBones) {
                        this._meshBones.length = 0;
                    }
                }
            }
        };
        /** @private
         * Updates the display of the slot.
         */
        p._updateSlotDisplay = function () {
            var currentDisplayIndex = -1;
            if (this._currentDisplay) {
                currentDisplayIndex = this._getDisplayIndex();
                this._removeDisplayFromContainer();
            }
            var displayObj = this._displayList[this._currentDisplayIndex];
            if (displayObj) {
                if (displayObj instanceof dragonBones.Armature) {
                    //_childArmature = display as Armature;
                    this._currentDisplay = displayObj.display;
                }
                else {
                    //_childArmature = null;
                    this._currentDisplay = displayObj;
                }
            }
            else {
                this._currentDisplay = null;
            }
            this._updateDisplay(this._currentDisplay);
            if (this._currentDisplay) {
                if (this._armature && this._isShowDisplay) {
                    if (currentDisplayIndex < 0) {
                        this._armature._slotsZOrderChanged = true;
                        this._addDisplayToContainer(this._armature.display);
                    }
                    else {
                        this._addDisplayToContainer(this._armature.display, currentDisplayIndex);
                    }
                }
                this._updateDisplayBlendMode(this._blendMode);
                this._updateDisplayColor(this._colorTransform.alphaOffset, this._colorTransform.redOffset, this._colorTransform.greenOffset, this._colorTransform.blueOffset, this._colorTransform.alphaMultiplier, this._colorTransform.redMultiplier, this._colorTransform.greenMultiplier, this._colorTransform.blueMultiplier, true);
                this._updateDisplayVisible(this._visible);
                this._updateTransform();
            }
        };
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    this._updateDisplayVisible(this._visible);
                }
            }
        );
        d(p, "displayList"
            /**
             * 显示对象列表(包含 display 或者 子骨架)
             * @member {any[]} dragonBones.Slot#displayList
             */
            ,function () {
                return this._displayList;
            }
            ,function (value) {
                if (!value) {
                    throw new Error();
                }
                //为什么要修改_currentDisplayIndex?
                if (this._currentDisplayIndex < 0) {
                    this._currentDisplayIndex = 0;
                }
                var i = this._displayList.length = value.length;
                while (i--) {
                    this._displayList[i] = value[i];
                }
                //在index不改变的情况下强制刷新 TO DO需要修改
                var displayIndexBackup = this._currentDisplayIndex;
                this._currentDisplayIndex = -1;
                this._changeDisplay(displayIndexBackup);
            }
        );
        d(p, "display"
            /**
             * 当前的显示对象(可能是 display 或者 子骨架)
             * @member {any} dragonBones.Slot#display
             */
            ,function () {
                return this._currentDisplay;
            }
            ,function (value) {
                if (this._currentDisplayIndex < 0) {
                    this._currentDisplayIndex = 0;
                }
                if (this._displayList[this._currentDisplayIndex] == value) {
                    return;
                }
                this._displayList[this._currentDisplayIndex] = value;
                this._updateSlotDisplay();
                this.updateChildArmatureAnimation();
                this._updateTransform(); //是否可以延迟更新？
            }
        );
        /**
         * 不推荐的 API. 使用 display 属性代替
         */
        p.getDisplay = function () {
            return this.display;
        };
        /**
         * Unrecommended API. Please use .display = instead.
         * @returns {any}
         */
        p.setDisplay = function (value) {
            this.display = value;
        };
        d(p, "childArmature"
            /**
             * 当前的子骨架
             * @member {Armature} dragonBones.Slot#childArmature
             */
            ,function () {
                if (this._displayList[this._currentDisplayIndex] instanceof dragonBones.Armature) {
                    return (this._displayList[this._currentDisplayIndex]);
                }
                return null;
            }
            ,function (value) {
                //设计的不好，要修改
                this.display = value;
            }
        );
        d(p, "zOrder"
            /**
             * 显示顺序。(支持小数用于实现动态插入slot)
             * @member {number} dragonBones.Slot#zOrder
             */
            ,function () {
                return this._originZOrder + this._tweenZOrder + this._offsetZOrder;
            }
            ,function (value) {
                if (this.zOrder != value) {
                    this._offsetZOrder = value - this._originZOrder - this._tweenZOrder;
                    if (this._armature) {
                        this._armature._slotsZOrderChanged = true;
                    }
                }
            }
        );
        d(p, "blendMode"
            /**
             * 混合模式
             * @member {string} dragonBones.Slot#blendMode
             */
            ,function () {
                return this._blendMode;
            }
            ,function (value) {
                if (this._blendMode != value) {
                    this._blendMode = value;
                    this._updateDisplayBlendMode(this._blendMode);
                }
            }
        );
        d(p, "gotoAndPlay",undefined
            /**
             * 播放子骨架的动画
             * @member {string} dragonBones.Slot#gotoAndPlay
             */
            ,function (value) {
                if (this._gotoAndPlay != value) {
                    this._gotoAndPlay = value;
                    this.updateChildArmatureAnimation();
                }
            }
        );
        //Abstract method
        /**
         * @private
         */
        p._updateDisplay = function (value) {
            throw new Error("");
        };
        /**
         * @private
         */
        p._getDisplayIndex = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * Adds the original display object to another display object.
         * @param container
         * @param index
         */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * remove the original display object from its parent.
         */
        p._removeDisplayFromContainer = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         * Updates the transform of the slot.
         */
        p._updateTransform = function () {
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         */
        p._updateDisplayVisible = function (value) {
            /**
             * bone.visible && slot.visible && updateVisible
             * this._parent.visible && this._visible && value;
             */
            throw new Error(egret.getString(4001));
        };
        /**
         * @private
         */
        p._updateFFD = function (vertices, offset) {
            this._ffdChanged = true;
            this._ffdVertices = vertices;
            this._ffdOffset = offset;
        };
        /**
         * @private
         * Updates the color of the display object.
         * @param a
         * @param r
         * @param g
         * @param b
         * @param aM
         * @param rM
         * @param gM
         * @param bM
         */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            if (colorChanged === void 0) { colorChanged = false; }
            this._colorTransform.alphaOffset = aOffset;
            this._colorTransform.redOffset = rOffset;
            this._colorTransform.greenOffset = gOffset;
            this._colorTransform.blueOffset = bOffset;
            this._colorTransform.alphaMultiplier = aMultiplier;
            this._colorTransform.redMultiplier = rMultiplier;
            this._colorTransform.greenMultiplier = gMultiplier;
            this._colorTransform.blueMultiplier = bMultiplier;
            this._isColorChanged = colorChanged;
        };
        /**
         * @private
         * Update the blend mode of the display object.
         * @param value The blend mode to use.
         */
        p._updateDisplayBlendMode = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            var displayControl = animationState.displayControl &&
                animationState.containsBoneMask(this.parent.name);
            if (displayControl) {
                var slotFrame = frame;
                var displayIndex = slotFrame.displayIndex;
                var childSlot;
                this._changeDisplay(displayIndex);
                this._updateDisplayVisible(slotFrame.visible);
                if (displayIndex >= 0) {
                    if (!isNaN(slotFrame.zOrder) && slotFrame.zOrder != this._tweenZOrder) {
                        this._tweenZOrder = slotFrame.zOrder;
                        this._armature._slotsZOrderChanged = true;
                    }
                }
                //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
                //后续会扩展更多的action，目前只有gotoAndPlay的含义
                if (frame.action) {
                    if (this.childArmature) {
                        this.childArmature.animation.gotoAndPlay(frame.action);
                    }
                }
                else {
                    this.gotoAndPlay = slotFrame.gotoAndPlay;
                }
            }
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            var output = this._calculateParentTransform();
            if (output) {
                this._globalTransformMatrix.concat(output.parentGlobalTransformMatrix);
                dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, this._global.scaleX * output.parentGlobalTransform.scaleX >= 0, this._global.scaleY * output.parentGlobalTransform.scaleY >= 0);
            }
            return output;
        };
        p._resetToOrigin = function () {
            this._changeDisplay(this._originDisplayIndex);
            this._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, true);
        };
        /**
         * @private
         */
        p._updateMesh = function () {
        };
        return Slot;
    }(dragonBones.DBObject));
    dragonBones.Slot = Slot;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationCache
     * @classdesc
     * AnimationCache 实例是动画缓存的实体，包含一个动画的所有缓存数据。
     * 每个Slot的缓存数据存在各个SlotTimelineCache中。
     * 一般来说 AnimationCache 不需要开发者直接操控，而是由AnimationCacheManager代为管理。
     * @see dragonBones.AnimationCacheManager
     * @see dragonBones.TimelineCache
     * @see dragonBones.SlotTimelineCache
     * @see dragonBones.SlotFrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

        //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
        </pre>
     */
    var AnimationCache = (function () {
        function AnimationCache() {
            //		public var boneTimelineCacheList:Vector.<BoneTimelineCache> = new Vector.<BoneTimelineCache>();
            this.slotTimelineCacheList = [];
            //		public var boneTimelineCacheDic:Object = {};
            this.slotTimelineCacheDic = {};
            this.frameNum = 0;
            // Modify Fast mode by duanchunlei
            this._cahceList = [];
        }
        var d = __define,c=AnimationCache,p=c.prototype;
        AnimationCache.initWithAnimationData = function (animationData, armatureData) {
            var output = new AnimationCache();
            output.name = animationData.name;
            //var boneTimelineList:Array<TransformTimeline> = animationData.timelineList;
            var boneName;
            var boneData;
            var slotData;
            var slotTimelineCache;
            var slotName;
            for (var i = 0, length = armatureData.boneDataList.length; i < length; i++) {
                boneName = armatureData.boneDataList[i].name;
                for (var j = 0, jlen = armatureData.slotDataList.length; j < jlen; j++) {
                    slotData = armatureData.slotDataList[j];
                    slotName = slotData.name;
                    if (slotData.parent == boneName) {
                        if (output.slotTimelineCacheDic[slotName] == null) {
                            slotTimelineCache = new dragonBones.SlotTimelineCache();
                            slotTimelineCache.name = slotName;
                            output.slotTimelineCacheList.push(slotTimelineCache);
                            output.slotTimelineCacheDic[slotName] = slotTimelineCache;
                        }
                    }
                }
            }
            return output;
        };
        //		public function initBoneTimelineCacheDic(boneCacheGeneratorDic:Object, boneFrameCacheDic:Object):void
        //		{
        //			var name:String;
        //			for each(var boneTimelineCache:BoneTimelineCache in boneTimelineCacheDic)
        //			{
        //				name = boneTimelineCache.name;
        //				boneTimelineCache.cacheGenerator = boneCacheGeneratorDic[name];
        //				boneTimelineCache.currentFrameCache = boneFrameCacheDic[name];
        //			}
        //		}
        p.initSlotTimelineCacheDic = function (slotCacheGeneratorDic, slotFrameCacheDic) {
            var name;
            for (var k in this.slotTimelineCacheDic) {
                var slotTimelineCache = this.slotTimelineCacheDic[k];
                name = slotTimelineCache.name;
                slotTimelineCache.cacheGenerator = slotCacheGeneratorDic[name];
                slotTimelineCache.currentFrameCache = slotFrameCacheDic[name];
            }
        };
        //		public function bindCacheUserBoneDic(boneDic:Object):void
        //		{
        //			for(var name:String in boneDic)
        //			{
        //				(boneTimelineCacheDic[name] as BoneTimelineCache).bindCacheUser(boneDic[name]);
        //			}
        //		}
        p.bindCacheUserSlotDic = function (slotDic) {
            for (var name in slotDic) {
                (this.slotTimelineCacheDic[name]).bindCacheUser(slotDic[name]);
            }
        };
        p.addFrame = function (frameIndex, armature) {
            //this.frameNum++;
            //			var boneTimelineCache:BoneTimelineCache;
            //			for(var i:int = 0, length:int = boneTimelineCacheList.length; i < length; i++)
            //			{
            //				boneTimelineCache = boneTimelineCacheList[i];
            //				boneTimelineCache.addFrame();
            //			}
            var slotTimelineCache;
            for (var i = 0, length = this.slotTimelineCacheList.length; i < length; i++) {
                slotTimelineCache = this.slotTimelineCacheList[i];
                slotTimelineCache.addFrame(frameIndex, armature);
            }
            this._cahceList[frameIndex] = true;
        };
        p.update = function (progress) {
            var frameIndex = Math.floor(progress * (this.frameNum - 1));
            //			var boneTimelineCache:BoneTimelineCache;
            //			for(var i:int = 0, length:int = boneTimelineCacheList.length; i < length; i++)
            //			{
            //				boneTimelineCache = boneTimelineCacheList[i];
            //				boneTimelineCache.update(frameIndex);
            //			}
            var slotTimelineCache;
            for (var i = 0, length = this.slotTimelineCacheList.length; i < length; i++) {
                slotTimelineCache = this.slotTimelineCacheList[i];
                slotTimelineCache.update(frameIndex);
            }
        };
        return AnimationCache;
    }());
    dragonBones.AnimationCache = AnimationCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationCacheManager
     * @classdesc
     * AnimationCacheManager 实例是动画缓存管理器，他可以为一个或多个同类型的Armature生成动画缓存数据，从而提高动画运行效率。
     * 目前AnimationCacheManager只支持对FastArmatrue生成缓存，以后会扩展为对任何实现ICacheableArmature接口的Armature生成缓存。
     * @see dragonBones.ICacheableArmature
     * @see dragonBones.FastArmature
     * @see dragonBones.AnimationCache
     * @see dragonBones.FrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var AnimationCacheManager = (function () {
        function AnimationCacheManager() {
            this.animationCacheDic = {};
            //		public var boneFrameCacheDic:Object = {};
            this.slotFrameCacheDic = {};
        }
        var d = __define,c=AnimationCacheManager,p=c.prototype;
        /**
         * 通过ArmatrueData创建并初始化AnimationCacheManager。
         * AnimationCacheManager的创建需要依赖ArmatrueData。
         * @param armatureData {ArmatureData} 骨架数据实例。
         * @param frameRate {number} 帧频。帧频决定生成数据缓存的采样率。
         * @see dragonBones.ArmatureData.
         */
        AnimationCacheManager.initWithArmatureData = function (armatureData, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            var output = new AnimationCacheManager();
            output.armatureData = armatureData;
            if (frameRate <= 0) {
                var animationData = armatureData.animationDataList[0];
                if (animationData) {
                    output.frameRate = animationData.frameRate;
                }
            }
            else {
                output.frameRate = frameRate;
            }
            return output;
        };
        /**
         * 为所有动画初始化AnimationCache实例。在生成动画缓存之前需要调用这个API生成相应的AnimationCache实例
         * @see dragonBones.AnimationCache.
         */
        p.initAllAnimationCache = function () {
            var length = this.armatureData.animationDataList.length;
            for (var i = 0; i < length; i++) {
                var animationData = this.armatureData.animationDataList[i];
                this.animationCacheDic[animationData.name] = dragonBones.AnimationCache.initWithAnimationData(animationData, this.armatureData);
            }
        };
        /**
         * 指定动画名，初始化AnimationCache实例。在生成动画缓存之前需要调用这个API生成相应的AnimationCache实例
         * @param animationName {string} 动画名。
         * @see dragonBones.AnimationCache.
         */
        p.initAnimationCache = function (animationName) {
            this.animationCacheDic[animationName] = dragonBones.AnimationCache.initWithAnimationData(this.armatureData.getAnimationData(animationName), this.armatureData);
        };
        /**
         * 绑定Armature列表做为动画缓存的使用者。
         * 在为Armature生成动画缓存之前，需要将其绑定为动画缓存的使用者
         * @param armatures {Array<any>} 骨架列表。
         * @see dragonBones.ICacheableArmature.
         */
        p.bindCacheUserArmatures = function (armatures) {
            var length = armatures.length;
            for (var i = 0; i < length; i++) {
                var armature = armatures[i];
                this.bindCacheUserArmature(armature);
            }
        };
        /**
         * 绑定制定Armature做为动画缓存的使用者。
         * 在为Armature生成动画缓存之前，需要将其绑定为动画缓存的使用者
         * @param armatures {FastArmature} 要绑定为缓存使用者的骨架对象。
         * @see dragonBones.ICacheableArmature.
         */
        p.bindCacheUserArmature = function (armature) {
            armature.animation.animationCacheManager = this;
            var cacheUser;
            //			for each(cacheUser in armature._boneDic)
            //			{
            //				cacheUser.frameCache = boneFrameCacheDic[cacheUser.name];
            //			}
            /*for( var k in armature._slotDic)
            {
                cacheUser = armature._slotDic[k];
                cacheUser.frameCache = this.slotFrameCacheDic[cacheUser.name];
            }*/
            /*
            var length:number = armature._slotDic.length;
            for(var i:number = 0;i < length;i++){
                cacheUser = armature._slotDic[i];
                cacheUser.frameCache = this.slotFrameCacheDic[cacheUser.name];
            }
            */
        };
        /**
         * 设置指定的Armature做为动画缓存的生成器。（同一个Armature可以既是缓存使用者，也是缓存生成器）
         * 在为Armature生成动画缓存之前，需要设置动画缓存的生成器
         * @param armatures {FastArmature} 要设置为缓存生成器的骨架对象。
         * @see dragonBones.ICacheableArmature.
         */
        p.setCacheGeneratorArmature = function (armature) {
            this.cacheGeneratorArmature = armature;
            var cacheUser;
            //			for each(cacheUser in armature._boneDic)
            //			{
            //				boneFrameCacheDic[cacheUser.name] = new FrameCache();
            //			}
            for (var slot in armature._slotDic) {
                cacheUser = armature._slotDic[slot];
                this.slotFrameCacheDic[cacheUser.name] = new dragonBones.SlotFrameCache();
            }
            /*
            var length:number = armature._slotDic.length;
            for(var i:number = 0;i < length;i++){
                cacheUser = armature._slotDic[i];
                this.slotFrameCacheDic[cacheUser.name] = new SlotFrameCache();
            }
            */
            for (var anim in this.animationCacheDic) {
                var animationCache = this.animationCacheDic[anim];
                animationCache.initSlotTimelineCacheDic(armature._slotDic, this.slotFrameCacheDic);
            }
            /*
            var length1:number = this.animationCacheDic.length;
            for(var i1:number = 0;i1 < length1;i1++){
                var animationCache:AnimationCache = this.animationCacheDic[i1];
//				animationCache.initBoneTimelineCacheDic(armature._boneDic, boneFrameCacheDic);
                animationCache.initSlotTimelineCacheDic(armature._slotDic, this.slotFrameCacheDic);
            }
            */
        };
        /**
         * 生成所有动画缓存数据。生成之后，所有绑定CacheUser的Armature就都能够使用这些缓存了。
         * 在为调用这个API生成动画缓存之前，需要：
         * 1.调用API initAllAnimationCache 初始化AnimationCache实例
         * 2.调用API setCacheGeneratorArmature 设置动画缓存的生成器,
         * 3.调用API bindCacheUserArmatures 绑定动画缓存的使用者
         * @param loop {boolean} 要生成缓存的动画是否需要循环播放。如果该动画在播放时只需要播放一次，则设置为false。如果需要播放大于一次，则设置为true。
         * @see dragonBones.AnimationCache
         */
        p.generateAllAnimationCache = function (loop) {
            /*
            var length:number = this.animationCacheDic.length;
            for(var i:number = 0;i < length;i++){
                var animationCache:AnimationCache = this.animationCacheDic[i];
                this.generateAnimationCache(animationCache.name);
            }
            */
            for (var anim in this.animationCacheDic) {
                var animationCache = this.animationCacheDic[anim];
                this.generateAnimationCache(animationCache.name, loop);
            }
        };
        /**
         * 生成指定动画缓存数据。生成之后，所有绑定CacheUser的Armature就都能够使用这些缓存了。
         * 在为调用这个API生成动画缓存之前，需要：
         * 1.调用API initAnimationCache 初始化AnimationCache实例
         * 2.调用API setCacheGeneratorArmature 设置动画缓存的生成器,
         * 3.调用API bindCacheUserArmatures 绑定动画缓存的使用者
         * @param animationName {string} 要生成缓存的动画名。
         * @param loop {boolean} 要生成缓存的动画是否需要循环播放。如果该动画在播放时只需要播放一次，则设置为false。如果需要播放大于一次，则设置为true。
         * @see dragonBones.AnimationCache
         */
        p.generateAnimationCache = function (animationName, loop) {
            var temp = this.cacheGeneratorArmature.enableCache;
            this.cacheGeneratorArmature.enableCache = false;
            var animationCache = this.animationCacheDic[animationName];
            if (!animationCache) {
                return;
            }
            var animationState = this.cacheGeneratorArmature.getAnimation().animationState;
            var passTime = 1 / this.frameRate;
            if (loop) {
                this.cacheGeneratorArmature.getAnimation().gotoAndPlay(animationName, 0, -1, 0);
            }
            else {
                this.cacheGeneratorArmature.getAnimation().gotoAndPlay(animationName, 0, -1, 1);
            }
            var tempEnableEventDispatch = this.cacheGeneratorArmature.enableEventDispatch;
            this.cacheGeneratorArmature.enableEventDispatch = false;
            var lastProgress;
            do {
                lastProgress = animationState.progress;
                this.cacheGeneratorArmature.advanceTime(passTime);
            } while (animationState.progress >= lastProgress && animationState.progress < 1);
            this.cacheGeneratorArmature.enableEventDispatch = tempEnableEventDispatch;
            this.resetCacheGeneratorArmature();
            this.cacheGeneratorArmature.enableCache = temp;
        };
        /**
         * 将缓存生成器骨架重置，生成动画缓存后调用。
         * @see dragonBones.ICacheableArmature
         */
        p.resetCacheGeneratorArmature = function () {
            this.cacheGeneratorArmature.resetAnimation();
        };
        /**
         * 获取制定名称的AnimationCache实例。
         * @param animationName {string} 动画名。
         * @see dragonBones.AnimationCache
         */
        p.getAnimationCache = function (animationName) {
            return this.animationCacheDic[animationName];
        };
        return AnimationCacheManager;
    }());
    dragonBones.AnimationCacheManager = AnimationCacheManager;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FrameCache = (function () {
        function FrameCache() {
            this.globalTransform = new dragonBones.DBTransform();
            this.globalTransformMatrix = new dragonBones.Matrix();
        }
        var d = __define,c=FrameCache,p=c.prototype;
        //浅拷贝提高效率
        p.copy = function (frameCache) {
            this.globalTransform = frameCache.globalTransform;
            this.globalTransformMatrix = frameCache.globalTransformMatrix;
        };
        p.clear = function () {
            this.globalTransform = FrameCache.ORIGIN_TRAMSFORM;
            this.globalTransformMatrix = FrameCache.ORIGIN_MATRIX;
        };
        FrameCache.ORIGIN_TRAMSFORM = new dragonBones.DBTransform();
        FrameCache.ORIGIN_MATRIX = new dragonBones.Matrix();
        return FrameCache;
    }());
    dragonBones.FrameCache = FrameCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotFrameCache
     * @classdesc
     * SlotFrameCache 存储了Slot的帧缓存数据。
     * @see dragonBones.FastSlot
     * @see dragonBones.ICacheUser
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var SlotFrameCache = (function (_super) {
        __extends(SlotFrameCache, _super);
        function SlotFrameCache() {
            _super.call(this);
            this.displayIndex = -1;
        }
        var d = __define,c=SlotFrameCache,p=c.prototype;
        //浅拷贝提高效率
        p.copy = function (frameCache) {
            _super.prototype.copy.call(this, frameCache);
            this.colorTransform = frameCache.colorTransform;
            this.displayIndex = frameCache.displayIndex;
            this.gotoAndPlay = frameCache.gotoAndPlay;
        };
        p.clear = function () {
            _super.prototype.clear.call(this);
            this.colorTransform = null;
            this.displayIndex = -1;
            this.gotoAndPlay = null;
        };
        return SlotFrameCache;
    }(dragonBones.FrameCache));
    dragonBones.SlotFrameCache = SlotFrameCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TimelineCache
     * @classdesc
     * TimelineCache 是时间轴缓存基类存。
     * @see dragonBones.SlotTimelineCache
     * @see dragonBones.FrameCache
     * @see dragonBones.ICacheUser
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var TimelineCache = (function () {
        function TimelineCache() {
            this.frameCacheList = new Array();
        }
        var d = __define,c=TimelineCache,p=c.prototype;
        p.addFrame = function (frameIndex, armature) {
        };
        p.update = function (frameIndex) {
            if (frameIndex === void 0) { frameIndex = 0; }
            this.currentFrameCache.copy(this.frameCacheList[frameIndex]);
        };
        p.bindCacheUser = function (cacheUser) {
            cacheUser.frameCache = this.currentFrameCache;
        };
        return TimelineCache;
    }());
    dragonBones.TimelineCache = TimelineCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimelineCache
     * @classdesc
     * SlotTimelineCache 存储了Slot的时间轴缓存数据。
     * @see dragonBones.TimelineCache
     * @see dragonBones.SlotFrameCache
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var SlotTimelineCache = (function (_super) {
        __extends(SlotTimelineCache, _super);
        function SlotTimelineCache() {
            _super.call(this);
        }
        var d = __define,c=SlotTimelineCache,p=c.prototype;
        p.addFrame = function (frameIndex, armature) {
            var cache = new dragonBones.SlotFrameCache();
            var slot = armature.getSlot(this.name);
            if (slot.global != slot._globalBackup) {
                cache.globalTransform = slot.global;
                cache.globalTransformMatrix = slot.globalTransformMatrix;
            }
            else {
                cache.globalTransform.copy(slot.global);
                cache.globalTransformMatrix.copyFrom(slot.globalTransformMatrix);
            }
            if (slot.colorChanged) {
                cache.colorTransform = dragonBones.ColorTransformUtil.cloneColor(slot.colorTransform);
            }
            cache.displayIndex = slot.displayIndex;
            cache.gotoAndPlay = slot.gotoAndPlay;
            this.frameCacheList[frameIndex] = cache;
        };
        return SlotTimelineCache;
    }(dragonBones.TimelineCache));
    dragonBones.SlotTimelineCache = SlotTimelineCache;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Event
     * @classdesc
     * 事件
     */
    var Event = (function (_super) {
       // __extends(Event, _super);
        /**
         * 创建一个Event实例
         * @param type 事件的类型
         */
        function Event(type, bubbles, cancelable) {
            if (bubbles === void 0) { bubbles = false; }
            if (cancelable === void 0) { cancelable = false; }
	        this.bubbles = bubbles;
            this.cancelable = cancelable;
            this.type = type;

    //        _super.call(this, type, bubbles, cancelable);
        }
        var d = __define,c=Event;p=c.prototype;
        return Event;
    })();
    dragonBones.Event = Event;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.AnimationEvent
     * @extends dragonBones.Event
     * @classdesc
     * 动画事件
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var AnimationEvent = (function (_super) {
        __extends(AnimationEvent, _super);
        /**
         * 创建一个新的 AnimationEvent 的实例
         * @param type 事件的类型
         * @param cancelable
         */
        function AnimationEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=AnimationEvent,p=c.prototype;
        d(AnimationEvent, "MOVEMENT_CHANGE"
            /**
             * 不推荐使用.
             */
            ,function () {
                return AnimationEvent.FADE_IN;
            }
        );
        d(p, "movementID"
            /**
             * 不推荐的API.
             * @member {string} dragonBones.AnimationEvent#movementID
             */
            ,function () {
                return this.animationName;
            }
        );
        d(p, "armature"
            /**
             * 配发出事件的骨架
             * @member {dragonBones.Armature} dragonBones.AnimationEvent#armature
             */
            ,function () {
                return (this.target);
            }
        );
        d(p, "animationName"
            /**
             * 获取动画的名字
             * @returns {string}
             * @member {string} dragonBones.AnimationEvent#animationName
             */
            ,function () {
                return this.animationState.name;
            }
        );
        /**
         * 当动画缓入的时候派发
         */
        AnimationEvent.FADE_IN = "fadeIn";
        /**
         * 当动画缓出的时候派发
         */
        AnimationEvent.FADE_OUT = "fadeOut";
        /**
         * 当动画开始播放时派发
         */
        AnimationEvent.START = "start";
        /**
         * 当动画停止时派发
         */
        AnimationEvent.COMPLETE = "complete";
        /**
         * 当动画播放完一轮后派发
         */
        AnimationEvent.LOOP_COMPLETE = "loopComplete";
        /**
         * 当动画缓入完成时派发
         */
        AnimationEvent.FADE_IN_COMPLETE = "fadeInComplete";
        /**
         * 当动画缓出结束后派发
         */
        AnimationEvent.FADE_OUT_COMPLETE = "fadeOutComplete";
        return AnimationEvent;
    }(dragonBones.Event));
    dragonBones.AnimationEvent = AnimationEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ArmatureEvent
     * @extends dragonBones.Event
     * @classdesc
     * 骨架事件
     */
    var ArmatureEvent = (function (_super) {
        __extends(ArmatureEvent, _super);
        /**
         * 创建一个 ArmatureEvent 的实例
         * @param type 事件类型
         */
        function ArmatureEvent(type) {
            _super.call(this, type);
        }
        var d = __define,c=ArmatureEvent,p=c.prototype;
        /**
         * 当zOrder成功更新后派发
         */
        ArmatureEvent.Z_ORDER_UPDATED = "zOrderUpdated";
        return ArmatureEvent;
    }(dragonBones.Event));
    dragonBones.ArmatureEvent = ArmatureEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FrameEvent
     * @extends dragonBones.Event
     * @classdesc
     * 帧事件
     *
     * @example
     * <pre>
     *  private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

     * </pre>
     */
    var FrameEvent = (function (_super) {
        __extends(FrameEvent, _super);
        /**
         * 创建一个新的 FrameEvent 实例
         * @param type 事件类型
         * @param cancelable
         */
        function FrameEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=FrameEvent,p=c.prototype;
        d(FrameEvent, "MOVEMENT_FRAME_EVENT"
            ,function () {
                return FrameEvent.ANIMATION_FRAME_EVENT;
            }
        );
        d(p, "armature"
            /**
             * 派发这个事件的骨架
             * @member {dragonBones.Armature} dragonBones.FrameEvent#armature
             */
            ,function () {
                return (this.target);
            }
        );
        /**
         * 当动画播放到一个关键帧时派发
         */
        FrameEvent.ANIMATION_FRAME_EVENT = "animationFrameEvent";
        /**
         *
         */
        FrameEvent.BONE_FRAME_EVENT = "boneFrameEvent";
        return FrameEvent;
    }(dragonBones.Event));
    dragonBones.FrameEvent = FrameEvent;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SoundEvent
     * @extends dragonBones.Event
     * @classdesc
     * 声音事件
     *
     * @example
       <pre>
        private exampleEvent():void
        {
            //获取动画数据
            var skeletonData = RES.getRes("skeleton");
            //获取纹理集数据
            var textureData = RES.getRes("textureConfig");
            //获取纹理集图片
            var texture = RES.getRes("texture");

            //创建一个工厂，用来创建Armature
            var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
            //把动画数据添加到工厂里
            factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
            //把纹理集数据和图片添加到工厂里
            factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

            //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
            var armatureName:string = skeletonData.armature[0].name;
            //从工厂里创建出Armature
            var armature:dragonBones.Armature = factory.buildArmature(armatureName);
            //获取装载Armature的容器
            var armatureDisplay = armature.display;
            armatureDisplay.x = 200;
            armatureDisplay.y = 400;
            //把它添加到舞台上
            this.addChild(armatureDisplay);

            //监听事件时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT, this.onFrameEvent,this);
            //监听骨骼时间轴上的事件
            armature.addEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT, this.onFrameEvent,this);
            //监听动画完成事件
            armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, this.onAnimationEvent,this);
            //监听动画开始事件
            armature.addEventListener(dragonBones.AnimationEvent.START, this.onAnimationEvent,this);
            //监听循环动画，播放完一遍的事件
            armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, this.onAnimationEvent,this);
            //监听声音事件
            var soundManager:dragonBones.SoundEventManager = dragonBones.SoundEventManager.getInstance();
            soundManager.addEventListener(dragonBones.SoundEvent.SOUND, this.onSoundEvent,this);

            //取得这个Armature动画列表中的第一个动画的名字
            var curAnimationName = armature.animation.animationList[0];
            //播放一遍动画
            armature.animation.gotoAndPlay(curAnimationName,0,-1,1);

            //把Armature添加到心跳时钟里
            dragonBones.WorldClock.clock.add(armature);
            //心跳时钟开启
            egret.Ticker.getInstance().register(function (advancedTime) {
                dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
            }, this);
        }
        private onFrameEvent(evt: dragonBones.FrameEvent):void
        {
            //打印出事件的类型，和事件的帧标签
            console.log(evt.type, evt.frameLabel);
        }

        private onAnimationEvent(evt: dragonBones.AnimationEvent):void
        {
            switch(evt.type)
            {
                case dragonBones.AnimationEvent.START:
                     break;
                case dragonBones.AnimationEvent.LOOP_COMPLETE:
                     break;
                case dragonBones.AnimationEvent.COMPLETE:
                     //动画完成后销毁这个armature
                     this.removeChild(evt.armature.display);
                     dragonBones.WorldClock.clock.remove(evt.armature);
                     evt.armature.dispose();
                     break;
            }
        }

        private onSoundEvent(evt: dragonBones.SoundEvent):void
        {
            //播放声音
            var flySound:egret.Sound = RES.getRes(evt.sound);
            console.log("soundEvent",evt.sound);
        }

       </pre>
     */
    var SoundEvent = (function (_super) {
        __extends(SoundEvent, _super);
        /**
         * Creates a new SoundEvent instance.
         * @param type
         * @param cancelable
         */
        function SoundEvent(type, cancelable) {
            if (cancelable === void 0) { cancelable = false; }
            _super.call(this, type);
        }
        var d = __define,c=SoundEvent,p=c.prototype;
        /**
         * Dispatched when the animation of the animation enter a frame containing sound labels.
         */
        SoundEvent.SOUND = "sound";
        return SoundEvent;
    }(dragonBones.Event));
    dragonBones.SoundEvent = SoundEvent;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.BaseFactory
     * @classdesc
     * 工厂的基类
     * @extends dragonBones.EventDispatcher
     *
     * @example
       <pre>
         //获取动画数据
         var skeletonData = RES.getRes("skeleton");
         //获取纹理集数据
         var textureData = RES.getRes("textureConfig");
         //获取纹理集图片
         var texture = RES.getRes("texture");

         //创建一个工厂，用来创建Armature
         var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
         //把动画数据添加到工厂里
         factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
         //把纹理集数据和图片添加到工厂里
         factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
         //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
         var armatureName:string = skeletonData.armature[0].name;
         //从工厂里创建出Armature
         var armature:dragonBones.Armature = factory.buildArmature(armatureName);
         //获取装载Armature的容器
         var armatureDisplay = armature.display;
         //把它添加到舞台上
         this.addChild(armatureDisplay);
         //取得这个Armature动画列表中的第一个动画的名字
         var curAnimationName = armature.animation.animationList[0];
         //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
         //第一个参数 animationName {string} 指定播放动画的名称.
         //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

         //把Armature添加到心跳时钟里
         dragonBones.WorldClock.clock.add(armature);
         //心跳时钟开启
         egret.Ticker.getInstance().register(function (advancedTime) {
             dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
         }, this);
       </pre>
     */
    var BaseFactory = (function (_super) {
        __extends(BaseFactory, _super);
        function BaseFactory() {
            _super.call(this);
            /** @private */
            this.dragonBonesDataDic = {};
            /** @private */
            this.textureAtlasDic = {};
        }
        var d = __define,c=BaseFactory,p=c.prototype;
        /**
         * 释放资源
         * @param  disposeData {boolean} (optional) 是否释放所有内部的引用
         */
        p.dispose = function (disposeData) {
            if (disposeData === void 0) { disposeData = true; }
            if (disposeData) {
                for (var skeletonName in this.dragonBonesDataDic) {
                    (this.dragonBonesDataDic[skeletonName]).dispose();
                    delete this.dragonBonesDataDic[skeletonName];
                }
                for (var textureAtlasName in this.textureAtlasDic) {
                    var textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                    if (textureAtlasArr) {
                        for (var i = 0, len = textureAtlasArr.length; i < len; i++) {
                            textureAtlasArr[i].dispose();
                        }
                    }
                    delete this.textureAtlasDic[textureAtlasName];
                }
            }
            this.dragonBonesDataDic = null;
            this.textureAtlasDic = null;
            //_currentDataName = null;
            //_currentTextureAtlasName = null;
        };
        /**
         * 根据名字获取一个DragonBonesData
         * @param name {string} 想要获取的DragonBonesData的名字
         * @returns {dragonBones.DragonBonesData} 返回指定名字的DragonBonesData（如果存在的话）
         */
        p.getDragonBonesData = function (name) {
            return this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字获取一个DragonBonesData（不推荐使用）
         * 建议使用方法getDragonBonesData来代替这个方法
         */
        p.getSkeletonData = function (name) {
            return this.getDragonBonesData(name);
        };
        /**
         * 添加一个DragonBonesData实例
         * @param data {dragonBones.DragonBonesData} 一个DragonBonesData实例
         * @param name {string} (optional) DragonBonesData的名字
         */
        p.addDragonBonesData = function (data, name) {
            if (name === void 0) { name = null; }
            if (!data) {
                throw new Error();
            }
            name = name || data.name;
            if (!name) {
                throw new Error(egret.getString(4002));
            }
            /*
            if(this.dragonBonesDataDic[name]){
                throw new Error();
            }*/
            this.dragonBonesDataDic[name] = data;
        };
        /**
         * 添加一个DragonBonesData实例（不推荐使用）
         * 建议使用方法addDragonBonesData来代替
         */
        p.addSkeletonData = function (data, name) {
            if (name === void 0) { name = null; }
            this.addDragonBonesData(data, name);
        };
        /**
         * 根据名字移除一个DragonBonesData实例.
         * @param name {string} 想要移除的DragonBonesData的名字
         */
        p.removeDragonBonesData = function (name) {
            delete this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字移除一个DragonBonesData实例.（不推荐使用）
         * 建议使用方法removeDragonBonesData代替
         */
        p.removeSkeletonData = function (name) {
            delete this.dragonBonesDataDic[name];
        };
        /**
         * 根据名字获取纹理集TextureAtlas
         * @param name {string} 需要获取的纹理集TextureAtlas的名字
         * @returns {any} 纹理集TextureAtlas
         */
        p.getTextureAtlas = function (name) {
            return this.textureAtlasDic[name];
        };
        /**
         * 添加一个纹理集
         * @param textureAtlas {any} 需要被添加的纹理集
         * @param name {string} (optional) 需要被添加的纹理集的名字
         */
        p.addTextureAtlas = function (textureAtlas, name) {
            if (name === void 0) { name = null; }
            if (!textureAtlas) {
                throw new Error();
            }
            if (!name && textureAtlas.hasOwnProperty("name")) {
                name = textureAtlas.name;
            }
            if (!name) {
                throw new Error(egret.getString(4002));
            }
            var textureAtlasArr = this.textureAtlasDic[name];
            if (textureAtlasArr == null) {
                textureAtlasArr = [];
                this.textureAtlasDic[name] = textureAtlasArr;
            }
            if (textureAtlasArr.indexOf(textureAtlas) != -1) {
                return;
            }
            textureAtlasArr.push(textureAtlas);
        };
        /**
         * 移除指定名字的纹理集
         * @param name {string} 需要移除的纹理集的名字
         */
        p.removeTextureAtlas = function (name) {
            delete this.textureAtlasDic[name];
        };
        /**
         * 获取TextureDisplay
         * @param textureName {string} 纹理的名字
         * @param textureAtlasName {string} 纹理集的名字
         * @param pivotX {number} 轴点的x坐标
         * @param pivotY {number} 轴点的y坐标
         * @returns {any} 返回的TextureDisplay
         */
        p.getTextureDisplay = function (textureName, textureAtlasName, pivotX, pivotY) {
            if (textureAtlasName === void 0) { textureAtlasName = null; }
            if (pivotX === void 0) { pivotX = NaN; }
            if (pivotY === void 0) { pivotY = NaN; }
            var targetTextureAtlas;
            var textureAtlasArr;
            var i;
            var len;
            if (textureAtlasName) {
                textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                if (textureAtlasArr) {
                    for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                        targetTextureAtlas = textureAtlasArr[i];
                        if (targetTextureAtlas.getRegion(textureName)) {
                            break;
                        }
                        targetTextureAtlas = null;
                    }
                }
            }
            else {
                for (textureAtlasName in this.textureAtlasDic) {
                    textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                    if (textureAtlasArr) {
                        for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                            targetTextureAtlas = textureAtlasArr[i];
                            if (targetTextureAtlas.getRegion(textureName)) {
                                break;
                            }
                            targetTextureAtlas = null;
                        }
                        if (targetTextureAtlas != null) {
                            break;
                        }
                    }
                }
            }
            if (!targetTextureAtlas) {
                return null;
            }
            if (isNaN(pivotX) || isNaN(pivotY)) {
                //默认dragonBonesData的名字和和纹理集的名字是一致的
                var data = this.dragonBonesDataDic[textureAtlasName];
                data = data ? data : this.findFirstDragonBonesData();
                if (data) {
                    var displayData = data.getDisplayDataByName(textureName);
                    if (displayData) {
                        pivotX = displayData.pivot.x;
                        pivotY = displayData.pivot.y;
                    }
                }
            }
            return this._generateDisplay(targetTextureAtlas, textureName, pivotX, pivotY);
        };
        /**
         * @private
         */
        p.getMeshDisplay = function (meshData, slot, textureAtlasName) {
            if (textureAtlasName === void 0) { textureAtlasName = null; }
            var targetTextureAtlas;
            var textureAtlasArr;
            var i;
            var len;
            var textureName = meshData.name;
            if (textureAtlasName) {
                textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                if (textureAtlasArr) {
                    for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                        targetTextureAtlas = textureAtlasArr[i];
                        if (targetTextureAtlas.getRegion(textureName)) {
                            break;
                        }
                        targetTextureAtlas = null;
                    }
                }
            }
            else {
                for (textureAtlasName in this.textureAtlasDic) {
                    textureAtlasArr = this.textureAtlasDic[textureAtlasName];
                    if (textureAtlasArr) {
                        for (i = 0, len = textureAtlasArr.length; i < len; i++) {
                            targetTextureAtlas = textureAtlasArr[i];
                            if (targetTextureAtlas.getRegion(textureName)) {
                                break;
                            }
                            targetTextureAtlas = null;
                        }
                        if (targetTextureAtlas != null) {
                            break;
                        }
                    }
                }
            }
            if (!targetTextureAtlas) {
                return null;
            }
            return this._generateMesh(targetTextureAtlas, textureName, meshData, slot);
        };
        /**
         * 构建骨架
         * 一般情况下dragonBonesData和textureAtlas是一对一的，通过相同的key对应。
         * @param armatureName 骨架的名字
         * @param fromDragonBonesDataName 骨架数据的名字 可选参数
         * @param fromTextureAtlasName 纹理集的名字 可选参数
         * @param skinName 皮肤的名字 可选参数
         * @returns {*}
         */
        p.buildArmature = function (armatureName, fromDragonBonesDataName, fromTextureAtlasName, skinName) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (fromTextureAtlasName === void 0) { fromTextureAtlasName = null; }
            if (skinName === void 0) { skinName = null; }
            var buildArmatureDataPackage = {};
            this.fillBuildArmatureDataPackageArmatureInfo(armatureName, fromDragonBonesDataName, buildArmatureDataPackage);
            if (fromTextureAtlasName == null) {
                fromTextureAtlasName = buildArmatureDataPackage.dragonBonesDataName;
            }
            var dragonBonesData = buildArmatureDataPackage.dragonBonesData;
            var armatureData = buildArmatureDataPackage.armatureData;
            if (!armatureData) {
                return null;
            }
            return this.buildArmatureUsingArmatureDataFromTextureAtlas(dragonBonesData, armatureData, fromTextureAtlasName, skinName);
        };
        /**
         * 构建fast骨架
         * 一般情况下dragonBonesData和textureAtlas是一对一的，通过相同的key对应。
         * @param armatureName 骨架的名字
         * @param fromDragonBonesDataName 骨架数据的名字 可选参数
         * @param fromTextureAtlasName 纹理集的名字 可选参数
         * @param skinName 皮肤的名字 可选参数
         * @returns {*}
         */
        p.buildFastArmature = function (armatureName, fromDragonBonesDataName, fromTextureAtlasName, skinName) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (fromTextureAtlasName === void 0) { fromTextureAtlasName = null; }
            if (skinName === void 0) { skinName = null; }
            var buildArmatureDataPackage = new BuildArmatureDataPackage();
            this.fillBuildArmatureDataPackageArmatureInfo(armatureName, fromDragonBonesDataName, buildArmatureDataPackage);
            if (fromTextureAtlasName == null) {
                fromTextureAtlasName = buildArmatureDataPackage.dragonBonesDataName;
            }
            var dragonBonesData = buildArmatureDataPackage.dragonBonesData;
            var armatureData = buildArmatureDataPackage.armatureData;
            if (!armatureData) {
                return null;
            }
            return this.buildFastArmatureUsingArmatureDataFromTextureAtlas(dragonBonesData, armatureData, fromTextureAtlasName, skinName);
        };
        /**
         * 用dragonBones数据，骨架数据，纹理集数据来构建骨架
         * @param dragonBonesData dragonBones数据
         * @param armatureData 骨架数据
         * @param textureAtlas 纹理集
         * @param skinName 皮肤名称 可选参数
         * @returns {Armature}
         */
        p.buildArmatureUsingArmatureDataFromTextureAtlas = function (dragonBonesData, armatureData, textureAtlasName, skinName) {
            if (skinName === void 0) { skinName = null; }
            var outputArmature = this._generateArmature();
            outputArmature.name = armatureData.name;
            outputArmature.__dragonBonesData = dragonBonesData;
            outputArmature._armatureData = armatureData;
            outputArmature._skewEnable = dragonBonesData.version >= 4.5;
            outputArmature.animation.animationDataList = armatureData.animationDataList;
            this._buildBones(outputArmature);
            outputArmature.buildIK();
            outputArmature.updateBoneCache();
            this._buildSlots(outputArmature, skinName, textureAtlasName);
            outputArmature.advanceTime(0);
            return outputArmature;
        };
        /**
         * 用dragonBones数据，骨架数据，纹理集数据来构建骨架
         * @param dragonBonesData dragonBones数据
         * @param armatureData 骨架数据
         * @param textureAtlas 纹理集
         * @param skinName 皮肤名称 可选参数
         * @returns {Armature}
         */
        p.buildFastArmatureUsingArmatureDataFromTextureAtlas = function (dragonBonesData, armatureData, textureAtlasName, skinName) {
            if (skinName === void 0) { skinName = null; }
            var outputArmature = this._generateFastArmature();
            outputArmature.name = armatureData.name;
            outputArmature.__dragonBonesData = dragonBonesData;
            outputArmature._armatureData = armatureData;
            outputArmature._skewEnable = dragonBonesData.version >= 4.5;
            outputArmature.animation.animationDataList = armatureData.animationDataList;
            this._buildFastBones(outputArmature);
            outputArmature.buildIK();
            outputArmature.updateBoneCache();
            this._buildFastSlots(outputArmature, skinName, textureAtlasName);
            outputArmature.updateSlotsZOrder();
            outputArmature.advanceTime(0);
            return outputArmature;
        };
        /**
         * 拷贝动画到骨架中
         * 暂时不支持ifRemoveOriginalAnimationList为false的情况
         * @param toArmature  拷贝到的那个骨架
         * @param fromArmatreName 从哪个骨架里拷贝，骨架的名字
         * @param fromDragonBonesDataName 从哪个DragonBones数据中拷贝，Dragonbones数据的名字
         * @param ifRemoveOriginalAnimationList 是否移除原骨架里的动画，暂时不支持为false的情况
         * @returns {boolean}
         */
        p.copyAnimationsToArmature = function (toArmature, fromArmatreName, fromDragonBonesDataName, ifRemoveOriginalAnimationList) {
            if (fromDragonBonesDataName === void 0) { fromDragonBonesDataName = null; }
            if (ifRemoveOriginalAnimationList === void 0) { ifRemoveOriginalAnimationList = true; }
            var buildArmatureDataPackage = {};
            if (!this.fillBuildArmatureDataPackageArmatureInfo(fromArmatreName, fromDragonBonesDataName, buildArmatureDataPackage)) {
                return false;
            }
            var fromArmatureData = buildArmatureDataPackage.armatureData;
            toArmature.animation.animationDataList = fromArmatureData.animationDataList;
            //处理子骨架的复制
            var fromSkinData = fromArmatureData.getSkinData("");
            var fromSlotData;
            var fromDisplayData;
            var toSlotList = toArmature.getSlots(false);
            var toSlot;
            var toSlotDisplayList;
            var toSlotDisplayListLength = 0;
            var toDisplayObject;
            var toChildArmature;
            var length1 = toSlotList.length;
            for (var i1 = 0; i1 < length1; i1++) {
                toSlot = toSlotList[i1];
                toSlotDisplayList = toSlot.displayList;
                toSlotDisplayListLength = toSlotDisplayList.length;
                for (var i = 0; i < toSlotDisplayListLength; i++) {
                    toDisplayObject = toSlotDisplayList[i];
                    if (toDisplayObject instanceof dragonBones.Armature) {
                        toChildArmature = toDisplayObject;
                        fromSlotData = fromSkinData.getSlotData(toSlot.name);
                        fromDisplayData = fromSlotData.displayDataList[i];
                        if (fromDisplayData.type == dragonBones.DisplayData.ARMATURE) {
                            this.copyAnimationsToArmature(toChildArmature, fromDisplayData.name, buildArmatureDataPackage.dragonBonesDataName, ifRemoveOriginalAnimationList);
                        }
                    }
                }
            }
            return true;
        };
        p.fillBuildArmatureDataPackageArmatureInfo = function (armatureName, dragonBonesDataName, outputBuildArmatureDataPackage) {
            if (dragonBonesDataName) {
                outputBuildArmatureDataPackage.dragonBonesDataName = dragonBonesDataName;
                outputBuildArmatureDataPackage.dragonBonesData = this.dragonBonesDataDic[dragonBonesDataName];
                outputBuildArmatureDataPackage.armatureData = outputBuildArmatureDataPackage.dragonBonesData.getArmatureDataByName(armatureName);
                return true;
            }
            else {
                for (dragonBonesDataName in this.dragonBonesDataDic) {
                    outputBuildArmatureDataPackage.dragonBonesData = this.dragonBonesDataDic[dragonBonesDataName];
                    outputBuildArmatureDataPackage.armatureData = outputBuildArmatureDataPackage.dragonBonesData.getArmatureDataByName(armatureName);
                    if (outputBuildArmatureDataPackage.armatureData) {
                        outputBuildArmatureDataPackage.dragonBonesDataName = dragonBonesDataName;
                        return true;
                    }
                }
            }
            return false;
        };
        p.fillBuildArmatureDataPackageTextureInfo = function (fromTextureAtlasName, outputBuildArmatureDataPackage) {
            outputBuildArmatureDataPackage.textureAtlas = this.textureAtlasDic[fromTextureAtlasName ? fromTextureAtlasName : outputBuildArmatureDataPackage.dragonBonesDataName];
        };
        p.findFirstDragonBonesData = function () {
            for (var key in this.dragonBonesDataDic) {
                var outputDragonBonesData = this.dragonBonesDataDic[key];
                if (outputDragonBonesData) {
                    return outputDragonBonesData;
                }
            }
            return null;
        };
        p.findFirstTextureAtlas = function () {
            for (var key in this.textureAtlasDic) {
                var outputTextureAtlas = this.textureAtlasDic[key];
                if (outputTextureAtlas) {
                    return outputTextureAtlas;
                }
            }
            return null;
        };
        p._buildBones = function (armature) {
            //按照从属关系的顺序建立
            var boneDataList = armature.armatureData.boneDataList;
            var boneData;
            var bone;
            var parent;
            for (var i = 0; i < boneDataList.length; i++) {
                boneData = boneDataList[i];
                bone = dragonBones.Bone.initWithBoneData(boneData);
                parent = boneData.parent;
                if (parent && armature.armatureData.getBoneData(parent) == null) {
                    parent = null;
                }
                //Todo use a internal addBone method to avoid sortBones every time.
                armature.addBone(bone, parent, true);
            }
            armature._updateAnimationAfterBoneListChanged();
        };
        p._buildSlots = function (armature, skinName, textureAtlasName) {
            var skinData = armature.armatureData.getSkinData(skinName);
            if (!skinData) {
                return;
            }
            armature.armatureData.setSkinData(skinName);
            var displayList = [];
            var slotDataList = armature.armatureData.slotDataList;
            var slotData;
            var slot;
            var bone;
            for (var i = 0; i < slotDataList.length; i++) {
                slotData = slotDataList[i];
                bone = armature.getBone(slotData.parent);
                if (!bone) {
                    continue;
                }
                slot = this._generateSlot();
                slot.initWithSlotData(slotData);
                bone.addSlot(slot);
                displayList.length = 0;
                var l = slotData.displayDataList.length;
                while (l--) {
                    var displayData = slotData.displayDataList[l];
                    switch (displayData.type) {
                        case dragonBones.DisplayData.ARMATURE:
                            var childArmature = this.buildArmatureUsingArmatureDataFromTextureAtlas(armature.__dragonBonesData, armature.__dragonBonesData.getArmatureDataByName(displayData.name), textureAtlasName, skinName);
                            displayList[l] = childArmature;
                            break;
                        case dragonBones.DisplayData.MESH:
                            displayList[l] = this.getMeshDisplay(displayData, slot, textureAtlasName);
                            break;
                        case dragonBones.DisplayData.IMAGE:
                        default:
                            displayList[l] = this.getTextureDisplay(displayData.name, textureAtlasName, displayData.pivot.x, displayData.pivot.y);
                            break;
                    }
                }
                //==================================================
                //如果显示对象有name属性并且name属性可以设置的话，将name设置为与slot同名，dragonBones并不依赖这些属性，只是方便开发者
                for (var j = 0, jLen = displayList.length; j < jLen; j++) {
                    var displayObject = displayList[j];
                    if (!displayObject) {
                        continue;
                    }
                    if (displayObject instanceof dragonBones.Armature) {
                        displayObject = displayObject.display;
                    }
                    if (displayObject.hasOwnProperty("name")) {
                        try {
                            displayObject["name"] = slot.name;
                        }
                        catch (err) {
                        }
                    }
                }
                //==================================================
                slot.displayList = displayList;
                slot._changeDisplay(slotData.displayIndex);
            }
        };
        p._buildFastBones = function (armature) {
            //按照从属关系的顺序建立
            var boneDataList = armature.armatureData.boneDataList;
            var boneData;
            var bone;
            for (var i = 0; i < boneDataList.length; i++) {
                boneData = boneDataList[i];
                bone = dragonBones.FastBone.initWithBoneData(boneData);
                armature.addBone(bone, boneData.parent);
            }
        };
        p._buildFastSlots = function (armature, skinName, textureAtlasName) {
            //根据皮肤初始化SlotData的DisplayDataList
            var skinData = armature.armatureData.getSkinData(skinName);
            if (!skinData) {
                return;
            }
            armature.armatureData.setSkinData(skinName);
            var slotDataList = armature.armatureData.slotDataList;
            var slotDisplayDataList = [];
            var displayList = [];
            var slotData;
            var slot;
            for (var i = 0; i < slotDataList.length; i++) {
                slotDisplayDataList.length = 0;
                displayList.length = 0;
                slotData = slotDataList[i];
                slot = this._generateFastSlot();
                slot.initWithSlotData(slotData);
                var l = slotData.displayDataList.length;
                while (l--) {
                    var displayData = slotData.displayDataList[l];
                    switch (displayData.type) {
                        case dragonBones.DisplayData.ARMATURE:
                            var childArmature = this.buildFastArmatureUsingArmatureDataFromTextureAtlas(armature.__dragonBonesData, armature.__dragonBonesData.getArmatureDataByName(displayData.name), textureAtlasName, skinName);
                            slotDisplayDataList[l] = [displayData, null];
                            displayList[l] = childArmature;
                            slot.hasChildArmature = true;
                            break;
                        case dragonBones.DisplayData.IMAGE:
                        case dragonBones.DisplayData.MESH:
                            slotDisplayDataList[l] = [displayData, this.getTextureData(displayData.name, textureAtlasName)];
                            displayList[l] = slot._rawDisplay;
                            break;
                        default:
                            slotDisplayDataList[l] = [displayData, null];
                            displayList[l] = null;
                            break;
                    }
                }
                //==================================================
                //如果显示对象有name属性并且name属性可以设置的话，将name设置为与slot同名，dragonBones并不依赖这些属性，只是方便开发者
                var length1 = displayList.length;
                for (var i1 = 0; i1 < length1; i1++) {
                    var displayObject = displayList[i1];
                    if (!displayObject) {
                        continue;
                    }
                    if (displayObject instanceof dragonBones.FastArmature) {
                        displayObject = displayObject.display;
                    }
                    if (displayObject.hasOwnProperty("name")) {
                        try {
                            displayObject["name"] = slot.name;
                        }
                        catch (err) {
                        }
                    }
                }
                //==================================================
                armature.addSlot(slot, slotData.parent);
                slot.displayDataList = slotDisplayDataList;
                slot.displayList = displayList;
                slot.displayIndex = slotData.displayIndex;
            }
        };
        p.getTextureData = function (textureName, textureAtlasName) {
            var textureData = null;
            var textureAtlasData = null;
            var textureAtlasDataList = this.textureAtlasDic[textureAtlasName];
            if (textureAtlasDataList) {
                for (var i in textureAtlasDataList) {
                    textureAtlasData = textureAtlasDataList[i];
                    textureData = textureAtlasData.getTextureData(textureName);
                    if (textureData) {
                        textureData.textureAtlas = textureAtlasData;
                        break;
                    }
                }
            }
            return textureData;
        };
        /**
         * @private
         * Generates an Armature instance.
         * @returns {dragonBones.Armature} Armature An Armature instance.
         */
        p._generateArmature = function () {
            return null;
        };
        /**
         * @private
         * Generates an Slot instance.
         * @returns {dragonBones.Slot} Slot An Slot instance.
         */
        p._generateSlot = function () {
            return null;
        };
        /**
         * @private
         * Generates an Armature instance.
         * @returns {dragonBones.Armature} Armature An Armature instance.
         */
        p._generateFastArmature = function () {
            return null;
        };
        /**
         * @private
         * Generates an Slot instance.
         * @returns {dragonBones.Slot} Slot An Slot instance.
         */
        p._generateFastSlot = function () {
            return null;
        };
        /**
         * @private
         * Generates a DisplayObject
         * @param textureAtlas {any} The TextureAtlas.
         * @param fullName {string} A qualified name.
         * @param pivotX {number} A pivot x based value.
         * @param pivotY {number} A pivot y based value.
         * @returns {any}
         */
        p._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
            return null;
        };
        /**
         * @private
         */
        p._generateMesh = function (textureAtlas, fullName, meshData, slot) {
            return null;
        };
        BaseFactory._helpMatrix = new dragonBones.Matrix();
        return BaseFactory;
    }(dragonBones.EventDispatcher));
    dragonBones.BaseFactory = BaseFactory;

    var BuildArmatureDataPackage = (function () {
        function BuildArmatureDataPackage() {
        }
        var d = __define,c=BuildArmatureDataPackage,p=c.prototype;
        return BuildArmatureDataPackage;
    }());
    dragonBones.BuildArmatureDataPackage = BuildArmatureDataPackage;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastArmature
     * @classdesc
     * FastArmature 是 DragonBones 高效率的骨骼动画系统。他能缓存动画数据，大大减少动画播放的计算
     * 不支持动态添加Bone和Slot，换装请通过更换Slot的dispaly或子骨架childArmature来实现
     * @extends dragonBones.EventDispatcher
     * @see dragonBones.ArmatureData
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastArmature = (function (_super) {
        __extends(FastArmature, _super);
        function FastArmature(display) {
            _super.call(this);
            /**
             * 保证CacheManager是独占的前提下可以开启，开启后有助于性能提高
             */
            this.isCacheManagerExclusive = false;
            this._cacheFrameIndex = -1;
            this._boneIKList = [];
            this._enableEventDispatch = true;
            /** @private*/
            this._useCache = true;
            /** @private*/
            this._isFrameCached = false;
            this._display = display;
            this._animation = new dragonBones.FastAnimation(this);
            this._slotsZOrderChanged = false;
            this._armatureData = null;
            this.boneList = [];
            this._boneDic = {};
            this.slotList = [];
            this._slotDic = {};
            this.slotHasChildArmatureList = [];
            this._eventList = [];
            this._ikList = [];
            this._delayDispose = false;
            this._lockDispose = false;
        }
        var d = __define,c=FastArmature,p=c.prototype;
        /**
         * Cleans up any resources used by this instance.
         */
        p.dispose = function () {
            this._delayDispose = true;
            if (!this._animation || this._lockDispose) {
                return;
            }
            this.userData = null;
            this._animation.dispose();
            var i = this.slotList.length;
            while (i--) {
                this.slotList[i].dispose();
            }
            i = this.boneList.length;
            while (i--) {
                this.boneList[i].dispose();
            }
            i = this._ikList.length;
            while (i--) {
                this._ikList[i].dispose();
            }
            this.slotList.length = 0;
            this.boneList.length = 0;
            this._armatureData = null;
            this._animation = null;
            this.slotList = null;
            this.boneList = null;
            this._eventList = null;
            this._ikList = null;
        };
        /**
         * Update the animation using this method typically in an ENTERFRAME Event or with a Timer.
         * @param The amount of second to move the playhead ahead.
         */
        p.advanceTime = function (passedTime) {
            this._lockDispose = true;
            this._isFrameCached = false;
            this._animation.advanceTime(passedTime);
            var bone;
            var slot;
            var i = 0;
            var len = this._boneIKList.length;
            var j;
            var jLen;
            if (this._isFrameCached) {
                if (!this._useCache) {
                    this._useCache = true;
                }
                i = this.slotList.length;
                while (i--) {
                    slot = this.slotList[i];
                    slot.updateByCache(this._cacheFrameIndex);
                }
            }
            else {
                if (this._useCache) {
                    this._useCache = false;
                }
                for (i = 0; i < len; i++) {
                    for (j = 0, jLen = this._boneIKList[i].length; j < jLen; j++) {
                        bone = this._boneIKList[i][j];
                        if (bone.isIKConstraint) {
                            var ikCon = this._ikList[i - 1];
                            if (ikCon.bones[0].name == bone.name) {
                                bone.update();
                                bone.rotationIK = bone.global.rotation;
                                if (ikCon.bones.length > 1) {
                                    ikCon.bones[1].update();
                                    ikCon.bones[1].rotationIK = ikCon.bones[1].global.rotation;
                                }
                                ikCon.compute();
                            }
                            bone.adjustGlobalTransformMatrixByIK();
                        }
                        else {
                            bone.update();
                            bone.rotationIK = bone.global.rotation;
                        }
                    }
                }
                i = this.slotList.length;
                while (i--) {
                    slot = this.slotList[i];
                    slot._update();
                }
            }
            i = this.slotHasChildArmatureList.length;
            while (i--) {
                slot = this.slotHasChildArmatureList[i];
                var childArmature = slot.childArmature;
                if (childArmature) {
                    childArmature.advanceTime(passedTime);
                }
            }
            if (this._slotsZOrderChanged) {
                this.updateSlotsZOrder();
            }
            // Modify Fast mode by duanchunlei
            if (!this._isFrameCached) {
                var animationCache = this._animation.animationState.animationCache;
                if (animationCache) {
                    animationCache.addFrame(this._cacheFrameIndex, this);
                }
            }
            while (this._eventList.length > 0) {
                this.dispatchEvent(this._eventList.shift());
            }
            this._lockDispose = false;
            if (this._delayDispose) {
                this.dispose();
            }
        };
        /**
         * 开启动画缓存
         * @param  {number} 帧速率，每秒缓存多少次数据，越大越流畅,若值小于零会被设置为动画数据中的默认帧率
         * @param  {Array<any>} 需要缓存的动画列表，如果为null，则全部动画都缓存
         * @param  {boolean} 动画是否是循环动画，仅在3.0以下的数据格式使用，如果动画不是循环动画请设置为false，默认为true。
         * @return {AnimationCacheManager}  返回缓存管理器，可以绑定到其他armature以减少内存
         */
        p.enableAnimationCache = function (frameRate, animationList, loop) {
            if (animationList === void 0) { animationList = null; }
            if (loop === void 0) { loop = true; }
            // Modify Fast mode by duanchunlei
            var animationCacheManager = this._armatureData._cacheManager;
            if (animationCacheManager) {
                //animationCacheManager.bindCacheUserArmature(this);
                this.enableCache = true;
                return animationCacheManager;
            }
            this._armatureData._cacheManager = animationCacheManager = dragonBones.AnimationCacheManager.initWithArmatureData(this.armatureData, frameRate);
            /*if(animationList){
                var length:number = animationList.length;
                for(var i:number = 0;i < length;i++){
                    var animationName:string = animationList[i];
                    animationCacheManager.initAnimationCache(animationName);
                }
            }*/
            //else{
            animationCacheManager.initAllAnimationCache();
            //}
            //animationCacheManager.setCacheGeneratorArmature(this);
            //animationCacheManager.generateAllAnimationCache(loop);
            //animationCacheManager.bindCacheUserArmature(this);
            this.enableCache = true;
            return animationCacheManager;
        };
        /**
         * 获取指定名称的 Bone
         * @param boneName {string} Bone名称
         * @returns {FastBone}
         */
        p.getBone = function (boneName) {
            return this._boneDic[boneName];
        };
        /**
         * 获取指定名称的 Slot
         * @param slotName {string} Slot名称
         * @returns {FastSlot}
         */
        p.getSlot = function (slotName) {
            return this._slotDic[slotName];
        };
        /**
         * 获取包含指定显示对象的 Bone
         * @param display {any} 显示对象实例
         * @returns {FastBone}
         */
        p.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot ? slot.parent : null;
        };
        /**
         * 获取包含指定显示对象的 Slot
         * @param displayObj {any} 显示对象实例
         * @returns {FastSlot}
         */
        p.getSlotByDisplay = function (displayObj) {
            if (displayObj) {
                for (var i = 0, len = this.slotList.length; i < len; i++) {
                    if (this.slotList[i].display == displayObj) {
                        return this.slotList[i];
                    }
                }
            }
            return null;
        };
        /**
         * 获取骨架包含的所有插槽
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastSlot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.slotList.concat() : this.slotList;
        };
        p._updateBonesByCache = function () {
            var i = this.boneList.length;
            var bone;
            while (i--) {
                bone = this.boneList[i];
                bone.update();
            }
        };
        /**
         * 在骨架中为指定名称的 FastBone 添加一个子 FastBone.
         * 和Armature不同,FastArmature的这个方法不能在运行时动态添加骨骼
         * @param bone {FastBone} FastBone 实例
         * @param parentName {string} 父骨头名称 默认：null
         */
        p.addBone = function (bone, parentName) {
            if (parentName === void 0) { parentName = null; }
            var parentBone;
            if (parentName) {
                parentBone = this.getBone(parentName);
                parentBone.boneList.push(bone);
            }
            bone.armature = this;
            bone.parentBoneData = parentBone;
            this.boneList.unshift(bone);
            this._boneDic[bone.name] = bone;
        };
        /**
         * 为指定名称的 FastBone 添加一个子 FastSlot.
         * 和Armature不同,FastArmature的这个方法不能在运行时动态添加插槽
         * @param slot {FastSlot} FastSlot 实例
         * @param boneName {string}
         * @see dragonBones.Bone
         */
        p.addSlot = function (slot, parentBoneName) {
            var bone = this.getBone(parentBoneName);
            if (bone) {
                slot.armature = this;
                slot.setParent(bone);
                bone.slotList.push(slot);
                slot._addDisplayToContainer(this.display);
                this.slotList.push(slot);
                this._slotDic[slot.name] = slot;
                if (slot.hasChildArmature) {
                    this.slotHasChildArmatureList.push(slot);
                }
            }
            else {
                throw new Error();
            }
        };
        /**
         * 按照显示层级为所有 Slot 排序
         */
        p.updateSlotsZOrder = function () {
            this.slotList.sort(this.sortSlot);
            var i = this.slotList.length;
            while (i--) {
                var slot = this.slotList[i];
                slot._addDisplayToContainer(this._display);
            }
            this._slotsZOrderChanged = false;
        };
        p.sortBoneList = function () {
            var i = this.boneList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var level = 0;
                var bone = this.boneList[i];
                var boneParent = bone;
                while (boneParent) {
                    level++;
                    boneParent = boneParent.parent;
                }
                helpArray[i] = [level, bone];
            }
            helpArray.sort(dragonBones.ArmatureData.sortBoneDataHelpArrayDescending);
            i = helpArray.length;
            while (i--) {
                this.boneList[i] = helpArray[i][1];
            }
            helpArray.length = 0;
        };
        /** @private When AnimationState enter a key frame, call this func*/
        p.arriveAtFrame = function (frame, animationState) {
            if (frame.event && this.hasEventListener(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.ANIMATION_FRAME_EVENT);
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                frameEvent.bone = frame.bone ? this.getBone(frame.bone) : null;
                this._addEvent(frameEvent);
            }
            if (frame.action) {
                this.animation.gotoAndPlay(frame.action);
            }
        };
        p.invalidUpdate = function (boneName) {
            if (boneName === void 0) { boneName = null; }
            if (boneName) {
                var bone = this.getBone(boneName);
                if (bone) {
                    bone.invalidUpdate();
                }
            }
            else {
                var i = this.boneList.length;
                while (i--) {
                    this.boneList[i].invalidUpdate();
                }
            }
        };
        p.resetAnimation = function () {
            this.animation.animationState._resetTimelineStateList();
            var length = this.boneList.length;
            for (var i = 0; i < length; i++) {
                var boneItem = this.boneList[i];
                boneItem._timelineState = null;
            }
            this.animation.stop();
        };
        p.sortSlot = function (slot1, slot2) {
            return slot1.zOrder < slot2.zOrder ? 1 : -1;
        };
        /**
         * 获取FastAnimation实例
         * @returns {any} FastAnimation实例
         */
        p.getAnimation = function () {
            return this._animation;
        };
        d(p, "armatureData"
            /**
             * ArmatureData.
             * @see dragonBones.ArmatureData.
             */
            ,function () {
                return this._armatureData;
            }
        );
        d(p, "animation"
            /**
             * An Animation instance
             * @see dragonBones.Animation
             */
            ,function () {
                return this._animation;
            }
        );
        d(p, "display"
            /**
             * Armature's display object. It's instance type depends on render engine. For example "flash.display.DisplayObject" or "startling.display.DisplayObject"
             */
            ,function () {
                return this._display;
            }
        );
        d(p, "enableCache"
            ,function () {
                return this._enableCache;
            }
            ,function (value) {
                this._enableCache = value;
            }
        );
        d(p, "enableEventDispatch"
            ,function () {
                return this._enableEventDispatch;
            }
            ,function (value) {
                this._enableEventDispatch = value;
            }
        );
        p._addEvent = function (event) {
            if (this._enableEventDispatch) {
                this._eventList.push(event);
            }
        };
        p.getIKs = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this._ikList.concat() : this._ikList;
        };
        p.buildIK = function () {
            var ikConstraintData;
            this._ikList.length = 0;
            for (var i = 0, len = this._armatureData.ikDataList.length; i < len; i++) {
                ikConstraintData = this._armatureData.ikDataList[i];
                this._ikList.push(new dragonBones.FastIKConstraint(ikConstraintData, this));
            }
        };
        p.updateBoneCache = function () {
            this.boneList.reverse();
            var temp = {};
            var ikConstraintsCount = this._ikList.length;
            var arrayCount = ikConstraintsCount + 1;
            var i;
            var len;
            var j;
            var jLen;
            var bone;
            var currentBone;
            this._boneIKList = [];
            while (this._boneIKList.length < arrayCount) {
                this._boneIKList[this._boneIKList.length] = [];
            }
            temp[this.boneList[0].name] = 0;
            for (i = 0, len = this._ikList.length; i < len; i++) {
                temp[this._ikList[i].bones[0].name] = i + 1;
            }
            next: for (i = 0, len = this.boneList.length; i < len; i++) {
                bone = this.boneList[i];
                currentBone = bone;
                while (currentBone) {
                    if (currentBone.parent == null) {
                        temp[currentBone.name] = 0;
                    }
                    if (temp.hasOwnProperty(currentBone.name)) {
                        this._boneIKList[temp[currentBone.name]].push(bone);
                        continue next;
                    }
                    currentBone = currentBone.parent;
                }
            }
        };
        p.getIKTargetData = function (bone) {
            var target = [];
            var ik;
            for (var i = 0, len = this._ikList.length; i < len; i++) {
                ik = this._ikList[i];
                if (bone.name == ik.target.name) {
                    target.push(ik);
                }
            }
            return target;
        };
        return FastArmature;
    }(dragonBones.EventDispatcher));
    dragonBones.FastArmature = FastArmature;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastDBObject
     * @classdesc
     * FastDBObject 是 FastBone 和 FastSlot 的基类
     * @see dragonBones.FastBone
     * @see dragonBones.FastSlot
     */
    var FastDBObject = (function () {
        function FastDBObject() {
            this._globalTransformMatrixBackup = this._globalTransformMatrix = new dragonBones.Matrix();
            this._globalBackup = this._global = new dragonBones.DBTransform();
            this._origin = new dragonBones.DBTransform();
            this._visible = true;
            this.armature = null;
            this._parent = null;
            this.userData = null;
            this.inheritRotation = true;
            this.inheritScale = true;
            this.inheritTranslation = true;
        }
        var d = __define,c=FastDBObject,p=c.prototype;
        /** @private */
        p.updateByCache = function (frameIndex) {
            this._global = this._frameCache.globalTransform;
            this._globalTransformMatrix = this._frameCache.globalTransformMatrix;
        };
        /** @private */
        p.switchTransformToBackup = function () {
            /*if(!this._globalBackup){
                this._globalBackup = new DBTransform();
                this._globalTransformMatrixBackup = new Matrix();
            }
            this._global = this._globalBackup;
            this._globalTransformMatrix = this._globalTransformMatrixBackup;*/
        };
        /** @private */
        p.setParent = function (value) {
            this._parent = value;
        };
        /**
         * Cleans up any resources used by this DBObject instance.
         */
        p.dispose = function () {
            this.userData = null;
            this._globalTransformMatrix = null;
            this._global = null;
            this._origin = null;
            this.armature = null;
            this._parent = null;
        };
        p._calculateParentTransform = function () {
            if (this.parent && (this.inheritTranslation || this.inheritRotation || this.inheritScale)) {
                var parentGlobalTransform = this._parent._global;
                var parentGlobalTransformMatrix = this._parent._globalTransformMatrix;
                /*
                if(	!this.inheritTranslation && (parentGlobalTransform.x != 0 || parentGlobalTransform.y != 0) ||
                    !this.inheritRotation && (parentGlobalTransform.skewX != 0 || parentGlobalTransform.skewY != 0) ||
                    !this.inheritScale && (parentGlobalTransform.scaleX != 1 || parentGlobalTransform.scaleY != 1)){
                    parentGlobalTransform = FastDBObject._tempParentGlobalTransform;
                    parentGlobalTransform.copy(this._parent._global);
                    if(!this.inheritTranslation){
                        parentGlobalTransform.x = 0;
                        parentGlobalTransform.y = 0;
                    }
                    if(!this.inheritScale){
                        parentGlobalTransform.scaleX = 1;
                        parentGlobalTransform.scaleY = 1;
                    }
                    if(!this.inheritRotation){
                        parentGlobalTransform.skewX = 0;
                        parentGlobalTransform.skewY = 0;
                    }

                    parentGlobalTransformMatrix = DBObject._tempParentGlobalTransformMatrix;
                    TransformUtil.transformToMatrix(parentGlobalTransform, parentGlobalTransformMatrix);
                }
                */
                return dragonBones.ParentTransformObject.create().setTo(parentGlobalTransform, parentGlobalTransformMatrix);
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return null;
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                //计算绝对坐标
                var x = this._global.x;
                var y = this._global.y;
                this._global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                this._global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;
                if (this.inheritRotation) {
                    this._global.skewX += parentGlobalTransform.skewX;
                    this._global.skewY += parentGlobalTransform.skewY;
                }
                if (this.inheritScale) {
                    this._global.scaleX *= parentGlobalTransform.scaleX;
                    this._global.scaleY *= parentGlobalTransform.scaleY;
                }
            }
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            return output;
        };
        p._calculateRelativeParentTransform = function () {
        };
        d(p, "name"
            ,function () {
                return this._name;
            }
            ,function (value) {
                this._name = value;
            }
        );
        d(p, "global"
            /**
             * This DBObject instance global transform instance.
             * @see dragonBones.DBTransform
             */
            ,function () {
                return this._global;
            }
        );
        d(p, "globalTransformMatrix"
            ,function () {
                return this._globalTransformMatrix;
            }
        );
        d(p, "origin"
            /**
             * This DBObject instance related to parent transform instance.
             * @see dragonBones.DBTransform
             */
            ,function () {
                return this._origin;
            }
        );
        d(p, "parent"
            /**
             * Indicates the Bone instance that directly contains this DBObject instance if any.
             */
            ,function () {
                return this._parent;
            }
        );
        d(p, "visible"
            ,function () {
                return this._visible;
            }
            ,function (value) {
                this._visible = value;
            }
        );
        d(p, "frameCache",undefined
            ,function (cache) {
                this._frameCache = cache;
            }
        );
        FastDBObject._tempParentGlobalTransform = new dragonBones.DBTransform();
        return FastDBObject;
    }());
    dragonBones.FastDBObject = FastDBObject;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastBone
     * @classdesc
     * FastBone 实例代表 FastArmature 中的一个骨头。一个FastArmature实例可以由很多 FastBone组成。
     * FastBone 在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移旋转缩放的实现
     * 和Bone相比，FastBone不能动态添加子骨骼和子插槽
     * @extends dragonBones.FastDBObject
     * @see dragonBones.FastArmature
     * @see dragonBones.FastSlot
     * @see dragonBones.BoneData
     */
    var FastBone = (function (_super) {
        __extends(FastBone, _super);
        function FastBone() {
            _super.call(this);
            this.slotList = [];
            this.boneList = [];
            /** @private */
            this._needUpdate = 0;
            this.isIKConstraint = false;
            this.childrenBones = [];
            this._needUpdate = 2;
            this._tweenPivot = new dragonBones.Point();
        }
        var d = __define,c=FastBone,p=c.prototype;
        FastBone.initWithBoneData = function (boneData) {
            var outputBone = new FastBone();
            outputBone.name = boneData.name;
            outputBone.length = boneData.length;
            outputBone.inheritRotation = boneData.inheritRotation;
            outputBone.inheritScale = boneData.inheritScale;
            outputBone.origin.copy(boneData.transform);
            return outputBone;
        };
        /**
         * 获取当前骨头包含的所有 FastBone 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastBone[]}
         */
        p.getBones = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.boneList.concat() : this.boneList;
        };
        /**
         * 获取当前骨头包含的所有 FastSlot 实例
         * @param returnCopy {boolean} 是否返回拷贝。默认：true
         * @returns {FastSlot[]}
         */
        p.getSlots = function (returnCopy) {
            if (returnCopy === void 0) { returnCopy = true; }
            return returnCopy ? this.slotList.concat() : this.slotList;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this._timelineState = null;
            this._tweenPivot = null;
        };
        //动画
        /**
         * 在下一帧强制更新当前 Bone 实例及其包含的所有 Slot 的动画。
         */
        p.invalidUpdate = function () {
            this._needUpdate = 2;
            this.operationInvalidUpdate(this);
            var i;
            var len;
            for (i = 0, len = this.childrenBones.length; i < len; i++) {
                if (this.childrenBones[i]._needUpdate != 2) {
                    this.operationInvalidUpdate(this.childrenBones[i]);
                    this.childrenBones[i].invalidUpdate();
                }
            }
        };
        p.operationInvalidUpdate = function (bone) {
            var arr = this.armature.getIKTargetData(bone);
            var i;
            var len;
            var j;
            var jLen;
            var ik;
            var bo;
            for (i = 0, len = arr.length; i < len; i++) {
                ik = arr[i];
                for (j = 0, jLen = ik.bones.length; j < jLen; j++) {
                    bo = ik.bones[j];
                    if (bo._needUpdate != 2) {
                        bo.invalidUpdate();
                    }
                }
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.copy(this._origin);
            if (this._timelineState) {
                this._global.add(this._timelineState._transform);
            }
        };
        /** @private */
        p.updateByCache = function (frameIndex) {
            _super.prototype.updateByCache.call(this, frameIndex);
            this._global = this._frameCache.globalTransform;
            this._globalTransformMatrix = this._frameCache.globalTransformMatrix;
        };
        /** @private */
        p.update = function (needUpdate) {
            if (needUpdate === void 0) { needUpdate = false; }
            this._needUpdate--;
            if (needUpdate || this._needUpdate > 0 || (this._parent && this._parent._needUpdate > 0)) {
                this._needUpdate = 1;
            }
            else {
                return;
            }
            this.updataLocalTransform();
            this.updateGlobalTransform();
        };
        p.updataLocalTransform = function () {
            this.blendingTimeline();
            this._calculateRelativeParentTransform();
        };
        p.updateGlobalTransform = function () {
            //计算global
            var result = this._updateGlobal();
            if (result) {
                result.release();
            }
        };
        p._updateGlobal = function () {
            if (!this.armature._skewEnable) {
                return _super.prototype._updateGlobal.call(this);
            }
            //this._calculateRelativeParentTransform();
            var output = this._calculateParentTransform();
            if (output != null && output.parentGlobalTransformMatrix && output.parentGlobalTransform) {
                //计算父骨头绝对坐标
                var parentMatrix = output.parentGlobalTransformMatrix;
                var parentGlobalTransform = output.parentGlobalTransform;
                var scaleXF = this._global.scaleX * parentGlobalTransform.scaleX > 0;
                var scaleYF = this._global.scaleY * parentGlobalTransform.scaleY > 0;
                var relativeRotation = this._global.rotation;
                var relativeScaleX = this._global.scaleX;
                var relativeScaleY = this._global.scaleY;
                var parentRotation = this.parentBoneRotation;
                this._localTransform = this._global;
                if (this.inheritScale && !this.inheritRotation) {
                    if (parentRotation != 0) {
                        this._localTransform = this._localTransform.clone();
                        this._localTransform.rotation -= parentRotation;
                    }
                }
                dragonBones.TransformUtil.transformToMatrix(this._localTransform, this._globalTransformMatrix);
                this._globalTransformMatrix.concat(parentMatrix);
                if (this.inheritScale) {
                    dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, scaleXF, scaleYF);
                }
                else {
                    dragonBones.TransformUtil.matrixToTransformPosition(this._globalTransformMatrix, this._global);
                    this._global.scaleX = this._localTransform.scaleX;
                    this._global.scaleY = this._localTransform.scaleY;
                    this._global.rotation = this._localTransform.rotation + (this.inheritRotation ? parentRotation : 0);
                    dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
                }
            }
            return output;
        };
        p.adjustGlobalTransformMatrixByIK = function () {
            if (!this.parent) {
                return;
            }
            this.updataLocalTransform();
            this._global.rotation = this.rotationIK - this.parentBoneRotation;
            this.updateGlobalTransform();
            //this.global.rotation = this.rotationIK;
            //TransformUtil.transformToMatrix(this.global, this._globalTransformMatrix);
        };
        /** @private */
        p._hideSlots = function () {
            var length = this.slotList.length;
            for (var i = 0; i < length; i++) {
                var childSlot = this.slotList[i];
                childSlot.hideSlots();
            }
        };
        p.blendingTimeline = function () {
            if (this._timelineState) {
                this._tweenPivot.x = this._timelineState._pivot.x;
                this._tweenPivot.y = this._timelineState._pivot.y;
            }
        };
        /** @private When bone timeline enter a key frame, call this func*/
        p.arriveAtFrame = function (frame, animationState) {
            var childSlot;
            if (frame.event && this.armature.hasEventListener(dragonBones.FrameEvent.BONE_FRAME_EVENT)) {
                var frameEvent = new dragonBones.FrameEvent(dragonBones.FrameEvent.BONE_FRAME_EVENT);
                frameEvent.bone = this;
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this.armature._addEvent(frameEvent);
            }
        };
        d(p, "childArmature"
            /**
             * 不推荐的API,建议使用 slot.childArmature 替代
             */
            ,function () {
                var s = this.slot;
                if (s) {
                    return s.childArmature;
                }
                return null;
            }
        );
        d(p, "display"
            /**
             * 不推荐的API,建议使用 slot.display 替代
             */
            ,function () {
                var s = this.slot;
                if (s) {
                    return s.display;
                }
                return null;
            }
            ,function (value) {
                var s = this.slot;
                if (s) {
                    s.display = value;
                }
            }
        );
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    for (var i = 0, len = this.armature.slotList.length; i < len; i++) {
                        if (this.armature.slotList[i].parent == this) {
                            this.armature.slotList[i]._updateDisplayVisible(this._visible);
                        }
                    }
                }
            }
        );
        d(p, "slot"
            /**
             * 返回当前 FastBone 实例包含的第一个 FastSlot 实例
             * @member {FastSlot} dragonBones.FastBone#slot
             */
            ,function () {
                return this.slotList.length > 0 ? this.slotList[0] : null;
            }
        );
        d(p, "parentBoneRotation"
            ,function () {
                return this.parent ? this.parent.rotationIK : 0;
            }
        );
        d(p, "parentBoneData",undefined
            ,function (value) {
                if (this._parent != value) {
                    if (this._parent != null) {
                        var index = this._parent.childrenBones.indexOf(this);
                        if (index >= 0) {
                            this._parent.childrenBones.splice(index, 1);
                        }
                    }
                    this.setParent(value);
                    if (this._parent != null) {
                        var indexs = this._parent.childrenBones.indexOf(this);
                        if (indexs < 0) {
                            this._parent.childrenBones.push(this);
                        }
                    }
                }
            }
        );
        return FastBone;
    }(dragonBones.FastDBObject));
    dragonBones.FastBone = FastBone;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var FastIKConstraint = (function () {
        function FastIKConstraint(data, armatureData) {
            this.animationCacheBend = 0;
            this.animationCacheWeight = -1;
            this.ikdata = data;
            this.armature = armatureData;
            this.weight = data.weight;
            this.bendDirection = (data.bendPositive ? 1 : -1);
            this.bones = [];
            var bone;
            if (data.chain) {
                bone = armatureData.getBone(data.bones).parent;
                bone.isIKConstraint = true;
                this.bones.push(bone);
            }
            bone = armatureData.getBone(data.bones);
            bone.isIKConstraint = true;
            this.bones.push(bone);
            this.target = armatureData.getBone(data.target);
        }
        var d = __define,c=FastIKConstraint,p=c.prototype;
        p.dispose = function () {
        };
        p.compute = function () {
            switch (this.bones.length) {
                case 1:
                    var weig1 = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    this.compute1(this.bones[0], this.target, weig1);
                    break;
                case 2:
                    var bend = this.animationCacheBend != 0 ? this.animationCacheBend : this.bendDirection;
                    var weig = this.animationCacheWeight >= 0 ? this.animationCacheWeight : this.weight;
                    var tt = this.compute2(this.bones[0], this.bones[1], this.target.global.x, this.target.global.y, bend, weig);
                    this.bones[0].rotationIK = this.bones[0].origin.rotation + (tt.x - this.bones[0].origin.rotation) * weig + this.bones[0].parent.rotationIK;
                    this.bones[1].rotationIK = this.bones[1].origin.rotation + (tt.y - this.bones[1].origin.rotation) * weig + this.bones[0].rotationIK;
                    break;
            }
        };
        p.compute1 = function (bone, target, weightA) {
            var parentRotation = (!bone.inheritRotation || bone.parent == null) ? 0 : bone.parent.global.rotation;
            var rotation = bone.global.rotation;
            var rotationIK = Math.atan2(target.global.y - bone.global.y, target.global.x - bone.global.x);
            bone.rotationIK = rotation + (rotationIK - rotation) * weightA;
        };
        p.compute2 = function (parent, child, targetX, targetY, bendDirection, weightA) {
            //添加斜切后的算法，现在用的
            if (weightA == 0) {
                return new dragonBones.Point(parent.global.rotation, child.global.rotation);
            }
            var tt = new dragonBones.Point();
            /**父的绝对坐标**/
            var p1 = new dragonBones.Point(parent.global.x, parent.global.y);
            /**子的绝对坐标**/
            var p2 = new dragonBones.Point(child.global.x, child.global.y);
            var matrix = new dragonBones.Matrix();
            dragonBones.TransformUtil.transformToMatrix(parent.parent.global, matrix);
            matrix.invert();
            var targetPoint = dragonBones.TransformUtil.applyMatrixToPoint(new dragonBones.Point(targetX, targetY), matrix, true);
            targetX = targetPoint.x;
            targetY = targetPoint.y;
            p1 = dragonBones.TransformUtil.applyMatrixToPoint(p1, matrix, true);
            p2 = dragonBones.TransformUtil.applyMatrixToPoint(p2, matrix, true);
            var psx = parent.origin.scaleX;
            var psy = parent.origin.scaleY;
            var csx = child.origin.scaleX;
            var childX = p2.x - p1.x;
            var childY = p2.y - p1.y;
            /**d1的长度**/
            var len1 = Math.sqrt(childX * childX + childY * childY);
            var parentAngle;
            var childAngle;
            var sign = 1;
            var offset1 = 0;
            var offset2 = 0;
            if (psx < 0) {
                psx = -psx;
                offset1 = Math.PI;
                sign = -1;
            }
            else {
                offset1 = 0;
                sign = 1;
            }
            if (psy < 0) {
                psy = -psy;
                sign = -sign;
            }
            if (csx < 0) {
                csx = -csx;
                offset2 = Math.PI;
            }
            else {
                offset2 = 0;
            }
            bendDirection = sign * bendDirection;
            outer: if (Math.abs(psx - psy) <= 0.001) {
                var childlength = child.length;
                var len2 = childlength * csx;
                targetX = targetX - p1.x;
                targetY = targetY - p1.y;
                var cosDenom = 2 * len1 * len2;
                var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                childAngle = Math.acos(cos) * bendDirection;
                var adjacent = len1 + len2 * cos;
                var opposite = len2 * Math.sin(childAngle);
                parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);
            }
            else {
                var l1 = len1;
                var tx = targetX - p1.x;
                var ty = targetY - p1.y;
                var l2 = child.length * child.origin.scaleX;
                var a = psx * l2;
                var b = psy * l2;
                var ta = Math.atan2(ty, tx);
                var aa = a * a;
                var bb = b * b;
                var ll = l1 * l1;
                var dd = tx * tx + ty * ty;
                var c0 = bb * ll + aa * dd - aa * bb;
                var c1 = -2 * bb * l1;
                var c2 = bb - aa;
                var d = c1 * c1 - 4 * c2 * c0;
                if (d >= 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0) {
                        q = -q;
                    }
                    q = -(c1 + q) / 2;
                    var r0 = q / c2;
                    var r1 = c0 / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        var y1 = Math.sqrt(dd - r * r) * bendDirection;
                        parentAngle = ta - Math.atan2(y1, r);
                        childAngle = Math.atan2(y1 / psy, (r - l1) / psx);
                        break outer;
                    }
                }
                var minAngle = 0;
                var minDist = Number.MAX_VALUE;
                var minX = 0;
                var minY = 0;
                var maxAngle = 0;
                var maxDist = 0;
                var maxX = 0;
                var maxY = 0;
                var x2 = l1 + a;
                var dist = x2 * x2;
                if (dist > maxDist) {
                    maxAngle = 0;
                    maxDist = dist;
                    maxX = x2;
                }
                x2 = l1 - a;
                dist = x2 * x2;
                if (dist < minDist) {
                    minAngle = Math.PI;
                    minDist = dist;
                    minX = x2;
                }
                var angle1 = Math.acos(-a * l1 / (aa - bb));
                x2 = a * Math.cos(angle1) + l1;
                var y2 = b * Math.sin(angle1);
                dist = x2 * x2 + y2 * y2;
                if (dist < minDist) {
                    minAngle = angle1;
                    minDist = dist;
                    minX = x2;
                    minY = y2;
                }
                if (dist > maxDist) {
                    maxAngle = angle1;
                    maxDist = dist;
                    maxX = x2;
                    maxY = y2;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    parentAngle = ta - Math.atan2(minY * bendDirection, minX);
                    childAngle = minAngle * bendDirection;
                }
                else {
                    parentAngle = ta - Math.atan2(maxY * bendDirection, maxX);
                    childAngle = maxAngle * bendDirection;
                }
            }
            var cx = child.origin.x;
            var cy = child.origin.y * psy;
            var initalRotation = Math.atan2(cy, cx) * sign;
            tt.x = parentAngle - initalRotation + offset1;
            tt.y = (childAngle + initalRotation) * sign + offset2;
            this.normalize(tt.x);
            this.normalize(tt.y);
            return tt;
        };
        p.normalize = function (rotation) {
            if (rotation > Math.PI) {
                rotation -= Math.PI * 2;
            }
            else if (rotation < -Math.PI) {
                rotation += Math.PI * 2;
            }
        };
        return FastIKConstraint;
    }());
    dragonBones.FastIKConstraint = FastIKConstraint;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastSlot
     * @classdesc
     * FastSlot 实例是骨头上的一个插槽，是显示图片的容器。
     * 一个 FastBone 上可以有多个FastSlot，每个FastSlot中同一时间都会有一张图片用于显示，不同的FastSlot中的图片可以同时显示。
     * 每个 FastSlot 中可以包含多张图片，同一个 FastSlot 中的不同图片不能同时显示，但是可以在动画进行的过程中切换，用于实现帧动画。
     * @extends dragonBones.DBObject
     * @see dragonBones.FastArmature
     * @see dragonBones.FastBone
     * @see dragonBones.SlotData
     */
    var FastSlot = (function (_super) {
        __extends(FastSlot, _super);
        function FastSlot(rawDisplay) {
            _super.call(this);
            this.hasChildArmature = false;
            // modify display index change
            this._displayIndex = -1;
            this._rawDisplay = null;
            this._display = null;
            this._childArmature = null;
            this._displayList = [];
            this._displayDataList = [];
            this._cacheTimeline = null;
            this.hasChildArmature = false;
            this.inheritRotation = true;
            this.inheritScale = true;
            this._originZOrder = 0;
            this._tweenZOrder = 0;
            this._offsetZOrder = 0;
            this._colorTransform = new dragonBones.ColorTransform();
            this._isColorChanged = false;
            this._rawDisplay = rawDisplay;
        }
        var d = __define,c=FastSlot,p=c.prototype;
        /**
         * 通过传入 SlotData 初始化FastSlot
         * @param slotData
         */
        p.initWithSlotData = function (slotData) {
            this.name = slotData.name;
            this.blendMode = slotData.blendMode;
            this._defaultGotoAndPlay = slotData.gotoAndPlay;
            this._originZOrder = slotData.zOrder;
            this._originDisplayIndex = slotData.displayIndex;
        };
        /**
         * @inheritDoc
         */
        p.dispose = function () {
            if (!this._displayList) {
                return;
            }
            _super.prototype.dispose.call(this);
            this._rawDisplay = null;
            this._display = null;
            this._childArmature = null;
            this._displayDataList = null;
            this._displayList = null;
        };
        //动画
        /** @private */
        p.updateByCache = function (frameIndex) {
            //var cacheTimeline = this.armature.animation.animationState.animationCache.slotTimelineCacheDic[this.name] as SlotTimelineCache;
            var frameCache = this._cacheTimeline.frameCacheList[frameIndex];
            var cacheDisplayIndex = (frameCache).displayIndex;
            if (cacheDisplayIndex != this._displayIndex) {
                //this.displayIndex = cacheDisplayIndex;
                this._displayIndex = cacheDisplayIndex;
                this.changeDisplay();
            }
            if (this._displayIndex < 0) {
                return;
            }
            if (this._frameCache && frameCache.globalTransform == this._frameCache.globalTransform) {
                this._frameCache = frameCache;
            }
            else {
                this._frameCache = frameCache;
                _super.prototype.updateByCache.call(this, frameIndex);
                this._updateTransform();
            }
            //颜色
            var cacheColor = (this._frameCache).colorTransform;
            var cacheColorChanged = cacheColor != null;
            if (this._isColorChanged != cacheColorChanged ||
                (this._isColorChanged && cacheColorChanged && !dragonBones.ColorTransformUtil.isEqual(this._colorTransform, cacheColor))) {
                cacheColor = cacheColor || dragonBones.ColorTransformUtil.originalColor;
                this._updateDisplayColor(cacheColor.alphaOffset, cacheColor.redOffset, cacheColor.greenOffset, cacheColor.blueOffset, cacheColor.alphaMultiplier, cacheColor.redMultiplier, cacheColor.greenMultiplier, cacheColor.blueMultiplier, cacheColorChanged);
            }
            var gotoAndPlay = (this._frameCache).gotoAndPlay;
            if (this._gotoAndPlay != gotoAndPlay) {
                this._gotoAndPlay = gotoAndPlay;
                this.updateChildArmatureAnimation();
            }
        };
        /** @private */
        p._update = function (needUpdate) {
            if (needUpdate === void 0) { needUpdate = false; }
            if (this._parent && (this._parent._needUpdate > 0 || needUpdate)) {
                if (this._global != this._globalBackup) {
                    this._global = this._globalBackup;
                    this._globalTransformMatrix = this._globalTransformMatrixBackup;
                }
                var result = this._updateGlobal();
                if (result) {
                    result.release();
                }
                this._updateTransform();
            }
        };
        p._calculateRelativeParentTransform = function () {
            this._global.copy(this._origin);
            this._global.x += this._parent._tweenPivot.x;
            this._global.y += this._parent._tweenPivot.y;
        };
        p.updateChildArmatureAnimation = function () {
            if (this.childArmature) {
                if (this._displayIndex >= 0) {
                    var curAnimation = this._gotoAndPlay;
                    if (curAnimation == null) {
                        curAnimation = this._defaultGotoAndPlay;
                        if (curAnimation == null) {
                            this.childArmature.armatureData.defaultAnimation;
                        }
                    }
                    if (curAnimation == null) {
                        if (this.armature && this.armature.animation.lastAnimationState) {
                            curAnimation = this.armature.animation.lastAnimationState.name;
                        }
                    }
                    if (curAnimation && this.childArmature.animation.hasAnimation(curAnimation)) {
                        this.childArmature.animation.gotoAndPlay(curAnimation);
                    }
                    else {
                        this.childArmature.animation.play();
                    }
                }
                else {
                    this.childArmature.animation.stop();
                    this.childArmature.animation._lastAnimationState = null;
                }
            }
        };
        // modify changeDisplay
        /** @private */
        p.changeDisplay = function () {
            var prevDisplay = this._display;
            var prevChildArmature = this._childArmature;
            if (this._displayIndex < 0 || this._displayIndex >= this._displayList.length) {
                this._display = this._rawDisplay;
            }
            else {
                this._display = this._displayList[this._displayIndex];
            }
            if (this._display instanceof dragonBones.FastArmature) {
                this._childArmature = this._display;
                this._display = this._display.display;
            }
            else {
                this._childArmature = null;
                if (!this._display) {
                    this._display = this._rawDisplay;
                }
            }
            if (this._childArmature != prevChildArmature) {
                if (this._childArmature) {
                    this._childArmature.animation.play();
                }
                else {
                }
            }
            if (this._display != prevDisplay) {
                this._updateDisplay(this._display);
                if (this.armature) {
                    if (prevDisplay) {
                        this._replaceDisplay(prevDisplay);
                    }
                    else {
                        this._addDisplay();
                    }
                }
            }
            if (this._display == this._rawDisplay) {
                this._updateFrame();
            }
            if (this._display != prevDisplay) {
                this._updateDisplayBlendMode(this._blendMode);
                //this._updateVisible();
                this._updateDisplayColor(this._colorTransform.alphaOffset, this._colorTransform.redOffset, this._colorTransform.greenOffset, this._colorTransform.blueOffset, this._colorTransform.alphaMultiplier, this._colorTransform.redMultiplier, this._colorTransform.greenMultiplier, this._colorTransform.blueMultiplier);
            }
            if (this._displayIndex >= 0 && this._displayIndex < this._displayDataList.length) {
                this._origin.copy(this._displayDataList[this._displayIndex][0].transform);
            }
            if (this.armature && !this.armature._isFrameCached) {
                this._update(true);
            }
        };
        d(p, "visible",undefined
            /** @private */
            ,function (value) {
                if (this._visible != value) {
                    this._visible = value;
                    this._updateDisplayVisible(this._visible);
                }
            }
        );
        d(p, "displayIndex"
            ,function () {
                return this._displayIndex;
            }
            ,function (value) {
                if (this._displayIndex == value) {
                    return;
                }
                this._displayIndex = value;
                this.changeDisplay();
            }
        );
        d(p, "display"
            /**
             * 当前的显示对象(可能是 display 或者 子骨架)
             * @member {any} dragonBones.FastSlot#display
             */
            ,function () {
                return this._display;
            }
            ,function (value) {
                var displayListLength = this._displayList.length;
                if (this._displayIndex >= displayListLength) {
                    if (displayListLength == 0) {
                        this._displayList[0] = value;
                    }
                    else {
                        this._displayList[displayListLength - 1] = value;
                    }
                }
                else {
                    this._displayList[this._displayIndex] = value;
                }
                if (this._displayIndex >= 0) {
                    this.changeDisplay();
                }
            }
        );
        d(p, "childArmature"
            /**
             * 当前的子骨架
             * @member {FastArmature} dragonBones.Slot#childArmature
             */
            ,function () {
                return this._childArmature;
            }
            ,function (value) {
                if (this._childArmature == value) {
                    return;
                }
                this.display = value;
            }
        );
        d(p, "displayDataList"
            /** @private */
            ,function () {
                return this._displayDataList;
            }
            /** @private */
            ,function (value) {
                if (this._displayDataList != value) {
                    if (value && value.length) {
                        this._displayDataList.length = value.length;
                        for (var i = 0, l = this._displayDataList.length; i < l; ++i) {
                            this._displayDataList[i] = value[i];
                        }
                    }
                    else {
                        this._displayDataList.length = 0;
                    }
                }
            }
        );
        d(p, "displayList"
            /**
             * 显示对象列表(包含 display 或者 子骨架)
             * @member {any[]} dragonBones.FastSlot#displayList
             */
            ,function () {
                return this._displayList;
            }
            ,function (value) {
                if (this._displayList != value) {
                    if (value && value.length) {
                        this._displayList.length = value.length;
                        for (var i = 0, l = this._displayList.length; i < l; ++i) {
                            this._displayList[i] = value[i];
                        }
                    }
                    else {
                        this._displayList.length = 0;
                    }
                }
                this.changeDisplay();
            }
        );
        d(p, "zOrder"
            /**
             * 显示顺序。(支持小数用于实现动态插入slot)
             * @member {number} dragonBones.FastSlot#zOrder
             */
            ,function () {
                return this._originZOrder + this._tweenZOrder + this._offsetZOrder;
            }
            ,function (value) {
                if (this.zOrder != value) {
                    this._offsetZOrder = value - this._originZOrder - this._tweenZOrder;
                    if (this.armature) {
                        this.armature._slotsZOrderChanged = true;
                    }
                }
            }
        );
        d(p, "blendMode"
            /**
             * 混合模式
             * @member {string} dragonBones.FastSlot#blendMode
             */
            ,function () {
                return this._blendMode;
            }
            ,function (value) {
                if (this._blendMode != value) {
                    this._blendMode = value;
                    this._updateDisplayBlendMode(this._blendMode);
                }
            }
        );
        d(p, "gotoAndPlay"
            ,function () {
                return this._gotoAndPlay;
            }
            /**
             * 播放子骨架动画
             * @member {string} dragonBones.FastSlot#gotoAndPlay
             */
            ,function (value) {
                if (this._gotoAndPlay != value) {
                    this._gotoAndPlay = value;
                    this.updateChildArmatureAnimation();
                }
            }
        );
        d(p, "colorTransform"
            ,function () {
                return this._colorTransform;
            }
        );
        d(p, "colorChanged"
            ,function () {
                return this._isColorChanged;
            }
        );
        //Abstract method
        /** @private */
        p._updateDisplay = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private */
        p._addDisplay = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private */
        p._replaceDisplay = function (prevDisplay) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private */
        p._removeDisplay = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private */
        p._getDisplayIndex = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Adds the original display object to another display object.
         * @param container
         * @param index
         */
        p._addDisplayToContainer = function (container, index) {
            if (index === void 0) { index = -1; }
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * remove the original display object from its parent.
         */
        p._removeDisplayFromContainer = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Updates the transform of the slot.
         */
        p._updateTransform = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Updates the frame of the slot.
         */
        p._updateFrame = function () {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         */
        p._updateDisplayVisible = function (value) {
            /**
             * bone.visible && slot.visible && updateVisible
             * this._parent.visible && this._visible && value;
             */
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /**
         * @private
         * Updates the color of the display object.
         * @param a
         * @param r
         * @param g
         * @param b
         * @param aM
         * @param rM
         * @param gM
         * @param bM
         */
        p._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
            if (colorChanged === void 0) { colorChanged = false; }
            this._colorTransform.alphaOffset = aOffset;
            this._colorTransform.redOffset = rOffset;
            this._colorTransform.greenOffset = gOffset;
            this._colorTransform.blueOffset = bOffset;
            this._colorTransform.alphaMultiplier = aMultiplier;
            this._colorTransform.redMultiplier = rMultiplier;
            this._colorTransform.greenMultiplier = gMultiplier;
            this._colorTransform.blueMultiplier = bMultiplier;
            this._isColorChanged = colorChanged;
        };
        /**
         * @private
         * Update the blend mode of the display object.
         * @param value The blend mode to use.
         */
        p._updateDisplayBlendMode = function (value) {
            throw new Error("Abstract method needs to be implemented in subclass!");
        };
        /** @private When slot timeline enter a key frame, call this func*/
        p._arriveAtFrame = function (frame, animationState) {
            var slotFrame = frame;
            this.displayIndex = slotFrame.displayIndex;
            this._updateDisplayVisible(slotFrame.visible);
            if (this._displayIndex >= 0) {
                if (!isNaN(slotFrame.zOrder) && slotFrame.zOrder != this._tweenZOrder) {
                    this._tweenZOrder = slotFrame.zOrder;
                    this.armature._slotsZOrderChanged = true;
                }
            }
            //[TODO]currently there is only gotoAndPlay belongs to frame action. In future, there will be more.
            //后续会扩展更多的action，目前只有gotoAndPlay的含义
            if (frame.action) {
                var targetArmature = this.childArmature;
                if (targetArmature) {
                    targetArmature.getAnimation().gotoAndPlay(frame.action);
                }
            }
            else if (slotFrame.gotoAndPlay) {
                this.gotoAndPlay = slotFrame.gotoAndPlay;
            }
        };
        /** @private */
        p.hideSlots = function () {
            this.displayIndex = -1;
            /*if (this._frameCache) {
                this._frameCache.clear();
            }*/
        };
        p._updateGlobal = function () {
            this._calculateRelativeParentTransform();
            dragonBones.TransformUtil.transformToMatrix(this._global, this._globalTransformMatrix);
            var output = this._calculateParentTransform();
            if (output) {
                this._globalTransformMatrix.concat(output.parentGlobalTransformMatrix);
                dragonBones.TransformUtil.matrixToTransform(this._globalTransformMatrix, this._global, this._global.scaleX * output.parentGlobalTransform.scaleX >= 0, this._global.scaleY * output.parentGlobalTransform.scaleY >= 0);
            }
            return output;
        };
        p._resetToOrigin = function () {
            this.displayIndex = this._originDisplayIndex;
            this._updateDisplayColor(0, 0, 0, 0, 1, 1, 1, 1, true);
        };
        return FastSlot;
    }(dragonBones.FastDBObject));
    dragonBones.FastSlot = FastSlot;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastAnimation
     * @classdesc
     * FastAnimation实例隶属于FastArmature,用于控制FastArmature的动画播放。
     * 和Animation相比，FastAnimation为了优化性能，不支持动画融合，在开启缓存的情况下，不支持无极的平滑补间
     * @see dragonBones.FastBone
     * @see dragonBones.FastArmature
     * @see dragonBones.FastAnimationState
     * @see dragonBones.AnimationData.
     *
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastAnimation = (function () {
        /**
         * 创建一个新的FastAnimation实例并赋给传入的FastArmature实例
         * @param armature {FastArmature} 骨架实例
         */
        function FastAnimation(armature) {
            /**
             * 当前正在运行的动画实例.
             * @member {FastAnimationState} dragonBones.FastAnimation#animationState
             */
            this.animationState = new dragonBones.FastAnimationState();
            this._armature = armature;
            this.animationState._armature = armature;
            this.animationList = [];
            this._animationDataObj = {};
            this._isPlaying = false;
            this._timeScale = 1;
        }
        var d = __define,c=FastAnimation,p=c.prototype;
        /**
         * Qualifies all resources used by this Animation instance for garbage collection.
         */
        p.dispose = function () {
            if (!this._armature) {
                return;
            }
            this._armature = null;
            this._animationDataList = null;
            this.animationList = null;
            this.animationState = null;
        };
        /**
         * 开始播放指定名称的动画。
         * 要播放的动画将经过指定时间的淡入过程，然后开始播放，同时之前播放的动画会经过相同时间的淡出过程。
         * @param animationName {string} 指定播放动画的名称.
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @param playTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         * @see dragonBones.FastAnimationState.
         */
        p.gotoAndPlay = function (animationName, fadeInTime, duration, playTimes) {
            if (fadeInTime === void 0) { fadeInTime = -1; }
            if (duration === void 0) { duration = -1; }
            if (playTimes === void 0) { playTimes = NaN; }
            if (!this._animationDataList) {
                return null;
            }
            var animationData = this._animationDataObj[animationName];
            if (!animationData) {
                return null;
            }
            // Modify Fast mode by duanchunlei
            if (this._armature.enableCache) {
                this.animationCacheManager = this._armature._armatureData._cacheManager;
                var animationCache = this.animationCacheManager.getAnimationCache(animationName);
                animationCache.frameNum = Math.ceil(animationData.duration * 0.001 * this.animationCacheManager.frameRate / animationData.scale);
                this.animationState.animationCache = animationCache;
                i = this._armature.slotList.length;
                while (i--) {
                    var slot = this._armature.slotList[i];
                    slot._cacheTimeline = animationCache.slotTimelineCacheDic[slot.name];
                }
            }
            this._isPlaying = true;
            //fadeInTime = fadeInTime < 0 ? (animationData.fadeTime < 0 ? 0.3 : animationData.fadeTime) : fadeInTime;
            fadeInTime = 0;
            var durationScale;
            if (duration < 0) {
                durationScale = animationData.scale < 0 ? 1 : animationData.scale;
            }
            else {
                durationScale = duration * 1000 / animationData.duration;
            }
            playTimes = isNaN(playTimes) ? animationData.playTimes : playTimes;
            //播放新动画
            this.animationState._fadeIn(animationData, playTimes, 1 / durationScale, fadeInTime);
            var i = this._armature.slotHasChildArmatureList.length;
            while (i--) {
                var slot = this._armature.slotHasChildArmatureList[i];
                var childArmature = slot.childArmature;
                if (childArmature) {
                    childArmature.getAnimation().gotoAndPlay(animationName);
                }
            }
            return this.animationState;
        };
        /**
         * 播放指定名称的动画并停止于某个时间点
         * @param animationName {string} 指定播放的动画名称.
         * @param time {number} 动画停止的绝对时间
         * @param normalizedTime {number} 动画停止的相对动画总时间的系数，这个参数和time参数是互斥的（例如 0.2：动画停止总时间的20%位置） 默认值：-1 意味着使用绝对时间。
         * @param fadeInTime {number} 动画淡入时间 (>= 0), 默认值：0
         * @param duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         * @see dragonBones.FastAnimationState.
         */
        p.gotoAndStop = function (animationName, time, normalizedTime, fadeInTime, duration) {
            if (normalizedTime === void 0) { normalizedTime = -1; }
            if (fadeInTime === void 0) { fadeInTime = 0; }
            if (duration === void 0) { duration = -1; }
            if (this.animationState.name != animationName) {
                this.gotoAndPlay(animationName, fadeInTime, duration);
            }
            if (normalizedTime >= 0) {
                this.animationState.setCurrentTime(this.animationState.totalTime * normalizedTime);
            }
            else {
                this.animationState.setCurrentTime(time);
            }
            this.animationState.stop();
            return this.animationState;
        };
        /**
         * 从当前位置继续播放动画
         */
        p.play = function () {
            if (!this._animationDataList) {
                return;
            }
            if (!this.animationState.name) {
                this.gotoAndPlay(this._animationDataList[0].name);
            }
            else if (!this._isPlaying) {
                this._isPlaying = true;
            }
            else {
                this.gotoAndPlay(this.animationState.name);
            }
        };
        /**
         * 暂停动画播放
         */
        p.stop = function () {
            this._isPlaying = false;
        };
        /** @private */
        p.advanceTime = function (passedTime) {
            if (!this._isPlaying) {
                return;
            }
            this.animationState._advanceTime(passedTime * this._timeScale);
        };
        /**
         * check if contains a AnimationData by name.
         * @return Boolean.
         * @see dragonBones.AnimationData.
         */
        p.hasAnimation = function (animationName) {
            return this._animationDataObj[animationName] != null;
        };
        d(p, "timeScale"
            /**
             * 时间缩放倍数
             * @member {number} dragonBones.FastAnimation#timeScale
             */
            ,function () {
                return this._timeScale;
            }
            ,function (value) {
                if (isNaN(value) || value < 0) {
                    value = 1;
                }
                this._timeScale = value;
            }
        );
        d(p, "animationDataList"
            /**
             * 包含的所有动画数据列表
             * @member {AnimationData[]} dragonBones.FastAnimation#animationDataList
             * @see dragonBones.AnimationData.
             */
            ,function () {
                return this._animationDataList;
            }
            ,function (value) {
                this._animationDataList = value;
                this.animationList.length = 0;
                var length = this._animationDataList.length;
                for (var i = 0; i < length; i++) {
                    var animationData = this._animationDataList[i];
                    this.animationList.push(animationData.name);
                    this._animationDataObj[animationData.name] = animationData;
                }
            }
        );
        d(p, "movementList"
            /**
             * Unrecommended API. Recommend use animationList.
             */
            ,function () {
                return this.animationList;
            }
        );
        d(p, "movementID"
            /**
             * Unrecommended API. Recommend use lastAnimationName.
             */
            ,function () {
                return this.lastAnimationName;
            }
        );
        /**
         * 是否正在播放
         * @member {boolean} dragonBones.FastAnimation#isPlaying
         */
        p.isPlaying = function () {
            return this._isPlaying && !this.isComplete;
        };
        d(p, "isComplete"
            /**
             * 是否播放完成.
             * @member {boolean} dragonBones.FastAnimation#isComplete
             */
            ,function () {
                return this.animationState.isComplete;
            }
        );
        d(p, "lastAnimationState"
            /**
             * 当前播放动画的实例.
             * @member {FastAnimationState} dragonBones.FastAnimation#lastAnimationState
             */
            ,function () {
                return this.animationState;
            }
        );
        d(p, "lastAnimationName"
            /**
             * 当前播放动画的名字.
             * @member {string} dragonBones.FastAnimation#lastAnimationName
             */
            ,function () {
                return this.animationState ? this.animationState.name : null;
            }
        );
        return FastAnimation;
    }());
    dragonBones.FastAnimation = FastAnimation;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastAnimationState
     * @classdesc
     * FastAnimationState 实例代表播放的动画， 可以对单个动画的播放进行最细致的调节。
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     * @example
       <pre>
        //获取动画数据
        var skeletonData = RES.getRes("skeleton");
        //获取纹理集数据
        var textureData = RES.getRes("textureConfig");
        //获取纹理集图片
        var texture = RES.getRes("texture");

        //创建一个工厂，用来创建Armature
        var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
        //把动画数据添加到工厂里
        factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
        //把纹理集数据和图片添加到工厂里
        factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));

        //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
        var armatureName:string = skeletonData.armature[0].name;
        //从工厂里创建出Armature
        var armature:dragonBones.FastArmature = factory.buildFastArmature(armatureName);
        //获取装载Armature的容器
        var armatureDisplay = armature.display;
        //把它添加到舞台上
        this.addChild(armatureDisplay);

        //以60fps的帧率开启动画缓存，缓存所有的动画数据
        var animationCachManager:dragonBones.AnimationCacheManager = armature.enableAnimationCache(60);

       //取得这个Armature动画列表中的第一个动画的名字
        var curAnimationName = armature.animation.animationList[0];
        //播放这个动画，gotoAndPlay各个参数说明
        //第一个参数 animationName {string} 指定播放动画的名称.
        //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
        //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
        //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
        armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

        //把Armature添加到心跳时钟里
        dragonBones.WorldClock.clock.add(armature);
        //心跳时钟开启
        egret.Ticker.getInstance().register(function (advancedTime) {
            dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
        }, this);
       </pre>
     */
    var FastAnimationState = (function () {
        function FastAnimationState() {
            this._boneTimelineStateList = [];
            this._slotTimelineStateList = [];
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._currentPlayTimes = 0;
            this._totalTime = 0; //毫秒
            this._currentTime = 0;
            this._lastTime = 0;
            this._playTimes = 0;
            this._fading = false;
        }
        var d = __define,c=FastAnimationState,p=c.prototype;
        p.dispose = function () {
            this._resetTimelineStateList();
            this._armature = null;
        };
        /**
         * 播放当前动画。如果动画已经播放完毕, 将不会继续播放.
         * @returns {FastAnimationState} 动画播放状态实例
         */
        p.play = function () {
            this._isPlaying = true;
            return this;
        };
        /**
         * 暂停当前动画的播放。
         * @returns {AnimationState} 动画播放状态实例
         */
        p.stop = function () {
            this._isPlaying = false;
            return this;
        };
        p.setCurrentTime = function (value) {
            if (value < 0 || isNaN(value)) {
                value = 0;
            }
            this._time = value;
            this._currentTime = this._time * 1000;
            return this;
        };
        p._resetTimelineStateList = function () {
            var i = this._boneTimelineStateList.length;
            while (i--) {
                dragonBones.FastBoneTimelineState.returnObject(this._boneTimelineStateList[i]);
            }
            this._boneTimelineStateList.length = 0;
            i = this._slotTimelineStateList.length;
            while (i--) {
                dragonBones.FastSlotTimelineState.returnObject(this._slotTimelineStateList[i]);
            }
            this._slotTimelineStateList.length = 0;
            this.name = null;
        };
        /** @private */
        p._fadeIn = function (aniData, playTimes, timeScale, fadeTotalTime) {
            this.animationData = aniData;
            this.name = this.animationData.name;
            this._totalTime = this.animationData.duration;
            this.autoTween = aniData.autoTween;
            this.setTimeScale(timeScale);
            this.setPlayTimes(playTimes);
            //reset
            this._isComplete = false;
            this._currentFrameIndex = -1;
            this._currentPlayTimes = -1;
            if (Math.round(this._totalTime * this.animationData.frameRate * 0.001) < 2) {
                this._currentTime = this._totalTime;
            }
            else {
                this._currentTime = -1;
            }
            this._fadeTotalTime = fadeTotalTime * this._timeScale;
            this._fading = this._fadeTotalTime > 0;
            //default
            this._isPlaying = true;
            if (this._armature.enableCache && this.animationCache && this._fading && this._boneTimelineStateList) {
                this.updateTransformTimeline(this._progress);
            }
            this._time = 0;
            this._progress = 0;
            this._updateTimelineStateList();
            this.hideBones();
            return;
        };
        /**
         * @private
         * Update timeline state based on mixing transforms and clip.
         */
        p._updateTimelineStateList = function () {
            this._resetTimelineStateList();
            var timelineName;
            var length = this.animationData.timelineList.length;
            for (var i = 0; i < length; i++) {
                var boneTimeline = this.animationData.timelineList[i];
                timelineName = boneTimeline.name;
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    var boneTimelineState = dragonBones.FastBoneTimelineState.borrowObject();
                    boneTimelineState.fadeIn(bone, this, boneTimeline);
                    this._boneTimelineStateList.push(boneTimelineState);
                }
            }
            var length1 = this.animationData.slotTimelineList.length;
            for (var i1 = 0; i1 < length1; i1++) {
                var slotTimeline = this.animationData.slotTimelineList[i1];
                timelineName = slotTimeline.name;
                var slot = this._armature.getSlot(timelineName);
                if (slot && slot.displayList.length > 0) {
                    var slotTimelineState = dragonBones.FastSlotTimelineState.borrowObject();
                    slotTimelineState.fadeIn(slot, this, slotTimeline);
                    this._slotTimelineStateList.push(slotTimelineState);
                }
            }
        };
        /** @private */
        p._advanceTime = function (passedTime) {
            passedTime *= this._timeScale;
            if (this._fading) {
                //计算progress
                this._time += passedTime;
                this._progress = this._time / this._fadeTotalTime;
                if (this._progress >= 1) {
                    this._progress = 0;
                    this._time = 0;
                    this._fading = false;
                }
            }
            if (this._fading) {
                //update boneTimelie
                var length = this._boneTimelineStateList.length;
                for (var i = 0; i < length; i++) {
                    var timeline = this._boneTimelineStateList[i];
                    timeline.updateFade(this._progress);
                }
                //update slotTimelie
                var length1 = this._slotTimelineStateList.length;
                for (var i1 = 0; i1 < length1; i1++) {
                    var slotTimeline = this._slotTimelineStateList[i1];
                    slotTimeline.updateFade(this._progress);
                }
            }
            else {
                this.advanceTimelinesTime(passedTime);
            }
        };
        p.advanceTimelinesTime = function (passedTime) {
            if (this._isPlaying) {
                this._time += passedTime;
            }
            //计算是否已经播放完成isThisComplete
            var startFlg = false;
            var loopCompleteFlg = false;
            var completeFlg = false;
            var isThisComplete = false;
            var currentPlayTimes = 0;
            var currentTime = this._time * 1000;
            if (this._playTimes == 0 ||
                currentTime < this._playTimes * this._totalTime) {
                isThisComplete = false;
                this._progress = currentTime / this._totalTime;
                currentPlayTimes = Math.ceil(this._progress) || 1;
                this._progress -= Math.floor(this._progress);
                currentTime %= this._totalTime;
            }
            else {
                currentPlayTimes = this._playTimes;
                currentTime = this._totalTime;
                isThisComplete = true;
                this._progress = 1;
            }
            this._isComplete = isThisComplete;
            //if (this.isUseCache()) {
            if (this.animationCache) {
                var frameIndex = Math.floor(this._progress * (this.animationCache.frameNum - 1));
                this._armature._cacheFrameIndex = frameIndex;
                this._armature._isFrameCached = this.animationCache._cahceList[frameIndex];
                if (this._armature._isFrameCached) {
                }
                else {
                    this.updateTransformTimeline(this._progress);
                }
            }
            else {
                this.updateTransformTimeline(this._progress);
            }
            //update main timeline
            if (this._currentTime != currentTime) {
                if (this._currentPlayTimes != currentPlayTimes) {
                    if (this._currentPlayTimes > 0 && currentPlayTimes > 1) {
                        loopCompleteFlg = true;
                    }
                    this._currentPlayTimes = currentPlayTimes;
                }
                if (this._currentTime < 0) {
                    startFlg = true;
                }
                if (this._isComplete) {
                    completeFlg = true;
                }
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                this.updateMainTimeline(isThisComplete);
            }
            //抛事件
            var event;
            if (startFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.START)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.START);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
            if (completeFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.COMPLETE);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
            else if (loopCompleteFlg) {
                if (this._armature.hasEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE)) {
                    event = new dragonBones.AnimationEvent(dragonBones.AnimationEvent.LOOP_COMPLETE);
                    event.animationState = this;
                    this._armature._addEvent(event);
                }
            }
        };
        p.updateTransformTimeline = function (progress) {
            var i = this._boneTimelineStateList.length;
            var boneTimeline;
            var slotTimeline;
            if (this._isComplete) {
                //update boneTimelie
                while (i--) {
                    boneTimeline = this._boneTimelineStateList[i];
                    boneTimeline.update(progress);
                    this._isComplete = boneTimeline._isComplete && this._isComplete;
                }
                i = this._slotTimelineStateList.length;
                //update slotTimelie
                while (i--) {
                    slotTimeline = this._slotTimelineStateList[i];
                    slotTimeline.update(progress);
                    this._isComplete = slotTimeline._isComplete && this._isComplete;
                }
            }
            else {
                //update boneTimelie
                while (i--) {
                    boneTimeline = this._boneTimelineStateList[i];
                    boneTimeline.update(progress);
                }
                i = this._slotTimelineStateList.length;
                //update slotTimelie
                while (i--) {
                    slotTimeline = this._slotTimelineStateList[i];
                    slotTimeline.update(progress);
                }
            }
        };
        p.updateMainTimeline = function (isThisComplete) {
            var frameList = this.animationData._frameList;
            if (frameList.length > 0) {
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._lastTime = this._currentTime;
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (isThisComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = frameList[this._currentFrameIndex];
                    if (prevFrame) {
                        this._armature.arriveAtFrame(prevFrame, this);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._armature.arriveAtFrame(currentFrame, this);
                }
            }
        };
        p.setTimeScale = function (value) {
            if (isNaN(value) || value == Infinity) {
                value = 1;
            }
            this._timeScale = value;
            return this;
        };
        p.setPlayTimes = function (value) {
            if (value === void 0) { value = 0; }
            //如果动画只有一帧  播放一次就可以
            if (Math.round(this._totalTime * 0.001 * this.animationData.frameRate) < 2) {
                this._playTimes = 1;
            }
            else {
                this._playTimes = value;
            }
            return this;
        };
        d(p, "playTimes"
            /**
             * 播放次数 (0:循环播放， >0:播放次数)
             * @member {number} dragonBones.FastAnimationState#playTimes
             */
            ,function () {
                return this._playTimes;
            }
        );
        d(p, "currentPlayTimes"
            /**
             * 当前播放次数
             * @member {number} dragonBones.FastAnimationState#currentPlayTimes
             */
            ,function () {
                return this._currentPlayTimes < 0 ? 0 : this._currentPlayTimes;
            }
        );
        d(p, "isComplete"
            /**
             * 是否播放完成
             * @member {boolean} dragonBones.FastAnimationState#isComplete
             */
            ,function () {
                return this._isComplete;
            }
        );
        d(p, "isPlaying"
            /**
             * 是否正在播放
             * @member {boolean} dragonBones.FastAnimationState#isPlaying
             */
            ,function () {
                return (this._isPlaying && !this._isComplete);
            }
        );
        d(p, "totalTime"
            /**
             * 动画总时长（单位：秒）
             * @member {number} dragonBones.FastAnimationState#totalTime
             */
            ,function () {
                return this._totalTime * 0.001;
            }
        );
        d(p, "currentTime"
            /**
             * 动画当前播放时间（单位：秒）
             * @member {number} dragonBones.FastAnimationState#currentTime
             */
            ,function () {
                return this._currentTime < 0 ? 0 : this._currentTime * 0.001;
            }
        );
        /**
         * 是否使用缓存
         * @member {boolean} dragonBones.FastAnimationState#isUseCache
         */
        p.isUseCache = function () {
            return this._armature.enableCache && this.animationCache && !this._fading;
        };
        p.hideBones = function () {
            var length = this.animationData.hideTimelineNameMap.length;
            for (var i = 0; i < length; i++) {
                var timelineName = this.animationData.hideTimelineNameMap[i];
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    bone._hideSlots();
                }
            }
            var slotTimelineName;
            for (i = 0, length = this.animationData.hideSlotTimelineNameMap.length; i < length; i++) {
                slotTimelineName = this.animationData.hideSlotTimelineNameMap[i];
                var slot = this._armature.getSlot(slotTimelineName);
                if (slot) {
                    slot._resetToOrigin();
                }
            }
        };
        d(p, "progress"
            /**
             * 动画播放进度
             * @member {number} dragonBones.FastAnimationState#progress
             */
            ,function () {
                return this._progress;
            }
        );
        return FastAnimationState;
    }());
    dragonBones.FastAnimationState = FastAnimationState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastBoneTimelineState
     * @classdesc
     * FastBoneTimelineState 负责计算 Bone 的时间轴动画。
     * FastBoneTimelineState 实例隶属于 FastAnimationState. FastAnimationState在创建时会为每个包含动作的 FastBone生成一个 FastBoneTimelineState 实例.
     * @see dragonBones.FastAnimation
     * @see dragonBones.FastAnimationState
     * @see dragonBones.FastBone
     */
    var FastBoneTimelineState = (function () {
        function FastBoneTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._lastTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            this._updateMode = 0;
            this._transform = new dragonBones.DBTransform();
            this._durationTransform = new dragonBones.DBTransform();
            this._transformToFadein = new dragonBones.DBTransform();
            this._pivot = new dragonBones.Point();
            this._durationPivot = new dragonBones.Point();
        }
        var d = __define,c=FastBoneTimelineState,p=c.prototype;
        /** @private */
        FastBoneTimelineState.borrowObject = function () {
            if (FastBoneTimelineState._pool.length == 0) {
                return new FastBoneTimelineState();
            }
            return FastBoneTimelineState._pool.pop();
        };
        /** @private */
        FastBoneTimelineState.returnObject = function (timeline) {
            if (FastBoneTimelineState._pool.indexOf(timeline) < 0) {
                FastBoneTimelineState._pool[FastBoneTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        FastBoneTimelineState.clear = function () {
            var i = FastBoneTimelineState._pool.length;
            while (i--) {
                FastBoneTimelineState._pool[i].clear();
            }
            FastBoneTimelineState._pool.length = 0;
        };
        p.clear = function () {
            if (this._bone) {
                this._bone._timelineState = null;
                this._bone = null;
            }
            this._animationState = null;
            this._timelineData = null;
            this._originPivot = null;
        };
        /** @private */
        p.fadeIn = function (bone, animationState, timelineData) {
            this._bone = bone;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._isComplete = false;
            this._tweenTransform = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._durationPivot.x = 0;
            this._durationPivot.y = 0;
            this._pivot.x = 0;
            this._pivot.y = 0;
            this._originPivot = this._timelineData.originPivot;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
            if (animationState._fadeTotalTime > 0) {
                var pivotToFadein;
                if (this._bone._timelineState) {
                    this._transformToFadein.copy(this._bone._timelineState._transform);
                }
                else {
                    this._transformToFadein = new dragonBones.DBTransform();
                }
                var firstFrame = (this._timelineData.frameList[0]);
                this._durationTransform.copy(firstFrame.transform);
                this._durationTransform.minus(this._transformToFadein);
            }
            this._bone._timelineState = this;
        };
        /** @private */
        p.updateFade = function (progress) {
            this._transform.x = this._transformToFadein.x + this._durationTransform.x * progress;
            this._transform.y = this._transformToFadein.y + this._durationTransform.y * progress;
            this._transform.scaleX = this._transformToFadein.scaleX * (1 + (this._durationTransform.scaleX - 1) * progress);
            this._transform.scaleY = this._transformToFadein.scaleX * (1 + (this._durationTransform.scaleY - 1) * progress);
            this._transform.rotation = this._transformToFadein.rotation + this._durationTransform.rotation * progress;
            this._bone.invalidUpdate();
        };
        /** @private */
        p.update = function (progress) {
            if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
            else if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._bone.arriveAtFrame(currentFrame, this._animationState);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenTransform = false;
            this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
            this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
            this._transform.copy(currentFrame.transform);
            this._bone.invalidUpdate();
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
            }
            if (this._currentTime != currentTime) {
                this._lastTime = this._currentTime;
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration || this._currentTime < this._lastTime) {
                        this._currentFrameIndex++;
                        this._lastTime = this._currentTime;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._bone.arriveAtFrame(prevFrame, this._animationState);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._bone.arriveAtFrame(currentFrame, this._animationState);
                    this.updateToNextFrame(currentPlayTimes);
                }
                if (this._tweenTransform) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 && (this._animationState.playTimes &&
                this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999)) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.animationData.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                //transform
                this._durationTransform.x = nextFrame.transform.x - currentFrame.transform.x;
                this._durationTransform.y = nextFrame.transform.y - currentFrame.transform.y;
                this._durationTransform.skewX = nextFrame.transform.skewX - currentFrame.transform.skewX;
                this._durationTransform.skewY = nextFrame.transform.skewY - currentFrame.transform.skewY;
                this._durationTransform.scaleX = nextFrame.transform.scaleX - currentFrame.transform.scaleX + nextFrame.scaleOffset.x;
                this._durationTransform.scaleY = nextFrame.transform.scaleY - currentFrame.transform.scaleY + nextFrame.scaleOffset.y;
                this._durationPivot.x = nextFrame.pivot.x - currentFrame.pivot.x;
                this._durationPivot.y = nextFrame.pivot.y - currentFrame.pivot.y;
                this._durationTransform.normalizeRotation();
                if (nextFrameIndex == 0) {
                    this._durationTransform.skewX = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewX);
                    this._durationTransform.skewY = dragonBones.TransformUtil.formatRadian(this._durationTransform.skewY);
                }
                if (this._durationTransform.x ||
                    this._durationTransform.y ||
                    this._durationTransform.skewX ||
                    this._durationTransform.skewY ||
                    this._durationTransform.scaleX != 1 ||
                    this._durationTransform.scaleY != 1 ||
                    this._durationPivot.x ||
                    this._durationPivot.y) {
                    this._tweenTransform = true;
                }
                else {
                    this._tweenTransform = false;
                }
            }
            else {
                this._tweenTransform = false;
            }
            if (!this._tweenTransform) {
                this._transform.copy(currentFrame.transform);
                this._pivot.x = this._originPivot.x + currentFrame.pivot.x;
                this._pivot.y = this._originPivot.y + currentFrame.pivot.y;
                this._bone.invalidUpdate();
            }
        };
        p.updateTween = function () {
            var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
            if (this._tweenCurve) {
                progress = this._tweenCurve.getValueByProgress(progress);
            }
            else if (this._tweenEasing) {
                progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var currentTransform = currentFrame.transform;
            var currentPivot = currentFrame.pivot;
            //normal blending
            this._transform.x = currentTransform.x + this._durationTransform.x * progress;
            this._transform.y = currentTransform.y + this._durationTransform.y * progress;
            this._transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress;
            this._transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress;
            this._transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress;
            this._transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress;
            this._pivot.x = currentPivot.x + this._durationPivot.x * progress;
            this._pivot.y = currentPivot.y + this._durationPivot.y * progress;
            this._bone.invalidUpdate();
        };
        FastBoneTimelineState._pool = [];
        return FastBoneTimelineState;
    }());
    dragonBones.FastBoneTimelineState = FastBoneTimelineState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.FastSlotTimelineState
     * @classdesc
     * FastSlotTimelineState 负责计算 Slot 的时间轴动画。
     * FastSlotTimelineState 实例隶属于 FastAnimationState. FastAnimationState在创建时会为每个包含动作的 Slot生成一个 FastSlotTimelineState 实例.
     * @see dragonBones.FastAnimation
     * @see dragonBones.FastAnimationState
     * @see dragonBones.FastSlot
     */
    var FastSlotTimelineState = (function () {
        function FastSlotTimelineState() {
            this._totalTime = 0; //duration
            this._currentTime = 0;
            this._currentFrameIndex = 0;
            this._currentFramePosition = 0;
            this._currentFrameDuration = 0;
            //-1: frameLength>1, 0:frameLength==0, 1:frameLength==1
            this._updateMode = 0;
            this._durationColor = new dragonBones.ColorTransform();
        }
        var d = __define,c=FastSlotTimelineState,p=c.prototype;
        /** @private */
        FastSlotTimelineState.borrowObject = function () {
            if (FastSlotTimelineState._pool.length == 0) {
                return new FastSlotTimelineState();
            }
            return FastSlotTimelineState._pool.pop();
        };
        /** @private */
        FastSlotTimelineState.returnObject = function (timeline) {
            if (FastSlotTimelineState._pool.indexOf(timeline) < 0) {
                FastSlotTimelineState._pool[FastSlotTimelineState._pool.length] = timeline;
            }
            timeline.clear();
        };
        /** @private */
        FastSlotTimelineState.clear = function () {
            var i = FastSlotTimelineState._pool.length;
            while (i--) {
                FastSlotTimelineState._pool[i].clear();
            }
            FastSlotTimelineState._pool.length = 0;
        };
        p.clear = function () {
            this._slot = null;
            this._armature = null;
            this._animation = null;
            this._animationState = null;
            this._timelineData = null;
        };
        //动画开始结束
        /** @private */
        p.fadeIn = function (slot, animationState, timelineData) {
            this._slot = slot;
            this._armature = this._slot.armature;
            this._animation = this._armature.animation;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this.name = timelineData.name;
            this._totalTime = this._timelineData.duration;
            this._isComplete = false;
            this._blendEnabled = false;
            this._tweenColor = false;
            this._currentFrameIndex = -1;
            this._currentTime = -1;
            this._tweenEasing = NaN;
            this._weight = 1;
            switch (this._timelineData.frameList.length) {
                case 0:
                    this._updateMode = 0;
                    break;
                case 1:
                    this._updateMode = 1;
                    break;
                default:
                    this._updateMode = -1;
                    break;
            }
        };
        //动画进行中
        /** @private */
        p.updateFade = function (progress) {
        };
        /** @private */
        p.update = function (progress) {
            if (this._updateMode == -1) {
                this.updateMultipleFrame(progress);
            }
            else if (this._updateMode == 1) {
                this._updateMode = 0;
                this.updateSingleFrame();
            }
        };
        p.updateMultipleFrame = function (progress) {
            var currentPlayTimes = 0;
            progress /= this._timelineData.scale;
            progress += this._timelineData.offset;
            var currentTime = this._totalTime * progress;
            var playTimes = this._animationState.playTimes;
            if (playTimes == 0) {
                this._isComplete = false;
                currentPlayTimes = Math.ceil(Math.abs(currentTime) / this._totalTime) || 1;
                currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                if (currentTime < 0) {
                    currentTime += this._totalTime;
                }
            }
            else {
                var totalTimes = playTimes * this._totalTime;
                if (currentTime >= totalTimes) {
                    currentTime = totalTimes;
                    this._isComplete = true;
                }
                else if (currentTime <= -totalTimes) {
                    currentTime = -totalTimes;
                    this._isComplete = true;
                }
                else {
                    this._isComplete = false;
                }
                if (currentTime < 0) {
                    currentTime += totalTimes;
                }
                currentPlayTimes = Math.ceil(currentTime / this._totalTime) || 1;
                if (this._isComplete) {
                    currentTime = this._totalTime;
                }
                else {
                    currentTime -= Math.floor(currentTime / this._totalTime) * this._totalTime;
                }
            }
            if (this._currentTime != currentTime) {
                this._currentTime = currentTime;
                var frameList = this._timelineData.frameList;
                var prevFrame;
                var currentFrame;
                for (var i = 0, l = this._timelineData.frameList.length; i < l; ++i) {
                    if (this._currentFrameIndex < 0) {
                        this._currentFrameIndex = 0;
                    }
                    else if (this._currentTime < this._currentFramePosition || this._currentTime >= this._currentFramePosition + this._currentFrameDuration) {
                        this._currentFrameIndex++;
                        if (this._currentFrameIndex >= frameList.length) {
                            if (this._isComplete) {
                                this._currentFrameIndex--;
                                break;
                            }
                            else {
                                this._currentFrameIndex = 0;
                            }
                        }
                    }
                    else {
                        break;
                    }
                    currentFrame = (frameList[this._currentFrameIndex]);
                    if (prevFrame) {
                        this._slot._arriveAtFrame(prevFrame, this._animationState);
                    }
                    this._currentFrameDuration = currentFrame.duration;
                    this._currentFramePosition = currentFrame.position;
                    prevFrame = currentFrame;
                }
                if (currentFrame) {
                    this._slot._arriveAtFrame(currentFrame, this._animationState);
                    this._blendEnabled = currentFrame.displayIndex >= 0;
                    if (this._blendEnabled) {
                        this.updateToNextFrame(currentPlayTimes);
                    }
                    else {
                        this._tweenEasing = NaN;
                        this._tweenColor = false;
                    }
                }
                if (this._blendEnabled) {
                    this.updateTween();
                }
            }
        };
        p.updateToNextFrame = function (currentPlayTimes) {
            if (currentPlayTimes === void 0) { currentPlayTimes = 0; }
            var nextFrameIndex = this._currentFrameIndex + 1;
            if (nextFrameIndex >= this._timelineData.frameList.length) {
                nextFrameIndex = 0;
            }
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            var nextFrame = (this._timelineData.frameList[nextFrameIndex]);
            var tweenEnabled = false;
            if (nextFrameIndex == 0 &&
                (this._animationState.playTimes &&
                    this._animationState.currentPlayTimes >= this._animationState.playTimes &&
                    ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + currentPlayTimes - this._timelineData.offset) * this._timelineData.scale > 0.999999)) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0) {
                this._tweenEasing = NaN;
                tweenEnabled = false;
            }
            else if (this._animationState.autoTween) {
                this._tweenEasing = this._animationState.animationData.tweenEasing;
                if (isNaN(this._tweenEasing)) {
                    this._tweenEasing = currentFrame.tweenEasing;
                    this._tweenCurve = currentFrame.curve;
                    if (isNaN(this._tweenEasing) && this._tweenCurve == null) {
                        tweenEnabled = false;
                    }
                    else {
                        if (this._tweenEasing == 10) {
                            this._tweenEasing = 0;
                        }
                        //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                        tweenEnabled = true;
                    }
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            else {
                this._tweenEasing = currentFrame.tweenEasing;
                this._tweenCurve = currentFrame.curve;
                if ((isNaN(this._tweenEasing) || this._tweenEasing == 10) && this._tweenCurve == null) {
                    this._tweenEasing = NaN;
                    tweenEnabled = false;
                }
                else {
                    //_tweenEasing [-1, 0) 0 (0, 1] (1, 2]
                    tweenEnabled = true;
                }
            }
            if (tweenEnabled) {
                if (currentFrame.color || nextFrame.color) {
                    dragonBones.ColorTransformUtil.minus(nextFrame.color || dragonBones.ColorTransformUtil.originalColor, currentFrame.color || dragonBones.ColorTransformUtil.originalColor, this._durationColor);
                    this._tweenColor = this._durationColor.alphaOffset != 0 ||
                        this._durationColor.redOffset != 0 ||
                        this._durationColor.greenOffset != 0 ||
                        this._durationColor.blueOffset != 0 ||
                        this._durationColor.alphaMultiplier != 0 ||
                        this._durationColor.redMultiplier != 0 ||
                        this._durationColor.greenMultiplier != 0 ||
                        this._durationColor.blueMultiplier != 0;
                }
                else {
                    this._tweenColor = false;
                }
            }
            else {
                this._tweenColor = false;
            }
            if (!this._tweenColor) {
                var targetColor;
                var colorChanged;
                if (currentFrame.color) {
                    targetColor = currentFrame.color;
                    colorChanged = true;
                }
                else {
                    targetColor = dragonBones.ColorTransformUtil.originalColor;
                    colorChanged = false;
                }
                if ((this._slot._isColorChanged || colorChanged)) {
                    if (!dragonBones.ColorTransformUtil.isEqual(this._slot._colorTransform, targetColor)) {
                        this._slot._updateDisplayColor(targetColor.alphaOffset, targetColor.redOffset, targetColor.greenOffset, targetColor.blueOffset, targetColor.alphaMultiplier, targetColor.redMultiplier, targetColor.greenMultiplier, targetColor.blueMultiplier, colorChanged);
                    }
                }
            }
        };
        p.updateTween = function () {
            var currentFrame = (this._timelineData.frameList[this._currentFrameIndex]);
            if (this._tweenColor) {
                var progress = (this._currentTime - this._currentFramePosition) / this._currentFrameDuration;
                if (this._tweenCurve != null) {
                    progress = this._tweenCurve.getValueByProgress(progress);
                }
                else if (this._tweenEasing) {
                    progress = dragonBones.MathUtil.getEaseValue(progress, this._tweenEasing);
                }
                if (currentFrame.color) {
                    this._slot._updateDisplayColor(currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, currentFrame.color.redOffset + this._durationColor.redOffset * progress, currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true);
                }
                else {
                    this._slot._updateDisplayColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, this._durationColor.alphaMultiplier * progress + 1, this._durationColor.redMultiplier * progress + 1, this._durationColor.greenMultiplier * progress + 1, this._durationColor.blueMultiplier * progress + 1, true);
                }
            }
        };
        p.updateSingleFrame = function () {
            var currentFrame = (this._timelineData.frameList[0]);
            this._slot._arriveAtFrame(currentFrame, this._animationState);
            this._isComplete = true;
            this._tweenEasing = NaN;
            this._tweenColor = false;
            this._blendEnabled = currentFrame.displayIndex >= 0;
            if (this._blendEnabled) {
                var targetColor;
                var colorChanged;
                if (currentFrame.color) {
                    targetColor = currentFrame.color;
                    colorChanged = true;
                }
                else {
                    targetColor = dragonBones.ColorTransformUtil.originalColor;
                    colorChanged = false;
                }
                if ((this._slot._isColorChanged || colorChanged)) {
                    if (!dragonBones.ColorTransformUtil.isEqual(this._slot._colorTransform, targetColor)) {
                        this._slot._updateDisplayColor(targetColor.alphaOffset, targetColor.redOffset, targetColor.greenOffset, targetColor.blueOffset, targetColor.alphaMultiplier, targetColor.redMultiplier, targetColor.greenMultiplier, targetColor.blueMultiplier, colorChanged);
                    }
                }
            }
        };
        FastSlotTimelineState.HALF_PI = Math.PI * 0.5;
        FastSlotTimelineState.DOUBLE_PI = Math.PI * 2;
        FastSlotTimelineState._pool = [];
        return FastSlotTimelineState;
    }());
    dragonBones.FastSlotTimelineState = FastSlotTimelineState;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Point
     * @classdesc
     * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     * 下面的代码在 (0,0) 处创建一个点：
     *   var myPoint:Point = new Point();
     */
    var Point = (function () {
        /**
         *创建一个新点。
         * @param x 该点的水平坐标。
         * @param y 该点的垂直坐标。
         */
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        var d = __define,c=Point,p=c.prototype;
        /**
         *返回包含 x 和 y 坐标的值的字符串。
         * @returns {string}
         */
        p.toString = function () {
            return "[Point (x=" + this.x + " y=" + this.y + ")]";
        };
        return Point;
    }());
    dragonBones.Point = Point;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones
     * @classdesc
     * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     */
    var Rectangle = (function () {
        /**
         *创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度（以像素为单位）
         * @param height 矩形的高度（以像素为单位）。
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        var d = __define,c=Rectangle,p=c.prototype;
        return Rectangle;
    }());
    dragonBones.Rectangle = Rectangle;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Timeline
     * @classdesc
     * 保存时间轴相关的数据，包括关键帧，持续时间，时间缩放
     */
    var Timeline = (function () {
        /**
         * 初始化数据duration为0，scale为1
         */
        function Timeline() {
            /**
             * 持续时间，单位是帧
             * @member {number} dragonBones.Timeline#duration
             */
            this.duration = 0;
            this._frameList = [];
            this.duration = 0;
            this.scale = 1;
        }
        var d = __define,c=Timeline,p=c.prototype;
        p.dispose = function () {
            var i = this._frameList.length;
            while (i--) {
                this._frameList[i].dispose();
            }
            this._frameList = null;
        };
        /**
         * 添加一个关键帧数据
         * @param frame 关键帧数据
         * @see extension.dragonbones.model.Frame
         */
        p.addFrame = function (frame) {
            if (!frame) {
                throw new Error();
            }
            if (this._frameList.indexOf(frame) < 0) {
                this._frameList[this._frameList.length] = frame;
            }
            else {
                throw new Error();
            }
        };
        d(p, "frameList"
            /**
             * 获取关键帧列表
             * @returns {Array<Frame>}
             */
            ,function () {
                return this._frameList;
            }
        );
        return Timeline;
    }());
    dragonBones.Timeline = Timeline;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonbones.AnimationData
     * @extends dragonbones.Timeline
     * @classdesc
     * 保存动画数据
     */
    var AnimationData = (function (_super) {
        __extends(AnimationData, _super);
        /**
         * 创建一个AnimationData实例
         */
        function AnimationData() {
            _super.call(this);
            /**
             * 动画的帧率，表示每一秒钟播放多少帧
             * @member {number} dragonBones.AnimationData#frameRate
             */
            this.frameRate = 0;
            /**
             * 	播放次数 0为一直播放，默认为0
             * @member {number} dragonBones.AnimationData#playTimes
             */
            this.playTimes = 0;
            /**
             * 最后一帧持续的帧数
             * @member {number} dragonBones.AnimationData#lastFrameDuration
             */
            this.lastFrameDuration = 0;
            this.fadeTime = 0;
            this.playTimes = 0;
            this.autoTween = true;
            this.tweenEasing = NaN;
            this.hideTimelineNameMap = [];
            this.hideSlotTimelineNameMap = [];
            this._timelineList = [];
            this._slotTimelineList = [];
            this._ffdTimelineList = [];
        }
        var d = __define,c=AnimationData,p=c.prototype;
        d(p, "timelineList"
            /**
             * 时间轴列表
             * @returns {Array<TransformTimeline>}
             */
            ,function () {
                return this._timelineList;
            }
        );
        d(p, "slotTimelineList"
            ,function () {
                return this._slotTimelineList;
            }
        );
        d(p, "ffdTimelineList"
            ,function () {
                return this._ffdTimelineList;
            }
        );
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.hideTimelineNameMap = null;
            var i = 0;
            var len = 0;
            for (i = 0, len = this._timelineList.length; i < len; i++) {
                var timeline = this._timelineList[i];
                timeline.dispose();
            }
            this._timelineList = null;
            for (i = 0, len = this._slotTimelineList.length; i < len; i++) {
                var slotTimeline = this._slotTimelineList[i];
                slotTimeline.dispose();
            }
            this._slotTimelineList = null;
        };
        /**
         * 根据时间轴的名字获取时间轴数据
         * @param timelineName 时间轴的名字
         * @returns {*} 时间轴数据
         */
        p.getTimeline = function (timelineName) {
            var i = this._timelineList.length;
            while (i--) {
                if (this._timelineList[i].name == timelineName) {
                    return this._timelineList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个时间轴数据
         * @param timeline 需要被添加的时间轴数据
         */
        p.addTimeline = function (timeline) {
            if (!timeline) {
                throw new Error();
            }
            if (this._timelineList.indexOf(timeline) < 0) {
                this._timelineList[this._timelineList.length] = timeline;
            }
        };
        p.getSlotTimeline = function (timelineName) {
            var i = this._slotTimelineList.length;
            while (i--) {
                if (this._slotTimelineList[i].name == timelineName) {
                    return this._slotTimelineList[i];
                }
            }
            return null;
        };
        p.addSlotTimeline = function (timeline) {
            if (!timeline) {
                throw new Error();
            }
            if (this._slotTimelineList.indexOf(timeline) < 0) {
                this._slotTimelineList[this._slotTimelineList.length] = timeline;
            }
        };
        p.addFFDTimeline = function (timeline) {
            if (!timeline) {
                throw new Error();
            }
            if (this._ffdTimelineList.indexOf(timeline) < 0) {
                this._ffdTimelineList[this._ffdTimelineList.length] = timeline;
            }
        };
        return AnimationData;
    }(dragonBones.Timeline));
    dragonBones.AnimationData = AnimationData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ArmatureData
     * @classdesc
     * armature数据 一个armature数据包含一个角色的骨骼，皮肤，动画的数据
     * @see  dragonBones.BoneData
     * @see  dragonBones.SkinData
     * @see  dragonBones.AnimationData
     */
    var ArmatureData = (function () {
        /**
         * 创建一个ArmatureData实例
         */
        function ArmatureData() {
            // Modify Fast mode by duanchunlei
            this._cacheManager = null; // 标记缓存器是否已经生成过
            this._boneDataList = [];
            this._ikDataList = [];
            this._skinDataList = [];
            this._slotDataList = [];
            this._animationDataList = [];
            //_areaDataList = new Vector.<IAreaData>(0, true);
        }
        var d = __define,c=ArmatureData,p=c.prototype;
        ArmatureData.sortBoneDataHelpArray = function (object1, object2) {
            return object1[0] > object2[0] ? 1 : -1;
        };
        ArmatureData.sortBoneDataHelpArrayDescending = function (object1, object2) {
            return object1[0] > object2[0] ? -1 : 1;
        };
        p.setSkinData = function (skinName) {
            var i = 0;
            var len = this._slotDataList.length;
            for (i = 0; i < len; i++) {
                this._slotDataList[i].dispose();
            }
            var skinData;
            if (!skinName && this._skinDataList.length > 0) {
                skinData = this._skinDataList[0];
            }
            else {
                i = 0,
                    len = this._skinDataList.length;
                for (; i < len; i++) {
                    if (this._skinDataList[i].name == skinName) {
                        skinData = this._skinDataList[i];
                        break;
                    }
                }
            }
            if (skinData) {
                var slotData;
                i = 0, len = skinData.slotDataList.length;
                for (i = 0; i < len; i++) {
                    slotData = this.getSlotData(skinData.slotDataList[i].name);
                    if (slotData) {
                        var j = 0;
                        var jLen = skinData.slotDataList[i].displayDataList.length;
                        for (j = 0; j < jLen; j++) {
                            slotData.addDisplayData(skinData.slotDataList[i].displayDataList[j]);
                        }
                    }
                }
            }
        };
        /**
         * 释放资源
         */
        p.dispose = function () {
            var i = this._boneDataList.length;
            while (i--) {
                this._boneDataList[i].dispose();
            }
            i = this._ikDataList.length;
            while (i--) {
                this._ikDataList[i].dispose();
            }
            i = this._skinDataList.length;
            while (i--) {
                this._skinDataList[i].dispose();
            }
            i = this._slotDataList.length;
            while (i--) {
                this._slotDataList[i].dispose();
            }
            i = this._animationDataList.length;
            while (i--) {
                this._animationDataList[i].dispose();
            }
            this._boneDataList = null;
            this._ikDataList = null;
            this._slotDataList = null;
            this._skinDataList = null;
            this._animationDataList = null;
        };
        /**
         * 根据骨骼的名字获取到骨骼数据
         * @param boneName 骨骼的名字
         * @returns {*} 骨骼数据
         */
        p.getBoneData = function (boneName) {
            var i = this._boneDataList.length;
            while (i--) {
                if (this._boneDataList[i].name == boneName) {
                    return this._boneDataList[i];
                }
            }
            return null;
        };
        p.getIKData = function (ikName) {
            var i = this._ikDataList.length;
            while (i--) {
                if (this._ikDataList[i].name == ikName) {
                    return this._ikDataList[i];
                }
            }
            return null;
        };
        p.getSlotData = function (slotName) {
            var i = this._slotDataList.length;
            while (i--) {
                if (this._slotDataList[i].name == slotName) {
                    return this._slotDataList[i];
                }
            }
            return null;
        };
        /**
         * 根据皮肤的名字获取到皮肤数据
         * @param skinName  皮肤的名字
         * @returns {*}  皮肤数据
         */
        p.getSkinData = function (skinName) {
            if (!skinName && this._skinDataList.length > 0) {
                return this._skinDataList[0];
            }
            var i = this._skinDataList.length;
            while (i--) {
                if (this._skinDataList[i].name == skinName) {
                    return this._skinDataList[i];
                }
            }
            return null;
        };
        /**
         * 根据动画的名字获取动画数据
         * @param animationName 动画的名字
         * @returns {*} 动画数据
         */
        p.getAnimationData = function (animationName) {
            var i = this._animationDataList.length;
            while (i--) {
                if (this._animationDataList[i].name == animationName) {
                    return this._animationDataList[i];
                }
            }
            return null;
        };
        /**
         *添加一个骨骼数据
         * @param boneData
         */
        p.addBoneData = function (boneData) {
            if (!boneData) {
                throw new Error();
            }
            if (this._boneDataList.indexOf(boneData) < 0) {
                this._boneDataList[this._boneDataList.length] = boneData;
            }
            else {
                throw new Error();
            }
        };
        p.addIKData = function (ikData) {
            if (!ikData) {
                throw new Error();
            }
            if (this._ikDataList.indexOf(ikData) < 0) {
                this._ikDataList[this._ikDataList.length] = ikData;
            }
            else {
                throw new Error();
            }
        };
        p.addSlotData = function (slotData) {
            if (!slotData) {
                throw new Error();
            }
            if (this._slotDataList.indexOf(slotData) < 0) {
                this._slotDataList[this._slotDataList.length] = slotData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 添加一个皮肤数据
         * @param skinData
         */
        p.addSkinData = function (skinData) {
            if (!skinData) {
                throw new Error();
            }
            if (this._skinDataList.indexOf(skinData) < 0) {
                this._skinDataList[this._skinDataList.length] = skinData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 添加一个动画数据
         * @param animationData
         */
        p.addAnimationData = function (animationData) {
            if (!animationData) {
                throw new Error();
            }
            if (this._animationDataList.indexOf(animationData) < 0) {
                this._animationDataList[this._animationDataList.length] = animationData;
            }
        };
        /**
         * 对骨骼按照骨骼数的层级关系排序
         */
        p.sortBoneDataList = function () {
            var i = this._boneDataList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            while (i--) {
                var boneData = this._boneDataList[i];
                var level = 0;
                var parentData = boneData;
                while (parentData) {
                    level++;
                    parentData = this.getBoneData(parentData.parent);
                }
                helpArray[i] = [level, boneData];
            }
            helpArray.sort(ArmatureData.sortBoneDataHelpArray);
            i = helpArray.length;
            while (i--) {
                this._boneDataList[i] = helpArray[i][1];
            }
        };
        d(p, "boneDataList"
            /**
             * 获取骨骼数据列表
             * @returns {Array<BoneData>}
             */
            ,function () {
                return this._boneDataList;
            }
        );
        d(p, "ikDataList"
            ,function () {
                return this._ikDataList;
            }
        );
        d(p, "slotDataList"
            ,function () {
                return this._slotDataList;
            }
        );
        d(p, "skinDataList"
            /**
             * 获取皮肤数据列表
             * @returns {Array<SkinData>}
             */
            ,function () {
                return this._skinDataList;
            }
        );
        d(p, "animationDataList"
            /**
             * 获得动画数据列表
             * @returns {Array<AnimationData>}
             */
            ,function () {
                return this._animationDataList;
            }
        );
        return ArmatureData;
    }());
    dragonBones.ArmatureData = ArmatureData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.BoneData
     * @classdesc
     * 骨骼数据
     */
    var BoneData = (function () {
        /**
         * 初始化各个属性
         */
        function BoneData() {
            this.length = 0;
            this.global = new dragonBones.DBTransform();
            this.transform = new dragonBones.DBTransform();
            this.inheritRotation = true;
            this.inheritScale = false;
        }
        var d = __define,c=BoneData,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            this.global = null;
            this.transform = null;
        };
        return BoneData;
    }());
    dragonBones.BoneData = BoneData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ColorTransform
     * @classdesc
     * 表示颜色的transform
     */
    var ColorTransform = (function () {
        function ColorTransform() {
            this.alphaMultiplier = 1;
            this.alphaOffset = 0;
            this.blueMultiplier = 1;
            this.blueOffset = 0;
            this.greenMultiplier = 1;
            this.greenOffset = 0;
            this.redMultiplier = 1;
            this.redOffset = 0;
        }
        var d = __define,c=ColorTransform,p=c.prototype;
        return ColorTransform;
    }());
    dragonBones.ColorTransform = ColorTransform;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var CurveData = (function () {
        function CurveData() {
            this._dataChanged = false;
            this._pointList = [];
            this.sampling = new Array(CurveData.SamplingTimes);
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                this.sampling[i] = new dragonBones.Point();
            }
        }
        var d = __define,c=CurveData,p=c.prototype;
        p.getValueByProgress = function (progress) {
            if (this._dataChanged) {
                this.refreshSampling();
            }
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                var point = this.sampling[i];
                if (point.x >= progress) {
                    if (i == 0) {
                        return point.y * progress / point.x;
                    }
                    else {
                        var prevPoint = this.sampling[i - 1];
                        return prevPoint.y + (point.y - prevPoint.y) * (progress - prevPoint.x) / (point.x - prevPoint.x);
                    }
                }
            }
            return point.y + (1 - point.y) * (progress - point.x) / (1 - point.x);
        };
        p.refreshSampling = function () {
            for (var i = 0; i < CurveData.SamplingTimes - 1; i++) {
                this.bezierCurve(CurveData.SamplingStep * (i + 1), this.sampling[i]);
            }
            this._dataChanged = false;
        };
        p.bezierCurve = function (t, outputPoint) {
            var l_t = 1 - t;
            outputPoint.x = 3 * this.point1.x * t * l_t * l_t + 3 * this.point2.x * t * t * l_t + Math.pow(t, 3);
            outputPoint.y = 3 * this.point1.y * t * l_t * l_t + 3 * this.point2.y * t * t * l_t + Math.pow(t, 3);
        };
        d(p, "pointList"
            ,function () {
                return this._pointList;
            }
            ,function (value) {
                this._pointList = value;
                this._dataChanged = true;
            }
        );
        p.isCurve = function () {
            return this.point1.x != 0 || this.point1.y != 0 || this.point2.x != 1 || this.point2.y != 1;
        };
        d(p, "point1"
            ,function () {
                return this.pointList[0];
            }
        );
        d(p, "point2"
            ,function () {
                return this.pointList[1];
            }
        );
        CurveData.SamplingTimes = 20;
        CurveData.SamplingStep = 0.05;
        return CurveData;
    }());
    dragonBones.CurveData = CurveData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DisplayData
     * @classdesc
     * 显示对象的数据，目前支持图片和子骨架
     */
    var DisplayData = (function () {
        /**
         * 初始化变换矩阵为单位矩阵
         * 注册点为{0，0}点
         */
        function DisplayData() {
            this.transform = new dragonBones.DBTransform();
            this.pivot = new dragonBones.Point();
        }
        var d = __define,c=DisplayData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            this.transform = null;
            this.pivot = null;
        };
        /**
         * 子骨架类型
         */
        DisplayData.ARMATURE = "armature";
        /**
         * 图片类型
         */
        DisplayData.IMAGE = "image";
        /**
         * @private
         * 网格类型
         */
        DisplayData.MESH = "mesh";
        return DisplayData;
    }());
    dragonBones.DisplayData = DisplayData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DragonBonesData
     * @classdesc
     * DragonBones的数据，包含了骨架数据和显示对象数据
     */
    var DragonBonesData = (function () {
        /**
         * 构造函数，实例化一个DragonBonesData类
         */
        function DragonBonesData() {
            /**
             * 数据版本
             */
            this.version = 0;
            this._armatureDataList = [];
            this._displayDataDictionary = {};
        }
        var d = __define,c=DragonBonesData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            for (var i = 0, len = this._armatureDataList.length; i < len; i++) {
                var armatureData = this._armatureDataList[i];
                armatureData.dispose();
            }
            this._armatureDataList = null;
            this.removeAllDisplayData();
            this._displayDataDictionary = null;
        };
        d(p, "armatureDataList"
            /**
             * 获取所有的骨架数据
             * @returns {Array<ArmatureData>}
             */
            ,function () {
                return this._armatureDataList;
            }
        );
        /**
         * 通过骨架的名字获取骨架的数据
         * @param armatureName 想要获取的骨架的名字
         * @returns {*} 骨架数据 ArmatureData
         */
        p.getArmatureDataByName = function (armatureName) {
            var i = this._armatureDataList.length;
            while (i--) {
                if (this._armatureDataList[i].name == armatureName) {
                    return this._armatureDataList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个骨架数据
         * @param armatureData
         */
        p.addArmatureData = function (armatureData) {
            if (!armatureData) {
                throw new Error();
            }
            if (this._armatureDataList.indexOf(armatureData) < 0) {
                this._armatureDataList[this._armatureDataList.length] = armatureData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 移除一个骨架数据
         * @param armatureData
         */
        p.removeArmatureData = function (armatureData) {
            var index = this._armatureDataList.indexOf(armatureData);
            if (index >= 0) {
                this._armatureDataList.splice(index, 1);
            }
        };
        /**
         * 根据骨架的名字，移除该骨架的数据
         * @param armatureName 想要移除的骨架的名字
         */
        p.removeArmatureDataByName = function (armatureName) {
            var i = this._armatureDataList.length;
            while (i--) {
                if (this._armatureDataList[i].name == armatureName) {
                    this._armatureDataList.splice(i, 1);
                }
            }
        };
        /**
         * 根据名字获取显示对象数据
         * @param name 想要获取的显示对象数据的名字
         * @returns {any} 显示对象数据 DisplayData
         */
        p.getDisplayDataByName = function (name) {
            return this._displayDataDictionary[name];
        };
        /**
         *添加一个显示对象数据
         * @param displayData 需要被添加的显示对象数据
         */
        p.addDisplayData = function (displayData) {
            this._displayDataDictionary[displayData.name] = displayData;
        };
        /**
         *根据显示对象的名字移除该显示对象数据
         * @param name 显示对象的名字
         */
        p.removeDisplayDataByName = function (name) {
            delete this._displayDataDictionary[name];
        };
        /**
         *移除所有的显示对象数据
         */
        p.removeAllDisplayData = function () {
            for (var name in this._displayDataDictionary) {
                delete this._displayDataDictionary[name];
            }
        };
        return DragonBonesData;
    }());
    dragonBones.DragonBonesData = DragonBonesData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.Frame
     * @classdesc
     *关键帧数据
     */
    var Frame = (function () {
        /**
         *构造函数
         */
        function Frame() {
            /**
             *位置
             * @member {number} dragonBones.Frame#position
             */
            this.position = 0;
            /**
             *持续时间
             * @member {number} dragonBones.Frame#duration
             */
            this.duration = 0;
            this.position = 0;
            this.duration = 0;
        }
        var d = __define,c=Frame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
        };
        return Frame;
    }());
    dragonBones.Frame = Frame;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var FFDFrame = (function (_super) {
        __extends(FFDFrame, _super);
        function FFDFrame() {
            _super.call(this);
        }
        var d = __define,c=FFDFrame,p=c.prototype;
        return FFDFrame;
    }(dragonBones.Frame));
    dragonBones.FFDFrame = FFDFrame;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var FFDTimeline = (function (_super) {
        __extends(FFDTimeline, _super);
        function FFDTimeline() {
            _super.call(this);
            this.offset = 0;
        }
        var d = __define,c=FFDTimeline,p=c.prototype;
        p.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return FFDTimeline;
    }(dragonBones.Timeline));
    dragonBones.FFDTimeline = FFDTimeline;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var IKData = (function () {
        function IKData() {
        }
        var d = __define,c=IKData,p=c.prototype;
        p.constructora = function () {
        };
        p.dispose = function () {
        };
        return IKData;
    }());
    dragonBones.IKData = IKData;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     * @class dragonBones.BoneData
     * @classdesc
     * 网格数据
     */
    var MeshData = (function (_super) {
        __extends(MeshData, _super);
        function MeshData() {
            _super.call(this);
            this.skinned = false;
            this.numVertex = 0;
            this.numTriangle = 0;
            this.triangles = [];
            this.vertices = [];
            this.vertexBones = [];
            this.bones = [];
            this.inverseBindPose = [];
            this.slotPose = new dragonBones.Matrix();
        }
        var d = __define,c=MeshData,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.triangles.length = 0;
            this.vertices.length = 0;
            this.vertexBones.length = 0;
            this.bones.length = 0;
            this.inverseBindPose.length = 0;
        };
        return MeshData;
    }(dragonBones.DisplayData));
    dragonBones.MeshData = MeshData;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * optimized by freem-trg
     * Intermediate class for store the results of the parent transformation
     */
    var ParentTransformObject = (function () {
        function ParentTransformObject() {
        }
        var d = __define,c=ParentTransformObject,p=c.prototype;
        /// Method to set properties after its creation/pooling
        p.setTo = function (parentGlobalTransform, parentGlobalTransformMatrix) {
            this.parentGlobalTransform = parentGlobalTransform;
            this.parentGlobalTransformMatrix = parentGlobalTransformMatrix;
            return this;
        };
        /// Cleanup object and return it to the object pool
        p.release = function () {
            ParentTransformObject.dispose(this);
        };
        /// Create/take new clean object from the object pool
        ParentTransformObject.create = function () {
            if (ParentTransformObject._poolSize > 0) {
                ParentTransformObject._poolSize--;
                return ParentTransformObject._pool.pop();
            }
            return new ParentTransformObject();
        };
        /// Cleanup object and return it to the object pool
        ParentTransformObject.dispose = function (parentTransformObject) {
            parentTransformObject.parentGlobalTransform = null;
            parentTransformObject.parentGlobalTransformMatrix = null;
            ParentTransformObject._pool[ParentTransformObject._poolSize++] = parentTransformObject;
        };
        /// Object pool to reduce GC load
        ParentTransformObject._pool = [];
        ParentTransformObject._poolSize = 0;
        return ParentTransformObject;
    }());
    dragonBones.ParentTransformObject = ParentTransformObject;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SkinData
     * @classdesc
     * 皮肤数据，皮肤是由一些插槽组成，每个插槽都有一个骨骼控制，骨骼的运动带动插槽的运动形成动画，
     * 插槽里可以放置显示对象，目前支持的显示对象有图片和子骨架两种
     */
    var SkinData = (function () {
        /**
         * 构造函数，实例化一个SkinData类
         */
        function SkinData() {
            /**
             * @private
             */
            this.hasMesh = false;
            this._slotDataList = [];
        }
        var d = __define,c=SkinData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            var i = this._slotDataList.length;
            while (i--) {
                this._slotDataList[i].dispose();
            }
            this._slotDataList = null;
        };
        /**
         * 根据插槽的名字获取插槽数据
         * @param slotName 想要获取的插槽的名字
         * @returns {*} 返回的插槽数据
         */
        p.getSlotData = function (slotName) {
            var i = this._slotDataList.length;
            while (i--) {
                if (this._slotDataList[i].name == slotName) {
                    return this._slotDataList[i];
                }
            }
            return null;
        };
        /**
         * 添加一个插槽数据
         * @param slotData
         */
        p.addSlotData = function (slotData) {
            if (!slotData) {
                throw new Error();
            }
            if (this._slotDataList.indexOf(slotData) < 0) {
                this._slotDataList[this._slotDataList.length] = slotData;
            }
            else {
                throw new Error();
            }
        };
        d(p, "slotDataList"
            /**
             * 获取所有的插槽数据
             * @returns {Array<SlotData>}
             */
            ,function () {
                return this._slotDataList;
            }
        );
        return SkinData;
    }());
    dragonBones.SkinData = SkinData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotData
     * @classdesc
     * 插槽数据，插槽是由骨骼控制的，可以装入显示对象的容器，显示对象可以是图片或者子骨架
     * 插槽可插入一个或者多个显示对象，但是同一时刻只能显示一个显示对象
     * 插槽支持关键帧动画，如果有多个显示对象，可以指定哪一帧显示哪一个显示对象
     */
    var SlotData = (function () {
        /**
         * 构造函数，实例化一个SlotData类
         */
        function SlotData() {
            this._displayDataList = [];
            this.zOrder = 0;
        }
        var d = __define,c=SlotData,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            this._displayDataList.length = 0;
        };
        /**
         * 添加一个显示对象数据
         * @param displayData
         */
        p.addDisplayData = function (displayData) {
            if (!displayData) {
                throw new Error();
            }
            if (this._displayDataList.indexOf(displayData) < 0) {
                this._displayDataList[this._displayDataList.length] = displayData;
            }
            else {
                throw new Error();
            }
        };
        /**
         * 根据显示对象的名字获取显示对象数据
         * @param displayName 想要获取的显示对象的名字
         * @returns {*} 返回显示对象昂数据，如果没有返回null
         */
        p.getDisplayData = function (displayName) {
            var i = this._displayDataList.length;
            while (i--) {
                if (this._displayDataList[i].name == displayName) {
                    return this._displayDataList[i];
                }
            }
            return null;
        };
        d(p, "displayDataList"
            /**
             * 获取所有的显示对象
             * @returns {Array<DisplayData>}
             */
            ,function () {
                return this._displayDataList;
            }
        );
        return SlotData;
    }());
    dragonBones.SlotData = SlotData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotFrame
     * @extends dragonBones.Frame
     * @classdesc
     * 插槽的关键帧数据，包含
     * 插槽的显示序号，可见度，zOrder，colorTransform数据
     */
    var SlotFrame = (function (_super) {
        __extends(SlotFrame, _super);
        /**
         *构造函数，实例化一个SlotFrame
         */
        function SlotFrame() {
            _super.call(this);
            /**
             *绑定到该插槽的显示序号，当插槽有多个显示对象时，指定显示哪一个显示对象
             * @member {number} dragonBones.SlotFrame#displayIndex
             */
            this.displayIndex = 0;
            this.tweenEasing = 10;
            this.displayIndex = 0;
            this.visible = true;
            this.zOrder = NaN;
        }
        var d = __define,c=SlotFrame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.color = null;
        };
        return SlotFrame;
    }(dragonBones.Frame));
    dragonBones.SlotFrame = SlotFrame;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.SlotTimeline
     * @extends dragonBones.Timeline
     * @classdesc
     * 插槽的时间轴数据，包含一个和多个关键帧数据
     */
    var SlotTimeline = (function (_super) {
        __extends(SlotTimeline, _super);
        /**
         * 构造函数，实例化一个SlotTimeline
         */
        function SlotTimeline() {
            _super.call(this);
            this.offset = 0;
        }
        var d = __define,c=SlotTimeline,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return SlotTimeline;
    }(dragonBones.Timeline));
    dragonBones.SlotTimeline = SlotTimeline;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformFrame
     * @extends dragonBones.Frame
     * @classdesc
     * 骨骼的关键帧数据，包含骨骼的缓动，旋转，transform数据和
     * 插槽的显示序号，可见度，zOrder，colorTransform数据
     */
    var TransformFrame = (function (_super) {
        __extends(TransformFrame, _super);
        /**
         *构造函数，实例化一个TransformFrame
         */
        function TransformFrame() {
            _super.call(this);
            /**
             * 旋转几圈
             * @member {number} dragonBones.TransformFrame#tweenRotate
             */
            this.tweenRotate = 0;
            /**
             *绑定到该骨骼的插槽的显示序号，当插槽有多个显示对象时，指定显示哪一个显示对象
             * @member {number} dragonBones.TransformFrame#displayIndex
             */
            this.displayIndex = 0;
            this.tweenEasing = 10;
            this.tweenRotate = 0;
            this.tweenScale = true;
            this.displayIndex = 0;
            this.visible = true;
            this.zOrder = NaN;
            this.global = new dragonBones.DBTransform();
            this.transform = new dragonBones.DBTransform();
            this.pivot = new dragonBones.Point();
            this.scaleOffset = new dragonBones.Point();
        }
        var d = __define,c=TransformFrame,p=c.prototype;
        /**
         *释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.global = null;
            this.transform = null;
            this.pivot = null;
            this.scaleOffset = null;
            this.color = null;
        };
        return TransformFrame;
    }(dragonBones.Frame));
    dragonBones.TransformFrame = TransformFrame;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformTimeline
     * @extends dragonBones.Timeline
     * @classdesc
     * 骨骼的时间轴数据，包含一个和多个关键帧数据
     */
    var TransformTimeline = (function (_super) {
        __extends(TransformTimeline, _super);
        /**
         * 构造函数，实例化一个TransformTimeline
         */
        function TransformTimeline() {
            _super.call(this);
            this.originTransform = new dragonBones.DBTransform();
            this.originTransform.scaleX = 1;
            this.originTransform.scaleY = 1;
            this.originPivot = new dragonBones.Point();
            this.offset = 0;
        }
        var d = __define,c=TransformTimeline,p=c.prototype;
        /**
         * 释放资源
         */
        p.dispose = function () {
            _super.prototype.dispose.call(this);
            this.originTransform = null;
            this.originPivot = null;
        };
        return TransformTimeline;
    }(dragonBones.Timeline));
    dragonBones.TransformTimeline = TransformTimeline;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var VertexBoneData = (function () {
        function VertexBoneData() {
            this.indices = [];
            this.weights = [];
            this.vertices = [];
        }
        var d = __define,c=VertexBoneData,p=c.prototype;
        return VertexBoneData;
    }());
    dragonBones.VertexBoneData = VertexBoneData;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var VertexData = (function (_super) {
        __extends(VertexData, _super);
        function VertexData() {
            _super.call(this);
            this.u = 0;
            this.v = 0;
        }
        var d = __define,c=VertexData,p=c.prototype;
        return VertexData;
    }(dragonBones.Point));
    dragonBones.VertexData = VertexData;
})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *@class dragonBones.DataParser
     * @classdesc
     * 老版本数据解析
     */
    var Data3Parser = (function () {
        function Data3Parser() {
        }
        var d = __define,c=Data3Parser,p=c.prototype;
        Data3Parser.parseDragonBonesData = function (rawDataToParse) {
            if (!rawDataToParse) {
                throw new Error();
            }
            var version = rawDataToParse[dragonBones.ConstValues.A_VERSION];
            version = version.toString();
            if (version.toString() != dragonBones.DragonBones.DATA_VERSION &&
                version.toString() != dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION &&
                version.toString() != "2.3") {
                throw new Error("Nonsupport version!");
            }
            var frameRate = Data3Parser.getNumber(rawDataToParse, dragonBones.ConstValues.A_FRAME_RATE, 0) || 0;
            var outputDragonBonesData = new dragonBones.DragonBonesData();
            outputDragonBonesData.name = rawDataToParse[dragonBones.ConstValues.A_NAME];
            outputDragonBonesData.isGlobal = rawDataToParse[dragonBones.ConstValues.A_IS_GLOBAL] == "0" ? false : true;
            Data3Parser.tempDragonBonesData = outputDragonBonesData;
            var armatureList = rawDataToParse[dragonBones.ConstValues.ARMATURE];
            for (var i = 0, len = armatureList.length; i < len; i++) {
                var armatureObject = armatureList[i];
                outputDragonBonesData.addArmatureData(Data3Parser.parseArmatureData(armatureObject, frameRate));
            }
            Data3Parser.tempDragonBonesData = null;
            return outputDragonBonesData;
        };
        Data3Parser.parseArmatureData = function (armatureDataToParse, frameRate) {
            var outputArmatureData = new dragonBones.ArmatureData();
            outputArmatureData.name = armatureDataToParse[dragonBones.ConstValues.A_NAME];
            var i;
            var len;
            var boneList = armatureDataToParse[dragonBones.ConstValues.BONE];
            for (i = 0, len = boneList.length; i < len; i++) {
                var boneObject = boneList[i];
                outputArmatureData.addBoneData(Data3Parser.parseBoneData(boneObject));
            }
            var skinList = armatureDataToParse[dragonBones.ConstValues.SKIN];
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinSlotList = skinList[i];
                var skinSlotObject = skinSlotList[dragonBones.ConstValues.SLOT];
                for (var j = 0, jLen = skinSlotObject.length; j < jLen; j++) {
                    var slotObject = skinSlotObject[j];
                    outputArmatureData.addSlotData(Data3Parser.parseSlotData(slotObject));
                }
            }
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinObject = skinList[i];
                outputArmatureData.addSkinData(Data3Parser.parseSkinData(skinObject));
            }
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                dragonBones.DBDataUtil.transformArmatureData(outputArmatureData);
            }
            outputArmatureData.sortBoneDataList();
            var animationList = armatureDataToParse[dragonBones.ConstValues.ANIMATION];
            for (i = 0, len = animationList.length; i < len; i++) {
                var animationObject = animationList[i];
                var animationData = Data3Parser.parseAnimationData(animationObject, frameRate);
                dragonBones.DBDataUtil.addHideTimeline(animationData, outputArmatureData);
                dragonBones.DBDataUtil.transformAnimationData(animationData, outputArmatureData, Data3Parser.tempDragonBonesData.isGlobal);
                outputArmatureData.addAnimationData(animationData);
            }
            return outputArmatureData;
        };
        //把bone的初始transform解析并返回
        Data3Parser.parseBoneData = function (boneObject) {
            var boneData = new dragonBones.BoneData();
            boneData.name = boneObject[dragonBones.ConstValues.A_NAME];
            boneData.parent = boneObject[dragonBones.ConstValues.A_PARENT];
            boneData.length = Number(boneObject[dragonBones.ConstValues.A_LENGTH]) || 0;
            boneData.inheritRotation = Data3Parser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_ROTATION, true);
            boneData.inheritScale = Data3Parser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_SCALE, true);
            Data3Parser.parseTransform(boneObject[dragonBones.ConstValues.TRANSFORM], boneData.transform);
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                boneData.global.copy(boneData.transform);
            }
            return boneData;
        };
        Data3Parser.parseSkinData = function (skinObject) {
            var skinData = new dragonBones.SkinData();
            skinData.name = skinObject[dragonBones.ConstValues.A_NAME];
            var slotList = skinObject[dragonBones.ConstValues.SLOT];
            for (var i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                skinData.addSlotData(Data3Parser.parseSkinSlotData(slotObject));
            }
            return skinData;
        };
        Data3Parser.parseSkinSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = (slotObject[dragonBones.ConstValues.A_Z_ORDER]);
            slotData.zOrder = Data3Parser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            var displayList = slotObject[dragonBones.ConstValues.DISPLAY];
            if (displayList) {
                for (var i = 0, len = displayList.length; i < len; i++) {
                    var displayObject = displayList[i];
                    slotData.addDisplayData(Data3Parser.parseDisplayData(displayObject));
                }
            }
            return slotData;
        };
        Data3Parser.parseSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = (slotObject[dragonBones.ConstValues.A_Z_ORDER]);
            slotData.zOrder = Data3Parser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            slotData.displayIndex = 0;
            return slotData;
        };
        Data3Parser.parseDisplayData = function (displayObject) {
            var displayData = new dragonBones.DisplayData();
            displayData.name = displayObject[dragonBones.ConstValues.A_NAME];
            displayData.type = displayObject[dragonBones.ConstValues.A_TYPE];
            Data3Parser.parseTransform(displayObject[dragonBones.ConstValues.TRANSFORM], displayData.transform, displayData.pivot);
            if (Data3Parser.tempDragonBonesData != null) {
                Data3Parser.tempDragonBonesData.addDisplayData(displayData);
            }
            return displayData;
        };
        /** @private */
        Data3Parser.parseAnimationData = function (animationObject, frameRate) {
            var animationData = new dragonBones.AnimationData();
            animationData.name = animationObject[dragonBones.ConstValues.A_NAME];
            animationData.frameRate = frameRate;
            animationData.duration = Math.round((Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_DURATION, 1) || 1) * 1000 / frameRate);
            animationData.playTimes = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_LOOP, 1);
            animationData.playTimes = animationData.playTimes != NaN ? animationData.playTimes : 1;
            animationData.fadeTime = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_FADE_IN_TIME, 0) || 0;
            animationData.scale = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            //use frame tweenEase, NaN
            //overwrite frame tweenEase, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            animationData.tweenEasing = Data3Parser.getNumber(animationObject, dragonBones.ConstValues.A_TWEEN_EASING, NaN);
            animationData.autoTween = Data3Parser.getBoolean(animationObject, dragonBones.ConstValues.A_AUTO_TWEEN, true);
            Data3Parser._currentAnimationData = animationData;
            var frameObjectList = animationObject[dragonBones.ConstValues.FRAME];
            var i = 0;
            var len = 0;
            if (frameObjectList) {
                for (i = 0, len = frameObjectList.length; i < len; i++) {
                    var frameObject = frameObjectList[i];
                    //var frame:Frame = DataParser.parseTransformFrame(frameObject, frameRate);
                    var frame = new dragonBones.Frame();
                    Data3Parser.parseFrame(frameObject, frame, frameRate);
                    animationData.addFrame(frame);
                }
            }
            Data3Parser.parseTimeline(animationObject, animationData);
            var lastFrameDuration = animationData.duration;
            var displayIndexChangeSlotTimelines = [];
            var displayIndexChangeTimelines = [];
            var timelineObjectList = animationObject[dragonBones.ConstValues.TIMELINE];
            var displayIndexChange;
            if (timelineObjectList) {
                for (i = 0, len = timelineObjectList.length; i < len; i++) {
                    var timelineObject = timelineObjectList[i];
                    var timeline = Data3Parser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                    //timeline = Data3Parser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                    lastFrameDuration = Math.min(lastFrameDuration, timeline.frameList[timeline.frameList.length - 1].duration);
                    animationData.addTimeline(timeline);
                    var slotTimeline = Data3Parser.parseSlotTimeline(timelineObject, animationData.duration, frameRate);
                    animationData.addSlotTimeline(slotTimeline);
                    if (animationData.autoTween && !displayIndexChange) {
                        var slotFrame;
                        for (var j = 0, jlen = slotTimeline.frameList.length; j < jlen; j++) {
                            slotFrame = slotTimeline.frameList[j];
                            if (slotFrame && slotFrame.displayIndex < 0) {
                                displayIndexChange = true;
                                break;
                            }
                        }
                    }
                }
                /**
                 * 如果有slot的displayIndex为空的情况，那么当autoTween为ture时，它对应的bone的补间应该去掉
                 * 以下就是处理这种情况，把autoTween的全局的tween应用到每一帧上，然后把autoTween变为false
                 * 此时autoTween就不起任何作用了
                 */
                var animationTween = animationData.tweenEasing;
                if (displayIndexChange) {
                    len = animationData.slotTimelineList.length;
                    for (i = 0; i < len; i++) {
                        slotTimeline = animationData.slotTimelineList[i];
                        timeline = animationData.timelineList[i];
                        var curFrame;
                        var curSlotFrame;
                        var nextSlotFrame;
                        for (j = 0, jlen = slotTimeline.frameList.length; j < jlen; j++) {
                            curSlotFrame = slotTimeline.frameList[j];
                            curFrame = timeline.frameList[j];
                            nextSlotFrame = (j == jlen - 1) ? slotTimeline.frameList[0] : slotTimeline.frameList[j + 1];
                            if (curSlotFrame.displayIndex < 0 || nextSlotFrame.displayIndex < 0) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = NaN;
                            }
                            else if (animationTween == 10) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = 0;
                            }
                            else if (!isNaN(animationTween)) {
                                curFrame.tweenEasing = curSlotFrame.tweenEasing = animationTween;
                            }
                            else if (curFrame.tweenEasing == 10) {
                                curFrame.tweenEasing = 0;
                            }
                        }
                    }
                    animationData.autoTween = false;
                }
            }
            if (animationData.frameList.length > 0) {
                lastFrameDuration = Math.min(lastFrameDuration, animationData.frameList[animationData.frameList.length - 1].duration);
            }
            //取得timeline中最小的lastFrameDuration并保存
            animationData.lastFrameDuration = lastFrameDuration;
            return animationData;
        };
        Data3Parser.parseSlotTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.SlotTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = Data3Parser.parseSlotFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            Data3Parser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        Data3Parser.parseSlotFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.SlotFrame();
            Data3Parser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.displayIndex = Math.floor(Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            //如果为NaN，则说明没有改变过zOrder
            outputFrame.zOrder = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_Z_ORDER, Data3Parser.tempDragonBonesData.isGlobal ? NaN : 0);
            var colorTransformObject = frameObject[dragonBones.ConstValues.COLOR_TRANSFORM];
            if (colorTransformObject) {
                outputFrame.color = new dragonBones.ColorTransform();
                Data3Parser.parseColorTransform(colorTransformObject, outputFrame.color);
            }
            return outputFrame;
        };
        Data3Parser.parseTransformTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.TransformTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.originPivot.x = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
            outputTimeline.originPivot.y = Data3Parser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
            outputTimeline.duration = duration;
            //
            var clearFrame = false;
            var position = 0;
            var animationFrame = null;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            var nextFrameObject;
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                if (i < len - 1) {
                    nextFrameObject = frameList[i + 1];
                }
                else if (i != 0) {
                    nextFrameObject = frameList[0];
                }
                else {
                    nextFrameObject = null;
                }
                var frame = Data3Parser.parseTransformFrame(frameObject, nextFrameObject, frameRate);
                outputTimeline.addFrame(frame);
                if (frame.event || frame.sound) {
                    if (!clearFrame) {
                        clearFrame = true;
                        Data3Parser._currentAnimationData.frameList.length = 0;
                    }
                    if (animationFrame) {
                        animationFrame.duration = position;
                    }
                    else if (position != 0) {
                        animationFrame = new dragonBones.Frame();
                        animationFrame.bone = outputTimeline.name;
                        animationFrame.duration = position;
                        Data3Parser._currentAnimationData.addFrame(animationFrame);
                    }
                    position = 0;
                    animationFrame = new dragonBones.Frame();
                    animationFrame.bone = outputTimeline.name;
                    Data3Parser.parseFrame(frameObject, animationFrame, frameRate);
                    Data3Parser._currentAnimationData.addFrame(animationFrame);
                }
                position += frame.duration;
            }
            Data3Parser.parseTimeline(timelineObject, outputTimeline);
            if (animationFrame) {
                //animationFrame.duration = position;
                Data3Parser.parseTimeline(null, Data3Parser._currentAnimationData);
            }
            return outputTimeline;
        };
        Data3Parser.parseTransformFrame = function (frameObject, nextFrameObject, frameRate) {
            var outputFrame = new dragonBones.TransformFrame();
            Data3Parser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.tweenRotate = Math.floor(Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_ROTATE, 0) || 0);
            outputFrame.tweenScale = Data3Parser.getBoolean(frameObject, dragonBones.ConstValues.A_TWEEN_SCALE, true);
            //outputFrame.displayIndex = Math.floor(Data3Parser.getNumber(frameObject, ConstValues.A_DISPLAY_INDEX, 0)|| 0);
            if (nextFrameObject && Math.floor(Data3Parser.getNumber(nextFrameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0) == -1) {
                outputFrame.tweenEasing = NaN;
            }
            Data3Parser.parseTransform(frameObject[dragonBones.ConstValues.TRANSFORM], outputFrame.transform, outputFrame.pivot);
            if (Data3Parser.tempDragonBonesData.isGlobal) {
                outputFrame.global.copy(outputFrame.transform);
            }
            outputFrame.scaleOffset.x = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_X_OFFSET, 0) || 0;
            outputFrame.scaleOffset.y = Data3Parser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_Y_OFFSET, 0) || 0;
            return outputFrame;
        };
        Data3Parser.parseTimeline = function (timelineObject, outputTimeline) {
            var position = 0;
            var frame;
            var frameList = outputTimeline.frameList;
            for (var i = 0, len = frameList.length; i < len; i++) {
                frame = frameList[i];
                frame.position = position;
                position += frame.duration;
            }
            //防止duration计算有误差
            if (frame) {
                frame.duration = outputTimeline.duration - frame.position;
            }
        };
        Data3Parser.parseFrame = function (frameObject, outputFrame, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            outputFrame.duration = Math.round(((frameObject[dragonBones.ConstValues.A_DURATION]) || 1) * 1000 / frameRate);
            outputFrame.action = frameObject[dragonBones.ConstValues.A_ACTION];
            outputFrame.event = frameObject[dragonBones.ConstValues.A_EVENT];
            outputFrame.sound = frameObject[dragonBones.ConstValues.A_SOUND];
        };
        Data3Parser.parseTransform = function (transformObject, transform, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (transformObject) {
                if (transform) {
                    transform.x = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_X, 0) || 0;
                    transform.y = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_Y, 0) || 0;
                    transform.skewX = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_X, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.skewY = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_Y, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.scaleX = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_X, 1) || 0;
                    transform.scaleY = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_Y, 1) || 0;
                }
                if (pivot) {
                    pivot.x = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
                    pivot.y = Data3Parser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
                }
            }
        };
        Data3Parser.parseColorTransform = function (colorTransformObject, colorTransform) {
            if (colorTransformObject) {
                if (colorTransform) {
                    colorTransform.alphaOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_OFFSET, 0);
                    colorTransform.redOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_OFFSET, 0);
                    colorTransform.greenOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_OFFSET, 0);
                    colorTransform.blueOffset = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_OFFSET, 0);
                    colorTransform.alphaMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_MULTIPLIER, 100) * 0.01;
                    colorTransform.redMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_MULTIPLIER, 100) * 0.01;
                    colorTransform.greenMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_MULTIPLIER, 100) * 0.01;
                    colorTransform.blueMultiplier = Data3Parser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_MULTIPLIER, 100) * 0.01;
                }
            }
        };
        Data3Parser.getBoolean = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "0":
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return false;
                    case "1":
                    case "true":
                    default:
                        return true;
                }
            }
            return defaultValue;
        };
        Data3Parser.getNumber = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return NaN;
                    default:
                        return Number(data[key]);
                }
            }
            return defaultValue;
        };
        Data3Parser._currentAnimationData = null;
        return Data3Parser;
    }());
    dragonBones.Data3Parser = Data3Parser;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     *@class dragonBones.DataParser
     * @classdesc
     * 数据解析
     *
     * @example
       <pre>
         //获取动画数据
         var skeletonData = RES.getRes("skeleton");
         //获取纹理集数据
         var textureData = RES.getRes("textureConfig");
         //获取纹理集图片
         var texture = RES.getRes("texture");

         //创建一个工厂，用来创建Armature
         var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
         //把动画数据添加到工厂里
         factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
         //把纹理集数据和图片添加到工厂里
         factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
         //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
         var armatureName:string = skeletonData.armature[0].name;
         //从工厂里创建出Armature
         var armature:dragonBones.Armature = factory.buildArmature(armatureName);
         //获取装载Armature的容器
         var armatureDisplay = armature.display;
         //把它添加到舞台上
         this.addChild(armatureDisplay);
         //取得这个Armature动画列表中的第一个动画的名字
         var curAnimationName = armature.animation.animationList[0];
         //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
         //第一个参数 animationName {string} 指定播放动画的名称.
         //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
         //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
         //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
         armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);

         //把Armature添加到心跳时钟里
         dragonBones.WorldClock.clock.add(armature);
         //心跳时钟开启
         egret.Ticker.getInstance().register(function (advancedTime) {
             dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
         }, this);
       </pre>
     */
    var DataParser = (function () {
        function DataParser() {
        }
        var d = __define,c=DataParser,p=c.prototype;
        /**
         *解析纹理集数据
         * @param rawData纹理集数据xml或者json
         * @param scale纹理资源的缩放，默认为1，不缩放
         * @returns {any}返回纹理集数据，存放TexutrueData的字典类型
         */
        DataParser.parseTextureAtlasData = function (rawData, scale) {
            if (scale === void 0) { scale = 1; }
            var textureAtlasData = {};
            var subTextureFrame;
            var subTextureList = rawData[dragonBones.ConstValues.SUB_TEXTURE];
            for (var i = 0, len = subTextureList.length; i < len; i++) {
                var subTextureObject = subTextureList[i];
                var subTextureName = subTextureObject[dragonBones.ConstValues.A_NAME];
                var subTextureRegion = new dragonBones.Rectangle();
                subTextureRegion.x = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_X, 0) / scale;
                subTextureRegion.y = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_Y, 0) / scale;
                subTextureRegion.width = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_WIDTH, 0) / scale;
                subTextureRegion.height = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_HEIGHT, 0) / scale;
                var rotated = subTextureObject[dragonBones.ConstValues.A_ROTATED] == "true";
                var frameWidth = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_WIDTH, 0) / scale;
                var frameHeight = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_HEIGHT, 0) / scale;
                if (frameWidth > 0 && frameHeight > 0) {
                    subTextureFrame = new dragonBones.Rectangle();
                    subTextureFrame.x = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_X, 0) / scale;
                    subTextureFrame.y = DataParser.getNumber(subTextureObject, dragonBones.ConstValues.A_FRAME_Y, 0) / scale;
                    subTextureFrame.width = frameWidth;
                    subTextureFrame.height = frameHeight;
                }
                else {
                    subTextureFrame = null;
                }
                textureAtlasData[subTextureName] = new dragonBones.TextureData(subTextureRegion, subTextureFrame, rotated);
            }
            return textureAtlasData;
        };
        /**
         * 解析DragonBones的数据，xml或者json，该数据包含了骨骼，皮肤，动画的数据
         * @param rawDataToParse DragonBones的数据，xml或者json格式
         * @returns {DragonBonesData} 返回DragonBones引擎使用的数据格式
         */
        DataParser.parseDragonBonesData = function (rawDataToParse) {
            if (!rawDataToParse) {
                throw new Error();
            }
            var version = rawDataToParse[dragonBones.ConstValues.A_VERSION];
            version = version.toString();
            if (version.toString() != dragonBones.DragonBones.DATA_VERSION &&
                version.toString() != dragonBones.DragonBones.DATA_VERSION_4_5 &&
                version.toString() != dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION &&
                version.toString() != "2.3") {
                throw new Error(egret.getString(4003));
            }
            else if (version.toString() == dragonBones.DragonBones.PARENT_COORDINATE_DATA_VERSION ||
                version.toString() == "2.3") {
                return dragonBones.Data3Parser.parseDragonBonesData(rawDataToParse);
            }
            var frameRate = DataParser.getNumber(rawDataToParse, dragonBones.ConstValues.A_FRAME_RATE, 0) || 0;
            var outputDragonBonesData = new dragonBones.DragonBonesData();
            outputDragonBonesData.name = rawDataToParse[dragonBones.ConstValues.A_NAME];
            outputDragonBonesData.isGlobal = rawDataToParse[dragonBones.ConstValues.A_IS_GLOBAL] == "0" ? false : true;
            outputDragonBonesData.version = parseFloat(version);
            DataParser.tempDragonBonesData = outputDragonBonesData;
            var armatureList = rawDataToParse[dragonBones.ConstValues.ARMATURE];
            for (var i = 0, len = armatureList.length; i < len; i++) {
                var armatureObject = armatureList[i];
                outputDragonBonesData.addArmatureData(DataParser.parseArmatureData(armatureObject, frameRate));
            }
            DataParser.tempDragonBonesData = null;
            return outputDragonBonesData;
        };
        DataParser.parseArmatureData = function (armatureDataToParse, frameRate) {
            var outputArmatureData = new dragonBones.ArmatureData();
            outputArmatureData.name = armatureDataToParse[dragonBones.ConstValues.A_NAME];
            DataParser._armatureData = outputArmatureData;
            var actions = armatureDataToParse[dragonBones.ConstValues.A_DEFAULT_ACTIONS];
            if (actions && actions.length == 1) {
                outputArmatureData.defaultAnimation = actions[0][dragonBones.ConstValues.A_GOTOANDPLAY];
            }
            outputArmatureData.frameRate = armatureDataToParse[dragonBones.ConstValues.A_FRAME_RATE];
            if (isNaN(outputArmatureData.frameRate) || outputArmatureData.frameRate <= 0) {
                outputArmatureData.frameRate = frameRate;
            }
            frameRate = outputArmatureData.frameRate;
            var boneList = armatureDataToParse[dragonBones.ConstValues.BONE];
            var i;
            var len;
            DataParser._rawBones.length = 0;
            for (i = 0, len = boneList.length; i < len; i++) {
                var boneObject = boneList[i];
                outputArmatureData.addBoneData(DataParser.parseBoneData(boneObject));
            }
            var ikList = armatureDataToParse[dragonBones.ConstValues.IK];
            if (ikList) {
                for (i = 0, len = ikList.length; i < len; i++) {
                    var ikObject = ikList[i];
                    outputArmatureData.addIKData(DataParser.parseIKData(ikObject));
                }
            }
            outputArmatureData.sortBoneDataList();
            var slotList = armatureDataToParse[dragonBones.ConstValues.SLOT];
            for (i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                outputArmatureData.addSlotData(DataParser.parseSlotData(slotObject));
            }
            var skinList = armatureDataToParse[dragonBones.ConstValues.SKIN];
            for (i = 0, len = skinList.length; i < len; i++) {
                var skinObject = skinList[i];
                outputArmatureData.addSkinData(DataParser.parseSkinData(skinObject));
            }
            if (DataParser.tempDragonBonesData.isGlobal) {
                dragonBones.DBDataUtil.transformArmatureData(outputArmatureData);
            }
            var animationList = armatureDataToParse[dragonBones.ConstValues.ANIMATION];
            for (i = 0, len = animationList.length; i < len; i++) {
                var animationObject = animationList[i];
                var animationData = DataParser.parseAnimationData(animationObject, frameRate);
                dragonBones.DBDataUtil.addHideTimeline(animationData, outputArmatureData, true);
                dragonBones.DBDataUtil.transformAnimationData(animationData, outputArmatureData, DataParser.tempDragonBonesData.isGlobal);
                outputArmatureData.addAnimationData(animationData);
            }
            return outputArmatureData;
        };
        //把bone的初始transform解析并返回
        DataParser.parseBoneData = function (boneObject) {
            var boneData = new dragonBones.BoneData();
            DataParser._rawBones.push(boneData);
            boneData.name = boneObject[dragonBones.ConstValues.A_NAME];
            boneData.parent = boneObject[dragonBones.ConstValues.A_PARENT];
            boneData.length = Number(boneObject[dragonBones.ConstValues.A_LENGTH]) || 0;
            boneData.inheritRotation = DataParser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_ROTATION, true);
            boneData.inheritScale = DataParser.getBoolean(boneObject, dragonBones.ConstValues.A_INHERIT_SCALE, true);
            DataParser.parseTransform(boneObject[dragonBones.ConstValues.TRANSFORM], boneData.transform);
            if (DataParser.tempDragonBonesData.isGlobal) {
                boneData.global.copy(boneData.transform);
            }
            return boneData;
        };
        DataParser.parseIKData = function (ikObject) {
            var ikData = new dragonBones.IKData();
            ikData.name = ikObject[dragonBones.ConstValues.A_NAME];
            ikData.target = ikObject[dragonBones.ConstValues.A_TARGET];
            if (ikObject.hasOwnProperty(dragonBones.ConstValues.A_WEIGHT)) {
                ikData.weight = Number(ikObject[dragonBones.ConstValues.A_WEIGHT]);
            }
            else {
                ikData.weight = 1;
            }
            ikData.bendPositive = DataParser.getBoolean(ikObject, dragonBones.ConstValues.A_BENDPOSITIVE, true);
            if (ikObject.hasOwnProperty(dragonBones.ConstValues.A_CHAIN)) {
                ikData.chain = ikObject[dragonBones.ConstValues.A_CHAIN];
            }
            else {
                ikData.chain = 0;
            }
            ikData.bones = ikObject[dragonBones.ConstValues.A_BONES];
            return ikData;
        };
        DataParser.parseSkinData = function (skinObject) {
            var skinData = new dragonBones.SkinData();
            DataParser._skinData = skinData;
            skinData.name = skinObject[dragonBones.ConstValues.A_NAME];
            var slotList = skinObject[dragonBones.ConstValues.SLOT];
            for (var i = 0, len = slotList.length; i < len; i++) {
                var slotObject = slotList[i];
                skinData.addSlotData(DataParser.parseSlotDisplayData(slotObject));
            }
            return skinData;
        };
        DataParser.parseSlotData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            var actions = slotObject[dragonBones.ConstValues.A_ACTIONS];
            if (actions && actions.length == 1) {
                slotData.gotoAndPlay = actions[0][dragonBones.ConstValues.A_GOTOANDPLAY];
            }
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            slotData.displayIndex = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0);
            slotData.blendMode = slotObject[dragonBones.ConstValues.A_BLENDMODE];
            return slotData;
        };
        DataParser.parseSlotDisplayData = function (slotObject) {
            var slotData = new dragonBones.SlotData();
            slotData.name = slotObject[dragonBones.ConstValues.A_NAME];
            slotData.parent = slotObject[dragonBones.ConstValues.A_PARENT];
            slotData.zOrder = DataParser.getNumber(slotObject, dragonBones.ConstValues.A_Z_ORDER, 0) || 0;
            DataParser._skinSlotData = slotData;
            DataParser._displayIndex = 0;
            var displayList = slotObject[dragonBones.ConstValues.DISPLAY];
            if (displayList) {
                for (var i = 0, len = displayList.length; i < len; i++) {
                    var displayObject = displayList[i];
                    slotData.addDisplayData(DataParser.parseDisplayData(displayObject));
                    DataParser._displayIndex++;
                }
            }
            return slotData;
        };
        DataParser.parseDisplayData = function (displayObject) {
            var displayData = new dragonBones.DisplayData();
            if (displayObject[dragonBones.ConstValues.A_TYPE] == "mesh") {
                displayData = DataParser.parseMeshData(displayObject);
            }
            else {
                displayData.name = displayObject[dragonBones.ConstValues.A_NAME];
                displayData.type = displayObject[dragonBones.ConstValues.A_TYPE];
                DataParser.parseTransform(displayObject[dragonBones.ConstValues.TRANSFORM], displayData.transform, displayData.pivot);
                displayData.pivot.x = NaN;
                displayData.pivot.y = NaN;
                if (DataParser.tempDragonBonesData != null) {
                    DataParser.tempDragonBonesData.addDisplayData(displayData);
                }
            }
            return displayData;
        };
        DataParser.parseMeshData = function (meshObject) {
            var meshData = new dragonBones.MeshData();
            meshData.name = meshObject[dragonBones.ConstValues.A_NAME];
            meshData.type = meshObject[dragonBones.ConstValues.A_TYPE];
            DataParser.parseTransform(meshObject[dragonBones.ConstValues.TRANSFORM], meshData.transform, meshData.pivot);
            meshData.pivot.x = NaN;
            meshData.pivot.y = NaN;
            var rawUVs = meshObject.uvs;
            var rawTriangles = meshObject.triangles;
            var rawWeights = meshObject.weights;
            var rawVertices = meshObject.vertices;
            var rawBonePose = meshObject.bonePose;
            if (meshObject.slotPose) {
                meshData.slotPose.a = meshObject.slotPose[0];
                meshData.slotPose.b = meshObject.slotPose[1];
                meshData.slotPose.c = meshObject.slotPose[2];
                meshData.slotPose.d = meshObject.slotPose[3];
                meshData.slotPose.tx = meshObject.slotPose[4];
                meshData.slotPose.ty = meshObject.slotPose[5];
            }
            meshData.skinned = rawWeights && rawWeights.length > 0;
            meshData.numVertex = rawUVs.length / 2;
            meshData.numTriangle = rawTriangles.length / 3;
            meshData.vertices.length = meshData.numVertex;
            meshData.triangles.length = meshData.numTriangle * 3;
            var l = 0;
            var i = 0;
            var iW = 0;
            var boneIndex = 0;
            var boneMatrix = null;
            var boneData = null;
            var inverseBindPose = []; // _armatureData.boneDataList.length
            DataParser._skinData.hasMesh = true;
            if (meshData.skinned) {
                meshData.vertexBones.length = meshData.numVertex;
                if (rawBonePose) {
                    for (i = 0, l = rawBonePose.length; i < l; i += 7) {
                        boneIndex = DataParser._armatureData.boneDataList.indexOf(DataParser._rawBones[rawBonePose[i]]);
                        boneMatrix = new dragonBones.Matrix();
                        boneMatrix.a = rawBonePose[i + 1];
                        boneMatrix.b = rawBonePose[i + 2];
                        boneMatrix.c = rawBonePose[i + 3];
                        boneMatrix.d = rawBonePose[i + 4];
                        boneMatrix.tx = rawBonePose[i + 5];
                        boneMatrix.ty = rawBonePose[i + 6];
                        boneMatrix.invert();
                        inverseBindPose[boneIndex] = boneMatrix;
                    }
                }
            }
            for (i = 0, l = rawUVs.length; i < l; i += 2) {
                var iN = i + 1;
                var vertexIndex = i * 0.5;
                var vertexData = meshData.vertices[vertexIndex] = new dragonBones.VertexData();
                vertexData.u = Number(rawUVs[i]);
                vertexData.v = Number(rawUVs[iN]);
                vertexData.x = Number(rawVertices[i]);
                vertexData.y = Number(rawVertices[iN]);
                if (meshData.skinned) {
                    var vertexBoneData = meshData.vertexBones[vertexIndex] = new dragonBones.VertexBoneData();
                    meshData.slotPose.transformPoint(vertexData.x, vertexData.y, vertexData);
                    for (var j = iW + 1, lJ = iW + 1 + rawWeights[iW] * 2; j < lJ; j += 2) {
                        boneData = DataParser._rawBones[rawWeights[j]];
                        boneIndex = meshData.bones.indexOf(boneData);
                        if (boneIndex < 0) {
                            boneIndex = meshData.bones.length;
                            meshData.bones[boneIndex] = boneData;
                        }
                        var vertexBonePoint = new dragonBones.Point(vertexData.x, vertexData.y);
                        vertexBoneData.indices.push(boneIndex);
                        vertexBoneData.weights.push(rawWeights[j + 1]);
                        vertexBoneData.vertices.push(vertexBonePoint);
                        if (meshData.inverseBindPose.length <= boneIndex) {
                            meshData.inverseBindPose.length = boneIndex + 1;
                        }
                        boneMatrix = meshData.inverseBindPose[boneIndex];
                        if (!boneMatrix) {
                            boneMatrix = inverseBindPose[DataParser._armatureData.boneDataList.indexOf(boneData)];
                            meshData.inverseBindPose[boneIndex] = boneMatrix;
                        }
                        if (boneMatrix) {
                            boneMatrix.transformPoint(vertexBonePoint.x, vertexBonePoint.y, vertexBonePoint);
                        }
                        iW = j + 2;
                    }
                }
            }
            for (i = 0, l = rawTriangles.length; i < l; ++i) {
                meshData.triangles[i] = rawTriangles[i];
            }
            return meshData;
        };
        /** @private */
        DataParser.parseAnimationData = function (animationObject, frameRate) {
            var animationData = new dragonBones.AnimationData();
            animationData.name = animationObject[dragonBones.ConstValues.A_NAME];
            animationData.frameRate = frameRate;
            animationData.duration = Math.ceil((DataParser.getNumber(animationObject, dragonBones.ConstValues.A_DURATION, 1) || 1) * 1000 / frameRate);
            animationData.playTimes = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_PLAY_TIMES, 1);
            animationData.playTimes = animationData.playTimes != NaN ? animationData.playTimes : 1;
            animationData.fadeTime = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_FADE_IN_TIME, 0) || 0;
            animationData.scale = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            //use frame tweenEase, NaN
            //overwrite frame tweenEase, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            animationData.tweenEasing = DataParser.getNumber(animationObject, dragonBones.ConstValues.A_TWEEN_EASING, NaN);
            animationData.autoTween = DataParser.getBoolean(animationObject, dragonBones.ConstValues.A_AUTO_TWEEN, true);
            var frameObjectList = animationObject[dragonBones.ConstValues.FRAME];
            var i = 0;
            var len = 0;
            if (frameObjectList) {
                for (i = 0, len = frameObjectList.length; i < len; i++) {
                    var frameObject = frameObjectList[i];
                    var frame = DataParser.parseTransformFrame(frameObject, frameRate);
                    animationData.addFrame(frame);
                }
            }
            DataParser.parseTimeline(animationObject, animationData);
            var lastFrameDuration = animationData.duration;
            var timelineObjectList = animationObject[dragonBones.ConstValues.BONE];
            if (timelineObjectList) {
                for (i = 0, len = timelineObjectList.length; i < len; i++) {
                    var timelineObject = timelineObjectList[i];
                    if (timelineObject) {
                        var timeline = DataParser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                        if (timeline.frameList.length > 0) {
                            lastFrameDuration = Math.min(lastFrameDuration, timeline.frameList[timeline.frameList.length - 1].duration);
                        }
                        animationData.addTimeline(timeline);
                    }
                }
            }
            var slotTimelineObjectList = animationObject[dragonBones.ConstValues.SLOT];
            if (slotTimelineObjectList) {
                for (i = 0, len = slotTimelineObjectList.length; i < len; i++) {
                    var slotTimelineObject = slotTimelineObjectList[i];
                    if (slotTimelineObject) {
                        var slotTimeline = DataParser.parseSlotTimeline(slotTimelineObject, animationData.duration, frameRate);
                        if (slotTimeline.frameList.length > 0) {
                            lastFrameDuration = Math.min(lastFrameDuration, slotTimeline.frameList[slotTimeline.frameList.length - 1].duration);
                            animationData.addSlotTimeline(slotTimeline);
                        }
                    }
                }
            }
            var ffdTimelineObjectList = animationObject["ffd"];
            if (ffdTimelineObjectList) {
                for (i = 0, len = ffdTimelineObjectList.length; i < len; i++) {
                    var ffdTimelineObject = ffdTimelineObjectList[i];
                    if (ffdTimelineObject) {
                        var ffdTimeline = DataParser.parseFFDTimeline(ffdTimelineObject, animationData.duration, frameRate);
                        if (ffdTimeline.frameList.length > 0) {
                            lastFrameDuration = Math.min(lastFrameDuration, ffdTimeline.frameList[ffdTimeline.frameList.length - 1].duration);
                            animationData.addFFDTimeline(ffdTimeline);
                        }
                    }
                }
            }
            if (animationData.frameList.length > 0) {
                lastFrameDuration = Math.min(lastFrameDuration, animationData.frameList[animationData.frameList.length - 1].duration);
            }
            //取得timeline中最小的lastFrameDuration并保存
            animationData.lastFrameDuration = lastFrameDuration;
            return animationData;
        };
        DataParser.parseTransformTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.TransformTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.originPivot.x = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
            outputTimeline.originPivot.y = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = DataParser.parseTransformFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            DataParser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        DataParser.parseSlotTimeline = function (timelineObject, duration, frameRate) {
            var outputTimeline = new dragonBones.SlotTimeline();
            outputTimeline.name = timelineObject[dragonBones.ConstValues.A_NAME];
            outputTimeline.scale = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            outputTimeline.offset = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            outputTimeline.duration = duration;
            var frameList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameList.length; i < len; i++) {
                var frameObject = frameList[i];
                var frame = DataParser.parseSlotFrame(frameObject, frameRate);
                outputTimeline.addFrame(frame);
            }
            DataParser.parseTimeline(timelineObject, outputTimeline);
            return outputTimeline;
        };
        DataParser.parseFFDTimeline = function (timelineObject, duration, frameRate) {
            var timeline = new dragonBones.FFDTimeline();
            timeline.skin = timelineObject[dragonBones.ConstValues.SKIN];
            timeline.name = timelineObject[dragonBones.ConstValues.SLOT]; // timelineObject[ConstValues.A_NAME];
            var skinData = DataParser._armatureData.getSkinData(timeline.skin);
            var slotData = skinData.getSlotData(timeline.name);
            var meshData = slotData.getDisplayData(timelineObject[dragonBones.ConstValues.A_NAME]);
            timeline.displayIndex = slotData.displayDataList.indexOf(meshData); // timelineObject[ConstValues.A_DISPLAY_INDEX];
            timeline.scale = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_SCALE, 1) || 0;
            timeline.offset = DataParser.getNumber(timelineObject, dragonBones.ConstValues.A_OFFSET, 0) || 0;
            timeline.duration = duration;
            var helpPoint = new dragonBones.Point();
            var helpPointB = new dragonBones.Point();
            var frameObjectList = timelineObject[dragonBones.ConstValues.FRAME];
            for (var i = 0, len = frameObjectList.length; i < len; i++) {
                var frameObject = frameObjectList[i];
                var frame = DataParser.parseFFDFrame(frameObject, frameRate);
                if (meshData.skinned) {
                    var vertices = [];
                    for (var iF = 0, lF = meshData.vertices.length; iF < lF; ++iF) {
                        var vertexBoneData = meshData.vertexBones[iF];
                        if (iF * 2 < frame.offset || iF * 2 - frame.offset >= frame.vertices.length) {
                            meshData.slotPose.transformPoint(0, 0, helpPoint, true);
                        }
                        else {
                            meshData.slotPose.transformPoint(frame.vertices[iF * 2 - frame.offset], frame.vertices[iF * 2 + 1 - frame.offset], helpPoint, true);
                        }
                        for (var iB = 0, lB = vertexBoneData.indices.length; iB < lB; ++iB) {
                            var boneIndex = vertexBoneData.indices[iB];
                            meshData.inverseBindPose[boneIndex].transformPoint(helpPoint.x, helpPoint.y, helpPointB, true);
                            vertices.push(helpPointB.x, helpPointB.y);
                        }
                    }
                    frame.offset = 0;
                    frame.vertices = vertices;
                }
                timeline.addFrame(frame);
            }
            DataParser.parseTimeline(timelineObject, timeline);
            return timeline;
        };
        DataParser.parseTransformFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.TransformFrame();
            DataParser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.tweenRotate = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_ROTATE, 0) || 0);
            outputFrame.tweenScale = DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_TWEEN_SCALE, true);
            outputFrame.displayIndex = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            DataParser.parseTransform(frameObject[dragonBones.ConstValues.TRANSFORM], outputFrame.transform, outputFrame.pivot);
            if (DataParser.tempDragonBonesData.isGlobal) {
                outputFrame.global.copy(outputFrame.transform);
            }
            outputFrame.scaleOffset.x = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_X_OFFSET, 0) || 0;
            outputFrame.scaleOffset.y = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_SCALE_Y_OFFSET, 0) || 0;
            return outputFrame;
        };
        DataParser.parseSlotFrame = function (frameObject, frameRate) {
            var outputFrame = new dragonBones.SlotFrame();
            DataParser.parseFrame(frameObject, outputFrame, frameRate);
            outputFrame.visible = !DataParser.getBoolean(frameObject, dragonBones.ConstValues.A_HIDE, false);
            //NaN:no tween, 10:auto tween, [-1, 0):ease in, 0:line easing, (0, 1]:ease out, (1, 2]:ease in out
            outputFrame.tweenEasing = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            outputFrame.displayIndex = Math.floor(DataParser.getNumber(frameObject, dragonBones.ConstValues.A_DISPLAY_INDEX, 0) || 0);
            var actions = frameObject[dragonBones.ConstValues.A_ACTIONS];
            if (actions && actions.length == 1) {
                outputFrame.gotoAndPlay = actions[0][dragonBones.ConstValues.A_GOTOANDPLAY];
            }
            //如果为NaN，则说明没有改变过zOrder
            outputFrame.zOrder = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_Z_ORDER, DataParser.tempDragonBonesData.isGlobal ? NaN : 0);
            var colorTransformObject = frameObject[dragonBones.ConstValues.COLOR];
            if (colorTransformObject) {
                outputFrame.color = new dragonBones.ColorTransform();
                DataParser.parseColorTransform(colorTransformObject, outputFrame.color);
            }
            return outputFrame;
        };
        DataParser.parseFFDFrame = function (frameObject, frameRate) {
            var frame = new dragonBones.FFDFrame();
            DataParser.parseFrame(frameObject, frame, frameRate);
            frame.tweenEasing = DataParser.getNumber(frameObject, dragonBones.ConstValues.A_TWEEN_EASING, 10);
            frame.offset = frameObject[dragonBones.ConstValues.A_OFFSET] || 0;
            var arr = frameObject.vertices;
            var vertices = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    vertices.push(Number(arr[i]));
                }
            }
            frame.vertices = vertices;
            return frame;
        };
        DataParser.parseTimeline = function (timelineObject, outputTimeline) {
            var position = 0;
            var frame;
            var frameList = outputTimeline.frameList;
            for (var i = 0, len = frameList.length; i < len; i++) {
                frame = frameList[i];
                frame.position = position;
                position += frame.duration;
            }
            //防止duration计算有误差
            if (frame) {
                frame.duration = outputTimeline.duration - frame.position;
            }
        };
        DataParser.parseFrame = function (frameObject, outputFrame, frameRate) {
            if (frameRate === void 0) { frameRate = 0; }
            outputFrame.duration = Math.round(((frameObject[dragonBones.ConstValues.A_DURATION]) || 1) * 1000 / frameRate);
            outputFrame.action = frameObject[dragonBones.ConstValues.A_ACTION];
            outputFrame.event = frameObject[dragonBones.ConstValues.A_EVENT];
            outputFrame.sound = frameObject[dragonBones.ConstValues.A_SOUND];
            var curve = frameObject[dragonBones.ConstValues.A_CURVE];
            if (curve != null && curve.length == 4) {
                outputFrame.curve = new dragonBones.CurveData();
                outputFrame.curve.pointList = [new dragonBones.Point(curve[0], curve[1]),
                    new dragonBones.Point(curve[2], curve[3])];
            }
        };
        DataParser.parseTransform = function (transformObject, transform, pivot) {
            if (pivot === void 0) { pivot = null; }
            if (transformObject) {
                if (transform) {
                    transform.x = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_X, 0) || 0;
                    transform.y = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_Y, 0) || 0;
                    transform.skewX = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_X, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.skewY = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SKEW_Y, 0) * dragonBones.ConstValues.ANGLE_TO_RADIAN || 0;
                    transform.scaleX = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_X, 1) || 0;
                    transform.scaleY = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_SCALE_Y, 1) || 0;
                }
                if (pivot) {
                    pivot.x = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_X, 0) || 0;
                    pivot.y = DataParser.getNumber(transformObject, dragonBones.ConstValues.A_PIVOT_Y, 0) || 0;
                }
            }
        };
        DataParser.parseColorTransform = function (colorTransformObject, colorTransform) {
            if (colorTransform) {
                colorTransform.alphaOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_OFFSET, 0);
                colorTransform.redOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_OFFSET, 0);
                colorTransform.greenOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_OFFSET, 0);
                colorTransform.blueOffset = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_OFFSET, 0);
                colorTransform.alphaMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_ALPHA_MULTIPLIER, 100) * 0.01;
                colorTransform.redMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_RED_MULTIPLIER, 100) * 0.01;
                colorTransform.greenMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_GREEN_MULTIPLIER, 100) * 0.01;
                colorTransform.blueMultiplier = DataParser.getNumber(colorTransformObject, dragonBones.ConstValues.A_BLUE_MULTIPLIER, 100) * 0.01;
            }
        };
        DataParser.getBoolean = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "0":
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return false;
                    case "1":
                    case "true":
                    default:
                        return true;
                }
            }
            return defaultValue;
        };
        DataParser.getNumber = function (data, key, defaultValue) {
            if (data && key in data) {
                switch (String(data[key])) {
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                        return NaN;
                    default:
                        return Number(data[key]);
                }
            }
            return defaultValue;
        };
        DataParser._rawBones = [];
        DataParser._armatureData = null;
        DataParser._skinData = null;
        DataParser._skinSlotData = null;
        DataParser._meshData = null;
        DataParser._displayIndex = 0;
        return DataParser;
    }());
    dragonBones.DataParser = DataParser;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TextureData
     * @classdesc
     * 纹理数据
     *
     * @example
     * <pre>
     *   //获取动画数据
     *   var skeletonData = RES.getRes("skeleton");
     *   //获取纹理集数据
     *   var textureData = RES.getRes("textureConfig");
     *   //获取纹理集图片
     *   var texture = RES.getRes("texture");
     *
     *   //创建一个工厂，用来创建Armature
     *   var factory:dragonBones.EgretFactory = new dragonBones.EgretFactory();
     *   //把动画数据添加到工厂里
     *   factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
     *   //把纹理集数据和图片添加到工厂里
     *   factory.addTextureAtlas(new dragonBones.EgretTextureAtlas(texture, textureData));
     *   //获取Armature的名字，dragonBones4.0的数据可以包含多个骨架，这里取第一个Armature
     *   var armatureName:string = skeletonData.armature[0].name;
     *   //从工厂里创建出Armature
     *   var armature:dragonBones.Armature = factory.buildArmature(armatureName);
     *   //获取装载Armature的容器
     *   var armatureDisplay = armature.display;
     *   //把它添加到舞台上
     *   this.addChild(armatureDisplay);
     *   //取得这个Armature动画列表中的第一个动画的名字
     *   var curAnimationName = armature.animation.animationList[0];
     *   //播放这个动画，gotoAndPlay参数说明,具体详见Animation类
     *   //第一个参数 animationName {string} 指定播放动画的名称.
     *   //第二个参数 fadeInTime {number} 动画淡入时间 (>= 0), 默认值：-1 意味着使用动画数据中的淡入时间.
     *   //第三个参数 duration {number} 动画播放时间。默认值：-1 意味着使用动画数据中的播放时间.
     *   //第四个参数 layTimes {number} 动画播放次数(0:循环播放, >=1:播放次数, NaN:使用动画数据中的播放时间), 默认值：NaN
     *   armature.animation.gotoAndPlay(curAnimationName,0.3,-1,0);
     *
     *   //把Armature添加到心跳时钟里
     *   dragonBones.WorldClock.clock.add(armature);
     *   //心跳时钟开启
     *   egret.Ticker.getInstance().register(function (advancedTime) {
     *       dragonBones.WorldClock.clock.advanceTime(advancedTime / 1000);
     *   }, this);
     * </pre>
     */
    var TextureData = (function () {
        /**
         *创建一个 TextureData 实例
         * @param region 区域
         * @param frame 帧的区域
         * @param rotated
         */
        function TextureData(region, frame, rotated) {
            this.region = region;
            this.frame = frame;
            this.rotated = rotated;
        }
        var d = __define,c=TextureData,p=c.prototype;
        return TextureData;
    }());
    dragonBones.TextureData = TextureData;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    var ColorTransformUtil = (function () {
        function ColorTransformUtil() {
        }
        var d = __define,c=ColorTransformUtil,p=c.prototype;
        ColorTransformUtil.cloneColor = function (color) {
            var c = new dragonBones.ColorTransform();
            c.redMultiplier = color.redMultiplier;
            c.greenMultiplier = color.greenMultiplier;
            c.blueMultiplier = color.blueMultiplier;
            c.alphaMultiplier = color.alphaMultiplier;
            c.redOffset = color.redOffset;
            c.greenOffset = color.greenOffset;
            c.blueOffset = color.blueOffset;
            c.alphaOffset = color.alphaOffset;
            return c;
        };
        ColorTransformUtil.isEqual = function (color1, color2) {
            return color1.alphaOffset == color2.alphaOffset &&
                color1.redOffset == color2.redOffset &&
                color1.greenOffset == color2.greenOffset &&
                color1.blueOffset == color2.blueOffset &&
                color1.alphaMultiplier == color2.alphaMultiplier &&
                color1.redMultiplier == color2.redMultiplier &&
                color1.greenMultiplier == color2.greenMultiplier &&
                color1.blueMultiplier == color2.blueMultiplier;
        };
        ColorTransformUtil.minus = function (color1, color2, outputColor) {
            outputColor.alphaOffset = color1.alphaOffset - color2.alphaOffset;
            outputColor.redOffset = color1.redOffset - color2.redOffset;
            outputColor.greenOffset = color1.greenOffset - color2.greenOffset;
            outputColor.blueOffset = color1.blueOffset - color2.blueOffset;
            outputColor.alphaMultiplier = color1.alphaMultiplier - color2.alphaMultiplier;
            outputColor.redMultiplier = color1.redMultiplier - color2.redMultiplier;
            outputColor.greenMultiplier = color1.greenMultiplier - color2.greenMultiplier;
            outputColor.blueMultiplier = color1.blueMultiplier - color2.blueMultiplier;
        };
        ColorTransformUtil.originalColor = new dragonBones.ColorTransform();
        return ColorTransformUtil;
    }());
    dragonBones.ColorTransformUtil = ColorTransformUtil;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.ConstValues
     * @classdesc
     *定义了常用的常量
     */
    var ConstValues = (function () {
        function ConstValues() {
        }
        var d = __define,c=ConstValues,p=c.prototype;
        /**
         * 角度转换为弧度
         */
        ConstValues.ANGLE_TO_RADIAN = Math.PI / 180;
        /**
         * 弧度转换为角度
         */
        ConstValues.RADIAN_TO_ANGLE = 180 / Math.PI;
        /**
         *龙骨
         */
        ConstValues.DRAGON_BONES = "dragonBones";
        /**
         * 骨架
         */
        ConstValues.ARMATURE = "armature";
        /**
         *皮肤
         */
        ConstValues.SKIN = "skin";
        /**
         * 骨骼
         */
        ConstValues.BONE = "bone";
        /**
         * ik
         */
        ConstValues.IK = "ik";
        /**
         * 插槽
         */
        ConstValues.SLOT = "slot";
        /**
         * 显示对象
         */
        ConstValues.DISPLAY = "display";
        /**
         * 动画
         */
        ConstValues.ANIMATION = "animation";
        /**
         * 时间轴
         */
        ConstValues.TIMELINE = "timeline";
        /**
         * 帧
         */
        ConstValues.FRAME = "frame";
        /**
         * 变换
         */
        ConstValues.TRANSFORM = "transform";
        /**
         * 颜色变换
         */
        ConstValues.COLOR_TRANSFORM = "colorTransform";
        ConstValues.COLOR = "color";
        /**
         * 矩形
         */
        ConstValues.RECTANGLE = "rectangle";
        /**
         * 椭圆
         */
        ConstValues.ELLIPSE = "ellipse";
        /**
         * 纹理集
         */
        ConstValues.TEXTURE_ATLAS = "TextureAtlas";
        /**
         * 子纹理
         */
        ConstValues.SUB_TEXTURE = "SubTexture";
        /**
         * 旋转
         */
        ConstValues.A_ROTATED = "rotated";
        /**
         * 帧的x坐标
         */
        ConstValues.A_FRAME_X = "frameX";
        /**
         * 帧的y坐标
         */
        ConstValues.A_FRAME_Y = "frameY";
        /**
         * 帧的宽度
         */
        ConstValues.A_FRAME_WIDTH = "frameWidth";
        /**
         * 帧的高度
         */
        ConstValues.A_FRAME_HEIGHT = "frameHeight";
        /**
         * 版本
         */
        ConstValues.A_VERSION = "version";
        /**
         * 图片路径
         */
        ConstValues.A_IMAGE_PATH = "imagePath";
        /**
         * 帧速率
         */
        ConstValues.A_FRAME_RATE = "frameRate";
        /**
         * 名字
         */
        ConstValues.A_NAME = "name";
        /**
         * 是否是全局
         */
        ConstValues.A_IS_GLOBAL = "isGlobal";
        /**
         * 父亲
         */
        ConstValues.A_PARENT = "parent";
        /**
         * 长度
         */
        ConstValues.A_LENGTH = "length";
        /**
         * 类型
         */
        ConstValues.A_TYPE = "type";
        /**
         * 缓入事件
         */
        ConstValues.A_FADE_IN_TIME = "fadeInTime";
        /**
         * 持续时长
         */
        ConstValues.A_DURATION = "duration";
        /**
         * 缩放
         */
        ConstValues.A_SCALE = "scale";
        /**
         * 偏移
         */
        ConstValues.A_OFFSET = "offset";
        /**
         * 循环
         */
        ConstValues.A_LOOP = "loop";
        ConstValues.A_PLAY_TIMES = "playTimes";
        /**
         * 事件
         */
        ConstValues.A_EVENT = "event";
        /**
         * 事件参数
         */
        ConstValues.A_EVENT_PARAMETERS = "eventParameters";
        /**
         * 声音
         */
        ConstValues.A_SOUND = "sound";
        /**
         * 动作
         */
        ConstValues.A_ACTION = "action";
        /**
         * 隐藏
         */
        ConstValues.A_HIDE = "hide";
        /**
         * 自动补间
         */
        ConstValues.A_AUTO_TWEEN = "autoTween";
        /**
         * 补间缓动
         */
        ConstValues.A_TWEEN_EASING = "tweenEasing";
        /**
         * 补间旋转
         */
        ConstValues.A_TWEEN_ROTATE = "tweenRotate";
        /**
         * 补间缩放
         */
        ConstValues.A_TWEEN_SCALE = "tweenScale";
        /**
         * 显示对象序号
         */
        ConstValues.A_DISPLAY_INDEX = "displayIndex";
        /**
         * z轴
         */
        ConstValues.A_Z_ORDER = "z";
        /**
         * 混合模式
         */
        ConstValues.A_BLENDMODE = "blendMode";
        /**
         * 宽度
         */
        ConstValues.A_WIDTH = "width";
        /**
         * 高度
         */
        ConstValues.A_HEIGHT = "height";
        /**
         * 继承缩放
         */
        ConstValues.A_INHERIT_SCALE = "inheritScale";
        /**
         * 继承旋转
         */
        ConstValues.A_INHERIT_ROTATION = "inheritRotation";
        /**
         * x轴
         */
        ConstValues.A_X = "x";
        /**
         * y轴
         */
        ConstValues.A_Y = "y";
        /**
         * x方向斜切
         */
        ConstValues.A_SKEW_X = "skX";
        /**
         * y方向斜切
         */
        ConstValues.A_SKEW_Y = "skY";
        /**
         * x方向缩放
         */
        ConstValues.A_SCALE_X = "scX";
        /**
         * y方向缩放
         */
        ConstValues.A_SCALE_Y = "scY";
        /**
         * 轴点的x坐标
         */
        ConstValues.A_PIVOT_X = "pX";
        /**
         * 轴点的y坐标
         */
        ConstValues.A_PIVOT_Y = "pY";
        /**
         * 透明度的偏移
         */
        ConstValues.A_ALPHA_OFFSET = "aO";
        /**
         * 红色的偏移
         */
        ConstValues.A_RED_OFFSET = "rO";
        /**
         * 绿色的偏移
         */
        ConstValues.A_GREEN_OFFSET = "gO";
        /**
         * 蓝色的偏移
         */
        ConstValues.A_BLUE_OFFSET = "bO";
        /**
         * 透明度的倍数
         */
        ConstValues.A_ALPHA_MULTIPLIER = "aM";
        /**
         * 红色的倍数
         */
        ConstValues.A_RED_MULTIPLIER = "rM";
        /**
         * 绿色的倍数
         */
        ConstValues.A_GREEN_MULTIPLIER = "gM";
        /**
         * 蓝色的倍数
         */
        ConstValues.A_BLUE_MULTIPLIER = "bM";
        /**
         * 动画曲线
         */
        ConstValues.A_CURVE = "curve";
        /**
         * x方向缩放的偏移
         */
        ConstValues.A_SCALE_X_OFFSET = "scXOffset";
        /**
         * y方向的偏移
         */
        ConstValues.A_SCALE_Y_OFFSET = "scYOffset";
        /**
         * 缩放模式
         */
        ConstValues.A_SCALE_MODE = "scaleMode";
        /**
         * 旋转修正
         */
        ConstValues.A_FIXED_ROTATION = "fixedRotation";
        /**
         * 默认动作
         */
        ConstValues.A_DEFAULT_ACTIONS = "defaultActions";
        /**
         * 动作
         */
        ConstValues.A_ACTIONS = "actions";
        /**
         * 播放子骨架的动画
         */
        ConstValues.A_GOTOANDPLAY = "gotoAndPlay";
        ConstValues.A_TARGET = "target";
        ConstValues.A_WEIGHT = "weight";
        ConstValues.A_BONES = "bone";
        ConstValues.A_BENDPOSITIVE = "bendPositive";
        ConstValues.A_CHAIN = "chain";
        return ConstValues;
    }());
    dragonBones.ConstValues = ConstValues;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.DBDataUtil
     * @classdesc
     * DragonBons的数据工具类，提供一些对数据处理的静态方法
     */
    var DBDataUtil = (function () {
        function DBDataUtil() {
        }
        var d = __define,c=DBDataUtil,p=c.prototype;
        /**
         * 把ArmatureData的绝对数据转成成相对数据
         * @param armatureData
         */
        DBDataUtil.transformArmatureData = function (armatureData) {
            var boneDataList = armatureData.boneDataList;
            var i = boneDataList.length;
            while (i--) {
                var boneData = boneDataList[i];
                if (boneData.parent) {
                    var parentBoneData = armatureData.getBoneData(boneData.parent);
                    if (parentBoneData) {
                        boneData.transform.copy(boneData.global);
                        dragonBones.TransformUtil.globalToLocal(boneData.transform, parentBoneData.global);
                    }
                }
            }
        };
        /**
         * 转换骨架数据中的动画数据
         * 把动画数据中的绝对的数据转换成相对的数据
         * @param armatureData
         */
        DBDataUtil.transformArmatureDataAnimations = function (armatureData) {
            var animationDataList = armatureData.animationDataList;
            var i = animationDataList.length;
            while (i--) {
                DBDataUtil.transformAnimationData(animationDataList[i], armatureData, false);
            }
        };
        /**
         *
         * @param animationData
         * @param armatureData
         */
        DBDataUtil.transformRelativeAnimationData = function (animationData, armatureData) {
        };
        /**
         * 把动画数据中的绝对的数据转换成相对的数据
         * @param animationData 动画数据
         * @param armatureData 骨架数据
         * @param isGlobalData 是否是绝对数据
         */
        DBDataUtil.transformAnimationData = function (animationData, armatureData, isGlobalData) {
            if (!isGlobalData) {
                DBDataUtil.transformRelativeAnimationData(animationData, armatureData);
                return;
            }
            var skinData = armatureData.getSkinData(null);
            var boneDataList = armatureData.boneDataList;
            var slotDataList;
            if (skinData) {
                slotDataList = skinData.slotDataList;
            }
            for (var i = 0; i < boneDataList.length; i++) {
                var boneData = boneDataList[i];
                var timeline = animationData.getTimeline(boneData.name);
                var slotTimeline = animationData.getSlotTimeline(boneData.name);
                if (!timeline && !slotTimeline) {
                    continue;
                }
                var slotData = null;
                if (slotDataList) {
                    for (var j = 0, jLen = slotDataList.length; j < jLen; j++) {
                        slotData = slotDataList[j];
                        //找到属于当前Bone的slot(FLash Pro制作的动画一个Bone只包含一个slot)
                        if (slotData.parent == boneData.name) {
                            break;
                        }
                    }
                }
                var frameList = timeline.frameList;
                if (slotTimeline) {
                    var slotFrameList = slotTimeline.frameList;
                }
                var originTransform = null;
                var originPivot = null;
                var prevFrame = null;
                var frameListLength = frameList.length;
                for (var j = 0; j < frameListLength; j++) {
                    var frame = (frameList[j]);
                    //计算frame的transoform信息
                    DBDataUtil.setFrameTransform(animationData, armatureData, boneData, frame);
                    frame.transform.x -= boneData.transform.x;
                    frame.transform.y -= boneData.transform.y;
                    frame.transform.skewX -= boneData.transform.skewX;
                    frame.transform.skewY -= boneData.transform.skewY;
                    frame.transform.scaleX /= boneData.transform.scaleX;
                    frame.transform.scaleY /= boneData.transform.scaleY;
                    //如果originTransform不存在说明当前帧是第一帧，将当前帧的transform保存至timeline的originTransform
                    /*
                    if(!originTransform){
                        originTransform = timeline.originTransform;
                        originTransform.copy(frame.transform);
                        originTransform.skewX = TransformUtil.formatRadian(originTransform.skewX);
                        originTransform.skewY = TransformUtil.formatRadian(originTransform.skewY);
                        originPivot = timeline.originPivot;
                        originPivot.x = frame.pivot.x;
                        originPivot.y = frame.pivot.y;
                    }

                    frame.transform.x -= originTransform.x;
                    frame.transform.y -= originTransform.y;
                    frame.transform.skewX = TransformUtil.formatRadian(frame.transform.skewX - originTransform.skewX);
                    frame.transform.skewY = TransformUtil.formatRadian(frame.transform.skewY - originTransform.skewY);
                    frame.transform.scaleX /= originTransform.scaleX;
                    frame.transform.scaleY /= originTransform.scaleY;

                    if(!timeline.transformed){
                        frame.pivot.x -= originPivot.x;
                        frame.pivot.y -= originPivot.y;
                    }
                    */
                    if (prevFrame) {
                        var dLX = frame.transform.skewX - prevFrame.transform.skewX;
                        if (prevFrame.tweenRotate) {
                            if (prevFrame.tweenRotate > 0) {
                                if (dLX < 0) {
                                    frame.transform.skewX += Math.PI * 2;
                                    frame.transform.skewY += Math.PI * 2;
                                }
                                if (prevFrame.tweenRotate > 1) {
                                    frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                    frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                }
                            }
                            else {
                                if (dLX > 0) {
                                    frame.transform.skewX -= Math.PI * 2;
                                    frame.transform.skewY -= Math.PI * 2;
                                }
                                if (prevFrame.tweenRotate < 1) {
                                    frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                    frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                }
                            }
                        }
                        else {
                            frame.transform.skewX = prevFrame.transform.skewX + dragonBones.TransformUtil.formatRadian(frame.transform.skewX - prevFrame.transform.skewX);
                            frame.transform.skewY = prevFrame.transform.skewY + dragonBones.TransformUtil.formatRadian(frame.transform.skewY - prevFrame.transform.skewY);
                        }
                    }
                    prevFrame = frame;
                }
                if (slotTimeline && slotFrameList) {
                    frameListLength = slotFrameList.length;
                    for (var j = 0; j < frameListLength; j++) {
                        var slotFrame = slotFrameList[j];
                        if (!slotTimeline.transformed) {
                            if (slotData) {
                                slotFrame.zOrder -= slotData.zOrder;
                            }
                        }
                    }
                    slotTimeline.transformed = true;
                }
                timeline.transformed = true;
            }
        };
        //计算frame的transoform信息
        DBDataUtil.setFrameTransform = function (animationData, armatureData, boneData, frame) {
            frame.transform.copy(frame.global);
            //找到当前bone的父亲列表 并将timeline信息存入parentTimelineList 将boneData信息存入parentDataList
            var parentData = armatureData.getBoneData(boneData.parent);
            if (parentData) {
                var parentTimeline = animationData.getTimeline(parentData.name);
                if (parentTimeline) {
                    var parentTimelineList = [];
                    var parentDataList = [];
                    while (parentTimeline) {
                        parentTimelineList.push(parentTimeline);
                        parentDataList.push(parentData);
                        parentData = armatureData.getBoneData(parentData.parent);
                        if (parentData) {
                            parentTimeline = animationData.getTimeline(parentData.name);
                        }
                        else {
                            parentTimeline = null;
                        }
                    }
                    var i = parentTimelineList.length;
                    var globalTransform;
                    var globalTransformMatrix = new dragonBones.Matrix();
                    var currentTransform = new dragonBones.DBTransform();
                    var currentTransformMatrix = new dragonBones.Matrix();
                    //从根开始遍历
                    while (i--) {
                        parentTimeline = parentTimelineList[i];
                        parentData = parentDataList[i];
                        //一级一级找到当前帧对应的每个父节点的transform(相对transform)
                        DBDataUtil.getTimelineTransform(parentTimeline, frame.position, currentTransform, !globalTransform);
                        if (!globalTransform) {
                            globalTransform = new dragonBones.DBTransform();
                            globalTransform.copy(currentTransform);
                        }
                        else {
                            currentTransform.x += parentTimeline.originTransform.x + parentData.transform.x;
                            currentTransform.y += parentTimeline.originTransform.y + parentData.transform.y;
                            currentTransform.skewX += parentTimeline.originTransform.skewX + parentData.transform.skewX;
                            currentTransform.skewY += parentTimeline.originTransform.skewY + parentData.transform.skewY;
                            currentTransform.scaleX *= parentTimeline.originTransform.scaleX * parentData.transform.scaleX;
                            currentTransform.scaleY *= parentTimeline.originTransform.scaleY * parentData.transform.scaleY;
                            dragonBones.TransformUtil.transformToMatrix(currentTransform, currentTransformMatrix);
                            currentTransformMatrix.concat(globalTransformMatrix);
                            dragonBones.TransformUtil.matrixToTransform(currentTransformMatrix, globalTransform, currentTransform.scaleX * globalTransform.scaleX >= 0, currentTransform.scaleY * globalTransform.scaleY >= 0);
                        }
                        dragonBones.TransformUtil.transformToMatrix(globalTransform, globalTransformMatrix);
                    }
                    dragonBones.TransformUtil.globalToLocal(frame.transform, globalTransform);
                }
            }
        };
        DBDataUtil.getTimelineTransform = function (timeline, position, retult, isGlobal) {
            var frameList = timeline.frameList;
            var i = frameList.length;
            while (i--) {
                var currentFrame = (frameList[i]);
                //找到穿越当前帧的关键帧
                if (currentFrame.position <= position && currentFrame.position + currentFrame.duration > position) {
                    //是最后一帧或者就是当前帧
                    if (i == frameList.length - 1 || position == currentFrame.position) {
                        retult.copy(isGlobal ? currentFrame.global : currentFrame.transform);
                    }
                    else {
                        var tweenEasing = currentFrame.tweenEasing;
                        var progress = (position - currentFrame.position) / currentFrame.duration;
                        if (tweenEasing && tweenEasing != 10) {
                            progress = dragonBones.MathUtil.getEaseValue(progress, tweenEasing);
                        }
                        var nextFrame = frameList[i + 1];
                        var currentTransform = isGlobal ? currentFrame.global : currentFrame.transform;
                        var nextTransform = isGlobal ? nextFrame.global : nextFrame.transform;
                        retult.x = currentTransform.x + (nextTransform.x - currentTransform.x) * progress;
                        retult.y = currentTransform.y + (nextTransform.y - currentTransform.y) * progress;
                        retult.skewX = dragonBones.TransformUtil.formatRadian(currentTransform.skewX + (nextTransform.skewX - currentTransform.skewX) * progress);
                        retult.skewY = dragonBones.TransformUtil.formatRadian(currentTransform.skewY + (nextTransform.skewY - currentTransform.skewY) * progress);
                        retult.scaleX = currentTransform.scaleX + (nextTransform.scaleX - currentTransform.scaleX) * progress;
                        retult.scaleY = currentTransform.scaleY + (nextTransform.scaleY - currentTransform.scaleY) * progress;
                    }
                    break;
                }
            }
        };
        /**
         * 添加进隐藏的时间轴
         * @param animationData
         * @param armatureData
         */
        DBDataUtil.addHideTimeline = function (animationData, armatureData, addHideSlot) {
            if (addHideSlot === void 0) { addHideSlot = false; }
            var boneDataList = armatureData.boneDataList;
            var slotDataList = armatureData.slotDataList;
            var i = boneDataList.length;
            while (i--) {
                var boneData = boneDataList[i];
                var boneName = boneData.name;
                if (!animationData.getTimeline(boneName)) {
                    if (animationData.hideTimelineNameMap.indexOf(boneName) < 0) {
                        animationData.hideTimelineNameMap.push(boneName);
                    }
                }
            }
            if (addHideSlot) {
                i = slotDataList.length;
                var slotData;
                var slotName;
                while (i--) {
                    slotData = slotDataList[i];
                    slotName = slotData.name;
                    if (!animationData.getSlotTimeline(slotName)) {
                        if (animationData.hideSlotTimelineNameMap.indexOf(slotName) < 0) {
                            animationData.hideSlotTimelineNameMap.push(slotName);
                        }
                    }
                }
            }
        };
        return DBDataUtil;
    }());
    dragonBones.DBDataUtil = DBDataUtil;

})(dragonBones || (dragonBones = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.MathUtil
     * @classdesc
     * 内部使用的有关数学计算的工具类
     */
    var MathUtil = (function () {
        function MathUtil() {
        }
        var d = __define,c=MathUtil,p=c.prototype;
        /** @private */
        MathUtil.getEaseValue = function (value, easing) {
            var valueEase = 1;
            if (easing > 1) {
                //valueEase = 0.5 * (1 - NumberUtils.cos(value * Math.PI));
                valueEase = 0.5 * (1 - MathUtil.cos(value * Math.PI));
                easing -= 1;
            }
            else if (easing > 0) {
                valueEase = 1 - Math.pow(1 - value, 2);
            }
            else if (easing < 0) {
                easing *= -1;
                valueEase = Math.pow(value, 2);
            }
            return (valueEase - value) * easing + value;
        };
        MathUtil.isNumber = function (value) {
            return typeof (value) === "number" && !isNaN(value);
        };
        /**
         * 得到对应角度值的sin近似值
         * @param value {number} 角度值
         * @returns {number} sin值
         */
        MathUtil.sin = function (value) {
            value *= MathUtil.RADIAN_TO_ANGLE;
            var valueFloor = Math.floor(value);
            var valueCeil = valueFloor + 1;
            var resultFloor = MathUtil.sinInt(valueFloor);
            var resultCeil = MathUtil.sinInt(valueCeil);
            return (value - valueFloor) * resultCeil + (valueCeil - value) * resultFloor;
        };
        MathUtil.sinInt = function (value) {
            value = value % 360;
            if (value < 0) {
                value += 360;
            }
            if (value < 90) {
                return db_sin_map[value];
            }
            if (value < 180) {
                return db_sin_map[180 - value];
            }
            if (value < 270) {
                return -db_sin_map[value - 180];
            }
            return -db_sin_map[360 - value];
        };
        /**
         * 得到对应角度值的cos近似值
         * @param value {number} 角度值
         * @returns {number} cos值
         */
        MathUtil.cos = function (value) {
            return MathUtil.sin(Math.PI / 2 - value);
        };
        /**
         * 角度转换为弧度
         */
        MathUtil.ANGLE_TO_RADIAN = Math.PI / 180;
        /**
         * 弧度转换为角度
         */
        MathUtil.RADIAN_TO_ANGLE = 180 / Math.PI;
        return MathUtil;
    }());
    dragonBones.MathUtil = MathUtil;

})(dragonBones || (dragonBones = {}));
var db_sin_map = {};
for (var dbMathIndex = 0; dbMathIndex <= 90; dbMathIndex++) {
    db_sin_map[dbMathIndex] = Math.sin(dbMathIndex * dragonBones.MathUtil.ANGLE_TO_RADIAN);
}
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var dragonBones;
(function (dragonBones) {
    /**
     * @class dragonBones.TransformUtils
     * @classdesc
     * 提供了一些常用的转换的静态方法
     */
    var TransformUtil = (function () {
        function TransformUtil() {
        }
        var d = __define,c=TransformUtil,p=c.prototype;
        TransformUtil.isEqual = function (n1, n2) {
            if (n1 >= n2) {
                return (n1 - n2) <= TransformUtil.ACCURACY;
            }
            else {
                return (n2 - n1) <= TransformUtil.ACCURACY;
            }
        };
        /**
         * 全局坐标系转成成局部坐标系
         * @param transform 全局坐标系下的变换
         * @param parent 父亲的坐标变换
         */
        TransformUtil.globalToLocal = function (transform, parent) {
            TransformUtil.transformToMatrix(transform, TransformUtil._helpTransformMatrix);
            TransformUtil.transformToMatrix(parent, TransformUtil._helpParentTransformMatrix);
            TransformUtil._helpParentTransformMatrix.invert();
            TransformUtil._helpTransformMatrix.concat(TransformUtil._helpParentTransformMatrix);
            TransformUtil.matrixToTransform(TransformUtil._helpTransformMatrix, transform, transform.scaleX * parent.scaleX >= 0, transform.scaleY * parent.scaleY >= 0);
        };
        /**
         *把transform数据转成成矩阵数据
         * @param transform 需要转换的transform数据
         * @param matrix 转换后的矩阵数据
         * @param keepScale 是否保持缩放
         */
        TransformUtil.transformToMatrix = function (transform, matrix) {
            matrix.a = transform.scaleX * dragonBones.MathUtil.cos(transform.skewY);
            matrix.b = transform.scaleX * dragonBones.MathUtil.sin(transform.skewY);
            matrix.c = -transform.scaleY * dragonBones.MathUtil.sin(transform.skewX);
            matrix.d = transform.scaleY * dragonBones.MathUtil.cos(transform.skewX);
            matrix.tx = transform.x;
            matrix.ty = transform.y;
        };
        /**
         *把 矩阵数据转成成transform数据
         * @param matrix 需要转换的矩阵数据
         * @param transform 转换后的transform数据
         * @param scaleXF x方向的缩放
         * @param scaleYF y方向的缩放
         */
        TransformUtil.matrixToTransform = function (matrix, transform, scaleXF, scaleYF) {
            transform.x = matrix.tx;
            transform.y = matrix.ty;
            transform.scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b) * (scaleXF ? 1 : -1);
            transform.scaleY = Math.sqrt(matrix.d * matrix.d + matrix.c * matrix.c) * (scaleYF ? 1 : -1);
            TransformUtil.tmpSkewXArray[0] = Math.acos(matrix.d / transform.scaleY);
            TransformUtil.tmpSkewXArray[1] = -TransformUtil.tmpSkewXArray[0];
            TransformUtil.tmpSkewXArray[2] = Math.asin(-matrix.c / transform.scaleY);
            TransformUtil.tmpSkewXArray[3] = TransformUtil.tmpSkewXArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewXArray[2] : TransformUtil.tmpSkewXArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[3])) {
                transform.skewX = TransformUtil.tmpSkewXArray[0];
            }
            else {
                transform.skewX = TransformUtil.tmpSkewXArray[1];
            }
            TransformUtil.tmpSkewYArray[0] = Math.acos(matrix.a / transform.scaleX);
            TransformUtil.tmpSkewYArray[1] = -TransformUtil.tmpSkewYArray[0];
            TransformUtil.tmpSkewYArray[2] = Math.asin(matrix.b / transform.scaleX);
            TransformUtil.tmpSkewYArray[3] = TransformUtil.tmpSkewYArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewYArray[2] : TransformUtil.tmpSkewYArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[3])) {
                transform.skewY = TransformUtil.tmpSkewYArray[0];
            }
            else {
                transform.skewY = TransformUtil.tmpSkewYArray[1];
            }
        };
        /** @private */
        TransformUtil.applyMatrixToPoint = function (targetPoint, matrix, returnNewPoint) {
            if (returnNewPoint === void 0) { returnNewPoint = false; }
            this._helpMatrix.tx = targetPoint.x;
            this._helpMatrix.ty = targetPoint.y;
            this._helpMatrix.concat(matrix);
            if (returnNewPoint) {
                return new dragonBones.Point(this._helpMatrix.tx, this._helpMatrix.ty);
            }
            else {
                targetPoint.x = this._helpMatrix.tx;
                targetPoint.y = this._helpMatrix.ty;
                return targetPoint;
            }
        };
        /**
         * 标准化弧度值，把弧度制换算到[-PI，PI]之间
         * @param radian 输入一个弧度值
         * @returns {number} 输出标准化后的弧度制
         */
        TransformUtil.formatRadian = function (radian) {
            //radian %= DOUBLE_PI;
            if (radian > Math.PI) {
                radian -= TransformUtil.DOUBLE_PI;
            }
            if (radian < -Math.PI) {
                radian += TransformUtil.DOUBLE_PI;
            }
            return radian;
        };
        /**
         *  确保角度在-180到180之间
         */
        TransformUtil.normalizeRotation = function (rotation) {
            rotation = (rotation + Math.PI) % (2 * Math.PI);
            rotation = rotation > 0 ? rotation : 2 * Math.PI + rotation;
            return rotation - Math.PI;
        };
        TransformUtil.matrixToTransformPosition = function (matrix, transform) {
            transform.x = matrix.tx;
            transform.y = matrix.ty;
        };
        TransformUtil.matrixToTransformScale = function (matrix, transform, scaleXF, scaleYF) {
            transform.scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b) * (scaleXF ? 1 : -1);
            transform.scaleY = Math.sqrt(matrix.d * matrix.d + matrix.c * matrix.c) * (scaleYF ? 1 : -1);
        };
        TransformUtil.matrixToTransformRotation = function (matrix, transform, scaleX, scaleY) {
            TransformUtil.tmpSkewXArray[0] = Math.acos(matrix.d / scaleY);
            TransformUtil.tmpSkewXArray[1] = -TransformUtil.tmpSkewXArray[0];
            TransformUtil.tmpSkewXArray[2] = Math.asin(-matrix.c / scaleY);
            TransformUtil.tmpSkewXArray[3] = TransformUtil.tmpSkewXArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewXArray[2] : TransformUtil.tmpSkewXArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewXArray[0], TransformUtil.tmpSkewXArray[3])) {
                transform.skewX = TransformUtil.tmpSkewXArray[0];
            }
            else {
                transform.skewX = TransformUtil.tmpSkewXArray[1];
            }
            TransformUtil.tmpSkewYArray[0] = Math.acos(matrix.a / scaleX);
            TransformUtil.tmpSkewYArray[1] = -TransformUtil.tmpSkewYArray[0];
            TransformUtil.tmpSkewYArray[2] = Math.asin(matrix.b / scaleX);
            TransformUtil.tmpSkewYArray[3] = TransformUtil.tmpSkewYArray[2] >= 0 ? Math.PI - TransformUtil.tmpSkewYArray[2] : TransformUtil.tmpSkewYArray[2] - Math.PI;
            if (TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[2]) || TransformUtil.isEqual(TransformUtil.tmpSkewYArray[0], TransformUtil.tmpSkewYArray[3])) {
                transform.skewY = TransformUtil.tmpSkewYArray[0];
            }
            else {
                transform.skewY = TransformUtil.tmpSkewYArray[1];
            }
        };
        TransformUtil.HALF_PI = Math.PI * 0.5;
        TransformUtil.DOUBLE_PI = Math.PI * 2;
        TransformUtil._helpTransformMatrix = new dragonBones.Matrix();
        TransformUtil._helpParentTransformMatrix = new dragonBones.Matrix();
        //optimized by freem-trg
        TransformUtil.tmpSkewXArray = [];
        TransformUtil.tmpSkewYArray = [];
        TransformUtil.ACCURACY = 0.0001;
        TransformUtil._helpMatrix = new dragonBones.Matrix();
        return TransformUtil;
    }());
    dragonBones.TransformUtil = TransformUtil;

})(dragonBones || (dragonBones = {}));
(function (dragonBones) {
    /**
     * @class dragonBones.HolaFactory
     * @extends dragonBones.BaseFactory
     * @classdesc
     * Hola引擎中DragonBones工厂的基类实现
    */
    function HolaFactory() {
        dragonBones.BaseFactory.call(this);
    }
    __extends(HolaFactory, dragonBones.BaseFactory);

    /**
     *创建骨架
     */
    HolaFactory.prototype._generateArmature = function () {
        return new dragonBones.Armature(DisplayObjectContainer.create());
    };

    /**
     *创建插槽
     */
    HolaFactory.prototype._generateSlot = function () {
        return new dragonBones.HolaSlot();
    };

    /**
     *创建显示对象
     */
    HolaFactory.prototype._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
        var texture = textureAtlas.getTexture(fullName);
        var bitmap = Bitmap.create(fullName);
        bitmap.setTexture(texture);
        if (isNaN(pivotX) || isNaN(pivotY)) {
            var subTextureFrame = (textureAtlas).getFrame(fullName);
            if (subTextureFrame != null) {
                pivotX = subTextureFrame.width / 2;
                pivotY = subTextureFrame.height / 2;
            }
            else {
                pivotX = bitmap.width / 2;
                pivotY = bitmap.height / 2;
            }
        }
        bitmap.setAnchorOffset(pivotX, pivotY);
        return bitmap;
    };

    /**
    *创建快速版本骨架
    */
    HolaFactory.prototype._generateFastArmature = function () {
        return new dragonBones.FastArmature(DisplayObjectContainer.create());
    };

    /**
    *创建快速版本插槽
    */
    HolaFactory.prototype._generateFastSlot = function () {
        return new dragonBones.HolaFastSlot(Bitmap.create());
    };

    /**
    *创建蒙皮
    */
    HolaFactory.prototype._generateMesh = function (textureAtlas, fullName, meshData, slot) {
        if (egret.Capabilities.renderMode == "webgl") {
            var mesh = new egret.Mesh();
            var meshNode = mesh.$renderNode;
            mesh.texture = textureAtlas.getTexture(fullName);
            var i = 0, iD = 0, l = 0;
            for (i = 0, l = meshData.numVertex; i < l; i++) {
                iD = i * 2;
                var dbVertexData = meshData.vertices[i];
                meshNode.uvs[iD] = dbVertexData.u;
                meshNode.uvs[iD + 1] = dbVertexData.v;
                meshNode.vertices[iD] = dbVertexData.x;
                meshNode.vertices[iD + 1] = dbVertexData.y;
            }
            for (i = 0, l = meshData.triangles.length; i < l; i++) {
                meshNode.indices[i] = meshData.triangles[i];
            }
            slot.isMeshEnabled = true;
            return mesh;
        }
        var bitmap = new egret.Bitmap();
        bitmap.texture = textureAtlas.getTexture(fullName);
        var subTextureFrame = (textureAtlas).getFrame(fullName);
        var pivotX = 0, pivotY = 0;
        if (subTextureFrame != null) {
            pivotX = subTextureFrame.width / 2;
            pivotY = subTextureFrame.height / 2;
        }
        else {
            pivotX = bitmap.width / 2;
            pivotY = bitmap.height / 2;
        }
        bitmap.anchorOffsetX = pivotX;
        bitmap.anchorOffsetY = pivotY;
        return bitmap;
    };

    dragonBones.HolaFactory = HolaFactory;
})(dragonBones || (dragonBones = {}));
(function (dragonBones) {
    /**
     * hola引擎使用的插槽
     */

    function HolaSlot() {
        dragonBones.Slot.call(this);
        this._holaDisplay = null;
    }
    __extends(HolaSlot, dragonBones.Slot);

    /**
     * 释放资源
     */
    HolaSlot.prototype.dispose = function() {
        if (this._displayList) {
            var length = this._displayList.length;
            for (var i = 0; i < length; i++) {
                var content = this._displayList[i];
                if (content instanceof dragonBones.Armature) {
                    content.dispose();
                }
            }
        }
        dragonBones.Slot.prototype.dispose.call(this);
        this._holaDisplay = null;
    };

    /**
     *更新显示对象
     */
    HolaSlot.prototype._updateDisplay = function (value) {
        this._holaDisplay = value;
    };

    /**
     *获取显示对象索引
     */
    HolaSlot.prototype._getDisplayIndex = function () {
        if (this._holaDisplay && this._holaDisplay.parent) {
            return this._holaDisplay.parent.getChildIndex(this._holaDisplay);
        }
        return -1;
    };

    /**
     *添加显示对象到容器
     */
    HolaSlot.prototype._addDisplayToContainer = function (container, index) {
        if (index === void 0) {
            index = -1;
        }
        if (this._holaDisplay && container) {
            if (index < 0) {
                container.addChild(this._holaDisplay);
            }
            else {
                index = Math.min(index, container.getChildCount());
                container.addChildAt(this._holaDisplay, index);
            }
        }
    };

    /**
     *移除当前显示对象
     */
    HolaSlot.prototype._removeDisplayFromContainer = function () {
        if (this._holaDisplay) {
            var parent = this._holaDisplay.getParent();
            if(parent) {
                parent.removeChild(this._holaDisplay);
            }
        }
    };

    /**
     *更新显示对象矩阵
     */
    HolaSlot.prototype._updateTransform = function () {
        if(this._holaDisplay) {
            this._holaDisplay.setTransform(this._globalTransformMatrix);
        }
    };

    /**
     *设置显示对象可见性(当插槽以及插槽上的骨骼可见时，显示对象可见)
     */
    HolaSlot.prototype._updateDisplayVisible = function (value) {
        if (this._holaDisplay && this._parent) {
            this._holaDisplay.setVisible(this._parent._visible && this._visible && value);
        }
    };

    /**
     *显示对象颜色变换
     */
    HolaSlot.prototype._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChange) {
        if (colorChange === void 0) {
            colorChange = false;
        }
        dragonBones.Slot.prototype._updateDisplayColor.call(this, aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChange);
        if (this._holaDisplay) {
            this._holaDisplay.setAlpha(aMultiplier);
        }
    };

    /**
     *设置显示对象混合模式
     */
    HolaSlot.prototype._updateDisplayBlendMode = function (value) {
        if (this._holaDisplay && value) {
            this._holaDisplay.setBlend(value);
        }
    };

    /**
     *更新相对父节点的矩阵变换
     */
    HolaSlot.prototype._calculateRelativeParentTransform = function () {
        this._global.scaleX = this._origin.scaleX * this._offset.scaleX;
        this._global.scaleY = this._origin.scaleY * this._offset.scaleY;
        this._global.skewX = this._origin.skewX + this._offset.skewX;
        this._global.skewY = this._origin.skewY + this._offset.skewY;
        this._global.x = this._origin.x + this._offset.x + this._parent._tweenPivot.x;
        this._global.y = this._origin.y + this._offset.y + this._parent._tweenPivot.y;
        if (this._displayDataList &&
            this._currentDisplayIndex >= 0 &&
            this._displayDataList[this._currentDisplayIndex] &&
            dragonBones.HolaTextureAtlas.rotatedDic[this._displayDataList[this._currentDisplayIndex].name] == 1) {
            this._global.skewX -= 1.57;
            this._global.skewY -= 1.57;
        }
    };

    /**
     *更新蒙皮
     */
    HolaSlot.prototype._updateMesh = function () {
        if (!this._meshData || !this.isMeshEnabled) {
            return;
        }
        var mesh = this._holaDisplay;
        var meshNode = mesh.$renderNode;
        var i = 0, iD = 0, l = 0;
        var xG = 0, yG = 0;
        if (this._meshData.skinned) {
            var bones = this._armature.getBones(false);
            var iF = 0;
            for (i = 0, l = this._meshData.numVertex; i < l; i++) {
                var vertexBoneData = this._meshData.vertexBones[i];
                var j = 0;
                var xL = 0;
                var yL = 0;

                iD = i * 2;
                xG = 0;
                yG = 0;
                for (var iB = 0, lB = vertexBoneData.indices.length; iB < lB; ++iB) {
                    var boneIndex = vertexBoneData.indices[iB];
                    var bone = this._meshBones[boneIndex];
                    var matrix = bone._globalTransformMatrix;
                    var point = vertexBoneData.vertices[j];
                    var weight = Number(vertexBoneData.weights[j]);
                    if (!this._ffdVertices || iF < this._ffdOffset || iF >= this._ffdVertices.length) {
                        xL = point.x;
                        yL = point.y;
                    }
                    else {
                        xL = point.x + this._ffdVertices[iF];
                        yL = point.y + this._ffdVertices[iF + 1];
                    }
                    xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * weight;
                    yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * weight;
                    j++;
                    iF += 2;
                }
                meshNode.vertices[iD] = xG;
                meshNode.vertices[iD + 1] = yG;
            }
                mesh.$updateVertices();
                mesh.$invalidateTransform();
        }
        else if (this._ffdChanged) {
            this._ffdChanged = false;
            for (i = 0, l = this._meshData.numVertex; i < l; ++i) {
                var vertexData = this._meshData.vertices[i];
                iD = i * 2;
                if (!this._ffdVertices || iD < this._ffdOffset || iD >= this._ffdVertices.length) {
                    xG = vertexData.x;
                    yG = vertexData.y;
                }
                else {
                    xG = Number(vertexData.x) + this._ffdVertices[iD - this._ffdOffset];
                    yG = Number(vertexData.y) + this._ffdVertices[iD - this._ffdOffset + 1];
                }
                meshNode.vertices[iD] = xG;
                meshNode.vertices[iD + 1] = yG;
            }
            mesh.$updateVertices();
            mesh.$invalidateTransform();
        }
    };

    dragonBones.HolaSlot = HolaSlot;
})(dragonBones || (dragonBones = {}));
(function (dragonBones) {
    /**
     * @class dragonBones.HolaFastSlot
     * @extends dragonBones.Slot
     * @classdesc
     * hola引擎使用的插槽
     */
    function HolaFastSlot(rawDisplay) {
        dragonBones.FastSlot.call(this, rawDisplay);
        this._holaDisplay = null;
    }

    __extends(HolaFastSlot, dragonBones.FastSlot);

    /**
     * 释放资源
     */
    HolaFastSlot.prototype.dispose = function () {
        if (this._displayList) {
            var length = this._displayList.length;
            for (var i = 0; i < length; i++) {
                var content = this._displayList[i];
                if (content instanceof dragonBones.FastArmature) {
                    content.dispose();
                }
            }
        }
        dragonBones.FastSlot.prototype.dispose.call(this);
        this._holaDisplay = null;
    };
    /** @private */
    HolaFastSlot.prototype._updateDisplay = function (value) {
        this._holaDisplay = value;
    };
    /** @private */
    HolaFastSlot.prototype._addDisplay = function () {
        var container = this.armature.display;
        container.addChild(this._holaDisplay);
    };
    /** @private */
    HolaFastSlot.prototype._replaceDisplay = function (prevDisplay) {
        var container = this.armature.display;
        var displayObject = prevDisplay;
        container.addChild(this._holaDisplay);
        container.swapChildren(this._holaDisplay, displayObject);
        container.removeChild(displayObject);
    };
    /** @private */
    HolaFastSlot.prototype._removeDisplay = function () {
        this._holaDisplay.parent.removeChild(this._holaDisplay);
    };
    //Abstract method
    /** @private */
    HolaFastSlot.prototype._getDisplayIndex = function () {
        if (this._holaDisplay && this._holaDisplay.parent) {
            return this._holaDisplay.parent.getChildIndex(this._holaDisplay);
        }
        return -1;
    };
    /** @private */
    HolaFastSlot.prototype._addDisplayToContainer = function (container, index) {
        if (index === void 0) { index = -1; }
        if (!this._holaDisplay) {
            this._holaDisplay = this._rawDisplay;
        }
        if (this._holaDisplay && container) {
            if (index < 0) {
                container.addChild(this._holaDisplay);
            }
            else {
                index = Math.min(index, container.getChildCount());
                container.addChildAt(this._holaDisplay, index);
            }
        }
    };
    /** @private */
    HolaFastSlot.prototype._removeDisplayFromContainer = function () {
        if (this._holaDisplay && this._holaDisplay.parent) {
            this._holaDisplay.parent.removeChild(this._holaDisplay);
        }
    };
    /** @private */
    HolaFastSlot.prototype._updateTransform = function () {
        if (this._displayIndex >= 0) {
            this._holaDisplay.setTransform(this._globalTransformMatrix);
        }
    };
    /** @private */
    HolaFastSlot.prototype._updateDisplayVisible = function (value) {
        if(this._holaDisplay && this._parent){
            this._holaDisplay.visible = this._parent._visible && this._visible && value;
        }
    };
    /** @private */
    HolaFastSlot.prototype._updateDisplayColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged) {
        if (colorChanged === void 0) { colorChanged = false; }
        dragonBones.FastSlot.prototype._updateDisplayColor.call(this, aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, colorChanged);
        if (this._holaDisplay) {
            this._holaDisplay.setAlpha(aMultiplier);
        }
    };
    /** @private */
    HolaFastSlot.prototype._updateFrame = function () {
        var dataLength = this._displayDataList.length;
        var textureIndex = this._displayIndex < dataLength ? this._displayIndex : (dataLength - 1);
        var textureData = textureIndex < 0 ? null : this._displayDataList[textureIndex][1];
        var display = this._holaDisplay;
        if (textureData) {
            var textureAtlasTexture = textureData.textureAtlas;
            var displayData = this.displayDataList[this._displayIndex][0];
            var rect = textureData.frame || textureData.region;
            var width = textureData.rotated ? rect.height : rect.width;
            var height = textureData.rotated ? rect.width : rect.height;
            //const pivotX = width * displayData.pivot.x - (textureData.frame ? textureData.frame.x : 0);
            //const pivotY = height * displayData.pivot.y - (textureData.frame ? textureData.frame.y : 0);
            var pivotX = displayData.pivot.x == displayData.pivot.x ? displayData.pivot.x : width * 0.5;
            var pivotY = displayData.pivot.y == displayData.pivot.y ? displayData.pivot.y : height * 0.5;
            if (!display.visible) {
                display.setVisible(true);
            }
            display.setTexture(textureAtlasTexture.getTexture(displayData.name));
            // display.readjustSize();
            display.setAnchorOffset(pivotX, pivotY);
        }
        else {
            if (display.visible) {
                display.setVisible(false);
            }
            display.setTexture(null);
        }
    };
    /** @private */
    HolaFastSlot.prototype._updateDisplayBlendMode = function (value) {
        if (this._holaDisplay && value) {
            this._holaDisplay.blendMode = value;
        }
    };

    dragonBones.HolaFastSlot = HolaFastSlot;
})(dragonBones || (dragonBones = {}));
function SpriteSheet(texture, scale) {
    this.srcX = 0;
    this.srcY = 0;
    this.scale = scale;
    this.textureMap = {};
    this.srcTexture = texture;
    this.srcWidth = texture.width;
    this.srcHeight = texture.height;
}

SpriteSheet.prototype.getTexture = function(name) {
    return this.srcTexture[name];
};

SpriteSheet.prototype.createTexture = function(name, dstX, dstY, dstW, dstH, offsetX, offsetY, srcW, srcH) {
    var newTexture;

    if (offsetX === void 0 || offsetX == 0) { offsetX = 0; }
    if (offsetY === void 0 || offsetY == 0) { offsetY = 0; }

    if (srcW === undefined) {
        srcW = offsetX + dstW;
    }

    if (srcH === undefined) {
        srcH = offsetY + dstH;
    }

    newTexture = Object.create(null);
    newTexture.sx = this.srcX + dstX;
    newTexture.sy = this.srcY + dstY;
    newTexture.sw = dstW * this.scale;
    newTexture.sh = dstH * this.scale;
    newTexture.dx = offsetX;
    newTexture.dy = offsetY;
    newTexture.dw = srcW * this.scale;
    newTexture.dh = srcH * this.scale;

    newTexture.name = name;
    newTexture.texture = this.srcTexture;
    this.textureMap[name] = newTexture;

    return newTexture;
};

SpriteSheet.prototype.dispose = function() {
    if(this.texture) {
        this.texture.dispose();
    }
};

function HolaTextureAtlas(texture, textureAtlasRawData, scale) {
    if (scale === void 0) { scale = 1; }
    this.scale = scale;
    this.texture = texture;
    this.textureDatas = {};
    this.textureAtlasRawData = textureAtlasRawData;
    this.name = textureAtlasRawData[dragonBones.ConstValues.A_NAME];
    this.parseData(textureAtlasRawData);
    this.spriteSheet = new SpriteSheet(texture, scale);
}

/**
*解析纹理数据
*/
HolaTextureAtlas.prototype.parseData = function (textureAtlasRawData) {
    this.textureDatas = dragonBones.DataParser.parseTextureAtlasData(textureAtlasRawData, this.scale);
};

/**
*根据名字获取纹理
*/
HolaTextureAtlas.prototype.getTexture = function (fullName) {
    var result = this.spriteSheet.getTexture(fullName);
    if (!result) {
        var data = this.textureDatas[fullName];
        if (data) {
            var frame = data.frame;
            if (frame) {
                result = this.spriteSheet.createTexture(fullName, data.region.x, data.region.y, data.region.width, data.region.height, -frame.x, -frame.y, frame.width, frame.height);
            }
            else {
                result = this.spriteSheet.createTexture(fullName, data.region.x, data.region.y, data.region.width, data.region.height);
            }
            if (data.rotated) {
                HolaTextureAtlas.rotatedDic[fullName] = 1;
            }
        }
    }
    return result;
};

/**
* 释放资源
*/
HolaTextureAtlas.prototype.dispose = function () {
    this.texture = null;
};

/**
*根据子纹理的名字获取子纹理所在的实际矩形区域
*/
HolaTextureAtlas.prototype.getRegion = function (subTextureName) {
    var textureData = this.textureDatas[subTextureName];
    if (textureData && textureData instanceof dragonBones.TextureData) {
        return textureData.region;
    }
    return null;
};

/**
*根据子纹理的名字获取子纹理所在的真实矩形区域
*/
HolaTextureAtlas.prototype.getFrame = function (subTextureName) {
    var textureData = this.textureDatas[subTextureName];
    if (textureData && textureData instanceof dragonBones.TextureData) {
        return textureData.frame;
    }
    return null;
};

/**
* 根据子纹理的名字获取子纹理数据
*/
HolaTextureAtlas.prototype.getTextureData = function (subTextureName) {
    return this.textureDatas[subTextureName];
};

HolaTextureAtlas.rotatedDic = {};

dragonBones = dragonBones || {};
dragonBones.HolaTextureAtlas = HolaTextureAtlas;
/*
 * File:   ui-skeleton-animation.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  SkelentonAnimation
 *
 * Copyright (c) 2011 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2015  Holaverse Inc.
 *
 */

/**
 * @class UIDragonBones
 * @extends UISkeletonAnimation
 * 龙骨骨骼动画。参考：[DragonBones](https://github.com/DragonBones)
 */
function UIDragonBones() {
	return;
}

UIDragonBones.prototype = new UISkeletonAnimation();
UIDragonBones.prototype.isUIDragonBones = true;
UIDragonBones.prototype.initUIDragonBones = UISkeletonAnimation.prototype.initUISkeletonAnimation;

UIDragonBones.prototype.pause = function() {
	if(this.armature) {
		this.armature.animation.stop();
	}

	return this;
}

UIDragonBones.prototype.resume = function() {
	if(this.armature) {
		this.armature.animation.play();
	}

	return this;
}

UIDragonBones.prototype.getEnableCache = function() {
    return !!this.enableCache;
}

UIDragonBones.prototype.setEnableCache = function(value) {
    this.enableCache = value;
    return this;
}

UIDragonBones.prototype.setupLoop = function(animationName, repeatTimes, onDone, onOneCycle) {
	var me = this;
	function loopComplete(e) {
		if(!e || !e.animationState
            || e.armature !== me._armature) {
            return;
		}
		if(me.onOneCycle) {
			try {
				me.onOneCycle();
			} catch(e) {
				console.debug('onOneCycle:', e);
			}
		}
	}

	function complete() {
		//me.stop();
		if(me.onDone) {
			try {
				me.onDone();
			} catch(e) {
				console.debug('onDone:', e);
			}
		}
	}

	if(!isNaN(repeatTimes)) {
		this.onDone = onDone;
		this.onOneCycle = onOneCycle;
		this._armature.addEventListener(dragonBones.AnimationEvent.COMPLETE, complete);
		this._armature.addEventListener(dragonBones.AnimationEvent.LOOP_COMPLETE, loopComplete);
	}
}

UIDragonBones.prototype.doPlay = UIDragonBones.prototype.gotoAndPlay = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	this.animationName = animationName;

	if(this.armature) {
		var armature = this.armature;

		if(animationName && armature.animation.animationList.indexOf(animationName) >= 0) {
			//if(onDone || onOneCycle || repeatTimes || typeof repeatTimes === 'undefined') {
			if(onDone || onOneCycle || repeatTimes) {
				repeatTimes = isNaN(repeatTimes) ? Number.MAX_VALUE : repeatTimes;
				this.setupLoop.apply(armature.animation, arguments);
			}
			var fadeIn = !useFadeIn ? 0 : undefined;
			armature.animation.gotoAndPlay(animationName, fadeIn, duration, repeatTimes);
		}
		else if(this.animations && animationName) {
			this.animate(animationName);
		}
		else {
			console.log("Unknow animation name: " + animationName);
		}
	}

	return this;
}

UIDragonBones.prototype.destroyArmature = function() {
	if(this.armature) {
		this.armature = null;
	}

	return;
}

UISkeletonAnimation.prototype.destroy = function() {
	this.destroyArmature();
	UIElement.prototype.destroy.call(this);

	return;
}

UISkeletonAnimation.prototype.getSlotRect = function(name) {
	if(!this.armature) {
		return null;
	}

	var slotList = this.armature._slotList;
	for(var i = 0; i < slotList.length; i++) {
		var iter = slotList[i];
		if(iter.name === name) {
			var display = iter.getDisplay();
			return display.textureAtlasRect;
		}
	}

	return null;
}

UISkeletonAnimation.prototype.replaceSlotImage = function(name, image, imageRect) {
	if(!this.armature) {
		return this;
	}

	if(imageRect && imageRect.w) {
		imageRect.width = imageRect.w;
	}
	if(imageRect && imageRect.h) {
		imageRect.height = imageRect.h;
	}

	var slotList = this.armature._slotList;
	for(var i = 0; i < slotList.length; i++) {
		var iter = slotList[i];
		if(iter.name === name) {
			iter.image = image;
			iter.imageRect = imageRect;
		}
	}

	return;
}

UIDragonBones.prototype.advanceTime = function() {
	var self = this;
	var armature = this.armature;

	armature.advanceTime = function() {
		if(self.isVisible()) {
			dragonBones.Armature.prototype.advanceTime.apply(this, arguments);
		}
	}

	return this;
}

UIDragonBones.prototype.createArmature = function(texture, textureData, skeletonData) {
	if(this.armature) {
		this.armature = null;
	}

	var factory = null;
	if(!MainContext.instance.factory) {
		factory = new dragonBones.HolaFactory();
		MainContext.instance.factory = factory;
	}
	else {
		factory = MainContext.instance.factory;
	}

	if(!factory.getSkeletonData(skeletonData.name)) {
		factory.addSkeletonData(dragonBones.DataParser.parseDragonBonesData(skeletonData));
	}

	if(!factory.getTextureAtlas(textureData.name)) {
		factory.addTextureAtlas(new dragonBones.HolaTextureAtlas(texture, textureData));
	}

    if(this.enableCache) {
        var armature = factory.buildFastArmature(skeletonData.armature[0].name, skeletonData.name);
        armature.enableAnimationCache(24);
    }
    else {
        var armature = factory.buildArmature(skeletonData.armature[0].name, skeletonData.name);
    }

	this.armature = armature;
	this.animationNames = armature.animation.animationList;
	this.animationName = this.animationNames.indexOf(this.animationName) > -1 ? this.animationName : this.animationNames[0];
}

UIDragonBones.prototype.getDuration = UIDragonBones.prototype.getAnimationDuration = function(animaName) {
	if(!this.armature) return 0;

	animaName = animaName || this.animationName;

	var index = this.armature.animation.animationList.indexOf(animaName);
	if(index > -1) {
		return this.armature.animation.animationDataList[index].duration;
	}

	return 0;
}

UIDragonBones.prototype.paintSelfOnly = function(canvas) {
	if(this.armature) {
		if(!this.isPaused()) {
			var dt = (canvas.timeStep * this.animTimeScale)/1000;
			this.armature.advanceTime(dt);
		}

		var x = this.w >> 1;
		var y = this.h >> 1;
		canvas.save();
		var scaleX = (this.animationScaleX) === 1 ? 1.01 : this.animationScaleX;
		var scaleY = (this.animationScaleY) === 1 ? 1.01 : this.animationScaleY;

        MainContext.instance.setObjectContainer(this.armature.display);
		MainContext.instance.setScale(scaleX, scaleY);
		MainContext.instance.setPosition(x, y);
		MainContext.instance.renderLoop(canvas);
		canvas.restore();

		canvas.needRedraw++;
	}

	return;
}

function UISkeletonAnimationCreator(type) {
	var args = [type, type, null, 1];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIDragonBones();
		return g.initUIDragonBones(this.type, 200, 200);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UISkeletonAnimationCreator("ui-dragonbones"));
ShapeFactoryGet().addShapeCreator(new UISkeletonAnimationCreator("ui-skeleton-animation"));

/*
 * File:   ui-particles.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  particles
 *
 * Copyright (c) 2014 - 2015  Li XianJing <xianjimli@hotmail.com>
 * Copyright (c) 2015 - 2016 Holaverse Inc.
 *
 */

/**
 * @class UIParticlesX
 * @extends UIElement
 * 粒子产生器。
 *
 *注意：
 *
 * 1.系统在载入粒子配置的文件的时候，默认读取配置文件内指定的图片名称，该图片必须和配置文件在同一目录下。
 *
 * 2.用我们官方指定的粒子编辑器生成的是一个json文件，该文件默认已经包含了图片资源。用其他工具生成的粒子有配置文件和图片文件。
 *
 * 3.特殊属性，选择资源的时候只需要指定plist或者json文件即可，不必指定图片文件，引擎会去读取。
 */
function UIParticlesX() {
	return;
}

UIParticlesX.prototype = new UIElement();
UIParticlesX.prototype.isUIParticlesX = true;
UIParticlesX.prototype.saveProps = ["dataURL", "textureURL"];

UIParticlesX.prototype.initUIParticlesX = function(type) {
	this.initUIElement(type);
	this.name = "ui-particles";
	this.autoEmit = true;
	this.paused = false;
	this.setDefSize(200, 200);
	this.setTextType(Shape.TEXT_NONE);
	this.setImage(UIElement.IMAGE_DEFAULT, null);
	this.images.display = UIElement.IMAGE_DISPLAY_CENTER;

	return this;
}

UIParticlesX.prototype.setEmitterPosition = function(x, y) {
	return this;
}

UIParticlesX.prototype.onFromJsonDone = function() {

	return this;
}

/**
 * @method emit
 * 发射粒子。
 * @param {Boolean} once 是否子发射一次。
 * @return {UIElement} 返回控件本身。
 *
 *     @example small frame
 *     this.win.find("ui-particles-general").emit(true);
 *
 */
UIParticlesX.prototype.emit = function(once) {
	this.particles.emit(once);
	return this;
}

/**
 * @method start
 * 启动粒子产生器，除非调用了stop，一般不需手工调用它。
 * 如果对已经启动的粒子编辑器调用该接口，系统会清空当前粒子编辑器状态，并重新生成。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.start = function() {
	this.particles.reset();
	return this;
}

/**
 * @method stop
 * 调用该接口，粒子发射器将不再发射新的粒子，已经发射的粒子会随着生命周期的结束而消失。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.stop = function() {
	this.particles.stop();
	return this;
}

/**
 * @method pause
 * 暂停。调用该接口，相当于一个时间停滞的效果，粒子发射器将暂停发射新的粒子，已经发射的粒子停留在该时刻的状态。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.pause = function() {
	this.paused = true;
	return this;
}

/**
 * @method resume
 * 恢复。恢复粒子发射、更新粒子状态。
 * @return {UIElement} 返回控件本身。
 *
 */
UIParticlesX.prototype.resume = function() {
	this.paused = false;

	return this;
}

UIParticlesX.prototype.loadPList = function(options, texture) {
	this.particles = new ParticleEmitter();
	this.particles.init(options);
	this.particles.setTexture(texture);

	return;
}

UIParticlesX.prototype.onInit = function() {
	var me = this;
	var options = null;

	if(this.dataURL) {
		ResLoader.loadData(this.dataURL, function(data) {
			try {
                options = JSON.parse(data);
			}
			catch(err) {
				var plist = new PList();
				options = plist.parse(data);
                if(options.textureFileName) {
                    me.textureURL = me.dataURL.substring(0, me.dataURL.lastIndexOf('/')+1) + options.textureFileName;
                }
			}

			delete me.particles;

			var url =  options.imageData || me.textureURL;
            if(url) {
                ResLoader.loadImage(url, function(img) {
                    if(img.width === 0 || img.height === 0) {
                        console.debug("particlesx invalid img");
                        return;
                    }
                    me.loadPList(options, img);
                });
			}
		});
	}

	return;
}

UIParticlesX.prototype.drawBgImage = function() {
	return;
}

UIParticlesX.prototype.setDataURL = function(url) {
	if(url === this.dataURL || !url) return;
	this.dataURL = url;
    if(/\.json$/.test(url)) {
        this.saveProps = ['dataURL'];
    }
    else {
	    this.textureURL = url.substring(0, url.lastIndexOf('.')+1) + 'png';
    }
	this.onInit();
}

UIParticlesX.prototype.getDataURL = function() {
	return this.dataURL;
}

UIParticlesX.prototype.drawParticle = function(canvas) {
	var paused = this.timeScaleIsZero() || this.paused || (this.isInDesignMode() && this.disablePreview);
	if(!paused) {
		this.particles.update(canvas.timeStep/1000);
	}

	this.particles.setScaleX(this.scaleX);
	this.particles.setScaleY(this.scaleY);

	this.particles.draw(canvas);
}

UIParticlesX.prototype.paintSelfOnly = function(canvas) {
	if(this.particles) {
		canvas.needRedraw++;
		canvas.save();
		canvas.translate(this.w/2, this.h/2);
		this.drawParticle(canvas);
		canvas.restore();
	}

	return;
}

UIParticlesX.prototype.shapeCanBeChild = function(shape) {
	return false;
}

function UIParticlesXCreator() {
	var args = ["ui-particles-x", "ui-particles-x", null, 1];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UIParticlesX();
		return g.initUIParticlesX(this.type);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UIParticlesXCreator());
void function() {

function pMultIn(point, factor) {
	point.x *= factor;
	point.y *= factor;
}

function pIn(p1, p2) {
	p1.x = p2.x;
	p1.y = p2.y;
}

function pAddIn(p1, p2) {
	p1.x += p2.x;
	p1.y += p2.y;
}

function pSubIn(p1, p2) {
	p1.x -= p2.x;
	p1.y -= p2.y;
}

function pNormalizeIn(p) {
	pMultIn(p, 1.0 / Math.sqrt(p.x * p.x + p.y * p.y));
}

function pZeroIn(p) {
	p.x = 0;
	p.y = 0;
}

function Point(x, y) {
	if(!(this instanceof Point)) {
		return new Point(x, y);	
	}
	this.x = x;
	this.y = y;
}

function Color(r, g, b, a) {
	if(!(this instanceof Color)) {
		return new Color(r, g, b, a);	
	}
	this.r = r;
	this.g = g;
	this.b = b;
	this.a = a;
}

function Rect(x, y, w, h) {
	if(!(this instanceof Rect)) {
		return new Rect(x, y, w, h);
	}

	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
}

function pointInMatrix(point, transform) {
	var x = point.x,
		y = point.y,
		a = transform.a,
		b = transform.b,
		c = transform.c,
		d = transform.d,
		tx = transform.tx,
		ty = transform.ty;

	return {x: a*x + c*y + tx, y: b*x + d*y + ty};
}

var ONE_RAD = Math.PI/180;
function angleToRadians(angle) {
	return ONE_RAD*angle;	
}

function randomMinus1To1() {
	return (Math.random() - 0.5) * 2;
}

function Clampf(val, min, max) {
	if(min > max) {
		var tmp = min;
		min = max;
		max = min;
	}

	return val < min ? min : val > max ? max : val;
}

var ONE 	  = 1;
var SRC_ALPHA = 0x0302;
var BLEND_DST = 0x0303;

function Particle() {
	//粒子坐标浮动值
	this.pos = Point(0, 0);
	//粒子起始坐标
	this.startPos = Point(0, 0);
	//粒子最终绘制的坐标
	this.drawPos = Point(0, 0);
	this.color = Color(0, 0, 0, 255);
	this.deltaColor = Color(0, 0, 0, 255);
	//重力模式
	this.modeA = new Particle.ParamsGravity();
	//半径模式
	this.modeB = new Particle.ParamsRadius();
	this.size = 0;
	this.deltaSize = 0;
	this.rotation = 0;
	this.deltaRotation = 0;
	this.timeToLive = 0;
	this.isChangeColor = false;
}

Particle.TemporaryPoints = [
	Point(0, 0),
	Point(0, 0),
	Point(0, 0),
	Point(0, 0)
];

////////////////////////////////////////////////////////////////////////////////
Particle.ModeGravity = function(speed, speedVar, gravityX, gravityY, radialAccel, 
	radialAccelVar, tangentialAccel, tangentialAccelVar, rotationIsDir) {
	//粒子初速度
	this.speed = speed;
	//粒子初速度浮值
	this.speedVar = speedVar;
	this.gravity = {x: gravityX, y: gravityY};
	this.radialAccel = radialAccel;
	this.radialAccelVar = radialAccelVar;
	this.tangentialAccel = tangentialAccel;
	this.tangentialAccelVar = tangentialAccelVar;
	this.rotationIsDir = rotationIsDir;
}

Particle.ModeGravity.prototype.randomFeatures = function(randians, particle) {
	var params = particle.modeA;
	//速度
	var speed = this.speed + this.speedVar * randomMinus1To1();
	//方向
	params.dir.x = Math.cos(randians);
	params.dir.y = Math.sin(randians);
	pMultIn(params.dir, speed);
	//径向加速度
	params.radialAccel = this.radialAccel + this.radialAccelVar * randomMinus1To1();
	//切向加速度
	params.tangentialAccel = this.tangentialAccel + this.tangentialAccelVar * randomMinus1To1();
}

Particle.ParamsGravity = function(p, radialAccel, tangentialAccel) {
	this.dir = p || Point(0, 0);
	this.radialAccel = radialAccel;
	this.tangentialAccel = tangentialAccel;
}

///////////////////////////////////////////////////////////////////////////////
Particle.ModeRadius = function(startRadius, startRadiusVar, endRadius,
	endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
	this.startRadius = startRadius;
	this.startRadiusVar = startRadiusVar;
	this.endRadius = endRadius;
	this.endRadiusVar = endRadiusVar;

	this.rotatePerSecond = rotatePerSecond;
	this.rotatePerSecondVar = rotatePerSecondVar;
}

Particle.ModeRadius.prototype.randomFeatures = function(randians, particle) {
	var params = particle.modeB;
	var startRadius = this.startRadius + this.startRadiusVar * randomMinus1To1();
	var endRadius = this.endRadius + this.endRadiusVar * randomMinus1To1();

	params.angle = randians;
	params.radius = startRadius;
	params.deltaRadius = (endRadius - startRadius) / particle.timeToLive;
	params.anglePerSecond = angleToRadians(this.rotatePerSecond + this.rotatePerSecondVar * randomMinus1To1());
}

Particle.ParamsRadius = function(angle, anglePerSecond, radius, deltaRadius) {
	//粒子旋转角度
	this.angle = angle;
	//粒子运动半径
	this.radius = radius || 0; 
	//粒子运动半径增量
	this.deltaRadius = deltaRadius || 0;
	//粒子旋转角速度
	this.anglePerSecond = anglePerSecond || 0;
}

////////////////////////////////////////////////////////////////////////////////
function ParticleEmitter(opts) {
	this.emitMode = 0;
	this.duration = 0;
	this.emitRate = 0;
	this.timeCounter = 0;
	//发射器原始坐标
	this.srcPos = Point(0, 0);
	//发射器坐标浮动值
	this.srcPosVar = Point(0, 0);
	this.angle = 0;
	this.angleVar = 0;
	this.maxParticles = 0;
	this.isRemoveOnFinish = false;
	this.particles = [];
	this.particleCounter = 0;

	this.positionType = ParticleEmitter.POS_TYPE_FREE;

	this.srcBlendFunc = 0;
	this.dstBlendFunc = 0;

	this.life = 0;
	this.lifeVar = 0;

	this.startSize = 0;
	this.startSizeVar = 0;
	this.endSize = 0;
	this.endSizeVar = 0;

	this.startColor = Color(0, 0, 0, 0);
	this.startColorVar = Color(0, 0, 0, 0);
	this.endColor = Color(0, 0, 0, 0);
	this.endColorVar = Color(0, 0, 0, 0);

	this.startSpin = 0;
	this.startSpinVar = 0;

	this.endSpin = 0;
	this.endSpinVar = 0;

	this.tmpZeroPoint = Point(0, 0);

	this.elapsed = 0;
	this.timeScale = 1;
	this.active = true;
	this.texture = null;

	this.scaleX = 1;
	this.scaleY = 1;

	this.transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
	this.worldTransform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};

	this.anchorPointInPoints = Point(0, 0);
}

ParticleEmitter.POS_TYPE_FREE 	 = 0;
ParticleEmitter.POS_TYPE_RELATIVE = 1;
ParticleEmitter.POS_TYPE_GROUPED  = 2;

ParticleEmitter.MODE_GRAVITY = 0;
ParticleEmitter.MODE_RADIUS  = 1;
ParticleEmitter.MODE_WIND	= 2;

function fetchProperty(opts, key, def) {
	return opts[key] != void 0 ? opts[key] : def;	
}

function renderToCache(image, cache) {
	var w = image.width;
    var h = image.height;

    cache[0].width = w;
    cache[0].height = h;
    cache[1].width = w;
    cache[1].height = h;
    cache[2].width = w;
    cache[2].height = h;
    cache[3].width = w;
    cache[3].height = h;

    var cacheCtx = cache[3].getContext("2d");
    cacheCtx.drawImage(image, 0, 0);
    var pixels = cacheCtx.getImageData(0, 0, w, h).data;

    var ctx;
    for(var rgbI = 0; rgbI < 4; rgbI++) {
        ctx = cache[rgbI].getContext("2d");

        var to = ctx.getImageData(0, 0, w, h);
        var data = to.data;
        for(var i = 0; i < pixels.length; i += 4) {
			data[i    ] = (rgbI === 0) ? pixels[i    ] : 0;
            data[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
            data[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
            data[i + 3] = pixels[i + 3];
		}
        ctx.putImageData(to, 0, 0);
	}
    image.onload = null;
}

ParticleEmitter.prototype.parseModeGravity = function(opts) {
	return new Particle.ModeGravity(
		parseFloat(fetchProperty(opts, "speed")),
		parseFloat(fetchProperty(opts, "speedVariance")),
		parseFloat(fetchProperty(opts, "gravityx")),
		parseFloat(fetchProperty(opts, "gravityy")),
		parseFloat(fetchProperty(opts, "radialAcceleration")),
		parseFloat(fetchProperty(opts, "radialAccelVariance")),
		parseFloat(fetchProperty(opts, "tangentialAcceleration")),
		parseFloat(fetchProperty(opts, "tangentialAccelVariance")),
		(fetchProperty(opts, "rotationIsDir", false))
	);
}

ParticleEmitter.prototype.parseModeRadius = function(opts) {
	return new Particle.ModeRadius(
		parseFloat(fetchProperty(opts, "maxRadius")),
		parseFloat(fetchProperty(opts, "maxRadiusVariance")),
		parseFloat(fetchProperty(opts, "minRadius")),
		0,
		parseFloat(fetchProperty(opts, "rotatePerSecond")),
		parseFloat(fetchProperty(opts, "rotatePerSecondVariance"))
	);
}

ParticleEmitter.prototype.init = function(opts) {
	this.maxParticles = parseInt(fetchProperty(opts, 'maxParticles', 0));

	for(var i = 0; i < this.maxParticles; i++) {
		this.particles.push(new Particle());
	}

	//emitter angle
	this.angle = parseInt(fetchProperty(opts, 'angle', 0));
	this.angleVar = parseInt(fetchProperty(opts, 'angleVariance', 0));

	//emitter duration
	this.duration = parseInt(fetchProperty(opts, 'duration', 0));
	this.backDuration = this.duration;

	//blend function
	this.srcBlendFunc = parseInt(fetchProperty(opts, 'blendFuncSource', 0));
	this.dstBlendFunc = parseInt(fetchProperty(opts, 'blendFuncDestination', 0));

	//particle color
    this.startColor.r = parseFloat(fetchProperty(opts, "startColorRed")) * 255;
    this.startColor.g = parseFloat(fetchProperty(opts, "startColorGreen")) * 255;
    this.startColor.b = parseFloat(fetchProperty(opts, "startColorBlue")) * 255;
    this.startColor.a = parseFloat(fetchProperty(opts, "startColorAlpha")) * 255;

    this.startColorVar.r = parseFloat(fetchProperty(opts, "startColorVarianceRed")) * 255;
    this.startColorVar.g = parseFloat(fetchProperty(opts, "startColorVarianceGreen")) * 255;
    this.startColorVar.b = parseFloat(fetchProperty(opts, "startColorVarianceBlue")) * 255;
    this.startColorVar.a = parseFloat(fetchProperty(opts, "startColorVarianceAlpha")) * 255;

    this.endColor.r = parseFloat(fetchProperty(opts, "finishColorRed")) * 255;
    this.endColor.g = parseFloat(fetchProperty(opts, "finishColorGreen")) * 255;
    this.endColor.b = parseFloat(fetchProperty(opts, "finishColorBlue")) * 255;
    this.endColor.a = parseFloat(fetchProperty(opts, "finishColorAlpha")) * 255;

    this.endColorVar.r = parseFloat(fetchProperty(opts, "finishColorVarianceRed")) * 255;
    this.endColorVar.g = parseFloat(fetchProperty(opts, "finishColorVarianceGreen")) * 255;
    this.endColorVar.b = parseFloat(fetchProperty(opts, "finishColorVarianceBlue")) * 255;
    this.endColorVar.a = parseFloat(fetchProperty(opts, "finishColorVarianceAlpha")) * 255;

    // particle size
    this.startSize = parseFloat(fetchProperty(opts, "startParticleSize"));
    this.startSizeVar = parseFloat(fetchProperty(opts, "startParticleSizeVariance"));
    this.endSize = parseFloat(fetchProperty(opts, "finishParticleSize"));
    this.endSizeVar = parseFloat(fetchProperty(opts, "finishParticleSizeVariance"));

    //emitter position
    this.srcPos.x = parseFloat(fetchProperty(opts, "sourcePositionx"));
    this.srcPos.y = parseFloat(fetchProperty(opts, "sourcePositiony"));
	this.srcPosVar.x = parseFloat(fetchProperty(opts, "sourcePositionVariancex"));
    this.srcPosVar.y = parseFloat(fetchProperty(opts, "sourcePositionVariancey"));
	
	//particle spining
	this.startSpin = parseFloat(fetchProperty(opts, "rotationStart"));
	this.startSpinVar = parseFloat(fetchProperty(opts, "rotationStartVariance"));
	this.endSpin = parseFloat(fetchProperty(opts, "rotationEnd"));
	this.endSpinVar = parseFloat(fetchProperty(opts, "rotationEndVariance"));

	//particle life span
	this.life = parseFloat(fetchProperty(opts, "particleLifespan"));
	this.lifeVar = parseFloat(fetchProperty(opts, "particleLifespanVariance"));

	//emitter rate
	this.emitRate = this.maxParticles / this.life;

	this.isRemoveOnFinish = fetchProperty(opts, "isAutoRemoveOnFinish", false);

	//emitter mode
	this.emitMode = parseFloat(fetchProperty(opts, "emitterType"));

	this.imageData = fetchProperty(opts, "imageData", null) ||
		fetchProperty(opts, "textureImageData", null);

	if(this.imageData) {
		var image = new Image();
		image.src = this.imageData;
		this.setTexture(image);
	}

	if(this.emitMode === ParticleEmitter.MODE_GRAVITY) {
		this.mode = this.parseModeGravity(opts);
	}
	else {
		this.mode = this.parseModeRadius(opts);
	}
}

ParticleEmitter.prototype.setScaleX = function(scaleX) {
	this.scaleX = scaleX;
	return this;
}

ParticleEmitter.prototype.setScaleY = function(scaleY) {
	this.scaleY = scaleY;
	return this;
}

ParticleEmitter.prototype.emit = function(once) {
	this.reset();
	if(once) {
		if("backDuration" in this) {
			this.duration = this.backDuration;
		}
		if(this.duration === -1) {
			this.duration = 1;
		}
	}
	else {
		if("backDuration" in this) {
			this.backDuration = this.duration;
		}
		this.duration = -1;
	}
}

ParticleEmitter.prototype.reset = function() {
	this.active = true;
	this.elapsed = 0;

	if("backDuration" in this) {
		this.duration = this.backDuration;
	}
	var particles = this.particles;
	for(var i = 0; i < particles.length; i++) {
		particles[i].timeToLive = 0;
	}
}

ParticleEmitter.prototype.reload = function(opts) {
	this.stop();
	this.init(opts);
	this.start();
}

ParticleEmitter.prototype.pause = function() {
	this.timeScale = 0;
	return this;
}

ParticleEmitter.prototype.resume = function() {
	this.timeScale = 1;
	return this;
}

ParticleEmitter.prototype.start = function() {
	this.reset();
	return this;
}

ParticleEmitter.prototype.stop = function() {
	if("backDuration" in this) {
		this.duration = this.backDuration;
	}
	this.active = false;
	this.elapsed = this.duration; 
	this.timeCounter = 0;

	return this;
}

ParticleEmitter.prototype.setTexture = function(texture) {
	if(texture === this.texture) return;

	this.texture = texture;
	//renderToCache(this.texture, this.tintCaches);
	this.textureRect = Rect(0, 0, texture.width, texture.height);

	return this;
}

ParticleEmitter.prototype.getWorldTransform = function() {
	var t = this.transform;	
	var a = 1, b = 0, c = 0, d = 1;

	t.tx = this.srcPos.x;
	t.ty = this.srcPos.y;

	t.a = a;
	t.b = b;
	t.c = c;
	t.d = d;

	var scaleX = this.scaleX, scaleY = this.scaleY;
	var appX = this.anchorPointInPoints.x, appY = this.anchorPointInPoints.y;

	scaleX = (scaleX < 0.000001 && scaleX > -0.000001) ? 0.000001 : scaleX;
	scaleY = (scaleY < 0.000001 && scaleY > -0.000001) ? 0.000001 : scaleY;
	
	if(scaleX !== 1 || scaleY !== 1) {
		a = t.a *= scaleX;
		b = t.b *= scaleX;
		c = t.c *= scaleY;
		d = t.d *= scaleY;
	}

	t.tx -= a * appX + c * appY;
	t.ty -= b * appX + d * appY;

	return this.transform;
}

ParticleEmitter.prototype.convertToWorldSpace = function(point) {
	return pointInMatrix(point, this.getWorldTransform());		
}

ParticleEmitter.prototype.initParticle = function(particle) {
	//timeToLive
	particle.timeToLive = this.life + this.lifeVar*randomMinus1To1();	
	particle.timeToLive = Math.max(0, particle.timeToLive);

	//position
	particle.pos.x = this.srcPosVar.x*randomMinus1To1();	
	particle.pos.y = this.srcPosVar.y*randomMinus1To1();	

	//color
	var startColor = {
		r: Clampf(this.startColor.r + this.startColorVar.r*randomMinus1To1(), 0, 255),
		g: Clampf(this.startColor.g + this.startColorVar.g*randomMinus1To1(), 0, 255),
		b: Clampf(this.startColor.b + this.startColorVar.b*randomMinus1To1(), 0, 255),
		a: Clampf(this.startColor.a + this.startColorVar.a*randomMinus1To1(), 0, 255)
	};
	var endColor = {
		r: Clampf(this.endColor.r + this.endColorVar.r*randomMinus1To1(), 0, 255),
		g: Clampf(this.endColor.g + this.endColorVar.g*randomMinus1To1(), 0, 255),
		b: Clampf(this.endColor.b + this.endColorVar.b*randomMinus1To1(), 0, 255),
		a: Clampf(this.endColor.a + this.endColorVar.a*randomMinus1To1(), 0, 255)
	};
	particle.color = startColor;	
	particle.deltaColor = {
		r: (endColor.r - startColor.r)/particle.timeToLive,
		g: (endColor.g - startColor.g)/particle.timeToLive,
		b: (endColor.b - startColor.b)/particle.timeToLive,
		a: (endColor.a - startColor.a)/particle.timeToLive
	};

	//size
	var startSize = this.startSize + this.startSizeVar * randomMinus1To1();
	var endSize = this.endSize + this.endSizeVar * randomMinus1To1();
	particle.size = Math.max(0, startSize);
	particle.deltaSize = (endSize - startSize) / particle.timeToLive;

	//rotation
	var startA = this.startSpin + this.startSpinVar * randomMinus1To1();
	var end = this.endSpin + this.endSpinVar * randomMinus1To1();
	particle.rotation = startA;
	particle.deltaRotation = (end - startA) / particle.timeToLive;

	//position
	if(this.positionType === ParticleEmitter.POS_TYPE_FREE) {
		particle.startPos = this.convertToWorldSpace(this.tmpZeroPoint);	
	}
	else if(this.positionType === ParticleEmitter.POS_TYPE_RELATIVE) {
		particle.startPos.x = this.srcPos.x;
		particle.startPos.y = this.srcPos.y;
	}

	//direction
	var randians = angleToRadians(this.angle + this.angleVar*randomMinus1To1());

	this.mode.randomFeatures(randians, particle);
}

ParticleEmitter.prototype.isFull = function() {
	return this.particleCounter >= this.maxParticles;
}

ParticleEmitter.prototype.addParticle = function() {
	if(!this.isFull()) {
		var particle = null;

		if(this.particleCounter < this.particles.length) {
			particle = this.particles[this.particleCounter];
		}
		else {
			particle = new Particle();
			this.particles.push(particle);
		}
		this.initParticle(particle);
		++this.particleCounter;	
	}
}

ParticleEmitter.prototype.updateParticles = function(dt) {
	var currentPosition = Particle.TemporaryPoints[0];
	
	if(this.positionType === ParticleEmitter.POS_TYPE_FREE) {
		pIn(currentPosition, this.convertToWorldSpace(this.tmpZeroPoint));
	}
	else if(this.positionType === ParticleEmitter.TYPE_RELATIVE) {
		currentPosition.x = this.srcPos.x;
		currentPosition.y = this.srcPos.y;
	}

	var	particle = null,
		particleIndex = 0,
		particles = this.particles,
		tpa = Particle.TemporaryPoints[1],
		tpb = Particle.TemporaryPoints[2],
		tpc = Particle.TemporaryPoints[3];

	while(particleIndex < this.particleCounter) {
		pZeroIn(tpa);
		pZeroIn(tpb);
		pZeroIn(tpc);

		particle = particles[particleIndex];
		particle.timeToLive -= dt;

		if(particle.timeToLive > 0) {
			if(this.emitMode === ParticleEmitter.MODE_GRAVITY) {
				var tmp = tpc, radial = tpa, tangential = tpb;		

				//radial acceleration
				if(particle.pos.x || particle.pos.y) {
					pIn(radial, particle.pos);
					//计算加速度
					pNormalizeIn(radial);
				}
				else {
					pZeroIn(radial);
				}
				pIn(tangential, radial);
				pMultIn(radial, particle.modeA.radialAccel);

				//tangential acceleration
				var newy = tangential.x;
				tangential.x = -tangential.y;
				tangential.y = newy;

				pMultIn(tangential, particle.modeA.tangentialAccel);

				pIn(tmp, radial);
				pAddIn(tmp, tangential);
				pAddIn(tmp, this.mode.gravity);
				pMultIn(tmp, dt);
				pAddIn(particle.modeA.dir, tmp);

				pIn(tmp, particle.modeA.dir);
				pMultIn(tmp, dt);
				pAddIn(particle.pos, tmp);
			}
			else {
				var modeB = particle.modeB;
				modeB.angle += modeB.anglePerSecond * dt;
				modeB.radius += modeB.deltaRadius * dt;

				particle.pos.x = -Math.cos(modeB.angle) * modeB.radius;
				particle.pos.y = -Math.sin(modeB.angle) * modeB.radius;
			}
			//color
			particle.color.r += particle.deltaColor.r * dt;
			particle.color.g += particle.deltaColor.g * dt;
			particle.color.b += particle.deltaColor.b * dt;
			particle.color.a += particle.deltaColor.a * dt;
			particle.isChangeColor = false;
			//size
			particle.size += (particle.deltaSize * dt);
			particle.size = Math.max(0, particle.size);
			//rotation
			particle.rotation += (particle.deltaRotation * dt);
			//position
			var newPos = tpa;
			if(this.positionType === ParticleEmitter.POS_TYPE_FREE
				|| this.positionType === ParticleEmitter.POS_TYPE_RELATIVE) {
				var diff = tpb;

				pIn(diff, currentPosition);
				pSubIn(diff, particle.startPos);

				pIn(newPos, particle.pos);
				pSubIn(newPos, diff);
			}
			else {
				pIn(newPos, particle.pos);	
			}

			pIn(particle.drawPos, newPos);
			++particleIndex;
		}
		else {
			//life < 0
			if(particleIndex !== this.particleCounter - 1) {
				var deadParticle = 	
				particles[particleIndex] = particles[this.particleCounter - 1];
				particles[this.particleCounter - 1] = particle;
			}
			--this.particleCounter;
		}
	}

	return;
}

ParticleEmitter.prototype.update = function(dt) {
	var emitLimit = 1.0/this.emitRate;

	dt*=this.timeScale;

	if(this.active) {
		if(this.particleCounter < this.maxParticles) {
			this.timeCounter += dt;	
		}

		while(this.particleCounter < this.maxParticles 
			&& this.timeCounter > emitLimit) {
			this.addParticle();
			this.timeCounter -= emitLimit;
		}
		this.elapsed += dt;
		if(this.duration !== -1 && this.duration <= this.elapsed) {
			this.stop();
		}
	}

	this.updateParticles(dt);
}

ParticleEmitter.prototype.setTransform = function(context, t) {
	//why
	context.transform(t.a, -t.b, -t.c, t.d, t.tx * this.scaleX, -(t.ty * this.scaleY));
}

ParticleEmitter.prototype.isBlendAdditive = function() {
	//why
	return ((this.srcBlendFunc === SRC_ALPHA && this.dstBlendFunc === ONE)
		|| (this.srcBlendFunc === ONE && this.dstBlendFunc === ONE));
}

ParticleEmitter.prototype.changeTextureColor = function(texture, color, rect) {
    if(!this.tintCache) {
	    this.tintCache = document.createElement("canvas");
    }
	var canvas = this.tintCache;
	var context = canvas.getContext("2d");

	canvas.width = texture.width;
	canvas.height = texture.height;
	context.globalCompositeOperation = "source-over";
	context.fillStyle = "rgb(" + (color.r|0) + "," + (color.g|0) + "," + (color.b|0) + ")";
	context.fillRect(0, 0, rect.w, rect.h);
	context.globalCompositeOperation = "multiply";
	context.drawImage(texture, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
	context.globalCompositeOperation = "destination-atop";
	context.drawImage(texture, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);

	return canvas;
}

ParticleEmitter.prototype.draw = function(context) {
	var texture = this.texture,
		particles = this.particles,
		textureRect = this.textureRect,
		particleCounter = this.particleCounter;

	context.save();	
	this.setTransform(context, this.worldTransform);
	if(this.isBlendAdditive()) {
		context.globalCompositeOperation = 'lighter';
	}
	else {
		context.globalCompositeOperation = 'source-over';
	}

	//assert texture mode
	var particle, lpx, alpha, size, 
		w = textureRect.w, h = textureRect.h;
	for (var i = 0; i < particleCounter; i++) {
		particle = particles[i];
		lpx = (0 | (particle.size * 0.5));
		alpha = particle.color.a / 255;
		if(alpha === 0) continue;

		context.globalAlpha = alpha;
		context.save();
		context.translate((0 | particle.drawPos.x), -(0 | particle.drawPos.y));

		size = Math.floor(particle.size / 4) * 4;
		context.scale(Math.max((1 / w) * size, 0.000001), Math.max((1 / h) * size, 0.000001));

		if(particle.rotation) {
			context.rotate(angleToRadians(particle.rotation));
		}

		var dstTexture = particle.isChangeColor ? 
			this.changeTextureColor(texture, particle.color, textureRect) : texture;

		context.drawImage(dstTexture, -(0 | (w / 2)), -(0 | (h / 2)));
		context.restore();
	}
	context.restore();
}

window.ParticleEmitter = ParticleEmitter;

}();
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * @namespace PIXI.spine
 */
module.exports = spine = {
    Spine:          require('./Spine'),
    SpineRuntime:   require('./SpineRuntime'),
    mesh:           require('./mesh/'),
    //loaders:        require('./loaders')
    Texture:        require('./texture/Texture.js'),
    BaseTexture:    require('./texture/BaseTexture.js'),
    Sprite: require('./sprites/Sprite.js'),
    Container: require('./display/Container.js'),
    CanvasRenderer: require('./renderers/canvas/CanvasRenderer.js')
};

global.PIXI = {
    VERSION: '3.0.11'
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Spine":3,"./SpineRuntime":45,"./display/Container.js":54,"./mesh/":59,"./renderers/canvas/CanvasRenderer.js":61,"./sprites/Sprite.js":63,"./texture/BaseTexture.js":64,"./texture/Texture.js":65}],2:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} [once=false] Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Hold the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],3:[function(require,module,exports){
var spine = require('../SpineRuntime');
var mesh  = require('../mesh/');
var Matrix = require('../SpineUtil/Matrix.js');
var utils = require('../utils.js');
var Sprite = require('../sprites/Sprite.js');
var Texture = require('../texture/Texture.js');
var Container = require('../display/Container.js');
//var atlasParser = require('../loaders/atlasParser');

/* Esoteric Software SPINE wrapper for pixi.js */
spine.Bone.yDown = true;

/**
 * A class that enables the you to import and run your spine animations in pixi.
 * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 *
 * ```js
 * var spineAnimation = new PIXI.Spine(spineData);
 * ```
 *
 * @class
 * @extends Container
 * @memberof spine
 * @param spineData {object} The spine data loaded from a spine atlas.
 */
function Spine(spineData)
{
    Container.call(this);

    if (!spineData)
    {
        throw new Error('The spineData param is required.');
    }

    if ((typeof spineData) === "string")
    {
        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
    }

    /**
     * The spineData object
     *
     * @member {object}
     */
    this.spineData = spineData;

    /**
     * A spine Skeleton object
     *
     * @member {object}
     */
    this.skeleton = new spine.Skeleton(spineData);
    this.skeleton.updateWorldTransform();

    /**
     * A spine AnimationStateData object created from the spine data passed in the constructor
     *
     * @member {object}
     */
    this.stateData = new spine.AnimationStateData(spineData);

    /**
     * A spine AnimationState object created from the spine AnimationStateData object
     *
     * @member {object}
     */
    this.state = new spine.AnimationState(this.stateData);

    /**
     * An array of containers
     *
     * @member {Container[]}
     */
    this.slotContainers = [];

    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)
    {
        var slot = this.skeleton.slots[i];
        var attachment = slot.attachment;
        var slotContainer = new Container();
        this.slotContainers.push(slotContainer);
        this.addChild(slotContainer);

        if (attachment instanceof spine.RegionAttachment)
        {
            var spriteName = attachment.rendererObject.name;
            var sprite = this.createSprite(slot, attachment);
            slot.currentSprite = sprite;
            slot.currentSpriteName = spriteName;
            slotContainer.addChild(sprite);
        }
        else if (attachment instanceof spine.MeshAttachment)
        {
            var mesh = this.createMesh(slot, attachment);
            slot.currentMesh = mesh;
            slot.currentMeshName = attachment.name;
            slotContainer.addChild(mesh);
        }
        else
        {
            continue;
        }

    }

    /**
     * Should the Spine object update its transforms
     *
     * @member {boolean}
     */
    this.autoUpdate = true;
}

Spine.fromAtlas = function(resourceName) {
    var skeletonData = atlasParser.AnimCache[resourceName];

    if (!skeletonData)
    {
        throw new Error('Spine data "' + resourceName + '" does not exist in the animation cache');
    }

    return new Spine(skeletonData);
}

Spine.prototype = Object.create(Container.prototype);
Spine.prototype.constructor = Spine;
module.exports = Spine;

Spine.globalAutoUpdate = false;

Object.defineProperties(Spine.prototype, {
    /**
     * If this flag is set to true, the spine animation will be autoupdated every time
     * the object id drawn. The down side of this approach is that the delta time is
     * automatically calculated and you could miss out on cool effects like slow motion,
     * pause, skip ahead and the sorts. Most of these effects can be achieved even with
     * autoupdate enabled but are harder to achieve.
     *
     * @member {boolean}
     * @memberof Spine#
     * @default true
     */
    autoUpdate: {
        get: function ()
        {
            return (this.updateTransform === Spine.prototype.autoUpdateTransform);
        },

        set: function (value)
        {
            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : Container.prototype.updateTransform;
        }
    }
});

/**
 * Update the spine skeleton and its animations by delta time (dt)
 *
 * @param dt {number} Delta time. Time by which the animation should be updated
 */
Spine.prototype.update = function (dt)
{
    this.state.update(dt);
    this.state.apply(this.skeleton);
    this.skeleton.updateWorldTransform();

    var drawOrder = this.skeleton.drawOrder;
    var slots = this.skeleton.slots;

    for (var i = 0, n = drawOrder.length; i < n; i++)
    {
        this.children[i] = this.slotContainers[drawOrder[i]];
    }

    for (i = 0, n = slots.length; i < n; i++)
    {
        var slot = slots[i];
        var attachment = slot.attachment;
        var slotContainer = this.slotContainers[i];

        if (!attachment)
        {
            slotContainer.visible = false;
            continue;
        }

        var type = attachment.type;
        if (type === spine.AttachmentType.region)
        {
            if (attachment.rendererObject)
            {
                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)
                {
                    var spriteName = attachment.rendererObject.name;
                    if (slot.currentSprite !== undefined)
                    {
                        slot.currentSprite.visible = false;
                    }
                    slot.sprites = slot.sprites || {};
                    if (slot.sprites[spriteName] !== undefined)
                    {
                        slot.sprites[spriteName].visible = true;
                    }
                    else
                    {
                        var sprite = this.createSprite(slot, attachment);
                        slotContainer.addChild(sprite);
                    }
                    slot.currentSprite = slot.sprites[spriteName];
                    slot.currentSpriteName = spriteName;
                }
            }

            if (slotContainer.transform ) {
                var transform = slotContainer.transform;
                var lt;
                if (slotContainer.transform.matrix2d) {
                    //gameofbombs pixi fork
                    lt = transform.matrix2d;
                    transform._dirtyVersion++;
                    transform.version = transform._dirtyVersion;
                    transform.isStatic = true;
                    transform.operMode = 0;
                } else
                if (PIXI.TransformManual) {
                    //PIXI v4.0
                    if (transform.position) {
                        transform = new PIXI.TransformManual();
                        slotContainer.transform = transform;
                    }
                    lt = transform.localTransform;
                } else {
                    //PIXI v4.0rc
                    if (!transform._dirtyLocal) {
                        transform = new PIXI.TransformStatic();
                        slotContainer.transform = transform;
                    }
                    lt = transform.localTransform;
                    transform._dirtyParentVersion = -1;
                    transform._dirtyLocal = 1;
                    transform._versionLocal = 1;
                }
                slot.bone.matrix.copy(lt);
                lt.tx += slot.bone.skeleton.x;
                lt.ty += slot.bone.skeleton.y;
            } else {
                //PIXI v3
                var lt = slotContainer.localTransform || new Matrix();
                slot.bone.matrix.copy(lt);
                lt.tx += slot.bone.skeleton.x;
                lt.ty += slot.bone.skeleton.y;
                slotContainer.localTransform = lt;
                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;
            }

            slot.currentSprite.blendMode = slot.blendMode;
            slot.currentSprite.tint = utils.rgb2hex([slot.r * attachment.r, slot.g * attachment.g, slot.b * attachment.b]);
        }
        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)
        {
            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)
            {
                var meshName = attachment.name;
                if (slot.currentMesh !== undefined)
                {
                    slot.currentMesh.visible = false;
                }

                slot.meshes = slot.meshes || {};

                if (slot.meshes[meshName] !== undefined)
                {
                    slot.meshes[meshName].visible = true;
                }
                else
                {
                    var mesh = this.createMesh(slot, attachment);
                    slotContainer.addChild(mesh);
                }

                slot.currentMesh = slot.meshes[meshName];
                slot.currentMeshName = meshName;
            }
            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);
            if (PIXI.VERSION[0] !== '3') {
                // PIXI version 4
                slot.currentMesh.dirty = true;
            }
        }
        else
        {
            slotContainer.visible = false;
            continue;
        }
        slotContainer.visible = true;

        slotContainer.alpha = slot.a;
    }
};

/**
 * When autoupdate is set to yes this function is used as pixi's updateTransform function
 *
 * @private
 */
Spine.prototype.autoUpdateTransform = function ()
{
    if (Spine.globalAutoUpdate) {
        this.lastTime = this.lastTime || Date.now();
        var timeDelta = (Date.now() - this.lastTime) * 0.001;
        this.lastTime = Date.now();
        this.update(timeDelta);
    } else {
        this.lastTime = 0;
    }

    Container.prototype.updateTransform.call(this);
};

/**
 * Create a new sprite to be used with spine.RegionAttachment
 *
 * @param slot {spine.Slot} The slot to which the attachment is parented
 * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
 * @private
 */
Spine.prototype.createSprite = function (slot, attachment)
{
    var descriptor = attachment.rendererObject;
    var texture = descriptor.texture;
    var sprite = new Sprite(texture);
    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;
    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;
    sprite.rotation = attachment.rotation * spine.degRad;
    sprite.anchor.x = 0.5;
    sprite.anchor.y = 0.5;
    sprite.position.x = attachment.x;
    sprite.position.y = attachment.y;
    sprite.alpha = attachment.a;

    slot.sprites = slot.sprites || {};
    slot.sprites[descriptor.name] = sprite;
    return sprite;
};

/**
 * Creates a Strip from the spine data
 * @param slot {spine.Slot} The slot to which the attachment is parented
 * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
 * @private
 */
Spine.prototype.createMesh = function (slot, attachment)
{
    var descriptor = attachment.rendererObject;
    var baseTexture = descriptor.page.rendererObject;
    var texture = new Texture(baseTexture);

    var strip = new mesh.Mesh(
        texture,
        new Float32Array(attachment.uvs.length),
        new Float32Array(attachment.uvs),
        new Uint16Array(attachment.triangles),
        mesh.Mesh.DRAW_MODES.TRIANGLES);

    strip.canvasPadding = 1.5;

    strip.alpha = attachment.a;

    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.name] = strip;

    return strip;
};

/**
 * Changes texture in attachment in specific slot.
 *
 * PIXI runtime feature, it was made to satisfy our users.
 *
 * @param slotName {string}
 * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
 * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
 * @returns {boolean} Success flag
 */
Spine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {
    var slot = this.skeleton.slots[slotIndex];
    if (!slot) {
        return false;
    }
    var attachment = slot.attachment;
    if (!attachment || !attachment.hackRegion) {
        return false;
    }
    var region = null;
    if (texture) {
        region = new spine.AtlasRegion();
        region.texture = texture;
        region.size = size;
    }

    attachment.hackRegion(region);
    var descriptor = attachment.rendererObject;
    if (slot.currentSprite) {
        var sprite = slot.currentSprite;
        sprite.texture = descriptor.texture;
        sprite.scale.x = attachment.width / descriptor.originalWidth;
        sprite.scale.y = - attachment.height / descriptor.originalHeight;
    }
    if (slot.currentMesh) {
        var mesh = slot.currentMesh;
        mesh.texture = descriptor.texture;
        for (var i = 0; i < attachment.uvs.length; i++) {
            mesh.uvs[i] = attachment.uvs[i];
        }
        if (PIXI.VERSION[0] !== '3') {
            // PIXI version 4
            mesh.indexDirty = true;
        } else {
            // PIXI version 3
            mesh.dirty = true;
        }
    }
    return true;
};

/**
 * Changes texture in attachment in specific slot.
 *
 * PIXI runtime feature, it was made to satisfy our users.
 *
 * @param slotName {string}
 * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
 * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
 * @returns {boolean} Success flag
 */
Spine.prototype.hackTextureBySlotName = function(slotName, texture, size) {
    var index = this.skeleton.findSlotIndex(slotName);
    if (index == -1) {
        return false;
    }
    return this.hackTextureBySlotIndex(index,texture, size);
};

function SlotContainerUpdateTransformV3()
{
    var pt = this.parent.worldTransform;
    var wt = this.worldTransform;
    var lt = this.localTransform;
    wt.a  = lt.a  * pt.a + lt.b  * pt.c;
    wt.b  = lt.a  * pt.b + lt.b  * pt.d;
    wt.c  = lt.c  * pt.a + lt.d  * pt.c;
    wt.d  = lt.c  * pt.b + lt.d  * pt.d;
    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    this._currentBounds = null;
};

},{"../SpineRuntime":45,"../SpineUtil/Matrix.js":47,"../display/Container.js":54,"../mesh/":59,"../sprites/Sprite.js":63,"../texture/Texture.js":65,"../utils.js":67}],4:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = function (name, timelines, duration)
{
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
};
spine.Animation.prototype = {
    apply: function (skeleton, lastTime, time, loop, events)
    {
        if (loop && this.duration != 0)
        {
            time %= this.duration;
            lastTime %= this.duration;
        }
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, lastTime, time, events, 1);
    },
    mix: function (skeleton, lastTime, time, loop, events, alpha)
    {
        if (loop && this.duration != 0)
        {
            time %= this.duration;
            lastTime %= this.duration;
        }
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, lastTime, time, events, alpha);
    }
};
spine.Animation.binarySearch = function (values, target, step)
{
    var low = 0;
    var high = Math.floor(values.length / step) - 2;
    if (!high) return step;
    var current = high >>> 1;
    while (true)
    {
        if (values[(current + 1) * step] <= target)
            low = current + 1;
        else
            high = current;
        if (low == high) return (low + 1) * step;
        current = (low + high) >>> 1;
    }
};
spine.Animation.binarySearch1 = function (values, target)
{
    var low = 0;
    var high = values.length - 2;
    if (!high) return 1;
    var current = high >>> 1;
    while (true)
    {
        if (values[current + 1] <= target)
            low = current + 1;
        else
            high = current;
        if (low == high) return low + 1;
        current = (low + high) >>> 1;
    }
};
spine.Animation.linearSearch = function (values, target, step)
{
    for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target) return i;
    return -1;
};
module.exports = spine.Animation;

},{"../SpineUtil":52}],5:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.TrackEntry = require('./TrackEntry');
spine.AnimationState = function (stateData)
{
    this.data = stateData;
    this.tracks = [];
    this.events = [];
};
spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function (delta)
    {
        delta *= this.timeScale;
        for (var i = 0; i < this.tracks.length; i++)
        {
            var current = this.tracks[i];
            if (!current) continue;

            current.time += delta * current.timeScale;
            if (current.previous)
            {
                var previousDelta = delta * current.previous.timeScale;
                current.previous.time += previousDelta;
                current.mixTime += previousDelta;
            }

            var next = current.next;
            if (next)
            {
                next.time = current.lastTime - next.delay;
                if (next.time >= 0) this.setCurrent(i, next);
            } else {
                // End non-looping animation when it reaches its end time and there is no next entry.
                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);
            }
        }
    },
    apply: function (skeleton)
    {
        skeleton.resetDrawOrder();

        for (var i = 0; i < this.tracks.length; i++)
        {
            var current = this.tracks[i];
            if (!current) continue;

            this.events.length = 0;

            var time = current.time;
            var lastTime = current.lastTime;
            var endTime = current.endTime;
            var loop = current.loop;
            if (!loop && time > endTime) time = endTime;

            var previous = current.previous;
            if (!previous)
            {
                if (current.mix == 1)
                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
                else
                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);
            } else {
                var previousTime = previous.time;
                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;
                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);

                var alpha = current.mixTime / current.mixDuration * current.mix;
                if (alpha >= 1)
                {
                    alpha = 1;
                    current.previous = null;
                }
                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
            }

            for (var ii = 0, nn = this.events.length; ii < nn; ii++)
            {
                var event = this.events[ii];
                if (current.onEvent) current.onEvent(i, event);
                if (this.onEvent) this.onEvent(i, event);
            }

            // Check if completed the animation or a loop iteration.
            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))
            {
                var count = Math.floor(time / endTime);
                if (current.onComplete) current.onComplete(i, count);
                if (this.onComplete) this.onComplete(i, count);
            }

            current.lastTime = current.time;
        }
    },
    clearTracks: function ()
    {
        for (var i = 0, n = this.tracks.length; i < n; i++)
            this.clearTrack(i);
        this.tracks.length = 0;
    },
    clearTrack: function (trackIndex)
    {
        if (trackIndex >= this.tracks.length) return;
        var current = this.tracks[trackIndex];
        if (!current) return;

        if (current.onEnd) current.onEnd(trackIndex);
        if (this.onEnd) this.onEnd(trackIndex);

        this.tracks[trackIndex] = null;
    },
    _expandToIndex: function (index)
    {
        if (index < this.tracks.length) return this.tracks[index];
        while (index >= this.tracks.length)
            this.tracks.push(null);
        return null;
    },
    setCurrent: function (index, entry)
    {
        var current = this._expandToIndex(index);
        if (current)
        {
            var previous = current.previous;
            current.previous = null;

            if (current.onEnd) current.onEnd(index);
            if (this.onEnd) this.onEnd(index);

            entry.mixDuration = this.data.getMix(current.animation, entry.animation);
            if (entry.mixDuration > 0)
            {
                entry.mixTime = 0;
                // If a mix is in progress, mix from the closest animation.
                if (previous && current.mixTime / current.mixDuration < 0.5)
                    entry.previous = previous;
                else
                    entry.previous = current;
            }
        }

        this.tracks[index] = entry;

        if (entry.onStart) entry.onStart(index);
        if (this.onStart) this.onStart(index);
    },
    setAnimationByName: function (trackIndex, animationName, loop)
    {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        return this.setAnimation(trackIndex, animation, loop);
    },
    /** Set the current animation. Any queued animations are cleared. */
    setAnimation: function (trackIndex, animation, loop)
    {
        var entry = new spine.TrackEntry();
        entry.animation = animation;
        entry.loop = loop;
        entry.endTime = animation.duration;
        this.setCurrent(trackIndex, entry);
        return entry;
    },
    addAnimationByName: function (trackIndex, animationName, loop, delay)
    {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        return this.addAnimation(trackIndex, animation, loop, delay);
    },
    /** Adds an animation to be played delay seconds after the current or last queued animation.
     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
    addAnimation: function (trackIndex, animation, loop, delay)
    {
        var entry = new spine.TrackEntry();
        entry.animation = animation;
        entry.loop = loop;
        entry.endTime = animation.duration;

        var last = this._expandToIndex(trackIndex);
        if (last)
        {
            while (last.next)
                last = last.next;
            last.next = entry;
        } else
            this.tracks[trackIndex] = entry;

        if (delay <= 0)
        {
            if (last)
                delay += last.endTime - this.data.getMix(last.animation, animation);
            else
                delay = 0;
        }
        entry.delay = delay;

        return entry;
    },
    /**
     * Returns true if animation exists in skeleton data
     * @param animationName
     * @returns {boolean}
     */
    hasAnimationByName: function (animationName)
    {
        var animation = this.data.skeletonData.findAnimation(animationName);
        return animation !== null;
    },
    /** May be null. */
    getCurrent: function (trackIndex)
    {
        if (trackIndex >= this.tracks.length) return null;
        return this.tracks[trackIndex];
    }
};
module.exports = spine.AnimationState;


},{"../SpineUtil":52,"./TrackEntry":39}],6:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AnimationStateData = function (skeletonData)
{
    this.skeletonData = skeletonData;
    this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function (fromName, toName, duration)
    {
        var from = this.skeletonData.findAnimation(fromName);
        if (!from) throw "Animation not found: " + fromName;
        var to = this.skeletonData.findAnimation(toName);
        if (!to) throw "Animation not found: " + toName;
        this.setMix(from, to, duration);
    },
    setMix: function (from, to, duration)
    {
        this.animationToMixTime[from.name + ":" + to.name] = duration;
    },
    getMix: function (from, to)
    {
        var key = from.name + ":" + to.name;
        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;
    }
};
module.exports = spine.AnimationStateData;


},{"../SpineUtil":52}],7:[function(require,module,exports){
var spine = require('../SpineUtil');
var Texture = require('../texture/Texture.js');
var Rectangle = require('../SpineUtil/Rectangle.js');
spine.AtlasReader = require('./AtlasReader');
spine.AtlasPage = require('./AtlasPage');
spine.AtlasRegion = require('./AtlasRegion');
//var syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')

spine.Atlas = function(atlasText, loaderFunction, callback) {
    this.pages = [];
    this.regions = [];
    if (typeof atlasText === "string") {
        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);
    }
};

spine.Atlas.prototype = {
    addTexture: function(name, texture) {
        var pages = this.pages;
        var page = null;
        for (var i=0;i<pages.length;i++) {
            if (pages[i].rendererObject === texture.baseTexture) {
                page = pages[i];
                break;
            }
        }
        if (page === null) {
            page = new spine.AtlasPage();
            page.name = 'texturePage';
            var baseTexture = texture.baseTexture;
            page.width = baseTexture.realWidth;
            page.height = baseTexture.realHeight;
            page.rendererObject = baseTexture;
            //those fields are not relevant in Pixi
            page.format = 'RGBA8888';
            page.minFilter = page.magFilter = "Nearest";
            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
            pages.push(page);
        }
        var region = new spine.AtlasRegion();
        region.name = name;
        region.page = page;
        region.texture = texture;
        region.index = -1;
        this.regions.push(region);
        return region;
    },
    addTextureHash: function(textures, stripExtension) {
        for (var key in textures) {
            if (textures.hasOwnProperty(key)) {
                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);
            }
        }
    },
    addSpineAtlas: function (atlasText, loaderFunction, callback)
    {
        //TODO: remove this legacy later
        if (typeof loaderFunction !== "function") {
            //old syntax
            var baseUrl = loaderFunction;
            var crossOrigin = callback;
            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);
            callback = null;
        }

        this.texturesLoading = 0;

        var self = this;

        var reader = new spine.AtlasReader(atlasText);
        var tuple = [];
        tuple.length = 4;
        var page = null;

        iterateParser();

        function iterateParser() {
            while (true) {
                var line = reader.readLine();
                if (line === null) {
                    return callback && callback(self);
                }
                line = reader.trim(line);
                if (!line.length)
                    page = null;
                else if (!page) {
                    page = new spine.AtlasPage();
                    page.name = line;

                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.
                        page.width = parseInt(tuple[0]);
                        page.height = parseInt(tuple[1]);
                        reader.readTuple(tuple);
                    } else {
                        //old format, detect width and height by texture
                    }
                    page.format = spine.Atlas.Format[tuple[0]];

                    reader.readTuple(tuple);
                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

                    var direction = reader.readValue();
                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
                    if (direction == "x")
                        page.uWrap = spine.Atlas.TextureWrap.repeat;
                    else if (direction == "y")
                        page.vWrap = spine.Atlas.TextureWrap.repeat;
                    else if (direction == "xy")
                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

                    // @ivanpopelyshev: I so want to use generators and "yield()" here, or at least promises
                    loaderFunction(line, function (texture) {
                        page.rendererObject = texture;
                        if (!texture.hasLoaded) {
                            texture.width = page.width;
                            texture.height = page.height;
                        }
                        self.pages.push(page);
                        if (!page.width || !page.height) {
                            page.width = texture.realWidth;
                            page.height = texture.realHeight;
                            if (!page.width || !page.height) {
                                console.log("ERROR spine atlas page " + page.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)");
                            }
                        }
                        iterateParser();
                    });
                    break;
                } else {
                    var region = new spine.AtlasRegion();
                    region.name = line;
                    region.page = page;

                    var rotate = reader.readValue() === "true" ? 6 : 0;

                    reader.readTuple(tuple);
                    var x = parseInt(tuple[0]);
                    var y = parseInt(tuple[1]);

                    reader.readTuple(tuple);
                    var width = parseInt(tuple[0]);
                    var height = parseInt(tuple[1]);

                    var resolution = page.rendererObject.resolution;
                    x /= resolution;
                    y /= resolution;
                    width /= resolution;
                    height /= resolution;

                    var frame = new Rectangle(x, y, rotate ? height : width, rotate ? width : height);

                    if (reader.readTuple(tuple) == 4) { // split is optional
                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

                            reader.readTuple(tuple);
                        }
                    }

                    var originalWidth = parseInt(tuple[0]) / resolution;
                    var originalHeight = parseInt(tuple[1]) / resolution;
                    reader.readTuple(tuple);
                    var offsetX = parseInt(tuple[0]) / resolution;
                    var offsetY = parseInt(tuple[1]) / resolution;

                    var orig = new Rectangle(0, 0, originalWidth, originalHeight);
                    var trim = new Rectangle(offsetX, originalHeight - height - offsetY, width, height);

                    //TODO: pixiv3 uses different frame/crop/trim
                    //FIXME
                    // pixi v3.0.11
                    var frame2 = new Rectangle(x, y, width, height);
                    var crop = frame2.clone();
                    trim.width = originalWidth;
                    trim.height = originalHeight;
                    region.texture = new Texture(region.page.rendererObject, frame2, crop, trim, rotate);

                    region.index = parseInt(reader.readValue());
                    region.texture._updateUvs();

                    self.regions.push(region);
                }
            }
        }
    },
    findRegion: function (name)
    {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
            if (regions[i].name == name) return regions[i];
        return null;
    },
    dispose: function ()
    {
        var pages = this.pages;
        for (var i = 0, n = pages.length; i < n; i++)
            pages[i].rendererObject.destroy(true);
    },
    updateUVs: function (page)
    {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
        {
            var region = regions[i];
            if (region.page != page) continue;
            region.texture._updateUvs();
        }
    }
};

spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
};

spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
};
module.exports = spine.Atlas;

},{"../SpineUtil":52,"../SpineUtil/Rectangle.js":50,"../texture/Texture.js":65,"./AtlasPage":9,"./AtlasReader":10,"./AtlasRegion":11}],8:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.RegionAttachment = require('./RegionAttachment');
spine.MeshAttachment = require('./MeshAttachment');
spine.WeightedMeshAttachment = require('./WeightedMeshAttachment');
spine.BoundingBoxAttachment = require('./BoundingBoxAttachment');
spine.AtlasAttachmentParser = function (atlas)
{
    this.atlas = atlas;
};
spine.AtlasAttachmentParser.prototype = {
    newRegionAttachment: function (skin, name, path)
    {
        var region = this.atlas.findRegion(path);
        if (!region) throw "Region not found in atlas: " + path + " (region attachment: " + name + ")";
        var attachment = new spine.RegionAttachment(name);
        attachment.rendererObject = region;
        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
        attachment.regionOffsetX = region.offsetX;
        attachment.regionOffsetY = region.spineOffsetY;
        attachment.regionWidth = region.width;
        attachment.regionHeight = region.height;
        attachment.regionOriginalWidth = region.originalWidth;
        attachment.regionOriginalHeight = region.originalHeight;
        return attachment;
    },
    newMeshAttachment: function (skin, name, path)
    {
        var region = this.atlas.findRegion(path);
        if (!region) throw "Region not found in atlas: " + path + " (mesh attachment: " + name + ")";
        var attachment = new spine.MeshAttachment(name);
        attachment.rendererObject = region;
        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));
        return attachment;
    },
    newWeightedMeshAttachment: function (skin, name, path)
    {
        var region = this.atlas.findRegion(path);
        if (!region) throw "Region not found in atlas: " + path + " (skinned mesh attachment: " + name + ")";
        var attachment = new spine.WeightedMeshAttachment(name);
        attachment.rendererObject = region;
        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));
        return attachment;
    },
    newBoundingBoxAttachment: function (skin, name)
    {
        return new spine.BoundingBoxAttachment(name);
    }
};
module.exports = spine.AtlasAttachmentParser;


},{"../SpineUtil":52,"./BoundingBoxAttachment":16,"./MeshAttachment":27,"./RegionAttachment":28,"./WeightedMeshAttachment":44}],9:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AtlasPage = function ()
{};
spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
};
module.exports = spine.AtlasPage;


},{"../SpineUtil":52}],10:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AtlasReader = function (text)
{
    this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
    index: 0,
    trim: function (value)
    {
        return value.replace(/^\s+|\s+$/g, "");
    },
    readLine: function ()
    {
        if (this.index >= this.lines.length) return null;
        return this.lines[this.index++];
    },
    readValue: function ()
    {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        return this.trim(line.substring(colon + 1));
    },
    /** Returns the number of tuple values read (1, 2 or 4). */
    readTuple: function (tuple)
    {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        var i = 0, lastMatch = colon + 1;
        for (; i < 3; i++)
        {
            var comma = line.indexOf(",", lastMatch);
            if (comma == -1) break;
            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
            lastMatch = comma + 1;
        }
        tuple[i] = this.trim(line.substring(lastMatch));
        return i + 1;
    }
};
module.exports = spine.AtlasReader;


},{"../SpineUtil":52}],11:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AtlasRegion = function ()
{};
spine.AtlasRegion.prototype = {
    name: null,
    /**
     * @member {Texture}
     */
    texture: null,

    /**
     * @member {spine.Spine.AtlasPage}
     */
    page: null,
    index: 0,
    splits: null,
    pads: null
};

Object.defineProperties(spine.AtlasRegion.prototype, {
    x: {
        get: function() {
            return this.texture.frame.x;
        }
    },
    y: {
        get: function() {
            return this.texture.frame.y;
        }
    },
    width: {
        get: function() {
            var tex = this.texture;
            //FIXME
            return tex.crop.width;
        }
    },
    height: {
        get: function() {
            var tex = this.texture;
            //FIXME
            return tex.crop.height;
        }
    },
    u: {
        get: function() {
            return this.texture._uvs.x0;
        }
    },
    v: {
        get: function() {
            return this.texture._uvs.y0;
        }
    },
    u2: {
        get: function() {
            return this.texture._uvs.x2;
        }
    },
    v2: {
        get: function() {
            return this.texture._uvs.y2;
        }
    },
    rotate: {
        get: function() {
            return !!this.texture.rotate;
        }
    },
    offsetX: {
        get: function() {
            var tex = this.texture;
            return tex.trim ? tex.trim.x : 0;
        }
    },
    offsetY: {
        get: function() {
            console.warn("Deprecation Warning: @Hackerham: I guess, if you are using SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.");
            return this.spineOffsetY;
        }
    },
    pixiOffsetY: {
        get: function() {
            var tex = this.texture;
            return tex.trim ? tex.trim.y : 0;
        }
    },
    spineOffsetY: {
        get: function() {
            var tex = this.texture;
            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
        }
    },
    originalWidth: {
        get: function() {
            var tex = this.texture;
            //FIXME
            if (tex.trim) {
                return tex.trim.width;
            }
            return tex.crop.width;
        }
    },
    originalHeight: {
        get: function() {
            var tex = this.texture;
            //FIXME
            if (tex.trim) {
                return tex.trim.height;
            }
            return tex.crop.height;
        }
    }
});

module.exports = spine.AtlasRegion;


},{"../SpineUtil":52}],12:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Curves = require('./Curves');
spine.Animation = require('./Animation');
spine.AttachmentTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.attachmentNames = [];
    this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length;
    },
    setFrame: function (frameIndex, time, attachmentName)
    {
        this.frames[frameIndex] = time;
        this.attachmentNames[frameIndex] = attachmentName;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0])
        {
            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
            return;
        } else if (lastTime > time) //
            lastTime = -1;

        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;
        if (frames[frameIndex] < lastTime) return;

        var attachmentName = this.attachmentNames[frameIndex];
        skeleton.slots[this.slotIndex].setAttachment(
            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
    }
};
module.exports = spine.AttachmentTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],13:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AttachmentType = {
    region: 0,
    boundingbox: 1,
    mesh: 2,
    weightedmesh : 3,
    skinnedmesh: 3,
    linkedmesh: 4,
    weightedlinkedmesh: 5
};
module.exports = spine.AttachmentType;


},{"../SpineUtil":52}],14:[function(require,module,exports){
var spine = require('../SpineUtil');
var Matrix = require('../SpineUtil/Matrix.js');


spine.Bone = function (boneData, skeleton, parent)
{
    this.data = boneData;
    this.skeleton = skeleton;
    this.parent = parent;
    this.matrix = new Matrix();
    this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
    x: 0, y: 0,
    rotation: 0, rotationIK: 0,
    scaleX: 1, scaleY: 1,
    shearX: 0, shearY: 0,
    flipX: false, flipY: false,

    worldSignX: 1, worldSignY: 1,
    update: function() {
        this.rotationIK = this.rotation;
        this.updateWorldTransform();
    },
    updateWorldTransform: function() {
        var rotation = this.rotationIK;
        var scaleX = this.scaleX;
        var scaleY = this.scaleY;
        var x = this.x;
        var y = this.y;
        var rotationX = rotation + this.shearX;
        var rotationY = rotation + 90 + this.shearY;

        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,
            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;
        var parent = this.parent;
        var m = this.matrix;
        var skeleton = this.skeleton;
        if (!parent) { // Root bone.
            if (skeleton.flipX) {
                x = -x;
                la = -la;
                lb = -lb;
            }
            if (skeleton.flipY !== spine.Bone.yDown) {
                y = -y;
                lc = -lc;
                ld = -ld;
            }
            m.a = la;
            m.c = lb;
            m.b = lc;
            m.d = ld;
            m.tx = x;
            m.ty = y;
            this.worldSignX = spine.signum(scaleX);
            this.worldSignY = spine.signum(scaleY);
            return;
        }


        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
        m.tx = pa * x + pb * y + parent.matrix.tx;
        m.ty = pc * x + pd * y + parent.matrix.ty;
        this.worldSignX = parent.worldSignX * spine.signum(scaleX);
        this.worldSignY = parent.worldSignY * spine.signum(scaleY);
        var data = this.data;

        if (data.inheritRotation && data.inheritScale) {
            m.a = pa * la + pb * lc;
            m.c = pa * lb + pb * ld;
            m.b = pc * la + pd * lc;
            m.d = pc * lb + pd * ld;
        } else {
            if (data.inheritRotation) { // No scale inheritance.
                pa = 1;
                pb = 0;
                pc = 0;
                pd = 1;
                do {
                    cos = Math.cos(parent.rotationIK * spine.degRad);
                    sin = Math.sin(parent.rotationIK * spine.degRad);
                    var temp = pa * cos + pb * sin;
                    pb = pa * -sin + pb * cos;
                    pa = temp;
                    temp = pc * cos + pd * sin;
                    pd = pc * -sin + pd * cos;
                    pc = temp;

                    if (!parent.data.inheritRotation) break;
                    parent = parent.parent;
                } while (parent != null);
                m.a = pa * la + pb * lc;
                m.c = pa * lb + pb * ld;
                m.b = pc * la + pd * lc;
                m.d = pc * lb + pd * ld;
            } else if (data.inheritScale) { // No rotation inheritance.
                pa = 1;
                pb = 0;
                pc = 0;
                pd = 1;
                do {
                    var r = parent.rotationIK;
                    cos = Math.cos(r * spine.degRad);
                    sin = Math.sin(r * spine.degRad);
                    var psx = parent.scaleX, psy = parent.scaleY;
                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;
                    temp = pa * za + pb * zc;
                    pb = pa * zb + pb * zd;
                    pa = temp;
                    temp = pc * za + pd * zc;
                    pd = pc * zb + pd * zd;
                    pc = temp;

                    if (psx < 0) {
                        r = -r;
                    } else {
                        sin = -sin;
                    }
                    temp = pa * cos + pb * sin;
                    pb = pa * -sin + pb * cos;
                    pa = temp;
                    temp = pc * cos + pd * sin;
                    pd = pc * -sin + pd * cos;
                    pc = temp;

                    if (!parent.data.inheritScale) break;
                    parent = parent.parent;
                } while (parent != null);
                m.a = pa * la + pb * lc;
                m.c = pa * lb + pb * ld;
                m.b = pc * la + pd * lc;
                m.d = pc * lb + pd * ld;
            } else {
                m.a = la;
                m.c = lb;
                m.b = lc;
                m.d = ld;
            }
            if (skeleton.flipX) {
                m.a = -m.a;
                m.c = -m.c;
            }
            if (skeleton.flipY !== spine.Bone.yDown) {
                m.b = -m.b;
                m.d = -m.d;
            }
        }
    },

    setToSetupPose: function ()
    {
        var data = this.data;
        this.x = data.x;
        this.y = data.y;
        this.rotation = data.rotation;
        this.rotationIK = this.rotation;
        this.scaleX = data.scaleX;
        this.scaleY = data.scaleY;
        this.shearX = data.shearX;
        this.shearY = data.shearY;
    },
    worldToLocal: function (world)
    {
        var m = this.matrix;
        var dx = world[0] - m.tx, dy = m.ty;
        var invDet = 1 / (m.a * m.d - m.b * m.c);
        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544
        world[0] = dx * m.a * invDet - dy * m.c * invDet;
        world[1] = dy * m.d * invDet - dx * m.b * invDet;
    },
    localToWorld: function (local)
    {
        var localX = local[0], localY = local[1];
        var m = this.matrix;
        local[0] = localX * m.a + localY * m.c + m.tx;
        local[1] = localX * m.b + localY * m.d + m.ty;
    },
    getWorldRotationX: function() {
        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;

    },
    getWorldRotationY: function() {
        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;
    },
    getWorldScaleX: function() {
        var a = this.matrix.a;
        var b = this.matrix.b;
        return Math.sqrt(a*a+b*b);
    },
    getWorldScaleY: function() {
        var c = this.matrix.c;
        var d = this.matrix.d;
        return Math.sqrt(c * c + d * d);
    }
};

Object.defineProperties(spine.Bone.prototype, {
    worldX: {
        get: function() {
            return this.matrix.tx;
        }
    },
    worldY:  {
        get: function() {
            return this.matrix.ty;
        }
    }
});

module.exports = spine.Bone;

},{"../SpineUtil":52,"../SpineUtil/Matrix.js":47}],15:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.BoneData = function (name, parent)
{
    this.name = name;
    this.parent = parent;
};
spine.BoneData.prototype = {
    length: 0,
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    shearX: 0, shearY: 0,
    inheritScale: true,
    inheritRotation: true
};
module.exports = spine.BoneData;


},{"../SpineUtil":52}],16:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AttachmentType = require('./AttachmentType');
spine.BoundingBoxAttachment = function (name)
{
    this.name = name;
    this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function (x, y, bone, worldVertices)
    {
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;
        var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2)
        {
            var px = vertices[i];
            var py = vertices[i + 1];
            worldVertices[i] = px * m00 + py * m01 + x;
            worldVertices[i + 1] = px * m10 + py * m11 + y;
        }
    }
};
module.exports = spine.BoundingBoxAttachment;


},{"../SpineUtil":52,"./AttachmentType":13}],17:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.ColorTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, r, g, b, a, ...
    this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 5;
    },
    setFrame: function (frameIndex, time, r, g, b, a)
    {
        frameIndex *= 5;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = r;
        this.frames[frameIndex + 2] = g;
        this.frames[frameIndex + 3] = b;
        this.frames[frameIndex + 4] = a;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var r, g, b, a;
        if (time >= frames[frames.length - 5])
        {
            // Time is after last frame.
            var i = frames.length - 1;
            r = frames[i - 3];
            g = frames[i - 2];
            b = frames[i - 1];
            a = frames[i];
        } else {
            // Interpolate between the previous frame and the current frame.
            var frameIndex = spine.Animation.binarySearch(frames, time, 5);
            var prevFrameR = frames[frameIndex - 4];
            var prevFrameG = frames[frameIndex - 3];
            var prevFrameB = frames[frameIndex - 2];
            var prevFrameA = frames[frameIndex - 1];
            var frameTime = frames[frameIndex];
            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);
            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;
            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;
            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;
            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;
        }
        var slot = skeleton.slots[this.slotIndex];
        if (alpha < 1)
        {
            slot.r += (r - slot.r) * alpha;
            slot.g += (g - slot.g) * alpha;
            slot.b += (b - slot.b) * alpha;
            slot.a += (a - slot.a) * alpha;
        } else {
            slot.r = r;
            slot.g = g;
            slot.b = b;
            slot.a = a;
        }
    }
};
module.exports = spine.ColorTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],18:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Curves = function (frameCount)
{
    this.curves = []; // type, x, y, ...
    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;
};
spine.Curves.prototype = {
    setLinear: function (frameIndex)
    {
        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;
    },
    setStepped: function (frameIndex)
    {
        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;
    },
    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
     * the difference between the keyframe's values. */
    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)
    {
        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;
        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;
        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;
        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;
        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;
        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;

        var i = frameIndex * 19/*BEZIER_SIZE*/;
        var curves = this.curves;
        curves[i++] = 2/*BEZIER*/;

        var x = dfx, y = dfy;
        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)
        {
            curves[i] = x;
            curves[i + 1] = y;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            x += dfx;
            y += dfy;
        }
    },
    getCurvePercent: function (frameIndex, percent)
    {
        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
        var curves = this.curves;
        var i = frameIndex * 19/*BEZIER_SIZE*/;
        var type = curves[i];
        if (type === 0/*LINEAR*/) return percent;
        if (type == 1/*STEPPED*/) return 0;
        i++;
        var x = 0;
        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)
        {
            x = curves[i];
            if (x >= percent)
            {
                var prevX, prevY;
                if (i == start)
                {
                    prevX = 0;
                    prevY = 0;
                } else {
                    prevX = curves[i - 2];
                    prevY = curves[i - 1];
                }
                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
            }
        }
        var y = curves[i - 1];
        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
    }
};
module.exports = spine.Curves;


},{"../SpineUtil":52}],19:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.DrawOrderTimeline = function (frameCount)
{
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.drawOrders = [];
    this.drawOrders.length = frameCount;
};
spine.DrawOrderTimeline.prototype = {
    getFrameCount: function ()
    {
        return this.frames.length;
    },
    setFrame: function (frameIndex, time, drawOrder)
    {
        this.frames[frameIndex] = time;
        this.drawOrders[frameIndex] = drawOrder;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var frameIndex;
        if (time >= frames[frames.length - 1]) // Time is after last frame.
            frameIndex = frames.length - 1;
        else
            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;

        var drawOrder = skeleton.drawOrder;
        var slots = skeleton.slots;
        var drawOrderToSetupIndex = this.drawOrders[frameIndex];
        if (drawOrderToSetupIndex)
        {
            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
            {
                drawOrder[i] = drawOrderToSetupIndex[i];
            }
        }

    }
};
module.exports = spine.DrawOrderTimeline;


},{"../SpineUtil":52,"./Animation":4}],20:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Event = function (data)
{
    this.data = data;
};
spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
};
module.exports = spine.Event;


},{"../SpineUtil":52}],21:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.EventData = function (name)
{
    this.name = name;
};
spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
};
module.exports = spine.EventData;


},{"../SpineUtil":52}],22:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.EventTimeline = function (frameCount)
{
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.events = [];
    this.events.length = frameCount;
};
spine.EventTimeline.prototype = {
    getFrameCount: function ()
    {
        return this.frames.length;
    },
    setFrame: function (frameIndex, time, event)
    {
        this.frames[frameIndex] = time;
        this.events[frameIndex] = event;
    },
    /** Fires events for frames > lastTime and <= time. */
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        if (!firedEvents) return;

        var frames = this.frames;
        var frameCount = frames.length;

        if (lastTime > time)
        { // Fire events after last time for looped animations.
            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
            lastTime = -1;
        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.
            return;
        if (time < frames[0]) return; // Time is before first frame.

        var frameIndex;
        if (lastTime < frames[0])
            frameIndex = 0;
        else
        {
            frameIndex = spine.Animation.binarySearch1(frames, lastTime);
            var frame = frames[frameIndex];
            while (frameIndex > 0)
            { // Fire multiple events with the same frame.
                if (frames[frameIndex - 1] != frame) break;
                frameIndex--;
            }
        }
        var events = this.events;
        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)
            firedEvents.push(events[frameIndex]);
    }
};
module.exports = spine.EventTimeline;


},{"../SpineUtil":52,"./Animation":4}],23:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.FfdTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount;
    this.frameVertices = [];
    this.frameVertices.length = frameCount;
};
spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function ()
    {
        return this.frames.length;
    },
    setFrame: function (frameIndex, time, vertices)
    {
        this.frames[frameIndex] = time;
        this.frameVertices[frameIndex] = vertices;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var slot = skeleton.slots[this.slotIndex];
        var slotAttachment = slot.attachment;
        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;

        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var frameVertices = this.frameVertices;
        var vertexCount = frameVertices[0].length;

        var vertices = slot.attachmentVertices;
        if (vertices.length != vertexCount) {
            vertices = slot.attachmentVertices = [];
            for (var k = 0; k < vertexCount; k++) vertices.push(0);
            // Don't mix from uninitialized slot vertices.
            alpha = 1;
        }

        if (time >= frames[frames.length - 1])
        { // Time is after last frame.
            var lastVertices = frameVertices[frames.length - 1];
            if (alpha < 1)
            {
                for (var i = 0; i < vertexCount; i++)
                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
            } else {
                for (var i = 0; i < vertexCount; i++)
                    vertices[i] = lastVertices[i];
            }
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch1(frames, time);
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));

        var prevVertices = frameVertices[frameIndex - 1];
        var nextVertices = frameVertices[frameIndex];

        if (alpha < 1)
        {
            for (var i = 0; i < vertexCount; i++)
            {
                var prev = prevVertices[i];
                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
            }
        } else {
            for (var i = 0; i < vertexCount; i++)
            {
                var prev = prevVertices[i];
                vertices[i] = prev + (nextVertices[i] - prev) * percent;
            }
        }
    }
};
module.exports = spine.FfdTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],24:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.IkConstraint = function (data, skeleton)
{
    this.data = data;
    this.mix = data.mix;
    this.bendDirection = data.bendDirection;

    this.bones = [];
    for (var i = 0, n = data.bones.length; i < n; i++)
        this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
};
spine.IkConstraint.prototype = {
    update: function() {
        this.apply();
    },
    apply: function ()
    {
        var target = this.target;
        var bones = this.bones;
        switch (bones.length)
        {
        case 1:
            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);
            break;
        case 2:
            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
            break;
        }
    }
};
/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
 * coordinate system. */
spine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)
{
    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;
    var rotation = bone.rotation;
    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;
    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;
    if (rotationIK > 180)
        rotationIK -= 360;
    else if (rotationIK < -180) rotationIK += 360;
    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;
    bone.updateWorldTransform();
};
/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
 * target is specified in the world coordinate system.
 * @param child Any descendant bone of the parent. */
spine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)
{
    if (alpha == 0) return;
    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;
    var offset1, offset2, sign2;
    if (psx < 0) {
        psx = -psx;
        offset1 = 180;
        sign2 = -1;
    } else {
        offset1 = 0;
        sign2 = 1;
    }
    if (psy < 0) {
        psy = -psy;
        sign2 = -sign2;
    }
    if (csx < 0) {
        csx = -csx;
        offset2 = 180;
    } else
        offset2 = 0;
    var pp = parent.parent;
    var ppm = pp.matrix;
    var tx, ty, dx, dy;
    if (pp == null) {
        tx = targetX - px;
        ty = targetY - py;
        dx = child.worldX - px;
        dy = child.worldY - py;
    } else {
        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);
        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;
        tx = (x * d - y * b) * invDet - px;
        ty = (y * a - x * c) * invDet - py;
        x = child.worldX - wx;
        y = child.worldY - wy;
        dx = (x * d - y * b) * invDet - px;
        dy = (y * a - x * c) * invDet - py;
    }
    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;
    outer:
        if (Math.abs(psx - psy) <= 0.0001) {
            l2 *= psx;
            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
            if (cos < -1)
                cos = -1;
            else if (cos > 1) cos = 1;
            a2 = Math.acos(cos) * bendDir;
            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);
            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);
        } else {
            cy = 0;
            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);
            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;
            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;
            var d = c1 * c1 - 4 * c2 * c0;
            if (d >= 0) {
                var q = Math.sqrt(d);
                if (c1 < 0) q = -q;
                q = -(c1 + q) / 2;
                var r0 = q / c2, r1 = c0 / q;
                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                if (r * r <= dd) {
                    var y = Math.sqrt(dd - r * r) * bendDir;
                    a1 = ta - Math.atan2(y, r);
                    a2 = Math.atan2(y / psy, (r - l1) / psx);
                    break outer;
                }
            }
            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;
            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
            var x = l1 + a, dist = x * x;
            if (dist > maxDist) {
                maxAngle = 0;
                maxDist = dist;
                maxX = x;
            }
            x = l1 - a;
            dist = x * x;
            if (dist < minDist) {
                minAngle = Math.PI;
                minDist = dist;
                minX = x;
            }
            var angle = Math.acos(-a * l1 / (aa - bb));
            x = a * Math.cos(angle) + l1;
            var y = b * Math.sin(angle);
            dist = x * x + y * y;
            if (dist < minDist) {
                minAngle = angle;
                minDist = dist;
                minX = x;
                minY = y;
            }
            if (dist > maxDist) {
                maxAngle = angle;
                maxDist = dist;
                maxX = x;
                maxY = y;
            }
            if (dd <= (minDist + maxDist) / 2) {
                a1 = ta - Math.atan2(minY * bendDir, minX);
                a2 = minAngle * bendDir;
            } else {
                a1 = ta - Math.atan2(maxY * bendDir, maxX);
                a2 = maxAngle * bendDir;
            }
        }
    var offset = Math.atan2(cy, child.x) * sign2;
    a1 = (a1 - offset) * spine.radDeg + offset1;
    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;
    if (a1 > 180)
        a1 -= 360;
    else if (a1 < -180) a1 += 360;
    if (a2 > 180)
        a2 -= 360;
    else if (a2 < -180) a2 += 360;
    var rotation = parent.rotation;
    parent.rotationIK = rotation + (a1 - rotation) * alpha;
    parent.updateWorldTransform();
    rotation = child.rotation;
    child.rotationIK = rotation + (a2 - rotation) * alpha;
    child.updateWorldTransform();
};
module.exports = spine.IkConstraint;


},{"../SpineUtil":52}],25:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.IkConstraintData = function (name)
{
    this.name = name;
    this.bones = [];
};
spine.IkConstraintData.prototype = {
    target: null,
    bendDirection: 1,
    mix: 1
};
module.exports = spine.IkConstraintData;


},{"../SpineUtil":52}],26:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.IkConstraintTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, mix, bendDirection, ...
    this.frames.length = frameCount * 3;
};
spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, mix, bendDirection)
    {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = mix;
        this.frames[frameIndex + 2] = bendDirection;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;
            ikConstraint.bendDirection = frames[frames.length - 1];
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch(frames, time, 3);
        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;
        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;
        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];
    }
};
module.exports = spine.IkConstraintTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],27:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.AttachmentType = require('./AttachmentType');
spine.MeshAttachment = function (name)
{
    this.name = name;
};
spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    parentMesh: null,
    inheritFFD: false,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1, g: 1, b: 1, a: 1,
    path: null,
    rendererObject: null,
    edges: null,
    width: 0, height: 0,
    updateUVs: function ()
    {
        var n = this.regionUVs.length;
        if (!this.uvs || this.uvs.length != n)
        {
            this.uvs = new spine.Float32Array(n);
        }
        var region = this.rendererObject;
        if (!region) return;
        var texture = region.texture;
        var r = texture._uvs;
        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;
        var x = region.offsetX, y = region.pixiOffsetY;
        for (var i = 0; i < n; i += 2)
        {
            var u = this.regionUVs[i], v = this.regionUVs[i+1];
            u = (u * w2 - x) / w1;
            v = (v * h2 - y) / h1;
            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;
            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;
        }
    },
    computeWorldVertices: function (x, y, slot, worldVertices)
    {
        var bone = slot.bone;
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;
        var vertices = this.vertices;
        var verticesCount = vertices.length;
        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;
        for (var i = 0; i < verticesCount; i += 2)
        {
            var vx = vertices[i];
            var vy = vertices[i + 1];
            worldVertices[i] = vx * m00 + vy * m01 + x;
            worldVertices[i + 1] = vx * m10 + vy * m11 + y;
        }
    },
    applyFFD: function(sourceAttachment) {
        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);
    },
    setParentMesh: function(parentMesh) {
        this.parentMesh = parentMesh;
        if (parentMesh != null) {
            this.vertices = parentMesh.vertices;
            this.regionUVs = parentMesh.regionUVs;
            this.triangles = parentMesh.triangles;
            this.hullLength = parentMesh.hullLength;
        }
    },
    hackRegion: function(newRegion) {
        if (!newRegion) {
            if (!this.oldRegion) return;
            newRegion = this.oldRegion;
        }
        if (!this.oldRegion) {
            this.oldRegion = this.rendererObject;
        }
        this.rendererObject = newRegion;
        this.updateUVs();
    }
};
module.exports = spine.MeshAttachment;


},{"../SpineUtil":52,"./AttachmentType":13}],28:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.AttachmentType = require('./AttachmentType');
spine.RegionAttachment = function (name)
{
    this.name = name;
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    width: 0, height: 0,
    r: 1, g: 1, b: 1, a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0, regionOffsetY: 0,
    regionWidth: 0, regionHeight: 0,
    regionOriginalWidth: 0, regionOriginalHeight: 0,
    setUVs: function (u, v, u2, v2, rotate)
    {
        var uvs = this.uvs;
        if (rotate)
        {
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v2;
            uvs[4/*X3*/] = u;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v;
            uvs[0/*X1*/] = u2;
            uvs[1/*Y1*/] = v2;
        } else {
            uvs[0/*X1*/] = u;
            uvs[1/*Y1*/] = v2;
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v;
            uvs[4/*X3*/] = u2;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v2;
        }
    },
    updateOffset: function ()
    {
        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
        var localX2 = localX + this.regionWidth * regionScaleX;
        var localY2 = localY + this.regionHeight * regionScaleY;
        var radians = this.rotation * spine.degRad;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        var localXCos = localX * cos + this.x;
        var localXSin = localX * sin;
        var localYCos = localY * cos + this.y;
        var localYSin = localY * sin;
        var localX2Cos = localX2 * cos + this.x;
        var localX2Sin = localX2 * sin;
        var localY2Cos = localY2 * cos + this.y;
        var localY2Sin = localY2 * sin;
        var offset = this.offset;
        offset[0/*X1*/] = localXCos - localYSin;
        offset[1/*Y1*/] = localYCos + localXSin;
        offset[2/*X2*/] = localXCos - localY2Sin;
        offset[3/*Y2*/] = localY2Cos + localXSin;
        offset[4/*X3*/] = localX2Cos - localY2Sin;
        offset[5/*Y3*/] = localY2Cos + localX2Sin;
        offset[6/*X4*/] = localX2Cos - localYSin;
        offset[7/*Y4*/] = localYCos + localX2Sin;
    },
    computeVertices: function (x, y, bone, vertices)
    {
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;
        var offset = this.offset;
        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
    },
    hackRegion: function(newRegion) {
        if (!newRegion) {
            if (!this.oldRegion) return;
            newRegion = this.oldRegion;
        }
        if (!this.oldRegion) {
            this.oldRegion = this.rendererObject;
            this.oldRegion.size = { width: this.width, height: this.height };
        }
        this.rendererObject = newRegion;
        if (newRegion.size) {
            this.width = newRegion.size.width;
            this.height = newRegion.size.height;
        }
    }
};
module.exports = spine.RegionAttachment;


},{"../SpineUtil":52,"./AttachmentType":13}],29:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.RotateTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, angle, ...
    this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 2;
    },
    setFrame: function (frameIndex, time, angle)
    {
        frameIndex *= 2;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = angle;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 2])
        { // Time is after last frame.
            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
            while (amount > 180)
                amount -= 360;
            while (amount < -180)
                amount += 360;
            bone.rotation += amount * alpha;
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch(frames, time, 2);
        var prevFrameValue = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        bone.rotation += amount * alpha;
    }
};
module.exports = spine.RotateTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],30:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.ScaleTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y)
    {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch(frames, time, 3);
        var prevFrameX = frames[frameIndex - 2];
        var prevFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;
        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;
    }
};
module.exports = spine.ScaleTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],31:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.ShearTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.ShearTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y)
    {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch(frames, time, 3);
        var prevFrameX = frames[frameIndex - 2];
        var prevFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;
    }
};
module.exports = spine.ShearTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],32:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Bone = require('./Bone');
spine.Slot = require('./Slot');
spine.IkConstraint = require('./IkConstraint');
spine.Skeleton = function (skeletonData)
{
    this.data = skeletonData;

    this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++)
    {
        var boneData = skeletonData.bones[i];
        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
        this.bones.push(new spine.Bone(boneData, this, parent));
    }

    this.slots = [];
    this.drawOrder = [];
    for (var i = 0, n = skeletonData.slots.length; i < n; i++)
    {
        var slotData = skeletonData.slots[i];
        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
        var slot = new spine.Slot(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(i);
    }

    this.ikConstraints = [];
    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)
        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));

    this.transformConstraints = [];
    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)
        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));

    this.boneCache = [];
    this.updateCache();
};
spine.Skeleton.prototype = {
    x: 0, y: 0,
    skin: null,
    r: 1, g: 1, b: 1, a: 1,
    time: 0,
    flipX: false, flipY: false,
    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */
    updateCache: function ()
    {
        var ikConstraints = this.ikConstraints;
        var ikConstraintsCount = ikConstraints.length;
        var transformConstraints = this.transformConstraints;
        var transformConstraintsCount = transformConstraints.length;

        var boneCache = this.boneCache;
        boneCache.length = 0;
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
        {
            var bone = bones[i];
            boneCache.push(bone);
            for (var j=0; j < transformConstraintsCount; j++) {
                if (transformConstraints[j].bone == bone) {
                    boneCache.push(transformConstraints[j]);
                }
            }
            for (var j=0; j < ikConstraintsCount; j++) {
                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {
                    boneCache.push(ikConstraints[j]);
                    break;
                }
            }
        }
    },
    /** Updates the world transform for each bone. */
    updateWorldTransform: function ()
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
        {
            var bone = bones[i];
            bone.rotationIK = bone.rotation;
        }
        var boneCache = this.boneCache;
        for (var i = 0, n = boneCache.length; i < n; i++) {
            boneCache[i].update();
        }
    },
    /** Sets the bones and slots to their setup pose values. */
    setToSetupPose: function ()
    {
        this.setBonesToSetupPose();
        this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function ()
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].setToSetupPose();

        var ikConstraints = this.ikConstraints;
        for (var i = 0, n = ikConstraints.length; i < n; i++)
        {
            var ikConstraint = ikConstraints[i];
            ikConstraint.bendDirection = ikConstraint.data.bendDirection;
            ikConstraint.mix = ikConstraint.data.mix;
        }

        var transformConstraints = this.transformConstraints;
        for (var i = 0, n = transformConstraints.length; i < n; i++)
        {
            var constraint = transformConstraints[i];
            var data = constraint.data;
            constraint.rotateMix = data.rotateMix;
            constraint.translateMix = data.translateMix;
            constraint.scaleMix = data.scaleMix;
            constraint.shearMix = data.shearMix;
        }
    },
    setSlotsToSetupPose: function ()
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
        {
            slots[i].setToSetupPose(i);
        }

        this.resetDrawOrder();
    },
    /** @return May return null. */
    getRootBone: function ()
    {
        return this.bones.length ? this.bones[0] : null;
    },
    /** @return May be null. */
    findBone: function (boneName)
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName)
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName)
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return slots[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName)
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return i;
        return -1;
    },
    setSkinByName: function (skinName)
    {
        var skin = this.data.findSkin(skinName);
        if (!skin) throw "Skin not found: " + skinName;
        this.setSkin(skin);
    },
    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was
     * no old skin, each slot's setup mode attachment is attached from the new skin.
     * @param newSkin May be null. */
    setSkin: function (newSkin)
    {
        if (newSkin)
        {
            if (this.skin)
                newSkin._attachAll(this, this.skin);
            else
            {
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                {
                    var slot = slots[i];
                    var name = slot.data.attachmentName;
                    if (name)
                    {
                        var attachment = newSkin.getAttachment(i, name);
                        if (attachment) slot.setAttachment(attachment);
                    }
                }
            }
        }
        this.skin = newSkin;
    },
    /** @return May be null. */
    getAttachmentBySlotName: function (slotName, attachmentName)
    {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
    },
    /** @return May be null. */
    getAttachmentBySlotIndex: function (slotIndex, attachmentName)
    {
        if (this.skin)
        {
            var attachment = this.skin.getAttachment(slotIndex, attachmentName);
            if (attachment) return attachment;
        }
        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
        return null;
    },
    /** @param attachmentName May be null. */
    setAttachment: function (slotName, attachmentName)
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
        {
            var slot = slots[i];
            if (slot.data.name == slotName)
            {
                var attachment = null;
                if (attachmentName)
                {
                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);
                    if (!attachment) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
                }
                slot.setAttachment(attachment);
                return;
            }
        }
        throw "Slot not found: " + slotName;
    },
    /** @return May be null. */
    findIkConstraint: function (constraintName)
    {
        var constraints = this.ikConstraints;
        for (var i = 0, n = constraints.length; i < n; i++)
            if (constraints[i].data.name == constraintName) return constraints[i];
        return null;
    },
    findTransformConstraint: function (constraintName)
    {
        var constraints = this.transformConstraints;
        for (var i = 0, n = constraints.length; i < n; i++)
            if (constraints[i].data.name == constraintName) return constraints[i];
        return null;
    },
    update: function (delta)
    {
        this.time += delta;
    },
    resetDrawOrder: function () {
        for (var i = 0, n = this.drawOrder.length; i < n; i++)
        {
            this.drawOrder[i] = i;
        }
    }
};
module.exports = spine.Skeleton;


},{"../SpineUtil":52,"./Bone":14,"./IkConstraint":24,"./Slot":37}],33:[function(require,module,exports){
var spine = require('../SpineRuntime') || {};
spine.AttachmentType = require('./AttachmentType');
spine.SkeletonBounds = function ()
{
    this.polygonPool = [];
    this.polygons = [];
    this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
    minX: 0, minY: 0, maxX: 0, maxY: 0,
    update: function (skeleton, updateAabb)
    {
        var slots = skeleton.slots;
        var slotCount = slots.length;
        var x = skeleton.x, y = skeleton.y;
        var boundingBoxes = this.boundingBoxes;
        var polygonPool = this.polygonPool;
        var polygons = this.polygons;

        boundingBoxes.length = 0;
        for (var i = 0, n = polygons.length; i < n; i++)
            polygonPool.push(polygons[i]);
        polygons.length = 0;

        for (var i = 0; i < slotCount; i++)
        {
            var slot = slots[i];
            var boundingBox = slot.attachment;
            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;
            boundingBoxes.push(boundingBox);

            var poolCount = polygonPool.length, polygon;
            if (poolCount > 0)
            {
                polygon = polygonPool[poolCount - 1];
                polygonPool.splice(poolCount - 1, 1);
            } else
                polygon = [];
            polygons.push(polygon);

            polygon.length = boundingBox.vertices.length;
            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
        }

        if (updateAabb) this.aabbCompute();
    },
    aabbCompute: function ()
    {
        var polygons = this.polygons;
        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
        for (var i = 0, n = polygons.length; i < n; i++)
        {
            var vertices = polygons[i];
            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)
            {
                var x = vertices[ii];
                var y = vertices[ii + 1];
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    },
    /** Returns true if the axis aligned bounding box contains the point. */
    aabbContainsPoint: function (x, y)
    {
        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
    },
    /** Returns true if the axis aligned bounding box intersects the line segment. */
    aabbIntersectsSegment: function (x1, y1, x2, y2)
    {
        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
            return false;
        var m = (y2 - y1) / (x2 - x1);
        var y = m * (minX - x1) + y1;
        if (y > minY && y < maxY) return true;
        y = m * (maxX - x1) + y1;
        if (y > minY && y < maxY) return true;
        var x = (minY - y1) / m + x1;
        if (x > minX && x < maxX) return true;
        x = (maxY - y1) / m + x1;
        if (x > minX && x < maxX) return true;
        return false;
    },
    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
    aabbIntersectsSkeleton: function (bounds)
    {
        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
    },
    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */
    containsPoint: function (x, y)
    {
        var polygons = this.polygons;
        for (var i = 0, n = polygons.length; i < n; i++)
            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];
        return null;
    },
    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */
    intersectsSegment: function (x1, y1, x2, y2)
    {
        var polygons = this.polygons;
        for (var i = 0, n = polygons.length; i < n; i++)
            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];
        return null;
    },
    /** Returns true if the polygon contains the point. */
    polygonContainsPoint: function (polygon, x, y)
    {
        var nn = polygon.length;
        var prevIndex = nn - 2;
        var inside = false;
        for (var ii = 0; ii < nn; ii += 2)
        {
            var vertexY = polygon[ii + 1];
            var prevY = polygon[prevIndex + 1];
            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))
            {
                var vertexX = polygon[ii];
                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;
            }
            prevIndex = ii;
        }
        return inside;
    },
    /** Returns true if the polygon contains the line segment. */
    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)
    {
        var nn = polygon.length;
        var width12 = x1 - x2, height12 = y1 - y2;
        var det1 = x1 * y2 - y1 * x2;
        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
        for (var ii = 0; ii < nn; ii += 2)
        {
            var x4 = polygon[ii], y4 = polygon[ii + 1];
            var det2 = x3 * y4 - y3 * x4;
            var width34 = x3 - x4, height34 = y3 - y4;
            var det3 = width12 * height34 - height12 * width34;
            var x = (det1 * width34 - width12 * det2) / det3;
            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))
            {
                var y = (det1 * height34 - height12 * det2) / det3;
                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;
            }
            x3 = x4;
            y3 = y4;
        }
        return false;
    },
    getPolygon: function (attachment)
    {
        var index = this.boundingBoxes.indexOf(attachment);
        return index == -1 ? null : this.polygons[index];
    },
    getWidth: function ()
    {
        return this.maxX - this.minX;
    },
    getHeight: function ()
    {
        return this.maxY - this.minY;
    }
};
module.exports = spine.SkeletonBounds;


},{"../SpineRuntime":45,"./AttachmentType":13}],34:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.SkeletonData = function ()
{
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.events = [];
    this.animations = [];
    this.ikConstraints = [];
    this.transformConstraints = [];
};
spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0, height: 0,
    version: null, hash: null,
    /** @return May be null. */
    findBone: function (boneName)
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName)
    {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName)
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
        {
            if (slots[i].name == slotName) return this.slots[i];
        }
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName)
    {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].name == slotName) return i;
        return -1;
    },
    /** @return May be null. */
    findSkin: function (skinName)
    {
        var skins = this.skins;
        for (var i = 0, n = skins.length; i < n; i++)
            if (skins[i].name == skinName) return skins[i];
        return null;
    },
    /** @return May be null. */
    findEvent: function (eventName)
    {
        var events = this.events;
        for (var i = 0, n = events.length; i < n; i++)
            if (events[i].name == eventName) return events[i];
        return null;
    },
    /** @return May be null. */
    findAnimation: function (animationName)
    {
        var animations = this.animations;
        for (var i = 0, n = animations.length; i < n; i++)
            if (animations[i].name == animationName) return animations[i];
        return null;
    },
    /** @return May be null. */
    findIkConstraint: function (constraintName)
    {
        var constraints = this.ikConstraints;
        for (var i = 0, n = constraints.length; i < n; i++)
            if (constraints[i].name == constraintName) return constraints[i];
        return null;
    },
    /** @return May be null. */
    findTransformConstraint: function (constraintName)
    {
        var constraints = this.transformConstraints;
        for (var i = 0, n = constraints.length; i < n; i++)
            if (constraints[i].name == constraintName) return constraints[i];
        return null;
    },
};
module.exports = spine.SkeletonData;


},{"../SpineUtil":52}],35:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.SkeletonData = require('./SkeletonData');
spine.BoneData = require('./BoneData');
spine.IkConstraintData = require('./IkConstraintData');
spine.TransformConstraintData = require('./TransformConstraintData');
spine.SlotData = require('./SlotData');
spine.Skin = require('./Skin');
spine.EventData = require('./EventData');
spine.AttachmentType = require('./AttachmentType');
spine.ColorTimeline = require('./ColorTimeline');
spine.AttachmentTimeline = require('./AttachmentTimeline');
spine.RotateTimeline = require('./RotateTimeline');
spine.ScaleTimeline = require('./ScaleTimeline');
spine.TranslateTimeline = require('./TranslateTimeline');
spine.ShearTimeline = require('./ShearTimeline');
spine.IkConstraintTimeline = require('./IkConstraintTimeline');
spine.TransformConstraintTimeline = require('./TransformConstraintTimeline');
spine.FfdTimeline = require('./FfdTimeline');
spine.DrawOrderTimeline = require('./DrawOrderTimeline');
spine.EventTimeline = require('./EventTimeline');
spine.Event = require('./Event');
spine.Animation = require('./Animation');

function LinkedMesh(mesh, skin, slotIndex, parent) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
}

spine.SkeletonJsonParser = function (attachmentLoader)
{
    if (attachmentLoader.pages) {
        //its an atlas, we have to wrap it
        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);
    } else {
        //got a loader, thats good
        this.attachmentLoader = attachmentLoader;
    }
    if (!attachmentLoader.newRegionAttachment) {
        console.warn("SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter");
    }
    this.linkedMeshes = [];
};
spine.SkeletonJsonParser.prototype = {
    scale: 1,
    readSkeletonData: function (root, name)
    {
        var skeletonData = new spine.SkeletonData();
        skeletonData.name = name;

        var scale = this.scale;
        // Skeleton.
        var skeletonMap = root["skeleton"];
        if (skeletonMap)
        {
            skeletonData.hash = skeletonMap["hash"];
            skeletonData.version = skeletonMap["spine"];
            skeletonData.width = skeletonMap["width"] || 0;
            skeletonData.height = skeletonMap["height"] || 0;
        }

        // Bones.
        var bones = root["bones"];
        for (var i = 0, n = bones.length; i < n; i++)
        {
            var boneMap = bones[i];
            var parent = null;
            if (boneMap["parent"])
            {
                parent = skeletonData.findBone(boneMap["parent"]);
                if (!parent) throw "Parent bone not found: " + boneMap["parent"];
            }
            var boneData = new spine.BoneData(boneMap["name"], parent);
            boneData.length = (boneMap["length"] || 0) * this.scale;
            boneData.x = (boneMap["x"] || 0) * this.scale;
            boneData.y = (boneMap["y"] || 0) * this.scale;
            boneData.rotation = (boneMap["rotation"] || 0);
            boneData.scaleX = boneMap.hasOwnProperty("scaleX") ? boneMap["scaleX"] : 1;
            boneData.scaleY = boneMap.hasOwnProperty("scaleY") ? boneMap["scaleY"] : 1;
            boneData.shearX = boneMap["shearX"] || 0;
            boneData.shearY = boneMap["shearY"] || 0;
            boneData.inheritScale = boneMap.hasOwnProperty("inheritScale") ? boneMap["inheritScale"] : true;
            boneData.inheritRotation = boneMap.hasOwnProperty("inheritRotation") ? boneMap["inheritRotation"] : true;
            skeletonData.bones.push(boneData);
        }

        // IK constraints.
        var ik = root["ik"];
        if (ik)
        {
            for (var i = 0, n = ik.length; i < n; i++)
            {
                var ikMap = ik[i];
                var ikConstraintData = new spine.IkConstraintData(ikMap["name"]);

                var bones = ikMap["bones"];
                for (var ii = 0, nn = bones.length; ii < nn; ii++)
                {
                    var bone = skeletonData.findBone(bones[ii]);
                    if (!bone) throw new Error( "IK bone not found: " + bones[ii] );
                    ikConstraintData.bones.push(bone);
                }

                ikConstraintData.target = skeletonData.findBone(ikMap["target"]);
                if (!ikConstraintData.target) throw new Error("Target bone not found: " + ikMap["target"]);

                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty("bendPositive") || ikMap["bendPositive"]) ? 1 : -1;
                ikConstraintData.mix = ikMap.hasOwnProperty("mix") ? ikMap["mix"] : 1;

                skeletonData.ikConstraints.push(ikConstraintData);
            }
        }

        var transform = root["transform"];
        if (transform) {
            for (var i = 0, n = transform.length; i<n; i++) {
                var transformMap = transform[i];
                var transformData = new spine.TransformConstraintData(transformMap["name"]);
                transformData.bone = skeletonData.findBone(transformMap["bone"]);
                if (!transformData.bone) throw new Error("Transform bone not found: " + transformData["bone"]);
                transformData.target = skeletonData.findBone(transformMap["target"]);
                if (!transformData.target) throw new Error("Target bone not found: " + transformData["target"]);

                transformData.offsetRotation = transformMap["rotation"] || 0;
                transformData.offsetX = (transformMap["offsetX"] || 0) * scale;
                transformData.offsetY = (transformMap["offsetY"] || 0) * scale;
                transformData.offsetScaleX = (transformMap["scaleX"] || 0) * scale;
                transformData.offsetScaleY = (transformMap["scaleY"] || 0) * scale;
                transformData.offsetShearY = (transformMap["offsetShearY"] || 0) * scale;

                transformData.rotateMix = transformMap.hasOwnProperty("rotateMix") ? transformMap["rotateMix"] : 1;
                transformData.translateMix = transformMap.hasOwnProperty("translateMix") ? transformMap["translateMix"] : 1;
                transformData.scaleMix = transformMap.hasOwnProperty("scaleMix") ? transformMap["scaleMix"] : 1;
                transformData.shearMix = transformMap.hasOwnProperty("shearMix") ? transformMap["shearMix"] : 1;

                skeletonData.transformConstraints.push(transformData);
            }
        }

        // Slots.
        var slots = root["slots"];
        for (var i = 0, n = slots.length; i < n; i++)
        {
            var slotMap = slots[i];
            var boneData = skeletonData.findBone(slotMap["bone"]);
            if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
            var slotData = new spine.SlotData(slotMap["name"], boneData);

            var color = slotMap["color"];
            if (color)
            {
                slotData.r = this.toColor(color, 0);
                slotData.g = this.toColor(color, 1);
                slotData.b = this.toColor(color, 2);
                slotData.a = this.toColor(color, 3);
            }

            slotData.attachmentName = slotMap["attachment"];


            slotData.blendMode = slotMap["blend"] && spine.SlotData.BLEND_MODE_MAP[slotMap["blend"]] || spine.SlotData.BLEND_MODE_MAP['normal'];

            skeletonData.slots.push(slotData);
        }

        // Skins.
        var skins = root["skins"];
        for (var skinName in skins)
        {
            if (!skins.hasOwnProperty(skinName)) continue;
            var skinMap = skins[skinName];
            var skin = new spine.Skin(skinName);
            for (var slotName in skinMap)
            {
                if (!skinMap.hasOwnProperty(slotName)) continue;
                var slotIndex = skeletonData.findSlotIndex(slotName);
                var slotEntry = skinMap[slotName];
                for (var attachmentName in slotEntry)
                {
                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;
                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);
                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);
                }
            }
            skeletonData.skins.push(skin);
            if (skin.name == "default") skeletonData.defaultSkin = skin;
        }

        var linkedMeshes = this.linkedMeshes;
        // Linked meshes.
        for (var i = 0, n = linkedMeshes.size; i < n; i++) {
            var linkedMesh = linkedMeshes[i];
            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;
            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
            linkedMesh.mesh.setParentMesh(parent);
            linkedMesh.mesh.updateUVs();
        }
        linkedMeshes.length = 0;

        // Events.
        var events = root["events"];
        for (var eventName in events)
        {
            if (!events.hasOwnProperty(eventName)) continue;
            var eventMap = events[eventName];
            var eventData = new spine.EventData(eventName);
            eventData.intValue = eventMap["int"] || 0;
            eventData.floatValue = eventMap["float"] || 0;
            eventData.stringValue = eventMap["string"] || null;
            skeletonData.events.push(eventData);
        }

        // Animations.
        var animations = root["animations"];
        for (var animationName in animations)
        {
            if (!animations.hasOwnProperty(animationName)) continue;
            this.readAnimation(animationName, animations[animationName], skeletonData);
        }

        return skeletonData;
    },
    readAttachment: function (skin, slotIndex, name, map)
    {
        name = map["name"] || name;

        var type = spine.AttachmentType[map["type"] || "region"];
        var path = map["path"] || name;

        var scale = this.scale;
        if (type == spine.AttachmentType.region)
        {
            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
            if (!region) return null;
            region.path = path;
            region.x = (map["x"] || 0) * scale;
            region.y = (map["y"] || 0) * scale;
            region.scaleX = map.hasOwnProperty("scaleX") ? map["scaleX"] : 1;
            region.scaleY = map.hasOwnProperty("scaleY") ? map["scaleY"] : 1;
            region.rotation = map["rotation"] || 0;
            region.width = (map["width"] || 0) * scale;
            region.height = (map["height"] || 0) * scale;

            var color = map["color"];
            if (color)
            {
                region.r = this.toColor(color, 0);
                region.g = this.toColor(color, 1);
                region.b = this.toColor(color, 2);
                region.a = this.toColor(color, 3);
            }

            region.updateOffset();
            return region;
        } else if (type == spine.AttachmentType.boundingbox)
        {
            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
            var vertices = map["vertices"];
            for (var i = 0, n = vertices.length; i < n; i++)
                attachment.vertices.push(vertices[i] * scale);
            return attachment;
        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)
        {
            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
            if (!mesh) return null;
            mesh.path = path;
            color = map["color"];
            if (color)
            {
                mesh.r = this.toColor(color, 0);
                mesh.g = this.toColor(color, 1);
                mesh.b = this.toColor(color, 2);
                mesh.a = this.toColor(color, 3);
            }
            mesh.width = (map["width"] || 0) * scale;
            mesh.height = (map["height"] || 0) * scale;

            var parent = map["parent"];
            if (!parent) {
                mesh.vertices = this.getFloatArray(map, "vertices", scale);
                mesh.triangles = this.getIntArray(map, "triangles");
                mesh.regionUVs = this.getFloatArray(map, "uvs", 1);
                mesh.updateUVs();
                mesh.hullLength = (map["hull"] || 0) * 2;
                if (map["edges"]) mesh.edges = this.getIntArray(map, "edges");
            } else {
                mesh.inheritFFD = !!map["ffd"];
                this.linkedMeshes.push(new LinkedMesh(mesh, map["skin"] || null, slotIndex, parent));
            }
            return mesh;
        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)
        {
            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);
            if (!mesh) return null;
            mesh.path = path;
            color = map["color"];
            if (color)
            {
                mesh.r = this.toColor(color, 0);
                mesh.g = this.toColor(color, 1);
                mesh.b = this.toColor(color, 2);
                mesh.a = this.toColor(color, 3);
            }
            mesh.width = (map["width"] || 0) * scale;
            mesh.height = (map["height"] || 0) * scale;

            var parent = map["parent"];
            if (!parent) {
                var uvs = this.getFloatArray(map, "uvs", 1);
                var vertices = this.getFloatArray(map, "vertices", 1);
                var weights = [];
                var bones = [];
                for (var i = 0, n = vertices.length; i < n; )
                {
                    var boneCount = vertices[i++] | 0;
                    bones[bones.length] = boneCount;
                    for (var nn = i + boneCount * 4; i < nn; )
                    {
                        bones[bones.length] = vertices[i];
                        weights[weights.length] = vertices[i + 1] * scale;
                        weights[weights.length] = vertices[i + 2] * scale;
                        weights[weights.length] = vertices[i + 3];
                        i += 4;
                    }
                }
                mesh.bones = bones;
                mesh.weights = weights;
                mesh.triangles = this.getIntArray(map, "triangles");
                mesh.regionUVs = uvs;
                mesh.updateUVs();

                mesh.hullLength = (map["hull"] || 0) * 2;
                if (map["edges"]) mesh.edges = this.getIntArray(map, "edges");
            } else {
                mesh.inheritFFD = !!map["ffd"];
                this.linkedMeshes.push(new LinkedMesh(mesh, map["skin"] || null, slotIndex, parent));
            }
            return mesh;
        }
        throw "Unknown attachment type: " + type;
    },
    readAnimation: function (name, map, skeletonData)
    {
        var timelines = [];
        var duration = 0;

        var slots = map["slots"];
        for (var slotName in slots)
        {
            if (!slots.hasOwnProperty(slotName)) continue;
            var slotMap = slots[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);

            for (var timelineName in slotMap)
            {
                if (!slotMap.hasOwnProperty(timelineName)) continue;
                var values = slotMap[timelineName];
                if (timelineName == "color")
                {
                    var timeline = new spine.ColorTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
                        var valueMap = values[i];
                        var color = valueMap["color"];
                        var r = this.toColor(color, 0);
                        var g = this.toColor(color, 1);
                        var b = this.toColor(color, 2);
                        var a = this.toColor(color, 3);
                        timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                        this.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

                } else if (timelineName == "attachment")
                {
                    var timeline = new spine.AttachmentTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
                        var valueMap = values[i];
                        timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

                } else
                    throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
            }
        }

        var bones = map["bones"];
        for (var boneName in bones)
        {
            if (!bones.hasOwnProperty(boneName)) continue;
            var boneIndex = skeletonData.findBoneIndex(boneName);
            if (boneIndex == -1) throw "Bone not found: " + boneName;
            var boneMap = bones[boneName];

            for (var timelineName in boneMap)
            {
                if (!boneMap.hasOwnProperty(timelineName)) continue;
                var values = boneMap[timelineName];
                if (timelineName == "rotate")
                {
                    var timeline = new spine.RotateTimeline(values.length);
                    timeline.boneIndex = boneIndex;

                    var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
                        var valueMap = values[i];
                        timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                        this.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

                } else if (timelineName == "translate" || timelineName == "scale" || timelineName == "shear")
                {
                    var timeline;
                    var timelineScale = 1;
                    if (timelineName == "scale") {
                        timeline = new spine.ScaleTimeline(values.length);
                    } else if (timelineName == "shear") {
                        timeline = new spine.ShearTimeline(values.length);
                    }
                    else
                    {
                        timeline = new spine.TranslateTimeline(values.length);
                        timelineScale = this.scale;
                    }
                    timeline.boneIndex = boneIndex;

                    var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
                        var valueMap = values[i];
                        var x = (valueMap["x"] || 0) * timelineScale;
                        var y = (valueMap["y"] || 0) * timelineScale;
                        timeline.setFrame(frameIndex, valueMap["time"], x, y);
                        this.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

                } else if (timelineName == "flipX" || timelineName == "flipY")
                {
                    throw "flipX and flipY are not supported in spine v3: (" + boneName + ")";
                } else
                    throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
            }
        }

        var ikMap = map["ik"];
        for (var ikConstraintName in ikMap)
        {
            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;
            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);
            var values = ikMap[ikConstraintName];
            var timeline = new spine.IkConstraintTimeline(values.length);
            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);
            var frameIndex = 0;
            for (var i = 0, n = values.length; i < n; i++)
            {
                var valueMap = values[i];
                var mix = valueMap.hasOwnProperty("mix") ? valueMap["mix"] : 1;
                var bendDirection = (!valueMap.hasOwnProperty("bendPositive") || valueMap["bendPositive"]) ? 1 : -1;
                timeline.setFrame(frameIndex, valueMap["time"], mix, bendDirection);
                this.readCurve(timeline, frameIndex, valueMap);
                frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);
        }

        var transformMap = map["transform"];
        for (var transformConstraintName in transformMap)
        {
            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;
            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);
            var values = transformMap[transformConstraintName];
            var timeline = new spine.TransformConstraintTimeline(values.length);
            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);
            var frameIndex = 0;
            for (var i = 0, n = values.length; i < n; i++)
            {
                var valueMap = values[i];
                var rotateMix = valueMap.hasOwnProperty("rotateMix") ? valueMap["rotateMix"] : 1;
                var translateMix = valueMap.hasOwnProperty("translateMix") ? valueMap["translateMix"] : 1;
                var scaleMix = valueMap.hasOwnProperty("scaleMix") ? valueMap["scaleMix"] : 1;
                var shearMix = valueMap.hasOwnProperty("shearMix") ? valueMap["shearMix"] : 1;
                timeline.setFrame(frameIndex, valueMap["time"], translateMix, scaleMix, shearMix);
                this.readCurve(timeline, frameIndex, valueMap);
                frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);
        }

        var ffd = map["ffd"];
        for (var skinName in ffd)
        {
            var skin = skeletonData.findSkin(skinName);
            var slotMap = ffd[skinName];
            for (slotName in slotMap)
            {
                var slotIndex = skeletonData.findSlotIndex(slotName);
                var meshMap = slotMap[slotName];
                for (var meshName in meshMap)
                {
                    var values = meshMap[meshName];
                    var timeline = new spine.FfdTimeline(values.length);
                    var attachment = skin.getAttachment(slotIndex, meshName);
                    if (!attachment) throw "FFD attachment not found: " + meshName;
                    timeline.slotIndex = slotIndex;
                    timeline.attachment = attachment;

                    var isMesh = attachment.type == spine.AttachmentType.mesh;
                    var vertexCount;
                    if (isMesh)
                        vertexCount = attachment.vertices.length;
                    else
                        vertexCount = attachment.weights.length / 3 * 2;

                    var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
                        var valueMap = values[i];
                        var vertices;
                        if (!valueMap["vertices"])
                        {
                            if (isMesh)
                                vertices = attachment.vertices;
                            else
                            {
                                vertices = [];
                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0
                            }
                        } else {
                            var verticesValue = valueMap["vertices"];
                            vertices = [];
                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0
                            var start = valueMap["offset"] || 0;
                            var nn = verticesValue.length;
                            if (this.scale == 1)
                            {
                                for (var ii = 0; ii < nn; ii++)
                                    vertices[ii + start] = verticesValue[ii];
                            } else {
                                for (var ii = 0; ii < nn; ii++)
                                    vertices[ii + start] = verticesValue[ii] * this.scale;
                            }
                            if (isMesh)
                            {
                                var meshVertices = attachment.vertices;
                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)
                                    vertices[ii] += meshVertices[ii];
                            }
                        }

                        timeline.setFrame(frameIndex, valueMap["time"], vertices);
                        this.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines[timelines.length] = timeline;
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                }
            }
        }

        var drawOrderValues = map["drawOrder"];
        if (!drawOrderValues) drawOrderValues = map["draworder"];
        if (drawOrderValues)
        {
            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
            var slotCount = skeletonData.slots.length;
            var frameIndex = 0;
            for (var i = 0, n = drawOrderValues.length; i < n; i++)
            {
                var drawOrderMap = drawOrderValues[i];
                var drawOrder = null;
                if (drawOrderMap["offsets"])
                {
                    drawOrder = [];
                    drawOrder.length = slotCount;
                    for (var ii = slotCount - 1; ii >= 0; ii--)
                        drawOrder[ii] = -1;
                    var offsets = drawOrderMap["offsets"];
                    var unchanged = [];
                    unchanged.length = slotCount - offsets.length;
                    var originalIndex = 0, unchangedIndex = 0;
                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)
                    {
                        var offsetMap = offsets[ii];
                        var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
                        if (slotIndex == -1) throw "Slot not found: " + offsetMap["slot"];
                        // Collect unchanged items.
                        while (originalIndex != slotIndex)
                            unchanged[unchangedIndex++] = originalIndex++;
                        // Set changed items.
                        drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++;
                    }
                    // Collect remaining unchanged items.
                    while (originalIndex < slotCount)
                        unchanged[unchangedIndex++] = originalIndex++;
                    // Fill in unchanged items.
                    for (var ii = slotCount - 1; ii >= 0; ii--)
                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
                }
                timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
        }

        var events = map["events"];
        if (events)
        {
            var timeline = new spine.EventTimeline(events.length);
            var frameIndex = 0;
            for (var i = 0, n = events.length; i < n; i++)
            {
                var eventMap = events[i];
                var eventData = skeletonData.findEvent(eventMap["name"]);
                if (!eventData) throw "Event not found: " + eventMap["name"];
                var event = new spine.Event(eventData);
                event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
                event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
                event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
                timeline.setFrame(frameIndex++, eventMap["time"], event);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
        }

        skeletonData.animations.push(new spine.Animation(name, timelines, duration));
    },
    readCurve: function (timeline, frameIndex, valueMap)
    {
        var curve = valueMap["curve"];
        if (!curve)
            timeline.curves.setLinear(frameIndex);
        else if (curve == "stepped")
            timeline.curves.setStepped(frameIndex);
        else if (curve instanceof Array)
            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
    },
    toColor: function (hexString, colorIndex)
    {
        if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;
    },
    getFloatArray: function (map, name, scale)
    {
        var list = map[name];
        var values = new spine.Float32Array(list.length);
        var i = 0, n = list.length;
        if (scale == 1)
        {
            for (; i < n; i++)
                values[i] = list[i];
        } else {
            for (; i < n; i++)
                values[i] = list[i] * scale;
        }
        return values;
    },
    getIntArray: function (map, name)
    {
        var list = map[name];
        var values = new spine.Uint16Array(list.length);
        for (var i = 0, n = list.length; i < n; i++)
            values[i] = list[i] | 0;
        return values;
    }
};
module.exports = spine.SkeletonJsonParser;


},{"../SpineUtil":52,"./Animation":4,"./AttachmentTimeline":12,"./AttachmentType":13,"./BoneData":15,"./ColorTimeline":17,"./DrawOrderTimeline":19,"./Event":20,"./EventData":21,"./EventTimeline":22,"./FfdTimeline":23,"./IkConstraintData":25,"./IkConstraintTimeline":26,"./RotateTimeline":29,"./ScaleTimeline":30,"./ShearTimeline":31,"./SkeletonData":34,"./Skin":36,"./SlotData":38,"./TransformConstraintData":41,"./TransformConstraintTimeline":42,"./TranslateTimeline":43}],36:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Skin = function (name)
{
    this.name = name;
    this.attachments = {};
};
spine.Skin.prototype = {
    addAttachment: function (slotIndex, name, attachment)
    {
        this.attachments[slotIndex + ":" + name] = attachment;
    },
    getAttachment: function (slotIndex, name)
    {
        return this.attachments[slotIndex + ":" + name];
    },
    _attachAll: function (skeleton, oldSkin)
    {
        for (var key in oldSkin.attachments)
        {
            var colon = key.indexOf(":");
            var slotIndex = parseInt(key.substring(0, colon));
            var name = key.substring(colon + 1);
            var slot = skeleton.slots[slotIndex];
            if (slot.attachment && slot.attachment.name == name)
            {
                var attachment = this.getAttachment(slotIndex, name);
                if (attachment) slot.setAttachment(attachment);
            }
        }
    }
};
module.exports = spine.Skin;


},{"../SpineUtil":52}],37:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Slot = function (slotData, bone)
{
    this.data = slotData;
    this.bone = bone;
    this.setToSetupPose();
};
spine.Slot.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    _attachmentTime: 0,
    attachment: null,
    attachmentVertices: [],
    setAttachment: function (attachment)
    {
        this.attachment = attachment;
        this._attachmentTime = this.bone.skeleton.time;
        this.attachmentVertices.length = 0;
    },
    setAttachmentTime: function (time)
    {
        this._attachmentTime = this.bone.skeleton.time - time;
    },
    getAttachmentTime: function ()
    {
        return this.bone.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function ()
    {
        var data = this.data;
        this.r = data.r;
        this.g = data.g;
        this.b = data.b;
        this.a = data.a;
        this.blendMode = data.blendMode;

        var slotDatas = this.bone.skeleton.data.slots;
        for (var i = 0, n = slotDatas.length; i < n; i++)
        {
            if (slotDatas[i] == data)
            {
                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                break;
            }
        }
    }
};
module.exports = spine.Slot;


},{"../SpineUtil":52}],38:[function(require,module,exports){
var spine = require('../SpineUtil');
var blend = require('../SpineUtil/blend.js');

spine.SlotData = function (name, boneData)
{
    this.name = name;
    this.boneData = boneData;
};

spine.SlotData.BLEND_MODE_MAP = {
    'multiply': blend.MULTIPLY,
    'screen': blend.SCREEN,
    'additive': blend.ADD,
    'normal': blend.NORMAL
};

spine.SlotData.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    attachmentName: null,
    blendMode: blend.NORMAL


};


module.exports = spine.SlotData;


},{"../SpineUtil":52,"../SpineUtil/blend.js":51}],39:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.TrackEntry = function ()
{};
spine.TrackEntry.prototype = {
    next: null, previous: null,
    animation: null,
    loop: false,
    delay: 0, time: 0, lastTime: -1, endTime: 0,
    timeScale: 1,
    mixTime: 0, mixDuration: 0, mix: 1,
    onStart: null, onEnd: null, onComplete: null, onEvent: null
};
module.exports = spine.TrackEntry;


},{"../SpineUtil":52}],40:[function(require,module,exports){
var spine = require('../SpineUtil');
var tempVec = [0, 0];
spine.TransformConstraint = function (data, skeleton)
{
    this.data = data;
    this.translateMix = data.translateMix;
    this.rotateMix = data.rotateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.offsetX = data.offsetX;
    this.offsetY = data.offsetY;
    this.offsetScaleX = data.offsetScaleX;
    this.offsetScaleY = data.offsetScaleY;
    this.offsetShearY = data.offsetShearY;

    this.bone = skeleton.findBone(data.bone.name);
    this.target = skeleton.findBone(data.target.name);
};

spine.TransformConstraint.prototype = {
    update: function() {
        this.apply();
    },
    apply: function ()
    {
        var bm = this.bone.matrix;
        var tm = this.target.matrix;

        var rotateMix = this.rotateMix;
        if (rotateMix > 0) {
            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;
            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);
            if (r > Math.PI)
                r -= Math.PI*2;
            else if (r < -Math.PI) r += Math.PI*2;
            r *= rotateMix;
            var cos = Math.cos(r), sin = Math.sin(r);
            bm.a = cos * a - sin * c;
            bm.c = cos * b - sin * d;
            bm.b = sin * a + cos * c;
            bm.d = sin * b + cos * d;
        }

        var scaleMix = this.rotateMix;
        if (scaleMix > 0) {
            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);
            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);
            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;
            bm.a *= s;
            bm.b *= s;
            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);
            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);
            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;
            bm.c *= s;
            bm.d *= s;
        }

        var shearMix = this.shearMix;
        if (shearMix > 0) {
            var b = bm.c, d = bm.d;
            var by = Math.atan2(d, b);
            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));
            if (r > Math.PI)
                r -= Math.PI*2;
            else if (r < -Math.PI) r += Math.PI*2;
            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;
            var s = Math.sqrt(b * b + d * d);
            bm.c = Math.cos(r) * s;
            bm.d = Math.sin(r) * s;
        }

        var translateMix = this.translateMix;
        if (translateMix > 0) {
            tempVec[0] = this.offsetX;
            tempVec[1] = this.offsetY;
            this.target.localToWorld(tempVec);
            bm.tx += (tempVec[0] - bm.tx) * translateMix;
            bm.ty += (tempVec[1] - bm.ty) * translateMix;
        }
    }
};

module.exports = spine.TransformConstraint;

},{"../SpineUtil":52}],41:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.TransformConstraintData = function (name)
{
    this.name = name;
    this.bone = null;
};
spine.TransformConstraintData.prototype = {
    target: null,
    rotateMix: 1,
    translateMix: 1,
    scaleMix: 1,
    shearMix: 1,
    offsetRotation: 0,
    offsetX: 0,
    offsetY: 0,
    offsetScaleX: 0,
    offsetScaleY: 0,
    offsetShearY: 0
};
module.exports = spine.TransformConstraintData;


},{"../SpineUtil":52}],42:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.TransformConstraintTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, mix, bendDirection, ...
    this.frames.length = frameCount * 3;
};
spine.TransformConstraintTimeline.prototype = {
    transformConstraintIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 5;
    },
    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)
    {
        frameIndex *= 5;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = rotateMix;
        this.frames[frameIndex + 2] = translateMix;
        this.frames[frameIndex + 3] = scaleMix;
        this.frames[frameIndex + 4] = shareMix;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];

        if (time >= frames[frames.length - 5])
        { // Time is after last frame.
            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;
            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;
            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;
            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frame = spine.Animation.binarySearch(frames, time, 5);
        var frameTime = frames[frame];
        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);

        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];
        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];
        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];
        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];
        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;
        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)
            * alpha;
        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;
        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;
    }
};
module.exports = spine.TransformConstraintTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],43:[function(require,module,exports){
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.Curves = require('./Curves');
spine.TranslateTimeline = function (frameCount)
{
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function ()
    {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y)
    {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
            return;
        }

        // Interpolate between the previous frame and the current frame.
        var frameIndex = spine.Animation.binarySearch(frames, time, 3);
        var prevFrameX = frames[frameIndex - 2];
        var prevFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;
        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;
    }
};
module.exports = spine.TranslateTimeline;


},{"../SpineUtil":52,"./Animation":4,"./Curves":18}],44:[function(require,module,exports){
var spine = require('../SpineUtil') || {};
spine.AttachmentType = require('./AttachmentType');
spine.WeightedMeshAttachment = function (name)
{
    this.name = name;
};
spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    parentMesh: null,
    inheritFFD: false,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1, g: 1, b: 1, a: 1,
    path: null,
    rendererObject: null,
    edges: null,
    width: 0, height: 0,
    updateUVs: function (u, v, u2, v2, rotate)
    {
        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;
        var n = this.regionUVs.length;
        if (!this.uvs || this.uvs.length != n)
        {
            this.uvs = new spine.Float32Array(n);
        }
        var region = this.rendererObject;
        if (!region) return;
        var texture = region.texture;
        var r = texture._uvs;
        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;
        var x = region.offsetX, y = region.pixiOffsetY;
        for (var i = 0; i < n; i += 2)
        {
            var u = this.regionUVs[i], v = this.regionUVs[i+1];
            u = (u * w2 - x) / w1;
            v = (v * h2 - y) / h1;
            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;
            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;
        }
    },
    computeWorldVertices: function (x, y, slot, worldVertices)
    {
        var skeletonBones = slot.bone.skeleton.bones;
        var weights = this.weights;
        var bones = this.bones;

        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;
        var wx, wy, vx, vy, weight;
        var m;
        if (!slot.attachmentVertices.length)
        {
            for (; v < n; w += 2)
            {
                wx = 0;
                wy = 0;
                nn = bones[v++] + v;
                for (; v < nn; v++, b += 3)
                {
                    m = skeletonBones[bones[v]].matrix;
                    vx = weights[b];
                    vy = weights[b + 1];
                    weight = weights[b + 2];
                    wx += (vx * m.a + vy * m.c + m.tx) * weight;
                    wy += (vx * m.b + vy * m.d + m.ty) * weight;
                }
                worldVertices[w] = wx + x;
                worldVertices[w + 1] = wy + y;
            }
        } else {
            var ffd = slot.attachmentVertices;
            for (; v < n; w += 2)
            {
                wx = 0;
                wy = 0;
                nn = bones[v++] + v;
                for (; v < nn; v++, b += 3, f += 2)
                {
                    m = skeletonBones[bones[v]].matrix;
                    vx = weights[b] + ffd[f];
                    vy = weights[b + 1] + ffd[f + 1];
                    weight = weights[b + 2];
                    wx += (vx * m.a + vy * m.c + m.tx) * weight;
                    wy += (vx * m.b + vy * m.d + m.ty) * weight;
                }
                worldVertices[w] = wx + x;
                worldVertices[w + 1] = wy + y;
            }
        }
    },
    applyFFD: function(sourceAttachment) {
        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);
    },
    setParentMesh: function(parentMesh) {
        this.parentMesh = parentMesh;
        if (parentMesh != null) {
            this.bones = parentMesh.bones;
            this.weights = parentMesh.weights;
            this.regionUVs = parentMesh.regionUVs;
            this.triangles = parentMesh.triangles;
            this.hullLength = parentMesh.hullLength;
        }
    }
};
module.exports = spine.WeightedMeshAttachment;


},{"../SpineUtil":52,"./AttachmentType":13}],45:[function(require,module,exports){
/******************************************************************************
 * Spine Runtimes Software License
 * Version 2.1
 *
 * Copyright (c) 2013, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to install, execute and perform the Spine Runtimes
 * Software (the "Software") solely for internal use. Without the written
 * permission of Esoteric Software (typically granted by licensing Spine), you
 * may not (a) modify, translate, adapt or otherwise create derivative works,
 * improvements of the Software or develop new applications using the Software
 * or (b) remove, delete, alter or obscure any trademarks or any copyright,
 * trademark, patent or other intellectual property or proprietary rights
 * notices on or in the Software, including any copy thereof. Redistributions
 * in binary or source form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/
var spine = require('../SpineUtil');
spine.Animation = require('./Animation');
spine.AnimationStateData = require('./AnimationStateData');
spine.AnimationState = require('./AnimationState');
spine.AtlasAttachmentParser = require('./AtlasAttachmentParser');
spine.Atlas = require('./Atlas');
spine.AtlasPage = require('./AtlasPage');
spine.AtlasReader = require('./AtlasReader');
spine.AtlasRegion = require('./AtlasRegion');
spine.AttachmentTimeline = require('./AttachmentTimeline');
spine.AttachmentType = require('./AttachmentType');
spine.BoneData = require('./BoneData');
spine.Bone = require('./Bone');
spine.BoundingBoxAttachment = require('./BoundingBoxAttachment');
spine.ColorTimeline = require('./ColorTimeline');
spine.Curves = require('./Curves');
spine.DrawOrderTimeline = require('./DrawOrderTimeline');
spine.EventData = require('./EventData');
spine.Event = require('./Event');
spine.EventTimeline = require('./EventTimeline');
spine.FfdTimeline = require('./FfdTimeline');
spine.IkConstraintData = require('./IkConstraintData');
spine.IkConstraint = require('./IkConstraint');
spine.IkConstraintTimeline = require('./IkConstraintTimeline');
spine.TransformConstraintData = require('./TransformConstraintData');
spine.TransformConstraint = require('./TransformConstraint');
spine.TransformConstraintTimeline = require('./TransformConstraintTimeline');
spine.MeshAttachment = require('./MeshAttachment');
spine.RegionAttachment = require('./RegionAttachment');
spine.RotateTimeline = require('./RotateTimeline');
spine.ScaleTimeline = require('./ScaleTimeline');
spine.ShearTimeline = require('./ShearTimeline');
spine.SkeletonBounds = require('./SkeletonBounds');
spine.SkeletonData = require('./SkeletonData');
spine.Skeleton = require('./Skeleton');
spine.SkeletonJsonParser = require('./SkeletonJsonParser');
spine.Skin = require('./Skin.js');
spine.WeightedMeshAttachment = require('./WeightedMeshAttachment');
spine.SlotData = require('./SlotData');
spine.Slot = require('./Slot');
spine.TrackEntry = require('./TrackEntry');
spine.TranslateTimeline = require('./TranslateTimeline');
module.exports = spine;

},{"../SpineUtil":52,"./Animation":4,"./AnimationState":5,"./AnimationStateData":6,"./Atlas":7,"./AtlasAttachmentParser":8,"./AtlasPage":9,"./AtlasReader":10,"./AtlasRegion":11,"./AttachmentTimeline":12,"./AttachmentType":13,"./Bone":14,"./BoneData":15,"./BoundingBoxAttachment":16,"./ColorTimeline":17,"./Curves":18,"./DrawOrderTimeline":19,"./Event":20,"./EventData":21,"./EventTimeline":22,"./FfdTimeline":23,"./IkConstraint":24,"./IkConstraintData":25,"./IkConstraintTimeline":26,"./MeshAttachment":27,"./RegionAttachment":28,"./RotateTimeline":29,"./ScaleTimeline":30,"./ShearTimeline":31,"./Skeleton":32,"./SkeletonBounds":33,"./SkeletonData":34,"./SkeletonJsonParser":35,"./Skin.js":36,"./Slot":37,"./SlotData":38,"./TrackEntry":39,"./TransformConstraint":40,"./TransformConstraintData":41,"./TransformConstraintTimeline":42,"./TranslateTimeline":43,"./WeightedMeshAttachment":44}],46:[function(require,module,exports){
// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16

var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var tempMatrices = [];
var Matrix = require('./Matrix');

var mul = [];

function signum(x) {
    if (x < 0) {
        return -1;
    }
    if (x > 0) {
        return 1;
    }
    return 0;
}

function init() {
    for (var i = 0; i < 16; i++) {
        var row = [];
        mul.push(row);
        for (var j = 0; j < 16; j++) {
            var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
            var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
            var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
            var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
            for (var k = 0; k < 16; k++) {
                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                    row.push(k);
                    break;
                }
            }
        }
    }

    for (i=0;i<16;i++) {
        var mat = new Matrix();
        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
        tempMatrices.push(mat);
    }
}

init();

/**
 * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html}, D8 is the same but with diagonals
 * Used for texture rotations
 * Vector xX(i), xY(i) is U-axis of sprite with rotation i
 * Vector yY(i), yY(i) is V-axis of sprite with rotation i
 * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
 * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
 * This is the small part of gameofbombs.com portal system. It works.
 * @author Ivan @ivanpopelyshev
 *
 * @namespace PIXI.GroupD8
 */
var GroupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MIRROR_HORIZONTAL: 12,
    uX: function (ind) {
        return ux[ind];
    },
    uY: function (ind) {
        return uy[ind];
    },
    vX: function (ind) {
        return vx[ind];
    },
    vY: function (ind) {
        return vy[ind];
    },
    inv: function (rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }
        return (-rotation) & 7;
    },
    add: function (rotationSecond, rotationFirst) {
        return mul[rotationSecond][rotationFirst];
    },
    sub: function (rotationSecond, rotationFirst) {
        return mul[rotationSecond][GroupD8.inv(rotationFirst)];
    },
    /**
     * Adds 180 degrees to rotation. Commutative operation
     * @param rotation
     * @returns {number}
     */
    rotate180: function (rotation) {
        return rotation ^ 4;
    },
    /**
     * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.
     * @param rotation
     * @returns {boolean}
     */
    isSwapWidthHeight: function(rotation) {
        return (rotation & 3) === 2;
    },
    byDirection: function (dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }
            else {
                return GroupD8.N;
            }
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }
            else {
                return GroupD8.W;
            }
        } else {
            if (dy > 0) {
                if (dx > 0) {
                    return GroupD8.SE;
                }
                else {
                    return GroupD8.SW;
                }
            }
            else if (dx > 0) {
                return GroupD8.NE;
            }
            else {
                return GroupD8.NW;
            }
        }
    },
    /**
     * Helps sprite to compensate texture packer rotation.
     * @param matrix {PIXI.Matrix} sprite world matrix
     * @param rotation {number}
     * @param tx {number|*} sprite anchoring
     * @param ty {number|*} sprite anchoring
     */
    matrixAppendRotationInv: function (matrix, rotation, tx, ty) {
        //Packer used "rotation", we use "inv(rotation)"
        var mat = tempMatrices[GroupD8.inv(rotation)];
        tx = tx || 0;
        ty = ty || 0;
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
};

module.exports = GroupD8;

},{"./Matrix":47}],47:[function(require,module,exports){
// @todo - ignore the too many parameters warning for now
// should either fix it or change the jshint config
// jshint -W072

var Point = require('./Point');

/**
 * The pixi Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 */
function Matrix()
{
    /**
     * @member {number}
     * @default 1
     */
    this.a = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.b = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.c = 0;

    /**
     * @member {number}
     * @default 1
     */
    this.d = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.tx = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.ty = 0;
}

Matrix.prototype.constructor = Matrix;
module.exports = Matrix;

/**
 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
 *
 * a = array[0]
 * b = array[1]
 * c = array[3]
 * d = array[4]
 * tx = array[2]
 * ty = array[5]
 *
 * @param array {number[]} The array that the matrix will be populated from.
 */
Matrix.prototype.fromArray = function (array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};


/**
 * sets the matrix properties
 *
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} tx
 * @param {number} ty
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.set = function (a, b, c, d, tx, ty)
{
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;

    return this;
};


/**
 * Creates an array from the current Matrix object.
 *
 * @param transpose {boolean} Whether we need to transpose the matrix or not
 * @param [out] {Array} If provided the array will be assigned to out
 * @return {number[]} the newly created array which contains the matrix
 */
Matrix.prototype.toArray = function (transpose, out)
{
    if (!this.array)
    {
        this.array = new Float32Array(9);
    }

    var array = out || this.array;

    if (transpose)
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

/**
 * Get a new position with the current transformation applied.
 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
 *
 * @param pos {Point} The origin
 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {Point} The new point, transformed through this matrix
 */
Matrix.prototype.apply = function (pos, newPos)
{
    newPos = newPos || new Point();

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;

    return newPos;
};

/**
 * Get a new position with the inverse of the current transformation applied.
 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
 *
 * @param pos {Point} The origin
 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {Point} The new point, inverse-transformed through this matrix
 */
Matrix.prototype.applyInverse = function (pos, newPos)
{
    newPos = newPos || new Point();

    var id = 1 / (this.a * this.d + this.c * -this.b);

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

    return newPos;
};

/**
 * Translates the matrix on the x and y.
 *
 * @param {number} x
 * @param {number} y
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.translate = function (x, y)
{
    this.tx += x;
    this.ty += y;

    return this;
};

/**
 * Applies a scale transformation to the matrix.
 *
 * @param {number} x The amount to scale horizontally
 * @param {number} y The amount to scale vertically
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.scale = function (x, y)
{
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;

    return this;
};


/**
 * Applies a rotation transformation to the matrix.
 *
 * @param {number} angle - The angle in radians.
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.rotate = function (angle)
{
    var cos = Math.cos( angle );
    var sin = Math.sin( angle );

    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;

    this.a = a1 * cos-this.b * sin;
    this.b = a1 * sin+this.b * cos;
    this.c = c1 * cos-this.d * sin;
    this.d = c1 * sin+this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;

    return this;
};

/**
 * Appends the given Matrix to this Matrix.
 *
 * @param {Matrix} matrix
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.append = function (matrix)
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;

    this.a  = matrix.a * a1 + matrix.b * c1;
    this.b  = matrix.a * b1 + matrix.b * d1;
    this.c  = matrix.c * a1 + matrix.d * c1;
    this.d  = matrix.c * b1 + matrix.d * d1;

    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

    return this;
};

/**
 * Sets the matrix based on all the available properties
 *
 * @param {number} x
 * @param {number} y
 * @param {number} pivotX
 * @param {number} pivotY
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {number} rotation
 * @param {number} skewX
 * @param {number} skewY
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)
{
    var a, b, c, d, sr, cr, cy, sy, nsx, cx;

    sr  = Math.sin(rotation);
    cr  = Math.cos(rotation);
    cy  = Math.cos(skewY);
    sy  = Math.sin(skewY);
    nsx = -Math.sin(skewX);
    cx  =  Math.cos(skewX);

    a  =  cr * scaleX;
    b  =  sr * scaleX;
    c  = -sr * scaleY;
    d  =  cr * scaleY;

    this.a  = cy * a + sy * c;
    this.b  = cy * b + sy * d;
    this.c  = nsx * a + cx * c;
    this.d  = nsx * b + cx * d;

    this.tx = x + ( pivotX * a + pivotY * c );
    this.ty = y + ( pivotX * b + pivotY * d );

    return this;
};

/**
 * Prepends the given Matrix to this Matrix.
 *
 * @param {Matrix} matrix
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.prepend = function(matrix)
{
    var tx1 = this.tx;

    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
    {
        var a1 = this.a;
        var c1 = this.c;
        this.a  = a1*matrix.a+this.b*matrix.c;
        this.b  = a1*matrix.b+this.b*matrix.d;
        this.c  = c1*matrix.a+this.d*matrix.c;
        this.d  = c1*matrix.b+this.d*matrix.d;
    }

    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;
    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;

    return this;
};

/**
 * Inverts this matrix
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.invert = function()
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1*d1-b1*c1;

    this.a = d1/n;
    this.b = -b1/n;
    this.c = -c1/n;
    this.d = a1/n;
    this.tx = (c1*this.ty-d1*tx1)/n;
    this.ty = -(a1*this.ty-b1*tx1)/n;

    return this;
};


/**
 * Resets this Matix to an identity (default) matrix.
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.identity = function ()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;

    return this;
};

/**
 * Creates a new Matrix object with the same values as this one.
 *
 * @return {Matrix} A copy of this matrix. Good for chaining method calls.
 */
Matrix.prototype.clone = function ()
{
    var matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the given matrix to be the same as the ones in this matrix
 *
 * @return {Matrix} The matrix given in parameter with its values updated.
 */
Matrix.prototype.copy = function (matrix)
{
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * A default (identity) matrix
 *
 * @static
 * @const
 */
Matrix.IDENTITY = new Matrix();

/**
 * A temp matrix
 *
 * @static
 * @const
 */
Matrix.TEMP_MATRIX = new Matrix();

},{"./Point":48}],48:[function(require,module,exports){
/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
function Point(x, y)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;
}

Point.prototype.constructor = Point;
module.exports = Point;

/**
 * Creates a clone of this point
 *
 * @return {Point} a copy of the point
 */
Point.prototype.clone = function ()
{
    return new Point(this.x, this.y);
};

/**
 * Copies x and y from the given point
 *
 * @param p {Point}
 */
Point.prototype.copy = function (p) {
    this.set(p.x, p.y);
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param p {Point}
 * @returns {boolean}
 */
Point.prototype.equals = function (p) {
    return (p.x === this.x) && (p.y === this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
Point.prototype.set = function (x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

},{}],49:[function(require,module,exports){
var Point = require('./Point'),
    CONST = require('../const');

/**
 * @class
 * @memberof PIXI
 * @param points {PIXI.Point[]|number[]|...PIXI.Point|...number} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
function Polygon(points_)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = points_;

    //if points isn't an array, use arguments as the array
    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var a = 0; a < points.length; ++a) {
            points[a] = arguments[a];
        }
    }

    // if this is an array of points, convert it to a flat array of numbers
    if (points[0] instanceof Point)
    {
        var p = [];
        for (var i = 0, il = points.length; i < il; i++)
        {
            p.push(points[i].x, points[i].y);
        }

        points = p;
    }

    this.closed = true;

    /**
     * An array of the points of this polygon
     *
     * @member {number[]}
     */
    this.points = points;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = 0;//CONST.SHAPES.POLY;
}

Polygon.prototype.constructor = Polygon;
module.exports = Polygon;

/**
 * Creates a clone of this polygon
 *
 * @return {PIXI.Polygon} a copy of the polygon
 */
Polygon.prototype.clone = function ()
{
    return new Polygon(this.points.slice());
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this polygon
 */
Polygon.prototype.contains = function (x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    var length = this.points.length / 2;

    for (var i = 0, j = length - 1; i < length; j = i++)
    {
        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],
            xj = this.points[j * 2], yj = this.points[j * 2 + 1],
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect)
        {
            inside = !inside;
        }
    }

    return inside;
};

},{"../const":53,"./Point":48}],50:[function(require,module,exports){
//var CONST = require('../../const');

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class
 * @param x {number} The X coordinate of the upper-left corner of the rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rectangle
 * @param width {number} The overall width of this rectangle
 * @param height {number} The overall height of this rectangle
 */
function Rectangle(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = 1;//CONST.SHAPES.RECT;
}

Rectangle.prototype.constructor = Rectangle;
module.exports = Rectangle;

/**
 * A constant empty rectangle.
 *
 * @static
 * @constant
 */
Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);


/**
 * Creates a clone of this Rectangle
 *
 * @return {Rectangle} a copy of the rectangle
 */
Rectangle.prototype.clone = function ()
{
    return new Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rectangle
 */
Rectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x < this.x + this.width)
    {
        if (y >= this.y && y < this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{}],51:[function(require,module,exports){
module.exports = {
   NORMAL:         0,
   ADD:            1,
   MULTIPLY:       2,
   SCREEN:         3,
   OVERLAY:        4,
   DARKEN:         5,
   LIGHTEN:        6,
   COLOR_DODGE:    7,
   COLOR_BURN:     8,
   HARD_LIGHT:     9,
   SOFT_LIGHT:     10,
   DIFFERENCE:     11,
   EXCLUSION:      12,
   HUE:            13,
   SATURATION:     14,
   COLOR:          15,
   LUMINOSITY:     16
};

},{}],52:[function(require,module,exports){
module.exports = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    temp: [],
    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,
    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,
    signum: function(x) {
        if (x>0) return 1;
        if (x<0) return -1;
        return 0;
    }
};


},{}],53:[function(require,module,exports){
module.exports = {
    /**
     * @property {number} PI_2 - Two Pi
     * @constant
     * @static
     */
    PI_2: Math.PI * 2,
    /**
     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @constant
     * @property {object} DEFAULT_RENDER_OPTIONS
     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false
     */
    DEFAULT_RENDER_OPTIONS: {
        view: null,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0x000000,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        roundPixels: false
    },
    /**
     * Constant to identify the Renderer Type.
     *
     * @static
     * @constant
     * @property {object} RENDERER_TYPE
     * @property {number} RENDERER_TYPE.UNKNOWN
     * @property {number} RENDERER_TYPE.WEBGL
     * @property {number} RENDERER_TYPE.CANVAS
     */
    RENDERER_TYPE: {
        UNKNOWN:    0,
        WEBGL:      1,
        CANVAS:     2
    },

    /**
     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
     * NORMAL.
     *
     * @static
     * @constant
     * @property {object} BLEND_MODES
     * @property {number} BLEND_MODES.NORMAL
     * @property {number} BLEND_MODES.ADD
     * @property {number} BLEND_MODES.MULTIPLY
     * @property {number} BLEND_MODES.SCREEN
     * @property {number} BLEND_MODES.OVERLAY
     * @property {number} BLEND_MODES.DARKEN
     * @property {number} BLEND_MODES.LIGHTEN
     * @property {number} BLEND_MODES.COLOR_DODGE
     * @property {number} BLEND_MODES.COLOR_BURN
     * @property {number} BLEND_MODES.HARD_LIGHT
     * @property {number} BLEND_MODES.SOFT_LIGHT
     * @property {number} BLEND_MODES.DIFFERENCE
     * @property {number} BLEND_MODES.EXCLUSION
     * @property {number} BLEND_MODES.HUE
     * @property {number} BLEND_MODES.SATURATION
     * @property {number} BLEND_MODES.COLOR
     * @property {number} BLEND_MODES.LUMINOSITY
     */
    BLEND_MODES: {
        NORMAL:         0,
        ADD:            1,
        MULTIPLY:       2,
        SCREEN:         3,
        OVERLAY:        4,
        DARKEN:         5,
        LIGHTEN:        6,
        COLOR_DODGE:    7,
        COLOR_BURN:     8,
        HARD_LIGHT:     9,
        SOFT_LIGHT:     10,
        DIFFERENCE:     11,
        EXCLUSION:      12,
        HUE:            13,
        SATURATION:     14,
        COLOR:          15,
        LUMINOSITY:     16
    },

    /**
     * The scale modes that are supported by pixi.
     *
     * The DEFAULT scale mode affects the default scaling mode of future operations.
     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
     *
     * @static
     * @constant
     * @property {object} SCALE_MODES
     * @property {number} SCALE_MODES.DEFAULT=LINEAR
     * @property {number} SCALE_MODES.LINEAR Smooth scaling
     * @property {number} SCALE_MODES.NEAREST Pixelating scaling
     */
    SCALE_MODES: {
        DEFAULT:    0,
        LINEAR:     0,
        NEAREST:    1
    }
};

},{}],54:[function(require,module,exports){
var utils = require('../utils.js'),
    Matrix = require('../SpineUtil/Matrix.js'),
    Rectangle = require('../SpineUtil/Rectangle.js'),
    DisplayObject = require('./DisplayObject'),
    //RenderTexture = require('../textures/RenderTexture'),
    _tempMatrix = new Matrix();

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * var container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
function Container()
{
    DisplayObject.call(this);

    /**
     * The array of children of this container.
     *
     * @member {PIXI.DisplayObject[]}
     * @readonly
     */
    this.children = [];
}

// constructor
Container.prototype = Object.create(DisplayObject.prototype);
Container.prototype.constructor = Container;
module.exports = Container;

Object.defineProperties(Container.prototype, {
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    width: {
        get: function ()
        {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function (value)
        {

            var width = this.getLocalBounds().width;

            if (width !== 0)
            {
                this.scale.x = value / width;
            }
            else
            {
                this.scale.x = 1;
            }


            this._width = value;
        }
    },

    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Container#
     */
    height: {
        get: function ()
        {
            return  this.scale.y * this.getLocalBounds().height;
        },
        set: function (value)
        {

            var height = this.getLocalBounds().height;

            if (height !== 0)
            {
                this.scale.y = value / height ;
            }
            else
            {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }
});

/**
 * Overridable method that can be used by Container subclasses whenever the children array is modified
 *
 * @private
 */
Container.prototype.onChildrenChange = function () {};

/**
 * Adds a child to the container.
 *
 * You can also add multple items like so: myContainer.addChild(thinkOne, thingTwo, thingThree)
 * @param child {PIXI.DisplayObject} The DisplayObject to add to the container
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChild = function (child)
{
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.addChild( arguments[i] );
        }
    }
    else
    {
        // if the child has a parent then lets remove it as Pixi objects can only exist in one place
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.push(child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(this.children.length-1);
        child.emit('added', this);
    }

    return child;
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @param child {PIXI.DisplayObject} The child to add
 * @param index {number} The index to place the child in
 * @return {PIXI.DisplayObject} The child that was added.
 */
Container.prototype.addChildAt = function (child, index)
{
    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);

        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * Swaps the position of 2 Display Objects within this container.
 *
 * @param child {PIXI.DisplayObject}
 * @param child2 {PIXI.DisplayObject}
 */
Container.prototype.swapChildren = function (child, child2)
{
    if (child === child2)
    {
        return;
    }

    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);

    if (index1 < 0 || index2 < 0)
    {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
};

/**
 * Returns the index position of a child DisplayObject instance
 *
 * @param child {PIXI.DisplayObject} The DisplayObject instance to identify
 * @return {number} The index position of the child display object to identify
 */
Container.prototype.getChildIndex = function (child)
{
    var index = this.children.indexOf(child);

    if (index === -1)
    {
        throw new Error('The supplied DisplayObject must be a child of the caller');
    }

    return index;
};

/**
 * Changes the position of an existing child in the display object container
 *
 * @param child {PIXI.DisplayObject} The child DisplayObject instance for which you want to change the index number
 * @param index {number} The resulting index number for the child display object
 */
Container.prototype.setChildIndex = function (child, index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('The supplied index is out of bounds');
    }

    var currentIndex = this.getChildIndex(child);

    utils.removeItems(this.children, currentIndex, 1); // remove from old position
    this.children.splice(index, 0, child); //add at new position
    this.onChildrenChange(index);
};

/**
 * Returns the child at the specified index
 *
 * @param index {number} The index to get the child at
 * @return {PIXI.DisplayObject} The child at the given index, if any.
 */
Container.prototype.getChildAt = function (index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
    }

    return this.children[index];
};

/**
 * Removes a child from the container.
 *
 * @param child {PIXI.DisplayObject} The DisplayObject to remove
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChild = function (child)
{
    var argumentsLength = arguments.length;

    // if there is only one argument we can bypass looping through the them
    if(argumentsLength > 1)
    {
        // loop through the arguments property and add all children
        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
        for (var i = 0; i < argumentsLength; i++)
        {
            this.removeChild( arguments[i] );
        }
    }
    else
    {
        var index = this.children.indexOf(child);

        if (index === -1)
        {
            return;
        }

        child.parent = null;
        utils.removeItems(this.children, index, 1);

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);
    }

    return child;
};

/**
 * Removes a child from the specified index position.
 *
 * @param index {number} The index to get the child from
 * @return {PIXI.DisplayObject} The child that was removed.
 */
Container.prototype.removeChildAt = function (index)
{
    var child = this.getChildAt(index);

    child.parent = null;
    utils.removeItems(this.children, index, 1);

    // TODO - lets either do all callbacks or all events.. not both!
    this.onChildrenChange(index);
    child.emit('removed', this);

    return child;
};

/**
 * Removes all children from this container that are within the begin and end indexes.
 *
 * @param beginIndex {number} The beginning position. Default value is 0.
 * @param endIndex {number} The ending position. Default value is size of the container.
 */
Container.prototype.removeChildren = function (beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;
    var removed, i;

    if (range > 0 && range <= end)
    {
        removed = this.children.splice(begin, range);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].parent = null;
        }

        this.onChildrenChange(beginIndex);

        for (i = 0; i < removed.length; ++i)
        {
            removed[i].emit('removed', this);
        }

        return removed;
    }
    else if (range === 0 && this.children.length === 0)
    {
        return [];
    }
    else
    {
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
};

/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} a texture of the display object
 */
Container.prototype.generateTexture = function (renderer, resolution, scaleMode)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/*
 * Updates the transform on all children of this container for rendering
 *
 * @private
 */
Container.prototype.updateTransform = function ()
{
    if (!this.visible)
    {
        return;
    }

    this.displayObjectUpdateTransform();

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }
};

// performance increase to avoid using call.. (10x faster)
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

/**
 * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getBounds = function ()
{
    if(!this._currentBounds)
    {

        if (this.children.length === 0)
        {
            return Rectangle.EMPTY;
        }

        // TODO the bounds have already been calculated this render session so return what we have

        var minX = Infinity;
        var minY = Infinity;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var childBounds;
        var childMaxX;
        var childMaxY;

        var childVisible = false;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            if (!child.visible)
            {
                continue;
            }

            childBounds = this.children[i].getBounds();
            if (childBounds === Rectangle.EMPTY) {
                continue;
            }
            childVisible = true;

            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;

            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;

            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }

        if (!childVisible)
        {
            this._currentBounds = Rectangle.EMPTY;
            return this._currentBounds;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;

        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

Container.prototype.containerGetBounds = Container.prototype.getBounds;

/**
 * Retrieves the non-global local bounds of the Container as a rectangle.
 * The calculation takes all visible children into consideration.
 *
 * @return {PIXI.Rectangle} The rectangular bounding area
 */
Container.prototype.getLocalBounds = function ()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = Matrix.IDENTITY;

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }

    this.worldTransform = matrixCache;

    this._currentBounds = null;

    return this.getBounds( Matrix.IDENTITY );
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 */
Container.prototype.renderWebGL = function (renderer)
{

    // if the object is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    var i, j;

    // do a quick check to see if this element has a mask or a filter.
    if (this._mask || this._filters)
    {
        renderer.currentRenderer.flush();

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters && this._filters.length)
        {
            renderer.filterManager.pushFilter(this, this._filters);
        }

        if (this._mask)
        {
            renderer.maskManager.pushMask(this, this._mask);
        }

        renderer.currentRenderer.start();

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (i = 0, j = this.children.length; i < j; i++)
        {
            this.children[i].renderWebGL(renderer);
        }

        renderer.currentRenderer.flush();

        if (this._mask)
        {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (this._filters)
        {
            renderer.filterManager.popFilter();

        }
        renderer.currentRenderer.start();
    }
    else
    {
        this._renderWebGL(renderer);

        // simple render children!
        for (i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].renderWebGL(renderer);
        }
    }
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.WebGLRenderer} The renderer
 * @private
 */
Container.prototype._renderWebGL = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 * @private
 */
Container.prototype._renderCanvas = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};


/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer} The renderer
 */
Container.prototype.renderCanvas = function (renderer)
{
    // if not visible or the alpha is 0 then no need to render this
    if (!this.visible || this.alpha <= 0 || !this.renderable)
    {
        return;
    }

    if (this._mask)
    {
        renderer.maskManager.pushMask(this._mask, renderer);
    }

    renderer.context.save();
    this._renderCanvas(renderer);
    renderer.context.restore();
    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].renderCanvas(renderer);
    }

    if (this._mask)
    {
        renderer.maskManager.popMask(renderer);
    }
};

/**
 * Destroys the container
 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
 */
Container.prototype.destroy = function (destroyChildren)
{
    DisplayObject.prototype.destroy.call(this);

    if (destroyChildren)
    {
        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].destroy(destroyChildren);
        }
    }

    this.removeChildren();

    this.children = null;
};

},{"../SpineUtil/Matrix.js":47,"../SpineUtil/Rectangle.js":50,"../utils.js":67,"./DisplayObject":55}],55:[function(require,module,exports){
var Matrix = require('../SpineUtil/Matrix.js'),
    Point = require('../SpineUtil/Point.js'),
    Rectangle = require('../SpineUtil/Rectangle.js'),
    //RenderTexture = require('../textures/RenderTexture'),
    EventEmitter = require('eventemitter3'),
    CONST = require('../const'),
    _tempMatrix = new Matrix(),
    _tempDisplayObjectParent = {worldTransform:new Matrix(), worldAlpha:1, children:[]};


/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @extends EventEmitter
 * @memberof
 */
function DisplayObject()
{
    EventEmitter.call(this);

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @member {Point}
     */
    this.position = new Point();

    /**
     * The scale factor of the object.
     *
     * @member {Point}
     */
    this.scale = new Point(1, 1);

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @member {Point}
     */
    this.pivot = new Point(0, 0);


    /**
     * The skew factor for the object in radians.
     *
     * @member {Point}
     */
    this.skew = new Point(0, 0);

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @member {number}
     */
    this.alpha = 1;

    /**
     * The visibility of the object. If false the object will not be drawn, and
     * the updateTransform function will not be called.
     *
     * @member {boolean}
     */
    this.visible = true;

    /**
     * Can this object be rendered, if false the object will not be drawn but the updateTransform
     * methods will still be called.
     *
     * @member {boolean}
     */
    this.renderable = true;

    /**
     * The display object container that contains this display object.
     *
     * @member {Container}
     * @readOnly
     */
    this.parent = null;

    /**
     * The multiplied alpha of the displayObject
     *
     * @member {number}
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * Current transform of the object based on world (parent) factors
     *
     * @member {Matrix}
     * @readOnly
     */
    this.worldTransform = new Matrix();

    /**
     * The area the filter is applied to. This is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @member {Rectangle}
     */
    this.filterArea = null;

    /**
     * cached sin rotation
     *
     * @member {number}
     * @private
     */
    this._sr = 0;

    /**
     * cached cos rotation
     *
     * @member {number}
     * @private
     */
    this._cr = 1;

    /**
     * The original, cached bounds of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._bounds = new Rectangle(0, 0, 1, 1);

    /**
     * The most up-to-date bounds of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._currentBounds = null;

    /**
     * The original, cached mask of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._mask = null;
}

// constructor
DisplayObject.prototype = Object.create(EventEmitter.prototype);
DisplayObject.prototype.constructor = DisplayObject;
module.exports = DisplayObject;

Object.defineProperties(DisplayObject.prototype, {
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof DisplayObject#
     */
    x: {
        get: function ()
        {
            return this.position.x;
        },
        set: function (value)
        {
            this.position.x = value;
        }
    },

    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof DisplayObject#
     */
    y: {
        get: function ()
        {
            return this.position.y;
        },
        set: function (value)
        {
            this.position.y = value;
        }
    },

    /**
     * Indicates if the sprite is globally visible.
     *
     * @member {boolean}
     * @memberof DisplayObject#
     * @readonly
     */
    worldVisible: {
        get: function ()
        {
            var item = this;

            do {
                if (!item.visible)
                {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }
    },

    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
     * In PIXI a regular mask must be a PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it utilises shape clipping.
     * To remove a mask, set this property to null.
     *
     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     * @memberof PIXI.DisplayObject#
     */
    mask: {
        get: function ()
        {
            return this._mask;
        },
        set: function (value)
        {
            if (this._mask)
            {
                this._mask.renderable = true;
            }

            this._mask = value;

            if (this._mask)
            {
                this._mask.renderable = false;
            }
        }
    },

    /**
     * Sets the filters for the displayObject.
     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
     * To remove filters simply set this property to 'null'
     *
     * @member {PIXI.AbstractFilter[]}
     * @memberof PIXI.DisplayObject#
     */
    filters: {
        get: function ()
        {
            return this._filters && this._filters.slice();
        },
        set: function (value)
        {
            this._filters = value && value.slice();
        }
    }

});

/*
 * Updates the object transform for rendering
 *
 * TODO - Optimization pass!
 */
DisplayObject.prototype.updateTransform = function ()
{
    // create some matrix refs for easy access
    var pt = this.parent.worldTransform;
    var wt = this.worldTransform;

    // temporary matrix variables
    var a, b, c, d, tx, ty;

    // looks like we are skewing
    if(this.skew.x || this.skew.y)
    {
        // I'm assuming that skewing is not going to be very common
        // With that in mind, we can do a full setTransform using the temp matrix
        _tempMatrix.setTransform(
            this.position.x,
            this.position.y,
            this.pivot.x,
            this.pivot.y,
            this.scale.x,
            this.scale.y,
            this.rotation,
            this.skew.x,
            this.skew.y
        );

        // now concat the matrix (inlined so that we can avoid using copy)
        wt.a  = _tempMatrix.a  * pt.a + _tempMatrix.b  * pt.c;
        wt.b  = _tempMatrix.a  * pt.b + _tempMatrix.b  * pt.d;
        wt.c  = _tempMatrix.c  * pt.a + _tempMatrix.d  * pt.c;
        wt.d  = _tempMatrix.c  * pt.b + _tempMatrix.d  * pt.d;
        wt.tx = _tempMatrix.tx * pt.a + _tempMatrix.ty * pt.c + pt.tx;
        wt.ty = _tempMatrix.tx * pt.b + _tempMatrix.ty * pt.d + pt.ty;
    }
    else
    {
        // so if rotation is between 0 then we can simplify the multiplication process...
        if (this.rotation % CONST.PI_2)
        {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            if (this.rotation !== this.rotationCache)
            {
                this.rotationCache = this.rotation;
                this._sr = Math.sin(this.rotation);
                this._cr = Math.cos(this.rotation);
            }

            // get the matrix values of the displayobject based on its transform properties..
            a  =  this._cr * this.scale.x;
            b  =  this._sr * this.scale.x;
            c  = -this._sr * this.scale.y;
            d  =  this._cr * this.scale.y;
            tx =  this.position.x;
            ty =  this.position.y;

            // check for pivot.. not often used so geared towards that fact!
            if (this.pivot.x || this.pivot.y)
            {
                tx -= this.pivot.x * a + this.pivot.y * c;
                ty -= this.pivot.x * b + this.pivot.y * d;
            }

            // concat the parent matrix with the objects transform.
            wt.a  = a  * pt.a + b  * pt.c;
            wt.b  = a  * pt.b + b  * pt.d;
            wt.c  = c  * pt.a + d  * pt.c;
            wt.d  = c  * pt.b + d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        else
        {
            // lets do the fast version as we know there is no rotation..
            a  = this.scale.x;
            d  = this.scale.y;

            tx = this.position.x - this.pivot.x * a;
            ty = this.position.y - this.pivot.y * d;

            wt.a  = a  * pt.a;
            wt.b  = a  * pt.b;
            wt.c  = d  * pt.c;
            wt.d  = d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
    }

    // multiply the alphas..
    this.worldAlpha = this.alpha * this.parent.worldAlpha;

    // reset the bounds each time this is called!
    this._currentBounds = null;
};

// performance increase to avoid using call.. (10x faster)
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

/**
 *
 *
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @param matrix {Matrix}
 * @return {Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getBounds = function (matrix) // jshint unused:false
{
    return Rectangle.EMPTY;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @return {Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getLocalBounds = function ()
{
    return this.getBounds(Matrix.IDENTITY);
};

/**
 * Calculates the global position of the display object
 *
 * @param position {Point} The world origin to calculate from
 * @return {Point} A point object representing the position of this object
 */
DisplayObject.prototype.toGlobal = function (position)
{
    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // don't need to update the lot
    return this.worldTransform.apply(position);
};

/**
 * Calculates the local position of the display object relative to another point
 *
 * @param position {Point} The world origin to calculate from
 * @param [from] {DisplayObject} The DisplayObject to calculate the global position from
 * @param [point] {Point} A Point object in which to store the value, optional (otherwise will create a new Point)
 * @return {Point} A point object representing the position of this object
 */
DisplayObject.prototype.toLocal = function (position, from, point)
{
    if (from)
    {
        position = from.toGlobal(position);
    }

    // this parent check is for just in case the item is a root object.
    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
    if(!this.parent)
    {
        this.parent = _tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
    }
    else
    {
        this.displayObjectUpdateTransform();
    }

    // simply apply the matrix..
    return this.worldTransform.applyInverse(position, point);
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};
/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} The resolution of the texture being generated
 * @return {PIXI.Texture} a texture of the display object
 */
DisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/**
 * Set the parent Container of this DisplayObject
 *
 * @param container {Container} The Container to add this DisplayObject to
 * @return {Container} The Container that this DisplayObject was added to
 */
DisplayObject.prototype.setParent = function (container)
{
    if (!container || !container.addChild)
    {
        throw new Error('setParent: Argument must be a Container');
    }

    container.addChild(this);
    return container;
};

/**
 * Convenience function to set the postion, scale, skew and pivot at once.
 *
 * @param [x=0] {number} The X position
 * @param [y=0] {number} The Y position
 * @param [scaleX=1] {number} The X scale value
 * @param [scaleY=1] {number} The Y scale value
 * @param [rotation=0] {number} The rotation
 * @param [skewX=0] {number} The X skew value
 * @param [skewY=0] {number} The Y skew value
 * @param [pivotX=0] {number} The X pivot value
 * @param [pivotY=0] {number} The Y pivot value
 * @return {PIXI.DisplayObject}
 */
DisplayObject.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) //jshint ignore:line
{
    this.position.x = x || 0;
    this.position.y = y || 0;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation || 0;
    this.skew.x = skewX || 0;
    this.skew.y = skewY || 0;
    this.pivot.x = pivotX || 0;
    this.pivot.y = pivotY || 0;
    return this;
};

/**
 * Base destroy method for generic display objects
 *
 */
DisplayObject.prototype.destroy = function ()
{

    this.position = null;
    this.scale = null;
    this.pivot = null;
    this.skew = null;

    this.parent = null;

    this._bounds = null;
    this._currentBounds = null;
    this._mask = null;

    this.worldTransform = null;
    this.filterArea = null;
};

},{"../SpineUtil/Matrix.js":47,"../SpineUtil/Point.js":48,"../SpineUtil/Rectangle.js":50,"../const":53,"eventemitter3":2}],56:[function(require,module,exports){
var Point = require('../SpineUtil/Point.js'),
    CONST = require('../const.js'),
    Polygon = require('../SpineUtil/Polygon.js'),
    Container = require('../display/Container.js'),
    tempPoint = new Point(),
    tempPolygon = new Polygon();

/**
 * Base mesh class
 * @class
 * @extends PIXI.Container
 * @memberof PIXI.mesh
 * @param texture {PIXI.Texture} The texture to use
 * @param [vertices] {Float32Array} if you want to specify the vertices
 * @param [uvs] {Float32Array} if you want to specify the uvs
 * @param [indices] {Uint16Array} if you want to specify the indices
 * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts
 */
function Mesh(texture, vertices, uvs, indices, drawMode)
{
    Container.call(this);

    /**
     * The texture of the Mesh
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The Uvs of the Mesh
     *
     * @member {Float32Array}
     */
    this.uvs = uvs || new Float32Array([0, 0,
        1, 0,
        1, 1,
        0, 1]);

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = vertices || new Float32Array([0, 0,
        100, 0,
        100, 100,
        0, 100]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    //  TODO auto generate this based on draw mode!
    this.indices = indices || new Uint16Array([0, 1, 3, 2]);

    /**
     * Whether the Mesh is dirty or not
     *
     * @member {boolean}
     */
    this.dirty = true;

    /**
     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove any blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.
     *
     * @member {number}
     */
    this.canvasPadding = 0;

    /**
     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
     *
     * @member {number}
     * @see PIXI.mesh.Mesh.DRAW_MODES
     */
    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;

    // run texture setter;
    this.texture = texture;

     /**
     * The default shader that is used if a mesh doesn't have a more specific one.
     *
     * @member {PIXI.Shader}
     */
    this.shader = null;
}

// constructor
Mesh.prototype = Object.create(Container.prototype);
Mesh.prototype.constructor = Mesh;
module.exports = Mesh;

Object.defineProperties(Mesh.prototype, {
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.mesh.Mesh#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {PIXI.WebGLRenderer} a reference to the WebGL renderer
 * @private
 */
Mesh.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.mesh);
    renderer.plugins.mesh.render(this);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {PIXI.CanvasRenderer}
 * @private
 */
Mesh.prototype._renderCanvas = function (renderer)
{
    var context = renderer.context;

    var transform = this.worldTransform;
    var res = renderer.resolution;

    if (renderer.roundPixels)
    {
        //context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, (transform.tx * res) | 0, (transform.ty * res) | 0);
        context.transform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, (transform.tx * res) | 0, (transform.ty * res) | 0);
    }
    else
    {
        //context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
        context.transform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
    }

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)
    {
        this._renderCanvasTriangleMesh(context);
    }
    else
    {
        this._renderCanvasTriangles(context);
    }
};

/**
 * Draws the object in Triangle Mesh mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangleMesh = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;

    var length = vertices.length / 2;
    // this.count++;

    for (var i = 0; i < length - 2; i++)
    {
        // draw some triangles!
        var index = i * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
    }
};

/**
 * Draws the object in triangle mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangles = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;
    var indices = this.indices;

    var length = indices.length;
    // this.count++;

    for (var i = 0; i < length; i += 3)
    {
        // draw some triangles!
        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
    }
};

/**
 * Draws one of the triangles that form this Mesh
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @param vertices {Float32Array} a reference to the vertices of the Mesh
 * @param uvs {Float32Array} a reference to the uvs of the Mesh
 * @param index0 {number} the index of the first vertex
 * @param index1 {number} the index of the second vertex
 * @param index2 {number} the index of the third vertex
 * @private
 */
Mesh.triArray = new Float32Array(12);
Mesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)
{
    var base = this._texture.baseTexture;
    var textureSource = base.source;
    var textureWidth = base.width;
    var textureHeight = base.height;

    if(context.drawImageTriArr) {
        Mesh.triArray[0] = uvs[index0] * base.width;
        Mesh.triArray[1] = uvs[index0 + 1] * base.height;
        Mesh.triArray[2] = vertices[index0];
        Mesh.triArray[3] = vertices[index0 + 1];
        Mesh.triArray[4] = uvs[index1] * base.width;
        Mesh.triArray[5] = uvs[index1 + 1] * base.height;
        Mesh.triArray[6] = vertices[index1];
        Mesh.triArray[7] = vertices[index1 + 1];
        Mesh.triArray[8] = uvs[index2] * base.width;
        Mesh.triArray[9] = uvs[index2 + 1] * base.height;
        Mesh.triArray[10] = vertices[index2];
        Mesh.triArray[11] = vertices[index2 + 1];

        //context.drawImageTri(textureSource, u0, v0, x0, y0, u1, v1, x1, y1, u2, v2, x2, y2);
        context.drawImageTriArr(textureSource, Mesh.triArray);
        return;
    }

    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];

    var u0 = uvs[index0] * base.width, u1 = uvs[index1] * base.width, u2 = uvs[index2] * base.width;
    var v0 = uvs[index0 + 1] * base.height, v1 = uvs[index1 + 1] * base.height, v2 = uvs[index2 + 1] * base.height;

    if (this.canvasPadding > 0)
    {
        var paddingX = this.canvasPadding / this.worldTransform.a;
        var paddingY = this.canvasPadding / this.worldTransform.d;
        var centerX = (x0 + x1 + x2) / 3;
        var centerY = (y0 + y1 + y2) / 3;

        var normX = x0 - centerX;
        var normY = y0 - centerY;

        var dist = Math.sqrt(normX * normX + normY * normY);
        x0 = centerX + (normX / dist) * (dist + paddingX);
        y0 = centerY + (normY / dist) * (dist + paddingY);

        //

        normX = x1 - centerX;
        normY = y1 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x1 = centerX + (normX / dist) * (dist + paddingX);
        y1 = centerY + (normY / dist) * (dist + paddingY);

        normX = x2 - centerX;
        normY = y2 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x2 = centerX + (normX / dist) * (dist + paddingX);
        y2 = centerY + (normY / dist) * (dist + paddingY);
    }

    context.save();
    context.beginPath();


    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);

    context.closePath();

    context.clip();

    // Compute matrix transform
    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);
    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);
    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);
    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);
    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);
    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);

    context.transform(deltaA / delta, deltaD / delta,
        deltaB / delta, deltaE / delta,
        deltaC / delta, deltaF / delta);

    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
    context.restore();
};



/**
 * Renders a flat Mesh
 *
 * @param Mesh {PIXI.mesh.Mesh} The Mesh to render
 * @private
 */
Mesh.prototype.renderMeshFlat = function (Mesh)
{
    var context = this.context;
    var vertices = Mesh.vertices;

    var length = vertices.length/2;
    // this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];
        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = '#FF0000';
    context.fill();
    context.closePath();
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @param event
 * @private
 */
Mesh.prototype._onTextureUpdate = function ()
{
    this.updateFrame = true;
};

/**
 * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Mesh.prototype.getBounds = function (matrix)
{
    if (!this._currentBounds) {
        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var minX = Infinity;
        var minY = Infinity;

        var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2) {
            var rawX = vertices[i], rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;

            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }

        if (minX === -Infinity || maxY === Infinity) {
            return Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
 *
 * @param point {PIXI.Point} the point to test
 * @return {boolean} the result of the test
 */
Mesh.prototype.containsPoint = function( point ) {
    if (!this.getBounds().contains(point.x, point.y)) {
        return false;
    }
    this.worldTransform.applyInverse(point,  tempPoint);

    var vertices = this.vertices;
    var points = tempPolygon.points;
    var i, len;

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {
        var indices = this.indices;
        len = this.indices.length;
        //TODO: inline this.
        for (i=0;i<len;i+=3) {
            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0+1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1+1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2+1];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    } else {
        len = vertices.length;
        for (i=0;i<len;i+=6) {
            points[0] = vertices[i];
            points[1] = vertices[i+1];
            points[2] = vertices[i+2];
            points[3] = vertices[i+3];
            points[4] = vertices[i+4];
            points[5] = vertices[i+5];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Different drawing buffer modes supported
 *
 * @static
 * @constant
 * @property {object} DRAW_MODES
 * @property {number} DRAW_MODES.TRIANGLE_MESH
 * @property {number} DRAW_MODES.TRIANGLES
 */
Mesh.DRAW_MODES = {
    TRIANGLE_MESH: 0,
    TRIANGLES: 1
};

},{"../SpineUtil/Point.js":48,"../SpineUtil/Polygon.js":49,"../const.js":53,"../display/Container.js":54}],57:[function(require,module,exports){
var Mesh = require('./Mesh');

/**
 * The Plane allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the Plane.
 * @param {int} segmentsX - The number ox x segments
 * @param {int} segmentsY - The number of y segments
 *
 */
function Plane(texture, segmentsX, segmentsY)
{
    Mesh.call(this, texture);

    /**
     * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
    this._ready = true;

    this.segmentsX =  segmentsX || 10;
    this.segmentsY = segmentsY || 10;

    this.drawMode = Mesh.DRAW_MODES.TRIANGLES;
    this.refresh();

}


// constructor
Plane.prototype = Object.create( Mesh.prototype );
Plane.prototype.constructor = Plane;
module.exports = Plane;

/**
 * Refreshes
 *
 */
Plane.prototype.refresh = function()
{
    var total = this.segmentsX * this.segmentsY;
    var verts = [];
    var colors = [];
    var uvs = [];
    var indices = [];
    var texture = this.texture;

  //  texture.width = 800 texture.width || 800;
 //   texture.height = 800//texture.height || 800;

    var segmentsXSub = this.segmentsX - 1;
    var segmentsYSub = this.segmentsY - 1;
    var i = 0;

    var sizeX = texture.width / segmentsXSub;
    var sizeY = texture.height / segmentsYSub;

    for (i = 0; i < total; i++) {

        var x = (i % this.segmentsX);
        var y = ( (i / this.segmentsX ) | 0 );


        verts.push((x * sizeX),
                   (y * sizeY));

        // this works for rectangular textures. 
        uvs.push(texture._uvs.x0 + (texture._uvs.x1 - texture._uvs.x0) * (x / (this.segmentsX-1)), texture._uvs.y0 + (texture._uvs.y3-texture._uvs.y0) * (y/ (this.segmentsY-1)));
      }

    //  cons

    var totalSub = segmentsXSub * segmentsYSub;

    for (i = 0; i < totalSub; i++) {

        var xpos = i % segmentsXSub;
        var ypos = (i / segmentsXSub ) | 0;


        var  value = (ypos * this.segmentsX) + xpos;
        var  value2 = (ypos * this.segmentsX) + xpos + 1;
        var  value3 = ((ypos+1) * this.segmentsX) + xpos;
        var  value4 = ((ypos+1) * this.segmentsX) + xpos + 1;

        indices.push(value, value2, value3);
        indices.push(value2, value4, value3);
    }


    //console.log(indices)
    this.vertices = new Float32Array(verts);
    this.uvs = new Float32Array(uvs);
    this.colors = new Float32Array(colors);
    this.indices = new Uint16Array(indices);
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Plane.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Plane ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

},{"./Mesh":56}],58:[function(require,module,exports){
var Mesh = require('./Mesh');
var Point = require('../SpineUtil/Point.js');

/**
 * The rope allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.mesh.Mesh
 * @memberof PIXI.mesh
 * @param {PIXI.Texture} texture - The texture to use on the rope.
 * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
 *
 */
function Rope(texture, points)
{
    Mesh.call(this, texture);

    /*
     * @member {PIXI.Point[]} An array of points that determine the rope
     */
    this.points = points;

    /*
     * @member {Float32Array} An array of vertices used to construct this rope.
     */
    this.vertices = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} The WebGL Uvs of the rope.
     */
    this.uvs = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} An array containing the color components
     */
    this.colors = new Float32Array(points.length * 2);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array(points.length * 2);

    /**
     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can
     * call _onTextureUpdated which could call refresh too early.
     *
     * @member {boolean}
     * @private
     */
     this._ready = true;

     this.refresh();
}


// constructor
Rope.prototype = Object.create(Mesh.prototype);
Rope.prototype.constructor = Rope;
module.exports = Rope;

/**
 * Refreshes
 *
 */
Rope.prototype.refresh = function ()
{
    var points = this.points;

    // if too little points, or texture hasn't got UVs set yet just move on.
    if (points.length < 1 || !this._texture._uvs)
    {
        return;
    }

    var uvs = this.uvs;

    var indices = this.indices;
    var colors = this.colors;

    var textureUvs = this._texture._uvs;
    var offset = new Point(textureUvs.x0, textureUvs.y0);
    var factor = new Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);

    uvs[0] = 0 + offset.x;
    uvs[1] = 0 + offset.y;
    uvs[2] = 0 + offset.x;
    uvs[3] = 1 * factor.y + offset.y;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        uvs[index] = amount * factor.x + offset.x;
        uvs[index+1] = 0 + offset.y;

        uvs[index+2] = amount * factor.x + offset.x;
        uvs[index+3] = 1 * factor.y + offset.y;

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;
    }

    this.dirty = true;
};

/**
 * Clear texture UVs when new texture is set
 *
 * @private
 */
Rope.prototype._onTextureUpdate = function ()
{
    Mesh.prototype._onTextureUpdate.call(this);

    // wait for the Rope ctor to finish before calling refresh
    if (this._ready) {
        this.refresh();
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
Rope.prototype.updateTransform = function ()
{
    var points = this.points;

    if (points.length < 1)
    {
        return;
    }

    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;

    // this.count -= 0.2;

    var vertices = this.vertices;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if (i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if (ratio > 1)
        {
            ratio = 1;
        }

        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perpX /= perpLength;
        perpY /= perpLength;

        perpX *= num;
        perpY *= num;

        vertices[index] = point.x + perpX;
        vertices[index+1] = point.y + perpY;
        vertices[index+2] = point.x - perpX;
        vertices[index+3] = point.y - perpY;

        lastPoint = point;
    }

    this.containerUpdateTransform();
};

},{"../SpineUtil/Point.js":48,"./Mesh":56}],59:[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.mesh
 */
module.exports = {
    Mesh:           require('./Mesh'),
    Plane:           require('./Plane'),
    Rope:           require('./Rope')
    //MeshRenderer:   require('./webgl/MeshRenderer'),
    //MeshShader:     require('./webgl/MeshShader')
};

},{"./Mesh":56,"./Plane":57,"./Rope":58}],60:[function(require,module,exports){
var utils = require('../utils'),
    Matrix = require('../SpineUtil/Matrix.js'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @param system {string} The name of the system this renderer is for.
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.backgroundColor=0x000000] {number} The background color of the rendered area (shown if not transparent).
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function SystemRenderer(system, width, height, options)
{
    EventEmitter.call(this);

    //utils.sayHello(system);

    // prepare options
    if (options)
    {
        for (var i in CONST.DEFAULT_RENDER_OPTIONS)
        {
            if (typeof options[i] === 'undefined')
            {
                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
            }
        }
    }
    else
    {
        options = CONST.DEFAULT_RENDER_OPTIONS;
    }

    /**
     * The type of the renderer.
     *
     * @member {number}
     * @default PIXI.RENDERER_TYPE.UNKNOWN
     * @see PIXI.RENDERER_TYPE
     */
    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    /**
     * The width of the canvas view
     *
     * @member {number}
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @member {number}
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    //this.view = options.view || document.createElement('canvas');

    /**
     * The resolution of the renderer
     *
     * @member {number}
     * @default 1
     */
    this.resolution = options.resolution;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    this.transparent = options.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @member {boolean}
     */
    this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    this.clearBeforeRender = options.clearBeforeRender;

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    this.roundPixels = options.roundPixels;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    this._backgroundColorRgb = [0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    this._backgroundColorString = '#000000';

    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {worldTransform:new Matrix(), worldAlpha:1, children:[]};

    /**
     * The last root object that the renderer tried to render.
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._lastObjectRendered = this._tempDisplayObjectParent;
}

// constructor
SystemRenderer.prototype = Object.create(EventEmitter.prototype);
SystemRenderer.prototype.constructor = SystemRenderer;
module.exports = SystemRenderer;

Object.defineProperties(SystemRenderer.prototype, {
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     * @memberof PIXI.SystemRenderer#
     */
    backgroundColor:
    {
        get: function ()
        {
            return this._backgroundColor;
        },
        set: function (val)
        {
            this._backgroundColor = val;
            this._backgroundColorString = utils.hex2string(val);
            utils.hex2rgb(val, this._backgroundColorRgb);
        }
    }
});

/**
 * Resizes the canvas view to the specified width and height
 *
 * @param width {number} the new width of the canvas view
 * @param height {number} the new height of the canvas view
 */
SystemRenderer.prototype.resize = function (width, height) {
    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize)
    {
        this.view.style.width = this.width / this.resolution + 'px';
        this.view.style.height = this.height / this.resolution + 'px';
    }
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
SystemRenderer.prototype.destroy = function (removeView) {
    if (removeView && this.view.parentNode)
    {
        this.view.parentNode.removeChild(this.view);
    }

    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    this.width = 0;
    this.height = 0;

    this.view = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this.roundPixels = false;

    this._backgroundColor = 0;
    this._backgroundColorRgb = null;
    this._backgroundColorString = null;
};

},{"../SpineUtil/Matrix.js":47,"../const":53,"../utils":67,"eventemitter3":2}],61:[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    utils = require('../../utils'),
    Matrix = require('../../SpineUtil/Matrix.js'),
    CONST = require('../../const');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.SystemRenderer
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
 */
function CanvasRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'Canvas', width, height, options);

    this.type = CONST.RENDERER_TYPE.CANVAS;

    this.refresh = true;
    this._mapBlendModes();

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {PIXI.DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {
        worldTransform: new Matrix(),
        worldAlpha: 1
    };
}

// constructor
CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
CanvasRenderer.prototype.constructor = CanvasRenderer;
module.exports = CanvasRenderer;
//utils.pluginTarget.mixin(CanvasRenderer);


CanvasRenderer.prototype.setContext = function (context) {
    this.context = context;
};

/**
 * Renders the object to this canvas view
 *
 * @param object {PIXI.DisplayObject} the object to be rendered
 */
CanvasRenderer.prototype.render = function (object)
{
    var cacheParent = object.parent;

    this._lastObjectRendered = object;

    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;
    this.renderDisplayObject(object, this.context);
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
CanvasRenderer.prototype.destroy = function (removeView)
{
    SystemRenderer.prototype.destroy.call(this, removeView);
    this.context = null;
    this.refresh = true;
};

/**
 * Renders a display object
 *
 * @param displayObject {PIXI.DisplayObject} The displayObject to render
 * @private
 */
CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)
{
    var tempContext = this.context;

    this.context = context;
    displayObject.renderCanvas(this);
    this.context = tempContext;
};

/**
 * Maps Pixi blend modes to canvas blend modes.
 *
 * @private
 */
CanvasRenderer.prototype._mapBlendModes = function ()
{
    if (!this.blendModes)
    {
        this.blendModes = {};

       this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
       this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
       this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';
       this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';
       this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';
       this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';
       this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';
       this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';
       this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';
       this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';
       this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';
       this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';
       this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';
       this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';
       this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturate';
       this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';
       this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';
    }
};

},{"../../SpineUtil/Matrix.js":47,"../../const":53,"../../utils":67,"../SystemRenderer":60}],62:[function(require,module,exports){
var utils = require('../../../utils');

/**
 * Utility methods for Sprite/Texture tinting.
 * @static
 * @class
 * @memberof PIXI
 */
var CanvasTinter = {};
module.exports = CanvasTinter;

/**
 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
 *
 * @param sprite {PIXI.Sprite} the sprite to tint
 * @param color {number} the color to use to tint the sprite with
 * @return {HTMLCanvasElement} The tinted canvas
 */
CanvasTinter.getTintedTexture = function (sprite, color)
{
    var texture = sprite.texture;

    color = CanvasTinter.roundColor(color);

    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    texture.tintCache = texture.tintCache || {};

    if (texture.tintCache[stringColor])
    {
        return texture.tintCache[stringColor];
    }

     // clone texture..
    var canvas = CanvasTinter.canvas || document.createElement('canvas');

    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
    CanvasTinter.tintMethod(texture, color, canvas);

    if (CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        CanvasTinter.canvas = null;
    }

    return canvas;
};

/**
 * Tint a texture using the 'multiply' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithMultiply = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'multiply';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    context.globalCompositeOperation = 'destination-atop';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );
};

/**
 * Tint a texture using the 'overlay' operation.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithOverlay = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'destination-atop';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    // context.globalCompositeOperation = 'copy';
};

/**
 * Tint a texture pixel per pixel.
 *
 * @param texture {PIXI.Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithPerPixel = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var resolution = texture.baseTexture.resolution;

    var crop = texture.crop.clone();
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    var rgbValues = utils.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, crop.width, crop.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
 *
 * @param color {number} the color to round, should be a hex color
 */
CanvasTinter.roundColor = function (color)
{
    var step = CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = utils.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return utils.rgb2hex(rgbValues);
};

/**
 * Number of steps which will be used as a cap when rounding colors.
 *
 * @member
 */
CanvasTinter.cacheStepsPerColorChannel = 8;

/**
 * Tint cache boolean flag.
 *
 * @member
 */
CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
 *
 * @member
 */
CanvasTinter.canUseMultiply = true;//utils.canUseNewCanvasBlendModes();

/**
 * The tinting method that will be used.
 *
 */
CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;

},{"../../../utils":67}],63:[function(require,module,exports){
var Texture = require('../texture/Texture'),
    Container = require('../display/Container'),
    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),
    utils = require('../utils'),
    CONST = require('../const'),
    Matrix = require('../SpineUtil/Matrix.js'),
    Point = require('../SpineUtil/Point.js'),
    GroupD8 = require('../SpineUtil/GroupD8.js'),
    tempPoint = new Point(),
    GroupD8 = GroupD8,
    canvasRenderWorldTransform = new Matrix();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 * @param texture {PIXI.Texture} The texture for this sprite
 */
function Sprite(texture)
{
    Container.call(this);

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
     *
     * @member {PIXI.Point}
     */
    this.anchor = new Point();

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @private
     */
    this._texture = null;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._height = 0;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * The shader that will be used to render the sprite. Set to null to remove a current shader.
     *
     * @member {PIXI.AbstractFilter|PIXI.Shader}
     */
    this.shader = null;

    /**
     * An internal cached value of the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.cachedTint = 0xFFFFFF;

    // call texture setter
    this.texture = texture || Texture.EMPTY;
}

// constructor
Sprite.prototype = Object.create(Container.prototype);
Sprite.prototype.constructor = Sprite;
module.exports = Sprite;

Object.defineProperties(Sprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    width: {
        get: function ()
        {
            return Math.abs(this.scale.x) * this.texture._frame.width;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.x) || 1;
            this.scale.x = sign * value / this.texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof PIXI.Sprite#
     */
    height: {
        get: function ()
        {
            return  Math.abs(this.scale.y) * this.texture._frame.height;
        },
        set: function (value)
        {
            var sign = utils.sign(this.scale.y) || 1;
            this.scale.y = sign * value / this.texture._frame.height;
            this._height = value;
        }
    },

    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     * @memberof PIXI.Sprite#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;
            this.cachedTint = 0xFFFFFF;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @private
 */
Sprite.prototype._onTextureUpdate = function ()
{
    // so if _width is 0 then width was not set..
    if (this._width)
    {
        this.scale.x = utils.sign(this.scale.x) * this._width / this.texture.frame.width;
    }

    if (this._height)
    {
        this.scale.y = utils.sign(this.scale.y) * this._height / this.texture.frame.height;
    }
};

/**
*
* Renders the object using the WebGL renderer
*
* @param renderer {PIXI.WebGLRenderer}
* @private
*/
Sprite.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);
};

/**
 * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
 * @return {PIXI.Rectangle} the framing rectangle
 */
Sprite.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        var width = this._texture._frame.width;
        var height = this._texture._frame.height;

        var w0 = width * (1-this.anchor.x);
        var w1 = width * -this.anchor.x;

        var h0 = height * (1-this.anchor.y);
        var h1 = height * -this.anchor.y;

        var worldTransform = matrix || this.worldTransform ;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var minX,
            maxX,
            minY,
            maxY;

        //TODO - I am SURE this can be optimised, but the below is not accurate enough..
        /*
        if (b === 0 && c === 0)
        {
            // scale may be negative!
            if (a < 0)
            {
                a *= -1;
            }

            if (d < 0)
            {
                d *= -1;
            }

            // this means there is no rotation going on right? RIGHT?
            // if thats the case then we can avoid checking the bound values! yay
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
        }
        else
        {
        */

        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        minX = x1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y1;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x1;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y1;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        //}

        // check for children
        if(this.children.length)
        {
            var childBounds = this.containerGetBounds();

            w0 = childBounds.x;
            w1 = childBounds.x + childBounds.width;
            h0 = childBounds.y;
            h1 = childBounds.y + childBounds.height;

            minX = (minX < w0) ? minX : w0;
            minY = (minY < h0) ? minY : h0;

            maxX = (maxX > w1) ? maxX : w1;
            maxY = (maxY > h1) ? maxY : h1;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

/**
 * Gets the local bounds of the sprite object.
 *
 */
Sprite.prototype.getLocalBounds = function ()
{
    this._bounds.x = -this._texture._frame.width * this.anchor.x;
    this._bounds.y = -this._texture._frame.height * this.anchor.y;
    this._bounds.width = this._texture._frame.width;
    this._bounds.height = this._texture._frame.height;
    return this._bounds;
};

/**
* Tests if a point is inside this sprite
*
* @param point {PIXI.Point} the point to test
* @return {boolean} the result of the test
*/
Sprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._texture._frame.width;
    var height = this._texture._frame.height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
* Renders the object using the Canvas renderer
*
* @param renderer {PIXI.CanvasRenderer} The renderer
* @private
*/
Sprite.prototype._renderCanvas = function (renderer)
{
    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
    {
        return;
    }

    var compositeOperation = renderer.blendModes[this.blendMode];
    if (compositeOperation !== renderer.context.globalCompositeOperation)
    {
        renderer.context.globalCompositeOperation = compositeOperation;
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        var texture = this._texture,
            wt = this.worldTransform,
            dx,
            dy,
            width = texture.crop.width,
            height = texture.crop.height;

        renderer.context.globalAlpha = this.worldAlpha;

        // If smoothingEnabled is supported and we need to change the smoothing property for this texture
        var smoothingEnabled = texture.baseTexture.scaleMode === CONST.SCALE_MODES.LINEAR;
        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)
        {
            renderer.context[renderer.smoothProperty] = smoothingEnabled;
        }

        //inline GroupD8.isSwapWidthHeight
        if ((texture.rotate & 3) === 2) {
            width = texture.crop.height;
            height = texture.crop.width;
        }
        if (texture.trim) {
            dx = texture.crop.width/2 + texture.trim.x - this.anchor.x * texture.trim.width;
            dy = texture.crop.height/2 + texture.trim.y - this.anchor.y * texture.trim.height;
        } else {
            dx = (0.5 - this.anchor.x) * texture._frame.width;
            dy = (0.5 - this.anchor.y) * texture._frame.height;
        }
        if(texture.rotate) {
            wt.copy(canvasRenderWorldTransform);
            wt = canvasRenderWorldTransform;
            GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
            // the anchor has already been applied above, so lets set it to zero
            dx = 0;
            dy = 0;
        }
        dx -= width/2;
        dy -= height/2;
        // Allow for pixel rounding
        if (renderer.roundPixels)
        {
            renderer.context.transform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                (wt.tx * renderer.resolution) | 0,
                (wt.ty * renderer.resolution) | 0
            );

            dx = dx | 0;
            dy = dy | 0;
        }
        else
        {

            renderer.context.transform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                wt.tx * renderer.resolution,
                wt.ty * renderer.resolution
            );


        }

        var resolution = texture.baseTexture.resolution;

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                // TODO clean up caching - how to clean up the caches?
                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderer.context.drawImage(
                this.tintedTexture,
                0,
                0,
                width * resolution,
                height * resolution,
                dx * renderer.resolution,
                dy * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
        else
        {
            renderer.context.drawImage(
                texture.baseTexture.source,
                texture.crop.x * resolution,
                texture.crop.y * resolution,
                width * resolution,
                height * resolution,
                dx  * renderer.resolution,
                dy  * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
    }
};

/**
 * Destroys this sprite and optionally its texture
 *
 * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well
 * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well
 */
Sprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)
{
    Container.prototype.destroy.call(this);

    this.anchor = null;

    if (destroyTexture)
    {
        this._texture.destroy(destroyBaseTexture);
    }

    this._texture = null;
    this.shader = null;
};

// some helper functions..

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
Sprite.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return new Sprite(texture);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {string} The image url of the texture
 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
Sprite.fromImage = function (imageId, crossorigin, scaleMode)
{
    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
};

},{"../SpineUtil/GroupD8.js":46,"../SpineUtil/Matrix.js":47,"../SpineUtil/Point.js":48,"../const":53,"../display/Container":54,"../renderers/canvas/utils/CanvasTinter":62,"../texture/Texture":65,"../utils":67}],64:[function(require,module,exports){
var utils = require('../utils'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3');

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @memberof PIXI
 * @param source {Image|Canvas} the source object of the texture.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @param resolution {number} the resolution of the texture for devices with different pixel ratios
 */
function BaseTexture(source, scaleMode, resolution)
{
    EventEmitter.call(this);

    //this.uid = utils.uid();

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution || 1;

    /**
     * The width of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.width = 100;

    /**
     * The height of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.height = 100;

    // TODO docs
    // used to store the actual dimensions of the source
    /**
     * Used to store the actual width of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realWidth = 100;
    /**
     * Used to store the actual height of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realHeight = 100;

    /**
     * The scale mode to apply when scaling this texture
     *
     * @member {number}
     * @default PIXI.SCALE_MODES.DEFAULT
     * @see PIXI.SCALE_MODES
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Set to true once the base texture has successfully loaded.
     *
     * This is never true if the underlying source fails to load or has no texture data.
     *
     * @member {boolean}
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * Set to true if the source is currently loading.
     *
     * If an Image source is loading the 'loaded' or 'error' event will be
     * dispatched when the operation ends. An underyling source that is
     * immediately-available bypasses loading entirely.
     *
     * @member {boolean}
     * @readonly
     */
    this.isLoading = false;

    /**
     * The image source that is used to create the texture.
     *
     * TODO: Make this a setter that calls loadSource();
     *
     * @member {Image|Canvas}
     * @readonly
     */
    this.source = null; // set in loadSource, if at all

    /**
     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
     * All blend modes, and shaders written for default value. Change it on your own risk.
     *
     * @member {boolean}
     * @default true
     */
    this.premultipliedAlpha = true;

    /**
     * @member {string}
     */
    this.imageUrl = null;

    /**
     * Wether or not the texture is a power of two, try to use power of two textures as much as you can
     * @member {boolean}
     * @private
     */
    this.isPowerOfTwo = false;

    // used for webGL

    /**
     *
     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
     * Also the texture must be a power of two size to work
     *
     * @member {boolean}
     */
    this.mipmap = false;

    /**
     * A map of renderer IDs to webgl textures
     *
     * @member {object<number, WebGLTexture>}
     * @private
     */
    this._glTextures = {};

    // if no source passed don't try to load
    if (source)
    {
        this.loadSource(source);
    }

    /**
     * Fired when a not-immediately-available source finishes loading.
     *
     * @event loaded
     * @memberof PIXI.BaseTexture#
     * @protected
     */

    /**
     * Fired when a not-immediately-available source fails to load.
     *
     * @event error
     * @memberof PIXI.BaseTexture#
     * @protected
     */
}

BaseTexture.prototype = Object.create(EventEmitter.prototype);
BaseTexture.prototype.constructor = BaseTexture;
module.exports = BaseTexture;

/**
 * Updates the texture on all the webgl renderers, this also assumes the src has changed.
 *
 * @fires update
 */
BaseTexture.prototype.update = function ()
{
    this.realWidth = this.source.naturalWidth || this.source.width;
    this.realHeight = this.source.naturalHeight || this.source.height;

    this.width = this.realWidth / this.resolution;
    this.height = this.realHeight / this.resolution;

    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);

    this.emit('update', this);
};

/**
 * Load a source.
 *
 * If the source is not-immediately-available, such as an image that needs to be
 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
 * and `hasLoaded` will remain false after this call.
 *
 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
 *
 *     if (texture.hasLoaded)
 {
 *        // texture ready for use
 *     } else if (texture.isLoading)
 {
 *        // listen to 'loaded' and/or 'error' events on texture
 *     } else {
 *        // not loading, not going to load UNLESS the source is reloaded
 *        // (it may still make sense to listen to the events)
 *     }
 *
 * @protected
 * @param source {Image|Canvas} the source object of the texture.
 */
BaseTexture.prototype.loadSource = function (source)
{
    var wasLoading = this.isLoading;
    this.hasLoaded = false;
    this.isLoading = false;

    if (wasLoading && this.source)
    {
        this.source.onload = null;
        this.source.onerror = null;
    }

    this.source = source;

    // Apply source if loaded. Otherwise setup appropriate loading monitors.
    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this._sourceLoaded();
    }
    else if (!source.getContext)
    {

        // Image fail / not ready
        this.isLoading = true;

        var scope = this;

        source.onload = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope._sourceLoaded();

            scope.emit('loaded', scope);
        };

        source.onerror = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope.emit('error', scope);
        };

        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
        //   "The value of `complete` can thus change while a script is executing."
        // So complete needs to be re-checked after the callbacks have been added..
        // NOTE: complete will be true if the image has no src so best to check if the src is set.
        if (source.complete && source.src)
        {
            this.isLoading = false;

            // ..and if we're complete now, no need for callbacks
            source.onload = null;
            source.onerror = null;

            if (source.width && source.height)
            {
                this._sourceLoaded();

                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('loaded', this);
                }
            }
            else
            {
                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('error', this);
                }
            }
        }
    }
};

/**
 * Used internally to update the width, height, and some other tracking vars once
 * a source has successfully loaded.
 *
 * @private
 */
BaseTexture.prototype._sourceLoaded = function ()
{
    this.hasLoaded = true;
    this.update();
};

/**
 * Destroys this base texture
 *
 */
BaseTexture.prototype.destroy = function ()
{
    if (this.imageUrl)
    {
        delete utils.BaseTextureCache[this.imageUrl];
        delete utils.TextureCache[this.imageUrl];

        this.imageUrl = null;

        if (!navigator.isCocoonJS)
        {
            this.source.src = '';
        }
    }
    else if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[this.source._pixiId];
    }

    this.source = null;

    this.dispose();
};

/**
 * Frees the texture from WebGL memory without destroying this texture object.
 * This means you can still use the texture later which will upload it to GPU
 * memory again.
 *
 */
BaseTexture.prototype.dispose = function ()
{
    this.emit('dispose', this);

    // this should no longer be needed, the renderers should cleanup all the gl textures.
    // this._glTextures = {};
};

/**
 * Changes the source image of the texture.
 * The original source must be an Image element.
 *
 * @param newSrc {string} the path of the image
 */
BaseTexture.prototype.updateSourceImage = function (newSrc)
{
    this.source.src = newSrc;

    this.loadSource(this.source);
};


BaseTexture.fromImageObj = function (image) {
    var texture = new BaseTexture(image);
    texture.hasLoaded = true;
    texture.update();
    return texture;
};

/**
 * Helper function that creates a base texture from the given image url.
 * If the image is not in the base texture cache it will be created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var baseTexture = utils.BaseTextureCache[imageUrl];

    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)
    {
        crossorigin = true;
    }

    if (!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }

        baseTexture = new BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;

        image.src = imageUrl;

        utils.BaseTextureCache[imageUrl] = baseTexture;

        // if there is an @2x at the end of the url we are going to assume its a highres image
        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
    }

    return baseTexture;
};

/**
 * Helper function that creates a base texture from the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return PIXI.BaseTexture
 */
BaseTexture.fromCanvas = function (canvas, scaleMode)
{
    if (!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + utils.uid();
    }

    var baseTexture = utils.BaseTextureCache[canvas._pixiId];

    if (!baseTexture)
    {
        baseTexture = new BaseTexture(canvas, scaleMode);
        utils.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};

},{"../const":53,"../utils":67,"eventemitter3":2}],65:[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    //VideoBaseTexture = require('./VideoBaseTexture'),
    TextureUvs = require('./TextureUvs'),
    EventEmitter = require('eventemitter3'),
    Rectangle = require('../SpineUtil/Rectangle.js'),
    utils = require('../utils');

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.png');
 * var sprite1 = new PIXI.Sprite(texture);
 * var sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * @class
 * @memberof PIXI
 * @param baseTexture {PIXI.BaseTexture} The base texture source to create the texture from
 * @param [frame] {PIXI.Rectangle} The rectangle frame of the texture to show
 * @param [crop] {PIXI.Rectangle} The area of original texture
 * @param [trim] {PIXI.Rectangle} Trimmed texture rectangle
 * @param [rotate] {number} indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
 */
function Texture(baseTexture, frame, crop, trim, rotate)
{
    EventEmitter.call(this);

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @member {boolean}
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new Rectangle(0, 0, 1, 1);
    }

    if (baseTexture instanceof Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @member {PIXI.BaseTexture}
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @member {PIXI.Rectangle}
     * @private
     */
    this._frame = frame;

    /**
     * The texture trim data.
     *
     * @member {PIXI.Rectangle}
     */
    this.trim = trim;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    this.valid = false;

    /**
     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
     *
     * @member {boolean}
     */
    this.requiresUpdate = false;

    /**
     * The WebGL UV data cache.
     *
     * @member {PIXI.TextureUvs}
     * @private
     */
    this._uvs = null;

    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @member {PIXI.Rectangle}
     */
    this.crop = crop || frame;//new Rectangle(0, 0, 1, 1);

    this._rotate = +(rotate || 0);

    if (rotate === true) {
        // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
        this._rotate = 2;
    } else {
        if (this._rotate % 2 !== 0) {
            throw 'attempt to use diamond-shaped UVs. If you are sure, set rotation manually';
        }
    }

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame)
        {
            frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);

            // if there is no frame we should monitor for any base texture changes..
            baseTexture.on('update', this.onBaseTextureUpdated, this);
        }
        this.frame = frame;
    }
    else
    {
        baseTexture.once('loaded', this.onBaseTextureLoaded, this);
    }

    /**
     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
     *
     * @event update
     * @memberof PIXI.Texture#
     * @protected
     */
}

Texture.prototype = Object.create(EventEmitter.prototype);
Texture.prototype.constructor = Texture;
module.exports = Texture;

Object.defineProperties(Texture.prototype, {
    /**
     * The frame specifies the region of the base texture that this texture uses.
     *
     * @member {PIXI.Rectangle}
     * @memberof PIXI.Texture#
     */
    frame: {
        get: function ()
        {
            return this._frame;
        },
        set: function (frame)
        {
            this._frame = frame;

            this.noFrame = false;

            this.width = frame.width;
            this.height = frame.height;

            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
            {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }

            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

            if (this.trim)
            {
                this.width = this.trim.width;
                this.height = this.trim.height;
                this._frame.width = this.trim.width;
                this._frame.height = this.trim.height;
            }
            else
            {
                this.crop = frame;
            }

            if (this.valid)
            {
                this._updateUvs();
            }
        }
    },
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    rotate: {
        get: function ()
        {
            return this._rotate;
        },
        set: function (rotate)
        {
            this._rotate = rotate;
            if (this.valid)
            {
                this._updateUvs();
            }
        }
    }
});

/**
 * Updates this texture on the gpu.
 *
 */
Texture.prototype.update = function ()
{
    this.baseTexture.update();
};

/**
 * Called when the base texture is loaded
 *
 * @private
 */
Texture.prototype.onBaseTextureLoaded = function (baseTexture)
{
    // TODO this code looks confusing.. boo to abusing getters and setterss!
    if (this.noFrame)
    {
        this.frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);
    }
    else
    {
        this.frame = this._frame;
    }

    this.emit('update', this);
};

/**
 * Called when the base texture is updated
 *
 * @private
 */
Texture.prototype.onBaseTextureUpdated = function (baseTexture)
{
    this._frame.width = baseTexture.width;
    this._frame.height = baseTexture.height;

    this.emit('update', this);
};

/**
 * Destroys this texture
 *
 * @param [destroyBase=false] {boolean} Whether to destroy the base texture as well
 */
Texture.prototype.destroy = function (destroyBase)
{
    if (this.baseTexture)
    {
        if (destroyBase)
        {
            this.baseTexture.destroy();
        }

        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

        this.baseTexture = null;
    }

    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.crop = null;

    this.valid = false;

    this.off('dispose', this.dispose, this);
    this.off('update', this.update, this);
};

/**
 * Creates a new texture object that acts the same as this one.
 *
 * @return {PIXI.Texture}
 */
Texture.prototype.clone = function ()
{
    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
};

/**
 * Updates the internal WebGL UV cache.
 *
 * @private
 */
Texture.prototype._updateUvs = function ()
{
    if (!this._uvs)
    {
        this._uvs = new TextureUvs();
    }

    this._uvs.set(this.crop, this.baseTexture, this.rotate);
};

/**
 * Helper function that creates a Texture object from the given image url.
 * If the image is not in the texture cache it will be  created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param crossorigin {boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var texture = utils.TextureCache[imageUrl];

    if (!texture)
    {
        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        utils.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {string} The frame Id of the texture in the cache
 * @return {PIXI.Texture} The newly created texture
 */
Texture.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return texture;
};

/**
 * Helper function that creates a new Texture based on the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture}
 */
Texture.fromCanvas = function (canvas, scaleMode)
{
    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
};

/**
 * Helper function that creates a new Texture based on the given video element.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideo = function (video, scaleMode)
{
    if (typeof video === 'string')
    {
        return Texture.fromVideoUrl(video, scaleMode);
    }
    else
    {
        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
    }
};

/**
 * Helper function that creates a new Texture based on the video url.
 *
 * @static
 * @param videoUrl {string}
 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
 * @return {PIXI.Texture} A Texture
 */
Texture.fromVideoUrl = function (videoUrl, scaleMode)
{
    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
};

/**
 * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
 *
 * @static
 * @param texture {PIXI.Texture} The Texture to add to the cache.
 * @param id {string} The id that the texture will be stored against.
 */
Texture.addTextureToCache = function (texture, id)
{
    utils.TextureCache[id] = texture;
};

/**
 * Remove a texture from the global utils.TextureCache.
 *
 * @static
 * @param id {string} The id of the texture to be removed
 * @return {PIXI.Texture} The texture that was removed
 */
Texture.removeTextureFromCache = function (id)
{
    var texture = utils.TextureCache[id];

    delete utils.TextureCache[id];
    delete utils.BaseTextureCache[id];

    return texture;
};

/**
 * An empty texture, used often to not have to create multiple empty textures.
 *
 * @static
 * @constant
 */
Texture.EMPTY = new Texture(new BaseTexture());

},{"../SpineUtil/Rectangle.js":50,"../utils":67,"./BaseTexture":64,"./TextureUvs":66,"eventemitter3":2}],66:[function(require,module,exports){

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 * @memberof PIXI
 */
function TextureUvs()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 1;
    this.y1 = 0;

    this.x2 = 1;
    this.y2 = 1;

    this.x3 = 0;
    this.y3 = 1;
}

module.exports = TextureUvs;

var GroupD8 = require('../SpineUtil/GroupD8');

/**
 * Sets the texture Uvs based on the given frame information
 * @param frame {PIXI.Rectangle}
 * @param baseFrame {PIXI.Rectangle}
 * @param rotate {number} Rotation of frame, see {@link PIXI.GroupD8}
 * @private
 */
TextureUvs.prototype.set = function (frame, baseFrame, rotate)
{
    var tw = baseFrame.width;
    var th = baseFrame.height;

    if(rotate)
    {
        //width and height div 2 div baseFrame size
        var swapWidthHeight = GroupD8.isSwapWidthHeight(rotate);
        var w2 = (swapWidthHeight ? frame.height : frame.width) / 2 / tw;
        var h2 = (swapWidthHeight ? frame.width : frame.height) / 2 / th;
        //coordinates of center
        var cX = frame.x / tw + w2;
        var cY = frame.y / th + h2;
        rotate = GroupD8.add(rotate, GroupD8.NW); //NW is top-left corner
        this.x0 = cX + w2 * GroupD8.uX(rotate);
        this.y0 = cY + h2 * GroupD8.uY(rotate);
        rotate = GroupD8.add(rotate, 2); //rotate 90 degrees clockwise
        this.x1 = cX + w2 * GroupD8.uX(rotate);
        this.y1 = cY + h2 * GroupD8.uY(rotate);
        rotate = GroupD8.add(rotate, 2);
        this.x2 = cX + w2 * GroupD8.uX(rotate);
        this.y2 = cY + h2 * GroupD8.uY(rotate);
        rotate = GroupD8.add(rotate, 2);
        this.x3 = cX + w2 * GroupD8.uX(rotate);
        this.y3 = cY + h2 * GroupD8.uY(rotate);
    }
    else
    {

        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;

        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;

        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
    }
};

},{"../SpineUtil/GroupD8":46}],67:[function(require,module,exports){
module.exports = {
    /**
     * Converts a hex color number to a string.
     *
     * @param hex {number}
     * @return {string} The string color.
     */
    hex2string: function (hex)
    {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;

        return '#' + hex;
    },

    /**
     * Converts a hex color number to an [R, G, B] array
     *
     * @param hex {number}
     * @param  {number[]} [out=[]]
     * @return {number[]} An array representing the [R, G, B] of the color.
     */
    hex2rgb: function (hex, out)
    {
        out = out || [];

        out[0] = (hex >> 16 & 0xFF) / 255;
        out[1] = (hex >> 8 & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;

        return out;
    },

    removeItems: function (arr, startIdx, removeCount)
    {
        var length = arr.length;

        if (startIdx >= length || removeCount === 0)
        {
            return;
        }

        removeCount = (startIdx+removeCount > length ? length-startIdx : removeCount);
        for (var i = startIdx, len = length-removeCount; i < len; ++i)
        {
            arr[i] = arr[i + removeCount];
        }

        arr.length = len;
    },

    /**
     * checks if the given width and height make a power of two rectangle
     *
     * @param width {number}
     * @param height {number}
     * @return {boolean}
     */
    isPowerOfTwo: function (width, height)
    {
        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
    },

    /**
     * Converts a color as an [R, G, B] array to a hex number
     *
     * @param rgb {number[]}
     * @return {number} The color number
     */
    rgb2hex: function (rgb)
    {
        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
    }
};

},{}]},{},[1])


//# sourceMappingURL=pixi-spine.js.map
/*
 * File:   ui-spine.js
 * Author: Li XianJing <xianjimli@hotmail.com>
 * Brief:  Spine Skeleton Animation.
 *
 * Copyright (c) 2015 - 2016  Holaverse Inc.
 *
 */

/**
 * @class UISpine
 * @extends UISkeletonAnimation
 * Spine骨骼动画。参考：[Spine](https://github.com/EsotericSoftware/spine-runtimes)
 */
function UISpine() {
}

UISpine.prototype = new UISkeletonAnimation();
UISpine.prototype.initUISpine = UISkeletonAnimation.prototype.initUISkeletonAnimation;

UISpine.prototype.onComplete = function(index, count) {
    if(count >= this.repeatTimes) {
        if(this.onDone) {
            this.onDone();
        }
    }
    else if(this.onOneCycle) {
        this.onOneCycle();
    }

    if(this.repeatTimes > 1 && count >= this.repeatTimes) {
        var track = this.spineInstance.state.tracks[index];
        track.animation.apply(this.spineInstance.skeleton, track.lastTime, track.endTime, false, track.events);
        this.spineInstance.state.clearTrack(index);
    }
};

UISpine.prototype.doPlay = UISpine.prototype.gotoAndPlay = function(animationName, repeatTimes, onDone, onOneCycle, useFadeIn, duration) {
	var me = this;
	this.animationName = animationName;

	if(this.spineInstance) {
        this.onDone = onDone;
        this.onOneCycle = onOneCycle;
	    this.repeatTimes = repeatTimes ? repeatTimes : Math.MAX_VALUE;
	    this.spineInstance.state.setAnimationByName(0, animationName, this.repeatTimes != 1);
        this.spineInstance.state.onComplete = this.onComplete.bind(this);
	}

	return this;
}

UISpine.prototype.pause = function() {
	if(this.spineInstance) {
	    this.spineInstance.state.timeScale = 0;
	}

	return this;
}

UISpine.prototype.resume = function() {
    if(this.spineInstance) {
        this.spineInstance.state.timeScale = 1;
    }
	return this;
}

UISpine.prototype.createArmature = function(texture, textureData, skeletonJSON, onDone) {
    if(this.spineInstance) {
        this.spineInstance = null;
    }

    var spineAtlas = new spine.SpineRuntime.Atlas(textureData, function(line, callback) {
        callback(spine.BaseTexture.fromImageObj(texture));
    });

    var attachmentParser = new spine.SpineRuntime.AtlasAttachmentParser(spineAtlas);
    var spineJsonParser = new spine.SpineRuntime.SkeletonJsonParser(attachmentParser);
    var skeletonData = spineJsonParser.readSkeletonData(skeletonJSON);
    this.spineInstance = new spine.Spine(skeletonData);
    this.animationNames = [];
    this.spineInstance.spineData.animations.forEach(function(it) {
        this.animationNames.push(it.name);
    }, this);
    this.skinNames = [];
    this.spineInstance.spineData.skins.forEach(function(it) {
        this.skinNames.push(it.name);
    }, this);
    this.animationName = this.animationName && this.animationNames.indexOf(this.animationName) > -1 ?
	    this.animationName : this.animationNames[0];

    this.skinName = this.skinName && this.skinNames.indexOf(this.skinName) >= 0 ?
        this.skinName : this.skinNames[0];

    if(!spine.renderer) {
        spine.renderer = new spine.CanvasRenderer();
    }

    return;
}

UISpine.prototype.update = function(canvas) {
	var dt = (canvas.timeStep * this.animTimeScale);
	this.spineInstance.update(dt/1000);
}

UISpine.prototype.destroyArmature = function() {
	if(this.spineInstance) {
		this.spineInstance = null;
        this.animationNames = null;
		this.animationName = void 0;
		this.skinName = void 0;
	}
}

UISpine.prototype.paintSelfOnly = function(canvas) {
	if(!this.spineInstance) {
		return;
	}

	var ay = this.h;
	var ax = this.w >> 1;

	canvas.translate(ax, ay);
	canvas.scale(this.animationScaleX, this.animationScaleY);

	if(!this.isPaused()) {
		this.update(canvas);
	}
    spine.renderer.setContext(canvas);
	spine.renderer.render(this.spineInstance);

	if(isNaN(canvas.needRedraw)) {
		canvas.needRedraw = 1;
	}
	canvas.needRedraw++;

	return;
}

UISpine.prototype.setSkin = function(skinName) {
	if(this.spineInstance) {
	    this.skinName = skinName;
        this.spineInstance.skeleton.setSkin(null);
	    this.spineInstance.skeleton.setSkinByName(skinName);
	}

	return this;
}

UISpine.prototype.getBound = function() {
    if(!this.spineInstance) {
        return {x: this.left, y: this.top, width: this.w, height: this.h};
    }

    var boundBox = this.spineInstance.skeleton.findSlot('BoundingBox');
    if(boundBox) {
        var vertices = boundBox.attachment.vertices;
        return {x: vertices[0], y: vertices[1],
            width: vertices[4] - vertices[0], height: vertices[5] - vertices[1]};
    }
    else {
        var bound = this.spineInstance.getBounds();
        return {x: this.x + this.w/2 + bound.x,
                y: this.y + this.h + bound.y,
                width: bound.width,
                height: bound.height
        };
    }
};

UISpine.prototype.getCurrentSkinKey = function() {
	if(this.spineInstance) {
        return this.skinName;
	}
};

UISpine.prototype.getCurrentAnimKey = function() {
	if(this.spineInstance) {
        return this.animationName;
	}
};

UISpine.prototype.getSkins = function() {
	if(this.spineInstance) {
        return this.skinNames;
	}

	return ["default"];
}

UISpine.prototype.getDuration = UISpine.prototype.getAnimationDuration = function(animaName) {
	if(!this.spineInstance) return 0;
	return this.spineInstance.state.tracks[0].animation.endTime;
}

UISpine.prototype.replaceSlotImage = function(name, image, imageRect) {
    if(!this.spineInstance || !image) {
        return;
    }

    var num = this.spineInstance.skeleton.findSlotIndex(name);
    if(num < 0) {
        return;
    }
    var slot = this.spineInstance.skeleton.slots[num];
    var baseTexture = spine.BaseTexture.fromImageObj(image);
    if(slot.currentSprite) {
        slot.currentSprite.texture.baseTexture = baseTexture;
    }

    return this;
}

function UISpineCreator() {
	var args = ["ui-spine", "ui-spine", null, true];

	ShapeCreator.apply(this, args);
	this.createShape = function(createReason) {
		var g = new UISpine();
		return g.initUISpine(this.type, 200, 200);
	}

	return;
}

ShapeFactoryGet().addShapeCreator(new UISpineCreator());
